/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2017 OSSRS(winlin)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#include "srs_librtmp.h"

// auto generated by configure
#ifndef SRS_AUTO_HEADER_HPP
#define SRS_AUTO_HEADER_HPP

#define SRS_AUTO_BUILD_TS "1533431927"
#define SRS_AUTO_BUILD_DATE "2018-08-05 09:18:47"
#define SRS_AUTO_UNAME "Darwin homeMacOS 17.7.0 Darwin Kernel Version 17.7.0: Thu Jun 21 22:53:14 PDT 2018; root:xnu-4570.71.2~1/RELEASE_X86_64 x86_64"
#define SRS_AUTO_USER_CONFIGURE "--x86-x64  --export-librtmp-single=/Users/winlin/git/srs-librtmp/src/srs"
#define SRS_AUTO_CONFIGURE "--prefix=/usr/local/srs --with-hls --without-hds --with-dvr --without-nginx --without-ssl --without-ffmpeg --without-transcode --without-ingest --without-stat --with-http-callback --with-http-server --without-stream-caster --without-kafka --with-http-api --with-librtmp --with-research --without-utest --without-gperf --without-gmc --without-gmd --without-gmp --without-gcp --without-gprof --without-arm-ubuntu12 --without-mips-ubuntu12 --log-trace"

#define SRS_X86_X64
#define SRS_X86_X64_BOOL true
#define SRS_EXPORT_LIBRTMP

#undef SRS_AUTO_EMBEDED_TOOL_CHAIN
#define SRS_AUTO_EMBEDED_TOOL_CHAIN_BOOL false

#undef SRS_AUTO_STREAM_CASTER
#define SRS_AUTO_STREAM_CASTER_BOOL false
#undef SRS_AUTO_KAFKA
#define SRS_AUTO_KAFKA_BOOL false
#undef SRS_AUTO_NGINX
#define SRS_AUTO_NGINX_BOOL false
#define SRS_AUTO_DVR
#define SRS_AUTO_DVR_BOOL true
#define SRS_AUTO_HLS
#define SRS_AUTO_HLS_BOOL true
#undef SRS_AUTO_HDS
#define SRS_AUTO_HDS_BOOL false
#undef SRS_AUTO_SSL
#define SRS_AUTO_SSL_BOOL false
#undef SRS_AUTO_MEM_WATCH
#define SRS_AUTO_MEM_WATCH_BOOL false
#undef SRS_AUTO_FFMPEG_TOOL
#define SRS_AUTO_FFMPEG_TOOL_BOOL false
#define SRS_AUTO_FFMPEG_STUB
#define SRS_AUTO_FFMPEG_STUB_BOOL true
#undef SRS_AUTO_TRANSCODE
#define SRS_AUTO_TRANSCODE_BOOL false
#undef SRS_AUTO_INGEST
#define SRS_AUTO_INGEST_BOOL false
#undef SRS_AUTO_STAT
#define SRS_AUTO_STAT_BOOL false
#undef SRS_AUTO_GPERF
#define SRS_AUTO_GPERF_BOOL false
#undef SRS_AUTO_GPERF_MC
#define SRS_AUTO_GPERF_MC_BOOL false
#undef SRS_AUTO_GPERF_MD
#define SRS_AUTO_GPERF_MD_BOOL false
#undef SRS_AUTO_GPERF_MP
#define SRS_AUTO_GPERF_MP_BOOL false
#undef SRS_AUTO_GPERF_CP
#define SRS_AUTO_GPERF_CP_BOOL false
#undef SRS_AUTO_EMBEDED_CPU
#define SRS_AUTO_EMBEDED_CPU_BOOL false
#undef SRS_AUTO_ARM_UBUNTU12
#define SRS_AUTO_ARM_UBUNTU12_BOOL false
#undef SRS_AUTO_MIPS_UBUNTU12
#define SRS_AUTO_MIPS_UBUNTU12_BOOL false

#undef SRS_AUTO_VERBOSE
#define SRS_AUTO_VERBOSE_BOOL false
#undef SRS_AUTO_INFO
#define SRS_AUTO_INFO_BOOL false
#define SRS_AUTO_TRACE
#define SRS_AUTO_TRACE_BOOL true

#define SRS_AUTO_PREFIX "/usr/local/srs"

#define SRS_AUTO_CONSTRIBUTORS "\
winlin<winlin@vip.126.com> \
wenjie.zhao<740936897@qq.com> \
xiangcheng.liu<liuxc0116@foxmail.com> \
naijia.liu<youngcow@youngcow.net> \
alcoholyi<alcoholyi@qq.com> \
byteman<wangchen2011@gmail.com> \
chad.wang<chad.wang.cn@gmail.com> \
suhetao<suhetao@gmail.com> \
Johnny<fengjihu@163.com> \
karthikeyan<keyanmca@gmail.com> \
StevenLiu<lq@chinaffmpeg.org> \
zhengfl<zhengfl_1989@126.com> \
tufang14<breadbean1449@gmail.com> \
allspace<allspace@gmail.com> \
niesongsong<nie950@gmail.com> \
rudeb0t<nimrod@themanxgroup.tw> \
CallMeNP<np.liamg@gmail.com> \
synote<synote@qq.com> \
lovecat<littlefawn@163.com> \
panda1986<542638787@qq.com> \
YueHonghui<hongf.yue@hotmail.com> \
ThomasDreibholz<dreibh@simula.no> \
JuntaoLiu<juntliu@gmail.com> \
"

#endif

// following is generated by src/core/srs_core.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_CORE_HPP
#define SRS_CORE_HPP

// current release version
#define VERSION_MAJOR       3
#define VERSION_MINOR       0
#define VERSION_REVISION    36

// generated by configure, only macros.
//#include <srs_auto_headers.hpp>

// provider info.
#define RTMP_SIG_SRS_KEY "SRS"
#define RTMP_SIG_SRS_CODE "OuXuli"
#define RTMP_SIG_SRS_AUTHROS "winlin,wenjie.zhao"
// contact info.
#define RTMP_SIG_SRS_WEB "http://ossrs.net"
#define RTMP_SIG_SRS_EMAIL "winlin@vip.126.com"
// debug info.
#define RTMP_SIG_SRS_ROLE "cluster"
#define RTMP_SIG_SRS_URL "https://github.com/ossrs/srs"
#define RTMP_SIG_SRS_LICENSE "The MIT License (MIT)"
#define RTMP_SIG_SRS_COPYRIGHT "Copyright (c) 2013-2018 " RTMP_SIG_SRS_KEY "(" RTMP_SIG_SRS_AUTHROS ")"
#define RTMP_SIG_SRS_PRIMARY RTMP_SIG_SRS_KEY "/" VERSION_STABLE_BRANCH
#define RTMP_SIG_SRS_HANDSHAKE RTMP_SIG_SRS_KEY "(" RTMP_SIG_SRS_VERSION ")"
#define RTMP_SIG_SRS_VERSION SRS_XSTR(VERSION_MAJOR) "." SRS_XSTR(VERSION_MINOR) "." SRS_XSTR(VERSION_REVISION)
#define RTMP_SIG_SRS_SERVER RTMP_SIG_SRS_KEY "/" RTMP_SIG_SRS_VERSION "(" RTMP_SIG_SRS_CODE ")"

// stable major version
#define VERSION_STABLE 2
#define VERSION_STABLE_BRANCH SRS_XSTR(VERSION_STABLE)".0release"

// internal macros, covert macro values to str,
// see: read https://gcc.gnu.org/onlinedocs/cpp/Stringification.html#Stringification
#define SRS_XSTR(v) SRS_INTERNAL_STR(v)
#define SRS_INTERNAL_STR(v) #v

/**
 * the core provides the common defined macros, utilities,
 * user must include the srs_core.hpp before any header, or maybe
 * build failed.
 */

// for 32bit os, 2G big file limit for unistd io, 
// ie. read/write/lseek to use 64bits size for huge file.
#ifndef _FILE_OFFSET_BITS
    #define _FILE_OFFSET_BITS 64
#endif

// for int64_t print using PRId64 format.
#ifndef __STDC_FORMAT_MACROS
    #define __STDC_FORMAT_MACROS
#endif

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <inttypes.h>
#endif

#include <assert.h>
#define srs_assert(expression) assert(expression)

#include <stddef.h>
#include <sys/types.h>

// important performance options.
//#include <srs_core_performance.hpp>

// free the p and set to NULL.
// p must be a T*.
#define srs_freep(p) \
    if (p) { \
        delete p; \
        p = NULL; \
    } \
    (void)0
// please use the freepa(T[]) to free an array,
// or the behavior is undefined.
#define srs_freepa(pa) \
    if (pa) { \
        delete[] pa; \
        pa = NULL; \
    } \
    (void)0

/**
 * important check for st(state-threads),
 * only support the following cpus: i386/amd64/x86_64/arm
 * @reamrk to patch ST for arm, read https://github.com/ossrs/state-threads/issues/1
 */
#if !defined(__amd64__) && !defined(__x86_64__) && !defined(__i386__) && !defined(__arm__) && !defined(__aarch64__)
    #error "only support i386/amd64/x86_64/arm cpu"
#endif

// Error predefined for all modules.
class SrsCplxError;
typedef SrsCplxError* srs_error_t;

#endif
// following is generated by src/core/srs_core_autofree.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_CORE_AUTO_FREE_HPP
#define SRS_CORE_AUTO_FREE_HPP

//#include <srs_core.hpp>

/**
 * auto free the instance in the current scope, for instance, MyClass* ptr,
 * which is a ptr and this class will:
 *       1. free the ptr.
 *       2. set ptr to NULL.
 *
 * Usage:
 *       MyClass* po = new MyClass();
 *       // ...... use po
 *       SrsAutoFree(MyClass, po);
 *
 * Usage for array:
 *      MyClass** pa = new MyClass*[size];
 *      // ....... use pa
 *      SrsAutoFreeA(MyClass*, pa);
 *
 * @remark the MyClass can be basic type, for instance, SrsAutoFreeA(char, pstr),
 *      where the char* pstr = new char[size].
 */
#define SrsAutoFree(className, instance) \
impl__SrsAutoFree<className> _auto_free_##instance(&instance, false)
#define SrsAutoFreeA(className, instance) \
impl__SrsAutoFree<className> _auto_free_array_##instance(&instance, true)
template<class T>
class impl__SrsAutoFree
{
private:
    T** ptr;
    bool is_array;
public:
    /**
     * auto delete the ptr.
     */
    impl__SrsAutoFree(T** p, bool array) {
        ptr = p;
        is_array = array;
    }
    
    virtual ~impl__SrsAutoFree() {
        if (ptr == NULL || *ptr == NULL) {
            return;
        }
        
        if (is_array) {
            delete[] *ptr;
        } else {
            delete *ptr;
        }
        
        *ptr = NULL;
    }
};

#endif
// following is generated by src/core/srs_core_performance.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_CORE_PERFORMANCE_HPP
#define SRS_CORE_PERFORMANCE_HPP

//#include <srs_core.hpp>

/**
 * this file defines the perfromance options.
 */

/**
 * to improve read performance, merge some packets then read,
 * when it on and read small bytes, we sleep to wait more data.,
 * that is, we merge some data to read together.
 * @see SrsConfig::get_mr_enabled()
 * @see SrsConfig::get_mr_sleep_ms()
 * @see https://github.com/ossrs/srs/issues/241
 * @example, for the default settings, this algorithm will use:
 *       that is, when got nread bytes smaller than 4KB, sleep(780ms).
 */
/**
 * https://github.com/ossrs/srs/issues/241#issuecomment-65554690
 * The merged read algorithm is ok and can be simplified for:
 *   1. Suppose the client network is ok. All algorithm go wrong when netowrk is not ok.
 *   2. Suppose the client send each packet one by one. Although send some together, it's same.
 *   3. SRS MR algorithm will read all data then sleep.
 * So, the MR algorithm is:
 *   while true:
 *       read all data from socket.
 *       sleep a while
 * For example, sleep 120ms. Then there is, and always 120ms data in buffer.
 * That is, the latency is 120ms(the sleep time).
 */
#define SRS_PERF_MERGED_READ
// the default config of mr.
#define SRS_PERF_MR_ENABLED false
#define SRS_PERF_MR_SLEEP 350

/**
 * the MW(merged-write) send cache time in ms.
 * the default value, user can override it in config.
 * to improve send performance, cache msgs and send in a time.
 * for example, cache 500ms videos and audios, then convert all these
 * msgs to iovecs, finally use writev to send.
 * @remark this largely improve performance, from 3.5k+ to 7.5k+.
 *       the latency+ when cache+.
 * @remark the socket send buffer default to 185KB, it large enough.
 * @see https://github.com/ossrs/srs/issues/194
 * @see SrsConfig::get_mw_sleep_ms()
 * @remark the mw sleep and msgs to send, maybe:
 *       mw_sleep        msgs        iovs
 *       350             43          86
 *       400             44          88
 *       500             46          92
 *       600             46          92
 *       700             82          164
 *       800             81          162
 *       900             80          160
 *       1000            88          176
 *       1100            91          182
 *       1200            89          178
 *       1300            119         238
 *       1400            120         240
 *       1500            119         238
 *       1600            131         262
 *       1700            131         262
 *       1800            133         266
 *       1900            141         282
 *       2000            150         300
 */
// the default config of mw.
#define SRS_PERF_MW_SLEEP 350
/**
 * how many msgs can be send entirely.
 * for play clients to get msgs then totally send out.
 * for the mw sleep set to 1800, the msgs is about 133.
 * @remark, recomment to 128.
 */
#define SRS_PERF_MW_MSGS 128

/**
 * whether set the socket send buffer size.
 * @see https://github.com/ossrs/srs/issues/251
 */
#define SRS_PERF_MW_SO_SNDBUF

/**
 * whether set the socket recv buffer size.
 * @see https://github.com/ossrs/srs/issues/251
 */
#undef SRS_PERF_MW_SO_RCVBUF
/**
 * whether enable the fast vector for qeueue.
 * @see https://github.com/ossrs/srs/issues/251
 */
#define SRS_PERF_QUEUE_FAST_VECTOR
/**
 * whether use cond wait to send messages.
 * @remark this improve performance for large connectios.
 * @see https://github.com/ossrs/srs/issues/251
 */
#define SRS_PERF_QUEUE_COND_WAIT
#ifdef SRS_PERF_QUEUE_COND_WAIT
    #define SRS_PERF_MW_MIN_MSGS 8
#endif
/**
 * the default value of vhost for
 * SRS whether use the min latency mode.
 * for min latence mode:
 * 1. disable the mr for vhost.
 * 2. use timeout for cond wait for consumer queue.
 * @see https://github.com/ossrs/srs/issues/257
 */
#define SRS_PERF_MIN_LATENCY_ENABLED false

/**
 * how many chunk stream to cache, [0, N].
 * to imporove about 10% performance when chunk size small, and 5% for large chunk.
 * @see https://github.com/ossrs/srs/issues/249
 * @remark 0 to disable the chunk stream cache.
 */
#define SRS_PERF_CHUNK_STREAM_CACHE 16

/**
 * the gop cache and play cache queue.
 */
// whether gop cache is on.
#define SRS_PERF_GOP_CACHE true
// in seconds, the live queue length.
#define SRS_PERF_PLAY_QUEUE 30

/**
 * whether always use complex send algorithm.
 * for some network does not support the complex send,
 * @see https://github.com/ossrs/srs/issues/320
 */
//#undef SRS_PERF_COMPLEX_SEND
#define SRS_PERF_COMPLEX_SEND
/**
 * whether enable the TCP_NODELAY
 * user maybe need send small tcp packet for some network.
 * @see https://github.com/ossrs/srs/issues/320
 */
#undef SRS_PERF_TCP_NODELAY
#define SRS_PERF_TCP_NODELAY
/**
 * set the socket send buffer,
 * to force the server to send smaller tcp packet.
 * @see https://github.com/ossrs/srs/issues/320
 * @remark undef it to auto calc it by merged write sleep ms.
 * @remark only apply it when SRS_PERF_MW_SO_SNDBUF is defined.
 */
#ifdef SRS_PERF_MW_SO_SNDBUF
    //#define SRS_PERF_SO_SNDBUF_SIZE 1024
    #undef SRS_PERF_SO_SNDBUF_SIZE
#endif

/**
 * define the following macro to enable the fast flv encoder.
 * @see https://github.com/ossrs/srs/issues/405
 */
#undef SRS_PERF_FAST_FLV_ENCODER
#define SRS_PERF_FAST_FLV_ENCODER

/**
 * whether ensure glibc memory check.
 */
#define SRS_PERF_GLIBC_MEMORY_CHECK
#undef SRS_PERF_GLIBC_MEMORY_CHECK

#endif

// following is generated by src/core/srs_core_mem_watch.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_CORE_MEM_WATCH_HPP
#define SRS_CORE_MEM_WATCH_HPP

//#include <srs_core.hpp>

#ifdef SRS_AUTO_MEM_WATCH

#include <string>

// watch the specified memory.
extern void srs_memory_watch(void* ptr, std::string category, int size);

// unwatch the specified memory.
extern void srs_memory_unwatch(void* ptr);

// report the memory watch.
extern void srs_memory_report();

#endif

#endif

// following is generated by src/kernel/srs_kernel_error.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_KERNEL_ERROR_HPP
#define SRS_KERNEL_ERROR_HPP

//#include <srs_core.hpp>

#include <string>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#define ERROR_SUCCESS                       0
#endif

///////////////////////////////////////////////////////
// system error.
///////////////////////////////////////////////////////
#define ERROR_SOCKET_CREATE                 1000
#define ERROR_SOCKET_SETREUSE               1001
#define ERROR_SOCKET_BIND                   1002
#define ERROR_SOCKET_LISTEN                 1003
#define ERROR_SOCKET_CLOSED                 1004
#define ERROR_SOCKET_GET_PEER_NAME          1005
#define ERROR_SOCKET_GET_PEER_IP            1006
#define ERROR_SOCKET_READ                   1007
#define ERROR_SOCKET_READ_FULLY             1008
#define ERROR_SOCKET_WRITE                  1009
#define ERROR_SOCKET_WAIT                   1010
#define ERROR_SOCKET_TIMEOUT                1011
#define ERROR_SOCKET_CONNECT                1012
#define ERROR_ST_SET_EPOLL                  1013
#define ERROR_ST_INITIALIZE                 1014
#define ERROR_ST_OPEN_SOCKET                1015
#define ERROR_ST_CREATE_LISTEN_THREAD       1016
#define ERROR_ST_CREATE_CYCLE_THREAD        1017
#define ERROR_ST_CONNECT                    1018
#define ERROR_SYSTEM_PACKET_INVALID         1019
#define ERROR_SYSTEM_CLIENT_INVALID         1020
#define ERROR_SYSTEM_ASSERT_FAILED          1021
#define ERROR_READER_BUFFER_OVERFLOW        1022
#define ERROR_SYSTEM_CONFIG_INVALID         1023
#define ERROR_SYSTEM_CONFIG_DIRECTIVE       1024
#define ERROR_SYSTEM_CONFIG_BLOCK_START     1025
#define ERROR_SYSTEM_CONFIG_BLOCK_END       1026
#define ERROR_SYSTEM_CONFIG_EOF             1027
#define ERROR_SYSTEM_STREAM_BUSY            1028
#define ERROR_SYSTEM_IP_INVALID             1029
#define ERROR_SYSTEM_FORWARD_LOOP           1030
#define ERROR_SYSTEM_WAITPID                1031
#define ERROR_SYSTEM_BANDWIDTH_KEY          1032
#define ERROR_SYSTEM_BANDWIDTH_DENIED       1033
#define ERROR_SYSTEM_PID_ACQUIRE            1034
#define ERROR_SYSTEM_PID_ALREADY_RUNNING    1035
#define ERROR_SYSTEM_PID_LOCK               1036
#define ERROR_SYSTEM_PID_TRUNCATE_FILE      1037
#define ERROR_SYSTEM_PID_WRITE_FILE         1038
#define ERROR_SYSTEM_PID_GET_FILE_INFO      1039
#define ERROR_SYSTEM_PID_SET_FILE_INFO      1040
#define ERROR_SYSTEM_FILE_ALREADY_OPENED    1041
#define ERROR_SYSTEM_FILE_OPENE             1042
#define ERROR_SYSTEM_FILE_CLOSE             1043
#define ERROR_SYSTEM_FILE_READ              1044
#define ERROR_SYSTEM_FILE_WRITE             1045
#define ERROR_SYSTEM_FILE_EOF               1046
#define ERROR_SYSTEM_FILE_RENAME            1047
#define ERROR_SYSTEM_CREATE_PIPE            1048
#define ERROR_SYSTEM_FILE_SEEK              1049
#define ERROR_SYSTEM_IO_INVALID             1050
#define ERROR_ST_EXCEED_THREADS             1051
#define ERROR_SYSTEM_SECURITY               1052
#define ERROR_SYSTEM_SECURITY_DENY          1053
#define ERROR_SYSTEM_SECURITY_ALLOW         1054
#define ERROR_SYSTEM_TIME                   1055
#define ERROR_SYSTEM_DIR_EXISTS             1056
#define ERROR_SYSTEM_CREATE_DIR             1057
#define ERROR_SYSTEM_KILL                   1058
#define ERROR_SYSTEM_CONFIG_PERSISTENCE     1059
#define ERROR_SYSTEM_CONFIG_RAW             1060
#define ERROR_SYSTEM_CONFIG_RAW_DISABLED    1061
#define ERROR_SYSTEM_CONFIG_RAW_NOT_ALLOWED 1062
#define ERROR_SYSTEM_CONFIG_RAW_PARAMS      1063
#define ERROR_SYSTEM_FILE_NOT_EXISTS        1064
#define ERROR_SYSTEM_HOURGLASS_RESOLUTION   1065
#define ERROR_SYSTEM_DNS_RESOLVE            1066
#define ERROR_SYSTEM_FRAGMENT_UNLINK        1067
#define ERROR_SYSTEM_FRAGMENT_RENAME        1068
#define ERROR_THREAD_DISPOSED               1069
#define ERROR_THREAD_INTERRUPED             1070
#define ERROR_THREAD_TERMINATED             1071
#define ERROR_THREAD_DUMMY                  1072
#define ERROR_ASPROCESS_PPID                1073
#define ERROR_EXCEED_CONNECTIONS            1074
#define ERROR_SOCKET_SETKEEPALIVE           1075

///////////////////////////////////////////////////////
// RTMP protocol error.
///////////////////////////////////////////////////////
#define ERROR_RTMP_PLAIN_REQUIRED           2000
#define ERROR_RTMP_CHUNK_START              2001
#define ERROR_RTMP_MSG_INVALID_SIZE         2002
#define ERROR_RTMP_AMF0_DECODE              2003
#define ERROR_RTMP_AMF0_INVALID             2004
#define ERROR_RTMP_REQ_CONNECT              2005
#define ERROR_RTMP_REQ_TCURL                2006
#define ERROR_RTMP_MESSAGE_DECODE           2007
#define ERROR_RTMP_MESSAGE_ENCODE           2008
#define ERROR_RTMP_AMF0_ENCODE              2009
#define ERROR_RTMP_CHUNK_SIZE               2010
#define ERROR_RTMP_TRY_SIMPLE_HS            2011
#define ERROR_RTMP_CH_SCHEMA                2012
#define ERROR_RTMP_PACKET_SIZE              2013
#define ERROR_RTMP_VHOST_NOT_FOUND          2014
#define ERROR_RTMP_ACCESS_DENIED            2015
#define ERROR_RTMP_HANDSHAKE                2016
#define ERROR_RTMP_NO_REQUEST               2017
#define ERROR_RTMP_HS_SSL_REQUIRE           2018
#define ERROR_RTMP_DURATION_EXCEED          2019
#define ERROR_RTMP_EDGE_PLAY_STATE          2020
#define ERROR_RTMP_EDGE_PUBLISH_STATE       2021
#define ERROR_RTMP_EDGE_PROXY_PULL          2022
#define ERROR_RTMP_EDGE_RELOAD              2023
#define ERROR_RTMP_AGGREGATE                2024
#define ERROR_RTMP_BWTC_DATA                2025
#define ERROR_OpenSslCreateDH               2026
#define ERROR_OpenSslCreateP                2027
#define ERROR_OpenSslCreateG                2028
#define ERROR_OpenSslParseP1024             2029
#define ERROR_OpenSslSetG                   2030
#define ERROR_OpenSslGenerateDHKeys         2031
#define ERROR_OpenSslCopyKey                2032
#define ERROR_OpenSslSha256Update           2033
#define ERROR_OpenSslSha256Init             2034
#define ERROR_OpenSslSha256Final            2035
#define ERROR_OpenSslSha256EvpDigest        2036
#define ERROR_OpenSslSha256DigestSize       2037
#define ERROR_OpenSslGetPeerPublicKey       2038
#define ERROR_OpenSslComputeSharedKey       2039
#define ERROR_RTMP_MIC_CHUNKSIZE_CHANGED    2040
#define ERROR_RTMP_MIC_CACHE_OVERFLOW       2041
#define ERROR_RTSP_TOKEN_NOT_NORMAL         2042
#define ERROR_RTSP_REQUEST_HEADER_EOF       2043
#define ERROR_RTP_HEADER_CORRUPT            2044
#define ERROR_RTP_TYPE96_CORRUPT            2045
#define ERROR_RTP_TYPE97_CORRUPT            2046
#define ERROR_RTSP_AUDIO_CONFIG             2047
#define ERROR_RTMP_STREAM_NOT_FOUND         2048
#define ERROR_RTMP_CLIENT_NOT_FOUND         2049
#define ERROR_OpenSslCreateHMAC             2050
#define ERROR_RTMP_STREAM_NAME_EMPTY        2051
#define ERROR_HTTP_HIJACK                   2052
//                                           
// system control message,
// not an error, but special control logic.
//
// connection is redirect to another server.
#define ERROR_CONTROL_REDIRECT              2997
// sys ctl: rtmp close stream, support replay.
#define ERROR_CONTROL_RTMP_CLOSE            2998
// FMLE stop publish and republish.
#define ERROR_CONTROL_REPUBLISH             2999

///////////////////////////////////////////////////////
// application level
///////////////////////////////////////////////////////
#define ERROR_HLS_METADATA                  3000
#define ERROR_HLS_DECODE_ERROR              3001
//#define ERROR_HLS_CREATE_DIR                3002
#define ERROR_HLS_OPEN_FAILED               3003
#define ERROR_HLS_WRITE_FAILED              3004
#define ERROR_HLS_AAC_FRAME_LENGTH          3005
#define ERROR_HLS_AVC_SAMPLE_SIZE           3006
#define ERROR_HTTP_PARSE_URI                3007
#define ERROR_HTTP_DATA_INVALID             3008
#define ERROR_HTTP_PARSE_HEADER             3009
#define ERROR_HTTP_HANDLER_MATCH_URL        3010
#define ERROR_HTTP_HANDLER_INVALID          3011
#define ERROR_HTTP_API_LOGS                 3012
#define ERROR_HTTP_REMUX_SEQUENCE_HEADER      3013
#define ERROR_HTTP_REMUX_OFFSET_OVERFLOW      3014
#define ERROR_ENCODER_VCODEC                3015
#define ERROR_ENCODER_OUTPUT                3016
#define ERROR_ENCODER_ACHANNELS             3017
#define ERROR_ENCODER_ASAMPLE_RATE          3018
#define ERROR_ENCODER_ABITRATE              3019
#define ERROR_ENCODER_ACODEC                3020
#define ERROR_ENCODER_VPRESET               3021
#define ERROR_ENCODER_VPROFILE              3022
#define ERROR_ENCODER_VTHREADS              3023
#define ERROR_ENCODER_VHEIGHT               3024
#define ERROR_ENCODER_VWIDTH                3025
#define ERROR_ENCODER_VFPS                  3026
#define ERROR_ENCODER_VBITRATE              3027
#define ERROR_ENCODER_FORK                  3028
#define ERROR_ENCODER_LOOP                  3029
#define ERROR_FORK_OPEN_LOG                 3030
#define ERROR_FORK_DUP2_LOG                 3031
#define ERROR_ENCODER_PARSE                 3032
#define ERROR_ENCODER_NO_INPUT              3033
#define ERROR_ENCODER_NO_OUTPUT             3034
#define ERROR_ENCODER_INPUT_TYPE            3035
#define ERROR_KERNEL_FLV_HEADER             3036
#define ERROR_KERNEL_FLV_STREAM_CLOSED      3037
#define ERROR_KERNEL_STREAM_INIT            3038
#define ERROR_EDGE_VHOST_REMOVED            3039
#define ERROR_HLS_AVC_TRY_OTHERS            3040
#define ERROR_H264_API_NO_PREFIXED          3041
#define ERROR_FLV_INVALID_VIDEO_TAG         3042
#define ERROR_H264_DROP_BEFORE_SPS_PPS      3043
#define ERROR_H264_DUPLICATED_SPS           3044
#define ERROR_H264_DUPLICATED_PPS           3045
#define ERROR_AAC_REQUIRED_ADTS             3046
#define ERROR_AAC_ADTS_HEADER               3047
#define ERROR_AAC_DATA_INVALID              3048
#define ERROR_HLS_TRY_MP3                   3049
#define ERROR_HTTP_DVR_DISABLED             3050
#define ERROR_HTTP_DVR_REQUEST              3051
#define ERROR_HTTP_JSON_REQUIRED            3052
#define ERROR_HTTP_DVR_CREATE_REQUEST       3053
#define ERROR_HTTP_DVR_NO_TAEGET            3054
#define ERROR_ADTS_ID_NOT_AAC               3055
#define ERROR_HDS_OPEN_F4M_FAILED           3056
#define ERROR_HDS_WRITE_F4M_FAILED          3057
#define ERROR_HDS_OPEN_BOOTSTRAP_FAILED     3058
#define ERROR_HDS_WRITE_BOOTSTRAP_FAILED    3059
#define ERROR_HDS_OPEN_FRAGMENT_FAILED      3060
#define ERROR_HDS_WRITE_FRAGMENT_FAILED     3061
#define ERROR_HLS_NO_STREAM                 3062
#define ERROR_JSON_LOADS                    3063
#define ERROR_RESPONSE_CODE                 3064
#define ERROR_RESPONSE_DATA                 3065
#define ERROR_REQUEST_DATA                  3066
#define ERROR_EDGE_PORT_INVALID             3067
#define ERROR_EXPECT_FILE_IO                3068
#define ERROR_MP4_BOX_OVERFLOW              3069
#define ERROR_MP4_BOX_REQUIRE_SPACE         3070
#define ERROR_MP4_BOX_ILLEGAL_TYPE          3071
#define ERROR_MP4_BOX_ILLEGAL_SCHEMA        3072
#define ERROR_MP4_BOX_STRING                3073
#define ERROR_MP4_BOX_ILLEGAL_BRAND         3074
#define ERROR_MP4_ESDS_SL_Config            3075
#define ERROR_MP4_ILLEGAL_MOOV              3076
#define ERROR_MP4_ILLEGAL_HANDLER           3077
#define ERROR_MP4_ILLEGAL_TRACK             3078
#define ERROR_MP4_MOOV_OVERFLOW             3079
#define ERROR_MP4_ILLEGAL_SAMPLES           3080
#define ERROR_MP4_ILLEGAL_TIMESTAMP         3081
#define ERROR_DVR_CANNOT_APPEND             3082
#define ERROR_DVR_ILLEGAL_PLAN              3083
#define ERROR_FLV_REQUIRE_SPACE             3084
#define ERROR_MP4_AVCC_CHANGE               3085
#define ERROR_MP4_ASC_CHANGE                3086
#define ERROR_DASH_WRITE_FAILED             3087
#define ERROR_TS_CONTEXT_NOT_READY          3088
#define ERROR_MP4_ILLEGAL_MOOF              3089
#define ERROR_OCLUSTER_DISCOVER             3090
#define ERROR_OCLUSTER_REDIRECT             3091

///////////////////////////////////////////////////////
// HTTP/StreamCaster/KAFKA protocol error.
///////////////////////////////////////////////////////
#define ERROR_HTTP_PATTERN_EMPTY            4000
#define ERROR_HTTP_PATTERN_DUPLICATED       4001
#define ERROR_HTTP_URL_NOT_CLEAN            4002
#define ERROR_HTTP_CONTENT_LENGTH           4003
#define ERROR_HTTP_LIVE_STREAM_EXT          4004
#define ERROR_HTTP_STATUS_INVALID           4005
#define ERROR_KERNEL_AAC_STREAM_CLOSED      4006
#define ERROR_AAC_DECODE_ERROR              4007
#define ERROR_KERNEL_MP3_STREAM_CLOSED      4008
#define ERROR_MP3_DECODE_ERROR              4009
#define ERROR_STREAM_CASTER_ENGINE          4010
#define ERROR_STREAM_CASTER_PORT            4011
#define ERROR_STREAM_CASTER_TS_HEADER       4012
#define ERROR_STREAM_CASTER_TS_SYNC_BYTE    4013
#define ERROR_STREAM_CASTER_TS_AF           4014
#define ERROR_STREAM_CASTER_TS_CRC32        4015
#define ERROR_STREAM_CASTER_TS_PSI          4016
#define ERROR_STREAM_CASTER_TS_PAT          4017
#define ERROR_STREAM_CASTER_TS_PMT          4018
#define ERROR_STREAM_CASTER_TS_PSE          4019
#define ERROR_STREAM_CASTER_TS_ES           4020
#define ERROR_STREAM_CASTER_TS_CODEC        4021
#define ERROR_STREAM_CASTER_AVC_SPS         4022
#define ERROR_STREAM_CASTER_AVC_PPS         4023
#define ERROR_STREAM_CASTER_FLV_TAG         4024
#define ERROR_HTTP_RESPONSE_EOF             4025
#define ERROR_HTTP_INVALID_CHUNK_HEADER     4026
#define ERROR_AVC_NALU_UEV                  4027
#define ERROR_AAC_BYTES_INVALID             4028
#define ERROR_HTTP_REQUEST_EOF              4029
#define ERROR_KAFKA_CODEC_STRING            4030
#define ERROR_KAFKA_CODEC_BYTES             4031
#define ERROR_KAFKA_CODEC_REQUEST           4032
#define ERROR_KAFKA_CODEC_RESPONSE          4033
#define ERROR_KAFKA_CODEC_ARRAY             4034
#define ERROR_KAFKA_CODEC_METADATA          4035
#define ERROR_KAFKA_CODEC_MESSAGE           4036
#define ERROR_KAFKA_CODEC_PRODUCER          4037
#define ERROR_HTTP_302_INVALID              4038
#define ERROR_BASE64_DECODE                 4039

///////////////////////////////////////////////////////
// HTTP API error.
///////////////////////////////////////////////////////
//#define ERROR_API_METHOD_NOT_ALLOWD

///////////////////////////////////////////////////////
// user-define error.
///////////////////////////////////////////////////////
#define ERROR_USER_START                    9000
//#define ERROR_USER_DISCONNECT               9001
#define ERROR_SOURCE_NOT_FOUND              9002
#define ERROR_USER_END                      9999

/**
 * whether the error code is an system control error.
 */
// TODO: FIXME: Remove it from underlayer for confused with error and logger.
extern bool srs_is_system_control_error(int error_code);
extern bool srs_is_system_control_error(srs_error_t err);
extern bool srs_is_client_gracefully_close(int error_code);
extern bool srs_is_client_gracefully_close(srs_error_t err);

// Use complex errors, @read https://github.com/ossrs/srs/issues/913
class SrsCplxError
{
private:
    int code;
    SrsCplxError* wrapped;
    std::string msg;
    
    std::string func;
    std::string file;
    int line;
    
    int cid;
    int rerrno;
    
    std::string desc;
private:
    SrsCplxError();
public:
    virtual ~SrsCplxError();
private:
    virtual std::string description();
public:
    static SrsCplxError* create(const char* func, const char* file, int line, int code, const char* fmt, ...);
    static SrsCplxError* wrap(const char* func, const char* file, int line, SrsCplxError* err, const char* fmt, ...);
    static SrsCplxError* success();
    static SrsCplxError* copy(SrsCplxError* from);
    static std::string description(SrsCplxError* err);
    static int error_code(SrsCplxError* err);
};

// Error helpers, should use these functions to new or wrap an error.
#define srs_success SrsCplxError::success()
#define srs_error_new(ret, fmt, ...) SrsCplxError::create(__FUNCTION__, __FILE__, __LINE__, ret, fmt, ##__VA_ARGS__)
#define srs_error_wrap(err, fmt, ...) SrsCplxError::wrap(__FUNCTION__, __FILE__, __LINE__, err, fmt, ##__VA_ARGS__)
#define srs_error_copy(err) SrsCplxError::copy(err)
#define srs_error_desc(err) SrsCplxError::description(err)
#define srs_error_code(err) SrsCplxError::error_code(err)
#define srs_error_reset(err) srs_freep(err); err = srs_success

#endif

// following is generated by src/kernel/srs_kernel_log.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_KERNEL_LOG_HPP
#define SRS_KERNEL_LOG_HPP

//#include <srs_core.hpp>

#include <stdio.h>

#include <errno.h>
#include <string.h>

//#include <srs_kernel_consts.hpp>

/**
 * the log level, for example:
 * if specified Debug level, all level messages will be logged.
 * if specified Warn level, only Warn/Error/Fatal level messages will be logged.
 */
enum SrsLogLevel
{
    SrsLogLevelForbidden = 0x00,
    // only used for very verbose debug, generally,
    // we compile without this level for high performance.
    SrsLogLevelVerbose = 0x01,
    SrsLogLevelInfo = 0x02,
    SrsLogLevelTrace = 0x04,
    SrsLogLevelWarn = 0x08,
    SrsLogLevelError = 0x10,
    SrsLogLevelDisabled = 0x20,
};

/**
 * the log interface provides method to write log.
 * but we provides some macro, which enable us to disable the log when compile.
 * @see also SmtDebug/SmtTrace/SmtWarn/SmtError which is corresponding to Debug/Trace/Warn/Fatal.
 */
class ISrsLog
{
public:
    ISrsLog();
    virtual ~ISrsLog();
public:
    /**
     * initialize log utilities.
     */
    virtual srs_error_t initialize();
    /**
     * reopen the log file for log rotate.
     */
    virtual void reopen();
public:
    /**
     * log for verbose, very verbose information.
     */
    virtual void verbose(const char* tag, int context_id, const char* fmt, ...);
    /**
     * log for debug, detail information.
     */
    virtual void info(const char* tag, int context_id, const char* fmt, ...);
    /**
     * log for trace, important information.
     */
    virtual void trace(const char* tag, int context_id, const char* fmt, ...);
    /**
     * log for warn, warn is something should take attention, but not a error.
     */
    virtual void warn(const char* tag, int context_id, const char* fmt, ...);
    /**
     * log for error, something error occur, do something about the error, ie. close the connection,
     * but we will donot abort the program.
     */
    virtual void error(const char* tag, int context_id, const char* fmt, ...);
};

/**
 * the context id manager to identify context, for instance, the green-thread.
 * usage:
 *      _srs_context->generate_id(); // when thread start.
 *      _srs_context->get_id(); // get current generated id.
 *      int old_id = _srs_context->set_id(1000); // set context id if need to merge thread context.
 */
// the context for multiple clients.
class ISrsThreadContext
{
public:
    ISrsThreadContext();
    virtual ~ISrsThreadContext();
public:
    /**
     * generate the id for current context.
     */
    virtual int generate_id();
    /**
     * get the generated id of current context.
     */
    virtual int get_id();
    /**
     * set the id of current context.
     * @return the previous id value; 0 if no context.
     */
    virtual int set_id(int v);
};

// @global user must provides a log object
extern ISrsLog* _srs_log;

// @global user must implements the LogContext and define a global instance.
extern ISrsThreadContext* _srs_context;

// donot print method
#if 1
    #define srs_verbose(msg, ...) _srs_log->verbose(NULL, _srs_context->get_id(), msg, ##__VA_ARGS__)
    #define srs_info(msg, ...)    _srs_log->info(NULL, _srs_context->get_id(), msg, ##__VA_ARGS__)
    #define srs_trace(msg, ...)   _srs_log->trace(NULL, _srs_context->get_id(), msg, ##__VA_ARGS__)
    #define srs_warn(msg, ...)    _srs_log->warn(NULL, _srs_context->get_id(), msg, ##__VA_ARGS__)
    #define srs_error(msg, ...)   _srs_log->error(NULL, _srs_context->get_id(), msg, ##__VA_ARGS__)
#endif
// use __FUNCTION__ to print c method
#if 0
    #define srs_verbose(msg, ...) _srs_log->verbose(__FUNCTION__, _srs_context->get_id(), msg, ##__VA_ARGS__)
    #define srs_info(msg, ...)    _srs_log->info(__FUNCTION__, _srs_context->get_id(), msg, ##__VA_ARGS__)
    #define srs_trace(msg, ...)   _srs_log->trace(__FUNCTION__, _srs_context->get_id(), msg, ##__VA_ARGS__)
    #define srs_warn(msg, ...)    _srs_log->warn(__FUNCTION__, _srs_context->get_id(), msg, ##__VA_ARGS__)
    #define srs_error(msg, ...)   _srs_log->error(__FUNCTION__, _srs_context->get_id(), msg, ##__VA_ARGS__)
#endif
// use __PRETTY_FUNCTION__ to print c++ class:method
#if 0
    #define srs_verbose(msg, ...) _srs_log->verbose(__PRETTY_FUNCTION__, _srs_context->get_id(), msg, ##__VA_ARGS__)
    #define srs_info(msg, ...)    _srs_log->info(__PRETTY_FUNCTION__, _srs_context->get_id(), msg, ##__VA_ARGS__)
    #define srs_trace(msg, ...)   _srs_log->trace(__PRETTY_FUNCTION__, _srs_context->get_id(), msg, ##__VA_ARGS__)
    #define srs_warn(msg, ...)    _srs_log->warn(__PRETTY_FUNCTION__, _srs_context->get_id(), msg, ##__VA_ARGS__)
    #define srs_error(msg, ...)   _srs_log->error(__PRETTY_FUNCTION__, _srs_context->get_id(), msg, ##__VA_ARGS__)
#endif

// TODO: FIXME: add more verbose and info logs.
#ifndef SRS_AUTO_VERBOSE
    #undef srs_verbose
    #define srs_verbose(msg, ...) (void)0
#endif
#ifndef SRS_AUTO_INFO
    #undef srs_info
    #define srs_info(msg, ...) (void)0
#endif
#ifndef SRS_AUTO_TRACE
    #undef srs_trace
    #define srs_trace(msg, ...) (void)0
#endif

#endif

// following is generated by src/kernel/srs_kernel_buffer.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_KERNEL_BUFFER_HPP
#define SRS_KERNEL_BUFFER_HPP

//#include <srs_core.hpp>

#include <sys/types.h>
#include <string>

class SrsBuffer;

/**
 * the srs codec, to code and decode object with bytes:
 *      code: to encode/serialize object to bytes in buffer,
 *      decode: to decode/deserialize object from bytes in buffer.
 * we use SrsBuffer as bytes helper utility,
 * for example, to code:
 *      ISrsCodec* obj = ...
 *      char* bytes = new char[obj->size()];
 *
 *      SrsBuffer* buf = new SrsBuffer();
 *      buf->initialize(bytes, obj->size())
 *
 *      obj->encode(buf);
 * for example, to decode:
 *      int nb_bytes = ...
 *      char* bytes = ...
 *
 *      SrsBuffer* buf = new Srsbuffer();
 *      buf->initialize(bytes, nb_bytes);
 *
 *      ISrsCodec* obj = ...
 *      obj->decode(buf);
 * @remark protocol or amf0 or json should implements this interface.
 */
// TODO: FIXME: protocol, amf0, json should implements it.
class ISrsCodec
{
public:
    ISrsCodec();
    virtual ~ISrsCodec();
public:
    /**
     * get the number of bytes to code to.
     */
    // TODO: FIXME: change to uint64_t.
    virtual int nb_bytes() = 0;
    /**
     * encode object to bytes in SrsBuffer.
     */
    virtual srs_error_t encode(SrsBuffer* buf) = 0;
public:
    /**
     * decode object from bytes in SrsBuffer.
     */
    virtual srs_error_t decode(SrsBuffer* buf) = 0;
};

/**
 * bytes utility, used to:
 * convert basic types to bytes,
 * build basic types from bytes.
 * @remark the buffer never mange the bytes, user must manage it.
 */
class SrsBuffer
{
private:
    // current position at bytes.
    char* p;
    // the bytes data for stream to read or write.
    char* bytes;
    // the total number of bytes.
    int nb_bytes;
public:
    SrsBuffer();
    SrsBuffer(char* b, int nb_b);
    virtual ~SrsBuffer();
// get the status of stream
public:
    /**
     * get data of stream, set by initialize.
     * current bytes = data() + pos()
     */
    virtual char* data();
    /**
     * the total stream size, set by initialize.
     * left bytes = size() - pos().
     */
    virtual int size();
    /**
     * tell the current pos.
     */
    virtual int pos();
    // Left bytes in buffer, total size() minus the current pos().
    virtual int left();
    /**
     * whether stream is empty.
     * if empty, user should never read or write.
     */
    virtual bool empty();
    /**
     * whether required size is ok.
     * @return true if stream can read/write specified required_size bytes.
     * @remark assert required_size positive.
     */
    virtual bool require(int required_size);
    // to change stream.
public:
    /**
     * to skip some size.
     * @param size can be any value. positive to forward; nagetive to backward.
     * @remark to skip(pos()) to reset stream.
     * @remark assert initialized, the data() not NULL.
     */
    virtual void skip(int size);
public:
    /**
     * get 1bytes char from stream.
     */
    virtual int8_t read_1bytes();
    /**
     * get 2bytes int from stream.
     */
    virtual int16_t read_2bytes();
    /**
     * get 3bytes int from stream.
     */
    virtual int32_t read_3bytes();
    /**
     * get 4bytes int from stream.
     */
    virtual int32_t read_4bytes();
    /**
     * get 8bytes int from stream.
     */
    virtual int64_t read_8bytes();
    /**
     * get string from stream, length specifies by param len.
     */
    virtual std::string read_string(int len);
    /**
     * get bytes from stream, length specifies by param len.
     */
    virtual void read_bytes(char* data, int size);
public:
    /**
     * write 1bytes char to stream.
     */
    virtual void write_1bytes(int8_t value);
    /**
     * write 2bytes int to stream.
     */
    virtual void write_2bytes(int16_t value);
    /**
     * write 4bytes int to stream.
     */
    virtual void write_4bytes(int32_t value);
    /**
     * write 3bytes int to stream.
     */
    virtual void write_3bytes(int32_t value);
    /**
     * write 8bytes int to stream.
     */
    virtual void write_8bytes(int64_t value);
    /**
     * write string to stream
     */
    virtual void write_string(std::string value);
    /**
     * write bytes to stream
     */
    virtual void write_bytes(char* data, int size);
};

/**
 * the bit stream, base on SrsBuffer,
 * for exmaple, the h.264 avc stream is bit stream.
 */
class SrsBitBuffer
{
private:
    int8_t cb;
    uint8_t cb_left;
    SrsBuffer* stream;
public:
    SrsBitBuffer();
    virtual ~SrsBitBuffer();
public:
    virtual srs_error_t initialize(SrsBuffer* s);
    virtual bool empty();
    virtual int8_t read_bit();
};

#endif
// following is generated by src/kernel/srs_kernel_utility.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_KERNEL_UTILITY_HPP
#define SRS_KERNEL_UTILITY_HPP

//#include <srs_core.hpp>

#include <string>
#include <vector>

class SrsBuffer;
class SrsBitBuffer;

// compare
#define srs_min(a, b) (((a) < (b))? (a) : (b))
#define srs_max(a, b) (((a) < (b))? (b) : (a))

// read nalu uev.
extern srs_error_t srs_avc_nalu_read_uev(SrsBitBuffer* stream, int32_t& v);
extern srs_error_t srs_avc_nalu_read_bit(SrsBitBuffer* stream, int8_t& v);

// get current system time in ms, use cache to avoid performance problem
extern int64_t srs_get_system_time_ms();
extern int64_t srs_get_system_startup_time_ms();
// the deamon st-thread will update it.
extern int64_t srs_update_system_time_ms();

// the any address for listener,
// it's "0.0.0.0" for ipv4, and "::" for ipv6.
extern std::string srs_any_address4listener();

// dns resolve utility, return the resolved ip address.
extern std::string srs_dns_resolve(std::string host, int& family);

// split the host:port to host and port.
// @remark the hostport format in <host[:port]>, where port is optional.
extern void srs_parse_hostport(const std::string& hostport, std::string& host, int& port);

// parse the endpoint to ip and port.
// @remark hostport format in <[ip:]port>, where ip is default to "0.0.0.0".
extern void srs_parse_endpoint(std::string hostport, std::string& ip, int& port);

// parse the int64 value to string.
extern std::string srs_int2str(int64_t value);
// parse the float value to string, precise is 2.
extern std::string srs_float2str(double value);
// convert bool to switch value, true to "on", false to "off".
extern std::string srs_bool2switch(bool v);

// whether system is little endian
extern bool srs_is_little_endian();

// replace old_str to new_str of str
extern std::string srs_string_replace(std::string str, std::string old_str, std::string new_str);
// trim char in trim_chars of str
extern std::string srs_string_trim_end(std::string str, std::string trim_chars);
// trim char in trim_chars of str
extern std::string srs_string_trim_start(std::string str, std::string trim_chars);
// remove char in remove_chars of str
extern std::string srs_string_remove(std::string str, std::string remove_chars);
// whether string end with
extern bool srs_string_ends_with(std::string str, std::string flag);
extern bool srs_string_ends_with(std::string str, std::string flag0, std::string flag1);
extern bool srs_string_ends_with(std::string str, std::string flag0, std::string flag1, std::string flag2);
extern bool srs_string_ends_with(std::string str, std::string flag0, std::string flag1, std::string flag2, std::string flag3);
// whether string starts with
extern bool srs_string_starts_with(std::string str, std::string flag);
extern bool srs_string_starts_with(std::string str, std::string flag0, std::string flag1);
extern bool srs_string_starts_with(std::string str, std::string flag0, std::string flag1, std::string flag2);
extern bool srs_string_starts_with(std::string str, std::string flag0, std::string flag1, std::string flag2, std::string flag3);
// whether string contains with
extern bool srs_string_contains(std::string str, std::string flag);
extern bool srs_string_contains(std::string str, std::string flag0, std::string flag1);
extern bool srs_string_contains(std::string str, std::string flag0, std::string flag1, std::string flag2);
// find the min match in str for flags.
extern std::string srs_string_min_match(std::string str, std::vector<std::string> flags);
// split the string by flag to array.
extern std::vector<std::string> srs_string_split(std::string str, std::string flag);
extern std::vector<std::string> srs_string_split(std::string str, std::vector<std::string> flags);

/**
 * compare the memory in bytes.
 * @return true if completely equal; otherwise, false.
 */
extern bool srs_bytes_equals(void* pa, void* pb, int size);

// create dir recursively
extern srs_error_t srs_create_dir_recursively(std::string dir);

// whether path exists.
extern bool srs_path_exists(std::string path);
// get the dirname of path, for instance, dirname("/live/livestream")="/live"
extern std::string srs_path_dirname(std::string path);
// get the basename of path, for instance, basename("/live/livestream")="livestream"
extern std::string srs_path_basename(std::string path);
// get the filename of path, for instance, filename("livestream.flv")="livestream"
extern std::string srs_path_filename(std::string path);
// get the file extension of path, for instance, filext("live.flv")=".flv"
extern std::string srs_path_filext(std::string path);

/**
 * whether stream starts with the avc NALU in "AnnexB"
 * from ISO_IEC_14496-10-AVC-2003.pdf, page 211.
 * start code must be "N[00] 00 00 01" where N>=0
 * @param pnb_start_code output the size of start code, must >=3.
 *       NULL to ignore.
 */
extern bool srs_avc_startswith_annexb(SrsBuffer* stream, int* pnb_start_code = NULL);

/**
 * whether stream starts with the aac ADTS
 * from ISO_IEC_14496-3-AAC-2001.pdf, page 75, 1.A.2.2 ADTS.
 * start code must be '1111 1111 1111'B, that is 0xFFF
 */
extern bool srs_aac_startswith_adts(SrsBuffer* stream);

/**
 * cacl the crc32 of bytes in buf, for ffmpeg.
 */
extern uint32_t srs_crc32_mpegts(const void* buf, int size);

/**
 * calc the crc32 of bytes in buf by IEEE, for zip.
 */
extern uint32_t srs_crc32_ieee(const void* buf, int size, uint32_t previous = 0);

/**
 * Decode a base64-encoded string.
 */
extern srs_error_t srs_av_base64_decode(std::string cipher, std::string& plaintext);

/**
 * Calculate the output size needed to base64-encode x bytes to a
 * null-terminated string.
 */
#define SRS_AV_BASE64_SIZE(x) (((x)+2) / 3 * 4 + 1)

/**
 * convert hex string to data.
 * for example, p=config='139056E5A0'
 * output hex to data={0x13, 0x90, 0x56, 0xe5, 0xa0}
 */
extern int srs_hex_to_data(uint8_t* data, const char* p, int size);

/**
 * generate the c0 chunk header for msg.
 * @param cache, the cache to write header.
 * @param nb_cache, the size of cache.
 * @return the size of header. 0 if cache not enough.
 */
extern int srs_chunk_header_c0(int perfer_cid, uint32_t timestamp, int32_t payload_length, int8_t message_type, int32_t stream_id, char* cache, int nb_cache);

/**
 * generate the c3 chunk header for msg.
 * @param cache, the cache to write header.
 * @param nb_cache, the size of cache.
 * @return the size of header. 0 if cache not enough.
 */
extern int srs_chunk_header_c3(int perfer_cid, uint32_t timestamp, char* cache, int nb_cache);

#endif

// following is generated by src/kernel/srs_kernel_flv.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_KERNEL_FLV_HPP
#define SRS_KERNEL_FLV_HPP

//#include <srs_core.hpp>

#include <string>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <sys/uio.h>
#endif

class SrsBuffer;
class ISrsWriter;
class ISrsReader;
class SrsFileReader;

#define SRS_FLV_TAG_HEADER_SIZE 11
#define SRS_FLV_PREVIOUS_TAG_SIZE 4

/****************************************************************************
 *****************************************************************************
 ****************************************************************************/
/**
 5. Protocol Control Messages
 RTMP reserves message type IDs 1-7 for protocol control messages.
 These messages contain information needed by the RTM Chunk Stream
 protocol or RTMP itself. Protocol messages with IDs 1 & 2 are
 reserved for usage with RTM Chunk Stream protocol. Protocol messages
 with IDs 3-6 are reserved for usage of RTMP. Protocol message with ID
 7 is used between edge server and origin server.
 */
#define RTMP_MSG_SetChunkSize                   0x01
#define RTMP_MSG_AbortMessage                   0x02
#define RTMP_MSG_Acknowledgement                0x03
#define RTMP_MSG_UserControlMessage             0x04
#define RTMP_MSG_WindowAcknowledgementSize      0x05
#define RTMP_MSG_SetPeerBandwidth               0x06
#define RTMP_MSG_EdgeAndOriginServerCommand     0x07
/**
 3. Types of messages
 The server and the client send messages over the network to
 communicate with each other. The messages can be of any type which
 includes audio messages, video messages, command messages, shared
 object messages, data messages, and user control messages.
 3.1. Command message
 Command messages carry the AMF-encoded commands between the client
 and the server. These messages have been assigned message type value
 of 20 for AMF0 encoding and message type value of 17 for AMF3
 encoding. These messages are sent to perform some operations like
 connect, createStream, publish, play, pause on the peer. Command
 messages like onstatus, result etc. are used to inform the sender
 about the status of the requested commands. A command message
 consists of command name, transaction ID, and command object that
 contains related parameters. A client or a server can request Remote
 Procedure Calls (RPC) over streams that are communicated using the
 command messages to the peer.
 */
#define RTMP_MSG_AMF3CommandMessage             17 // 0x11
#define RTMP_MSG_AMF0CommandMessage             20 // 0x14
/**
 3.2. Data message
 The client or the server sends this message to send Metadata or any
 user data to the peer. Metadata includes details about the
 data(audio, video etc.) like creation time, duration, theme and so
 on. These messages have been assigned message type value of 18 for
 AMF0 and message type value of 15 for AMF3.
 */
#define RTMP_MSG_AMF0DataMessage                18 // 0x12
#define RTMP_MSG_AMF3DataMessage                15 // 0x0F
/**
 3.3. Shared object message
 A shared object is a Flash object (a collection of name value pairs)
 that are in synchronization across multiple clients, instances, and
 so on. The message types kMsgContainer=19 for AMF0 and
 kMsgContainerEx=16 for AMF3 are reserved for shared object events.
 Each message can contain multiple events.
 */
#define RTMP_MSG_AMF3SharedObject               16 // 0x10
#define RTMP_MSG_AMF0SharedObject               19 // 0x13
/**
 3.4. Audio message
 The client or the server sends this message to send audio data to the
 peer. The message type value of 8 is reserved for audio messages.
 */
#define RTMP_MSG_AudioMessage                   8 // 0x08
/* *
 3.5. Video message
 The client or the server sends this message to send video data to the
 peer. The message type value of 9 is reserved for video messages.
 These messages are large and can delay the sending of other type of
 messages. To avoid such a situation, the video message is assigned
 the lowest priority.
 */
#define RTMP_MSG_VideoMessage                   9 // 0x09
/**
 3.6. Aggregate message
 An aggregate message is a single message that contains a list of submessages.
 The message type value of 22 is reserved for aggregate
 messages.
 */
#define RTMP_MSG_AggregateMessage               22 // 0x16

/****************************************************************************
 *****************************************************************************
 ****************************************************************************/
/**
 * the chunk stream id used for some under-layer message,
 * for example, the PC(protocol control) message.
 */
#define RTMP_CID_ProtocolControl                0x02
/**
 * the AMF0/AMF3 command message, invoke method and return the result, over NetConnection.
 * generally use 0x03.
 */
#define RTMP_CID_OverConnection                 0x03
/**
 * the AMF0/AMF3 command message, invoke method and return the result, over NetConnection,
 * the midst state(we guess).
 * rarely used, e.g. onStatus(NetStream.Play.Reset).
 */
#define RTMP_CID_OverConnection2                0x04
/**
 * the stream message(amf0/amf3), over NetStream.
 * generally use 0x05.
 */
#define RTMP_CID_OverStream                     0x05
/**
 * the stream message(amf0/amf3), over NetStream, the midst state(we guess).
 * rarely used, e.g. play("mp4:mystram.f4v")
 */
#define RTMP_CID_OverStream2                    0x08
/**
 * the stream message(video), over NetStream
 * generally use 0x06.
 */
#define RTMP_CID_Video                          0x06
/**
 * the stream message(audio), over NetStream.
 * generally use 0x07.
 */
#define RTMP_CID_Audio                          0x07

/**
 * 6.1. Chunk Format
 * Extended timestamp: 0 or 4 bytes
 * This field MUST be sent when the normal timsestamp is set to
 * 0xffffff, it MUST NOT be sent if the normal timestamp is set to
 * anything else. So for values less than 0xffffff the normal
 * timestamp field SHOULD be used in which case the extended timestamp
 * MUST NOT be present. For values greater than or equal to 0xffffff
 * the normal timestamp field MUST NOT be used and MUST be set to
 * 0xffffff and the extended timestamp MUST be sent.
 */
#define RTMP_EXTENDED_TIMESTAMP                 0xFFFFFF

/**
 * 4.1. Message Header
 */
class SrsMessageHeader
{
public:
    /**
     * 3bytes.
     * Three-byte field that contains a timestamp delta of the message.
     * @remark, only used for decoding message from chunk stream.
     */
    int32_t timestamp_delta;
    /**
     * 3bytes.
     * Three-byte field that represents the size of the payload in bytes.
     * It is set in big-endian format.
     */
    int32_t payload_length;
    /**
     * 1byte.
     * One byte field to represent the message type. A range of type IDs
     * (1-7) are reserved for protocol control messages.
     */
    int8_t message_type;
    /**
     * 4bytes.
     * Four-byte field that identifies the stream of the message. These
     * bytes are set in little-endian format.
     */
    int32_t stream_id;
    
    /**
     * Four-byte field that contains a timestamp of the message.
     * The 4 bytes are packed in the big-endian order.
     * @remark, used as calc timestamp when decode and encode time.
     * @remark, we use 64bits for large time for jitter detect and hls.
     */
    int64_t timestamp;
public:
    /**
     * get the perfered cid(chunk stream id) which sendout over.
     * set at decoding, and canbe used for directly send message,
     * for example, dispatch to all connections.
     */
    int perfer_cid;
public:
    SrsMessageHeader();
    virtual ~SrsMessageHeader();
public:
    bool is_audio();
    bool is_video();
    bool is_amf0_command();
    bool is_amf0_data();
    bool is_amf3_command();
    bool is_amf3_data();
    bool is_window_ackledgement_size();
    bool is_ackledgement();
    bool is_set_chunk_size();
    bool is_user_control_message();
    bool is_set_peer_bandwidth();
    bool is_aggregate();
public:
    /**
     * create a amf0 script header, set the size and stream_id.
     */
    void initialize_amf0_script(int size, int stream);
    /**
     * create a audio header, set the size, timestamp and stream_id.
     */
    void initialize_audio(int size, uint32_t time, int stream);
    /**
     * create a video header, set the size, timestamp and stream_id.
     */
    void initialize_video(int size, uint32_t time, int stream);
};

/**
 * message is raw data RTMP message, bytes oriented,
 * protcol always recv RTMP message, and can send RTMP message or RTMP packet.
 * the common message is read from underlay protocol sdk.
 * while the shared ptr message used to copy and send.
 */
class SrsCommonMessage
{
    // 4.1. Message Header
public:
    SrsMessageHeader header;
    // 4.2. Message Payload
public:
    /**
     * current message parsed size,
     *       size <= header.payload_length
     * for the payload maybe sent in multiple chunks.
     */
    int size;
    /**
     * the payload of message, the SrsCommonMessage never know about the detail of payload,
     * user must use SrsProtocol.decode_message to get concrete packet.
     * @remark, not all message payload can be decoded to packet. for example,
     *       video/audio packet use raw bytes, no video/audio packet.
     */
    char* payload;
public:
    SrsCommonMessage();
    virtual ~SrsCommonMessage();
public:
    /**
     * alloc the payload to specified size of bytes.
     */
    virtual void create_payload(int size);
public:
    /**
     * create common message,
     * from the header and body.
     * @remark user should never free the body.
     * @param pheader, the header to copy to the message. NULL to ignore.
     */
    virtual srs_error_t create(SrsMessageHeader* pheader, char* body, int size);
};

/**
 * the message header for shared ptr message.
 * only the message for all msgs are same.
 */
struct SrsSharedMessageHeader
{
    /**
     * 3bytes.
     * Three-byte field that represents the size of the payload in bytes.
     * It is set in big-endian format.
     */
    int32_t payload_length;
    /**
     * 1byte.
     * One byte field to represent the message type. A range of type IDs
     * (1-7) are reserved for protocol control messages.
     */
    int8_t message_type;
    /**
     * get the perfered cid(chunk stream id) which sendout over.
     * set at decoding, and canbe used for directly send message,
     * for example, dispatch to all connections.
     */
    int perfer_cid;
    
    SrsSharedMessageHeader();
    virtual ~SrsSharedMessageHeader();
};

/**
 * shared ptr message.
 * for audio/video/data message that need less memory copy.
 * and only for output.
 *
 * create first object by constructor and create(),
 * use copy if need reference count message.
 *
 */
class SrsSharedPtrMessage
{
    // 4.1. Message Header
public:
    // the header can shared, only set the timestamp and stream id.
    // @see https://github.com/ossrs/srs/issues/251
    //SrsSharedMessageHeader header;
    /**
     * Four-byte field that contains a timestamp of the message.
     * The 4 bytes are packed in the big-endian order.
     * @remark, used as calc timestamp when decode and encode time.
     * @remark, we use 64bits for large time for jitter detect and hls.
     */
    int64_t timestamp;
    /**
     * 4bytes.
     * Four-byte field that identifies the stream of the message. These
     * bytes are set in big-endian format.
     */
    int32_t stream_id;
    // 4.2. Message Payload
public:
    /**
     * current message parsed size,
     *       size <= header.payload_length
     * for the payload maybe sent in multiple chunks.
     */
    int size;
    /**
     * the payload of message, the SrsCommonMessage never know about the detail of payload,
     * user must use SrsProtocol.decode_message to get concrete packet.
     * @remark, not all message payload can be decoded to packet. for example,
     *       video/audio packet use raw bytes, no video/audio packet.
     */
    char* payload;
private:
    class SrsSharedPtrPayload
    {
    public:
        // shared message header.
        // @see https://github.com/ossrs/srs/issues/251
        SrsSharedMessageHeader header;
        // actual shared payload.
        char* payload;
        // size of payload.
        int size;
        // the reference count
        int shared_count;
    public:
        SrsSharedPtrPayload();
        virtual ~SrsSharedPtrPayload();
    };
    SrsSharedPtrPayload* ptr;
public:
    SrsSharedPtrMessage();
    virtual ~SrsSharedPtrMessage();
public:
    /**
     * create shared ptr message,
     * copy header, manage the payload of msg,
     * set the payload to NULL to prevent double free.
     * @remark payload of msg set to NULL if success.
     */
    virtual srs_error_t create(SrsCommonMessage* msg);
    /**
     * create shared ptr message,
     * from the header and payload.
     * @remark user should never free the payload.
     * @param pheader, the header to copy to the message. NULL to ignore.
     */
    virtual srs_error_t create(SrsMessageHeader* pheader, char* payload, int size);
    /**
     * get current reference count.
     * when this object created, count set to 0.
     * if copy() this object, count increase 1.
     * if this or copy deleted, free payload when count is 0, or count--.
     * @remark, assert object is created.
     */
    virtual int count();
    /**
     * check perfer cid and stream id.
     * @return whether stream id already set.
     */
    virtual bool check(int stream_id);
public:
    virtual bool is_av();
    virtual bool is_audio();
    virtual bool is_video();
public:
    /**
     * generate the chunk header to cache.
     * @return the size of header.
     */
    virtual int chunk_header(char* cache, int nb_cache, bool c0);
public:
    /**
     * copy current shared ptr message, use ref-count.
     * @remark, assert object is created.
     */
    virtual SrsSharedPtrMessage* copy();
};

/**
 * Transmux RTMP packets to FLV stream.
 */
class SrsFlvTransmuxer
{
private:
    ISrsWriter* writer;
private:
    char tag_header[SRS_FLV_TAG_HEADER_SIZE];
public:
    SrsFlvTransmuxer();
    virtual ~SrsFlvTransmuxer();
public:
    /**
     * initialize the underlayer file stream.
     * @remark user can initialize multiple times to encode multiple flv files.
     * @remark, user must free the @param fw, flv encoder never close/free it.
     */
    virtual srs_error_t initialize(ISrsWriter* fw);
public:
    /**
     * write flv header.
     * write following:
     *   1. E.2 The FLV header
     *   2. PreviousTagSize0 UI32 Always 0
     * that is, 9+4=13bytes.
     */
    virtual srs_error_t write_header();
    virtual srs_error_t write_header(char flv_header[9]);
    /**
     * write flv metadata.
     * @param type, the type of data, or other message type.
     *       @see SrsFrameType
     * @param data, the amf0 metadata which serialize from:
     *   AMF0 string: onMetaData,
     *   AMF0 object: the metadata object.
     * @remark assert data is not NULL.
     */
    virtual srs_error_t write_metadata(char type, char* data, int size);
    /**
     * write audio/video packet.
     * @remark assert data is not NULL.
     */
    virtual srs_error_t write_audio(int64_t timestamp, char* data, int size);
    virtual srs_error_t write_video(int64_t timestamp, char* data, int size);
public:
    /**
     * get the tag size,
     * including the tag header, body, and 4bytes previous tag size.
     * @remark assert data_size is not negative.
     */
    static int size_tag(int data_size);
#ifdef SRS_PERF_FAST_FLV_ENCODER
private:
    // cache tag header.
    int nb_tag_headers;
    char* tag_headers;
    // cache pps(previous tag size)
    int nb_ppts;
    char* ppts;
    // cache iovss.
    int nb_iovss_cache;
    iovec* iovss_cache;
public:
    /**
     * write the tags in a time.
     */
    virtual srs_error_t write_tags(SrsSharedPtrMessage** msgs, int count);
#endif
private:
    virtual srs_error_t write_metadata_to_cache(char type, char* data, int size, char* cache);
    virtual srs_error_t write_audio_to_cache(int64_t timestamp, char* data, int size, char* cache);
    virtual srs_error_t write_video_to_cache(int64_t timestamp, char* data, int size, char* cache);
    virtual srs_error_t write_pts_to_cache(int size, char* cache);
    virtual srs_error_t write_tag(char* header, int header_size, char* tag, int tag_size);
};

/**
 * decode flv file.
 */
class SrsFlvDecoder
{
private:
    ISrsReader* reader;
public:
    SrsFlvDecoder();
    virtual ~SrsFlvDecoder();
public:
    /**
     * initialize the underlayer file stream
     * @remark user can initialize multiple times to decode multiple flv files.
     * @remark user must free the @param fr, flv decoder never close/free it
     */
    virtual srs_error_t initialize(ISrsReader* fr);
public:
    /**
     * read the flv header, donot including the 4bytes previous tag size.
     * @remark assert header not NULL.
     */
    virtual srs_error_t read_header(char header[9]);
    /**
     * read the tag header infos.
     * @remark assert ptype/pdata_size/ptime not NULL.
     */
    virtual srs_error_t read_tag_header(char* ptype, int32_t* pdata_size, uint32_t* ptime);
    /**
     * read the tag data.
     * @remark assert data not NULL.
     */
    virtual srs_error_t read_tag_data(char* data, int32_t size);
    /**
     * read the 4bytes previous tag size.
     * @remark assert previous_tag_size not NULL.
     */
    virtual srs_error_t read_previous_tag_size(char previous_tag_size[4]);
};

/**
 * decode flv fast by only decoding the header and tag.
 * used for vod flv stream to read the header and sequence header,
 * then seek to specified offset.
 */
class SrsFlvVodStreamDecoder
{
private:
    SrsFileReader* reader;
public:
    SrsFlvVodStreamDecoder();
    virtual ~SrsFlvVodStreamDecoder();
public:
    /**
     * initialize the underlayer file stream
     * @remark user can initialize multiple times to decode multiple flv files.
     * @remark user must free the @param fr, flv decoder never close/free it.
     */
    virtual srs_error_t initialize(ISrsReader* fr);
public:
    /**
     * read the flv header and its size.
     * @param header, fill it 13bytes(9bytes header, 4bytes previous tag size).
     * @remark assert header not NULL.
     */
    virtual srs_error_t read_header_ext(char header[13]);
    /**
     * read the sequence header tags offset and its size.
     * @param pstart, the start offset of sequence header.
     * @param psize, output the size, (tag header)+(tag body)+(4bytes previous tag size).
     * @remark we think the first audio/video is sequence header.
     * @remark assert pstart/psize not NULL.
     */
    virtual srs_error_t read_sequence_header_summary(int64_t* pstart, int* psize);
public:
    /**
     * for start offset, seed to this position and response flv stream.
     */
    virtual srs_error_t seek2(int64_t offset);
};

#endif

// following is generated by src/kernel/srs_kernel_codec.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_KERNEL_CODEC_HPP
#define SRS_KERNEL_CODEC_HPP

//#include <srs_core.hpp>

#include <string>
#include <vector>

class SrsBuffer;

/**
 * The video codec id.
 * @doc video_file_format_spec_v10_1.pdf, page78, E.4.3.1 VIDEODATA
 * CodecID UB [4]
 * Codec Identifier. The following values are defined for FLV:
 *      2 = Sorenson H.263
 *      3 = Screen video
 *      4 = On2 VP6
 *      5 = On2 VP6 with alpha channel
 *      6 = Screen video version 2
 *      7 = AVC
 */
enum SrsVideoCodecId
{
    // set to the zero to reserved, for array map.
    SrsVideoCodecIdReserved = 0,
    SrsVideoCodecIdForbidden = 0,
    SrsVideoCodecIdReserved1 = 1,
    SrsVideoCodecIdReserved2 = 9,
    
    // for user to disable video, for example, use pure audio hls.
    SrsVideoCodecIdDisabled = 8,
    
    SrsVideoCodecIdSorensonH263 = 2,
    SrsVideoCodecIdScreenVideo = 3,
    SrsVideoCodecIdOn2VP6 = 4,
    SrsVideoCodecIdOn2VP6WithAlphaChannel = 5,
    SrsVideoCodecIdScreenVideoVersion2 = 6,
    SrsVideoCodecIdAVC = 7,
};
std::string srs_video_codec_id2str(SrsVideoCodecId codec);

/**
 * The video AVC frame trait(characteristic).
 * @doc video_file_format_spec_v10_1.pdf, page79, E.4.3.2 AVCVIDEOPACKET
 * AVCPacketType IF CodecID == 7 UI8
 * The following values are defined:
 *      0 = AVC sequence header
 *      1 = AVC NALU
 *      2 = AVC end of sequence (lower level NALU sequence ender is not required or supported)
 */
enum SrsVideoAvcFrameTrait
{
    // set to the max value to reserved, for array map.
    SrsVideoAvcFrameTraitReserved = 3,
    SrsVideoAvcFrameTraitForbidden = 3,
    
    SrsVideoAvcFrameTraitSequenceHeader = 0,
    SrsVideoAvcFrameTraitNALU = 1,
    SrsVideoAvcFrameTraitSequenceHeaderEOF = 2,
};

/**
 * The video AVC frame type, such as I/P/B.
 * @doc video_file_format_spec_v10_1.pdf, page78, E.4.3.1 VIDEODATA
 * Frame Type UB [4]
 * Type of video frame. The following values are defined:
 *      1 = key frame (for AVC, a seekable frame)
 *      2 = inter frame (for AVC, a non-seekable frame)
 *      3 = disposable inter frame (H.263 only)
 *      4 = generated key frame (reserved for server use only)
 *      5 = video info/command frame
 */
enum SrsVideoAvcFrameType
{
    // set to the zero to reserved, for array map.
    SrsVideoAvcFrameTypeReserved = 0,
    SrsVideoAvcFrameTypeForbidden = 0,
    SrsVideoAvcFrameTypeReserved1 = 6,
    
    SrsVideoAvcFrameTypeKeyFrame = 1,
    SrsVideoAvcFrameTypeInterFrame = 2,
    SrsVideoAvcFrameTypeDisposableInterFrame = 3,
    SrsVideoAvcFrameTypeGeneratedKeyFrame = 4,
    SrsVideoAvcFrameTypeVideoInfoFrame = 5,
};

/**
 * The audio codec id.
 * @doc video_file_format_spec_v10_1.pdf, page 76, E.4.2 Audio Tags
 * SoundFormat UB [4]
 * Format of SoundData. The following values are defined:
 *     0 = Linear PCM, platform endian
 *     1 = ADPCM
 *     2 = MP3
 *     3 = Linear PCM, little endian
 *     4 = Nellymoser 16 kHz mono
 *     5 = Nellymoser 8 kHz mono
 *     6 = Nellymoser
 *     7 = G.711 A-law logarithmic PCM
 *     8 = G.711 mu-law logarithmic PCM
 *     9 = reserved
 *     10 = AAC
 *     11 = Speex
 *     14 = MP3 8 kHz
 *     15 = Device-specific sound
 * Formats 7, 8, 14, and 15 are reserved.
 * AAC is supported in Flash Player 9,0,115,0 and higher.
 * Speex is supported in Flash Player 10 and higher.
 */
enum SrsAudioCodecId
{
    // set to the max value to reserved, for array map.
    SrsAudioCodecIdReserved1 = 16,
    SrsAudioCodecIdForbidden = 16,
    
    // for user to disable audio, for example, use pure video hls.
    SrsAudioCodecIdDisabled = 17,
    
    SrsAudioCodecIdLinearPCMPlatformEndian = 0,
    SrsAudioCodecIdADPCM = 1,
    SrsAudioCodecIdMP3 = 2,
    SrsAudioCodecIdLinearPCMLittleEndian = 3,
    SrsAudioCodecIdNellymoser16kHzMono = 4,
    SrsAudioCodecIdNellymoser8kHzMono = 5,
    SrsAudioCodecIdNellymoser = 6,
    SrsAudioCodecIdReservedG711AlawLogarithmicPCM = 7,
    SrsAudioCodecIdReservedG711MuLawLogarithmicPCM = 8,
    SrsAudioCodecIdReserved = 9,
    SrsAudioCodecIdAAC = 10,
    SrsAudioCodecIdSpeex = 11,
    SrsAudioCodecIdReservedMP3_8kHz = 14,
    SrsAudioCodecIdReservedDeviceSpecificSound = 15,
};
std::string srs_audio_codec_id2str(SrsAudioCodecId codec);

/**
 * The audio AAC frame trait(characteristic).
 * @doc video_file_format_spec_v10_1.pdf, page 77, E.4.2 Audio Tags
 * AACPacketType IF SoundFormat == 10 UI8
 * The following values are defined:
 *      0 = AAC sequence header
 *      1 = AAC raw
 */
enum SrsAudioAacFrameTrait
{
    // set to the max value to reserved, for array map.
    SrsAudioAacFrameTraitReserved = 2,
    SrsAudioAacFrameTraitForbidden = 2,
    
    SrsAudioAacFrameTraitSequenceHeader = 0,
    SrsAudioAacFrameTraitRawData = 1,
};

/**
 * The audio sample rate.
 * @see srs_flv_srates and srs_aac_srates.
 * @doc video_file_format_spec_v10_1.pdf, page 76, E.4.2 Audio Tags
 *      0 = 5.5 kHz = 5512 Hz
 *      1 = 11 kHz = 11025 Hz
 *      2 = 22 kHz = 22050 Hz
 *      3 = 44 kHz = 44100 Hz
 * However, we can extends this table.
 * @remark Use srs_flv_srates to convert it.
 */
enum SrsAudioSampleRate
{
    // set to the max value to reserved, for array map.
    SrsAudioSampleRateReserved = 4,
    SrsAudioSampleRateForbidden = 4,
    
    SrsAudioSampleRate5512 = 0,
    SrsAudioSampleRate11025 = 1,
    SrsAudioSampleRate22050 = 2,
    SrsAudioSampleRate44100 = 3,
};
std::string srs_audio_sample_rate2str(SrsAudioSampleRate v);

/**
 * The frame type, for example, audio, video or data.
 * @doc video_file_format_spec_v10_1.pdf, page 75, E.4.1 FLV Tag
 */
enum SrsFrameType
{
    // set to the zero to reserved, for array map.
    SrsFrameTypeReserved = 0,
    SrsFrameTypeForbidden = 0,
    
    // 8 = audio
    SrsFrameTypeAudio = 8,
    // 9 = video
    SrsFrameTypeVideo = 9,
    // 18 = script data
    SrsFrameTypeScript = 18,
};

/**
 * Fast tough the codec of FLV video.
 * @doc video_file_format_spec_v10_1.pdf, page 78, E.4.3 Video Tags
 */
class SrsFlvVideo
{
public:
    SrsFlvVideo();
    virtual ~SrsFlvVideo();
    // the following function used to finger out the flv/rtmp packet detail.
public:
    /**
     * only check the frame_type, not check the codec type.
     */
    static bool keyframe(char* data, int size);
    /**
     * check codec h264, keyframe, sequence header
     */
    // TODO: FIXME: Remove it, use SrsFormat instead.
    static bool sh(char* data, int size);
    /**
     * check codec h264.
     */
    static bool h264(char* data, int size);
    /**
     * check the video RTMP/flv header info,
     * @return true if video RTMP/flv header is ok.
     * @remark all type of audio is possible, no need to check audio.
     */
    static bool acceptable(char* data, int size);
};

/**
 * Fast tough the codec of FLV video.
 * @doc video_file_format_spec_v10_1.pdf, page 76, E.4.2 Audio Tags
 */
class SrsFlvAudio
{
public:
    SrsFlvAudio();
    virtual ~SrsFlvAudio();
    // the following function used to finger out the flv/rtmp packet detail.
public:
    /**
     * check codec aac, sequence header
     */
    static bool sh(char* data, int size);
    /**
     * check codec aac.
     */
    static bool aac(char* data, int size);
};

/**
 * the public data, event HLS disable, others can use it.
 */
/**
 * the flv sample rate map
 */
extern int srs_flv_srates[];

/**
 * the aac sample rate map
 */
extern int srs_aac_srates[];

// The impossible aac sample rate index.
#define SrsAacSampleRateUnset 15

// The max number of NALUs in a video, or aac frame in audio packet.
#define SrsMaxNbSamples 256

/**
 * The audio sample size in bits.
 * @doc video_file_format_spec_v10_1.pdf, page 76, E.4.2 Audio Tags
 * Size of each audio sample. This parameter only pertains to
 * uncompressed formats. Compressed formats always decode
 * to 16 bits internally.
 *      0 = 8-bit samples
 *      1 = 16-bit samples
 */
enum SrsAudioSampleBits
{
    // set to the max value to reserved, for array map.
    SrsAudioSampleBitsReserved = 2,
    SrsAudioSampleBitsForbidden = 2,
    
    SrsAudioSampleBits8bit = 0,
    SrsAudioSampleBits16bit = 1,
};
std::string srs_audio_sample_bits2str(SrsAudioSampleBits v);

/**
 * The audio channels.
 * @doc video_file_format_spec_v10_1.pdf, page 77, E.4.2 Audio Tags
 * Mono or stereo sound
 *      0 = Mono sound
 *      1 = Stereo sound
 */
enum SrsAudioChannels
{
    // set to the max value to reserved, for array map.
    SrsAudioChannelsReserved = 2,
    SrsAudioChannelsForbidden = 2,
    
    SrsAudioChannelsMono = 0,
    SrsAudioChannelsStereo = 1,
};
std::string srs_audio_channels2str(SrsAudioChannels v);

/**
 * Table 7-1 - NAL unit type codes, syntax element categories, and NAL unit type classes
 * ISO_IEC_14496-10-AVC-2012.pdf, page 83.
 */
enum SrsAvcNaluType
{
    // Unspecified
    SrsAvcNaluTypeReserved = 0,
    SrsAvcNaluTypeForbidden = 0,
    
    // Coded slice of a non-IDR picture slice_layer_without_partitioning_rbsp( )
    SrsAvcNaluTypeNonIDR = 1,
    // Coded slice data partition A slice_data_partition_a_layer_rbsp( )
    SrsAvcNaluTypeDataPartitionA = 2,
    // Coded slice data partition B slice_data_partition_b_layer_rbsp( )
    SrsAvcNaluTypeDataPartitionB = 3,
    // Coded slice data partition C slice_data_partition_c_layer_rbsp( )
    SrsAvcNaluTypeDataPartitionC = 4,
    // Coded slice of an IDR picture slice_layer_without_partitioning_rbsp( )
    SrsAvcNaluTypeIDR = 5,
    // Supplemental enhancement information (SEI) sei_rbsp( )
    SrsAvcNaluTypeSEI = 6,
    // Sequence parameter set seq_parameter_set_rbsp( )
    SrsAvcNaluTypeSPS = 7,
    // Picture parameter set pic_parameter_set_rbsp( )
    SrsAvcNaluTypePPS = 8,
    // Access unit delimiter access_unit_delimiter_rbsp( )
    SrsAvcNaluTypeAccessUnitDelimiter = 9,
    // End of sequence end_of_seq_rbsp( )
    SrsAvcNaluTypeEOSequence = 10,
    // End of stream end_of_stream_rbsp( )
    SrsAvcNaluTypeEOStream = 11,
    // Filler data filler_data_rbsp( )
    SrsAvcNaluTypeFilterData = 12,
    // Sequence parameter set extension seq_parameter_set_extension_rbsp( )
    SrsAvcNaluTypeSPSExt = 13,
    // Prefix NAL unit prefix_nal_unit_rbsp( )
    SrsAvcNaluTypePrefixNALU = 14,
    // Subset sequence parameter set subset_seq_parameter_set_rbsp( )
    SrsAvcNaluTypeSubsetSPS = 15,
    // Coded slice of an auxiliary coded picture without partitioning slice_layer_without_partitioning_rbsp( )
    SrsAvcNaluTypeLayerWithoutPartition = 19,
    // Coded slice extension slice_layer_extension_rbsp( )
    SrsAvcNaluTypeCodedSliceExt = 20,
};
std::string srs_avc_nalu2str(SrsAvcNaluType nalu_type);

/**
 * the avc payload format, must be ibmf or annexb format.
 * we guess by annexb first, then ibmf for the first time,
 * and we always use the guessed format for the next time.
 */
enum SrsAvcPayloadFormat
{
    SrsAvcPayloadFormatGuess = 0,
    SrsAvcPayloadFormatAnnexb,
    SrsAvcPayloadFormatIbmf,
};

/**
 * the aac profile, for ADTS(HLS/TS)
 * @see https://github.com/ossrs/srs/issues/310
 */
enum SrsAacProfile
{
    SrsAacProfileReserved = 3,
    
    // @see 7.1 Profiles, ISO_IEC_13818-7-AAC-2004.pdf, page 40
    SrsAacProfileMain = 0,
    SrsAacProfileLC = 1,
    SrsAacProfileSSR = 2,
};
std::string srs_aac_profile2str(SrsAacProfile aac_profile);

/**
 * the aac object type, for RTMP sequence header
 * for AudioSpecificConfig, @see ISO_IEC_14496-3-AAC-2001.pdf, page 33
 * for audioObjectType, @see ISO_IEC_14496-3-AAC-2001.pdf, page 23
 */
enum SrsAacObjectType
{
    SrsAacObjectTypeReserved = 0,
    SrsAacObjectTypeForbidden = 0,
    
    // Table 1.1 - Audio Object Type definition
    // @see @see ISO_IEC_14496-3-AAC-2001.pdf, page 23
    SrsAacObjectTypeAacMain = 1,
    SrsAacObjectTypeAacLC = 2,
    SrsAacObjectTypeAacSSR = 3,
    
    // AAC HE = LC+SBR
    SrsAacObjectTypeAacHE = 5,
    // AAC HEv2 = LC+SBR+PS
    SrsAacObjectTypeAacHEV2 = 29,
};
std::string srs_aac_object2str(SrsAacObjectType aac_object);
// ts/hls/adts audio header profile to RTMP sequence header object type.
SrsAacObjectType srs_aac_ts2rtmp(SrsAacProfile profile);
// RTMP sequence header object type to ts/hls/adts audio header profile.
SrsAacProfile srs_aac_rtmp2ts(SrsAacObjectType object_type);

/**
 * the profile for avc/h.264.
 * @see Annex A Profiles and levels, ISO_IEC_14496-10-AVC-2003.pdf, page 205.
 */
enum SrsAvcProfile
{
    SrsAvcProfileReserved = 0,
    
    // @see ffmpeg, libavcodec/avcodec.h:2713
    SrsAvcProfileBaseline = 66,
    // FF_PROFILE_H264_CONSTRAINED  (1<<9)  // 8+1; constraint_set1_flag
    // FF_PROFILE_H264_CONSTRAINED_BASELINE (66|FF_PROFILE_H264_CONSTRAINED)
    SrsAvcProfileConstrainedBaseline = 578,
    SrsAvcProfileMain = 77,
    SrsAvcProfileExtended = 88,
    SrsAvcProfileHigh = 100,
    SrsAvcProfileHigh10 = 110,
    SrsAvcProfileHigh10Intra = 2158,
    SrsAvcProfileHigh422 = 122,
    SrsAvcProfileHigh422Intra = 2170,
    SrsAvcProfileHigh444 = 144,
    SrsAvcProfileHigh444Predictive = 244,
    SrsAvcProfileHigh444Intra = 2192,
};
std::string srs_avc_profile2str(SrsAvcProfile profile);

/**
 * the level for avc/h.264.
 * @see Annex A Profiles and levels, ISO_IEC_14496-10-AVC-2003.pdf, page 207.
 */
enum SrsAvcLevel
{
    SrsAvcLevelReserved = 0,
    
    SrsAvcLevel_1 = 10,
    SrsAvcLevel_11 = 11,
    SrsAvcLevel_12 = 12,
    SrsAvcLevel_13 = 13,
    SrsAvcLevel_2 = 20,
    SrsAvcLevel_21 = 21,
    SrsAvcLevel_22 = 22,
    SrsAvcLevel_3 = 30,
    SrsAvcLevel_31 = 31,
    SrsAvcLevel_32 = 32,
    SrsAvcLevel_4 = 40,
    SrsAvcLevel_41 = 41,
    SrsAvcLevel_5 = 50,
    SrsAvcLevel_51 = 51,
};
std::string srs_avc_level2str(SrsAvcLevel level);

/**
 * A sample is the unit of frame.
 * It's a NALU for H.264.
 * It's the whole AAC raw data for AAC.
 * @remark Neither SPS/PPS or ASC is sample unit, it's codec sequence header.
 */
class SrsSample
{
public:
    // The size of unit.
    int size;
    // The ptr of unit, user must manage it.
    char* bytes;
public:
    SrsSample();
    virtual ~SrsSample();
};

/**
 * The codec is the information of encoder,
 * corresponding to the sequence header of FLV,
 * parsed to detail info.
 */
class SrsCodecConfig
{
public:
    SrsCodecConfig();
    virtual ~SrsCodecConfig();
};

/**
 * The audio codec info.
 */
class SrsAudioCodecConfig : public SrsCodecConfig
{
    // In FLV specification.
public:
    // The audio codec id; for FLV, it's SoundFormat.
    SrsAudioCodecId id;
    // The audio sample rate; for FLV, it's SoundRate.
    SrsAudioSampleRate sound_rate;
    // The audio sample size, such as 16 bits; for FLV, it's SoundSize.
    SrsAudioSampleBits sound_size;
    // The audio number of channels; for FLV, it's SoundType.
    // TODO: FIXME: Rename to sound_channels.
    SrsAudioChannels sound_type;
    int audio_data_rate; // in bps
    // In AAC specification.
public:
    /**
     * audio specified
     * audioObjectType, in 1.6.2.1 AudioSpecificConfig, page 33,
     * 1.5.1.1 Audio object type definition, page 23,
     *           in ISO_IEC_14496-3-AAC-2001.pdf.
     */
    SrsAacObjectType aac_object;
    /**
     * samplingFrequencyIndex
     */
    uint8_t aac_sample_rate;
    /**
     * channelConfiguration
     */
    uint8_t aac_channels;
    // Sequence header payload.
public:
    /**
     * the aac extra data, the AAC sequence header,
     * without the flv codec header,
     * @see: ffmpeg, AVCodecContext::extradata
     */
    std::vector<char> aac_extra_data;
public:
    SrsAudioCodecConfig();
    virtual ~SrsAudioCodecConfig();
public:
    virtual bool is_aac_codec_ok();
};

/**
 * The video codec info.
 */
class SrsVideoCodecConfig : public SrsCodecConfig
{
public:
    SrsVideoCodecId id;
    int video_data_rate; // in bps
    double frame_rate;
    double duration;
    int width;
    int height;
public:
    /**
     * the avc extra data, the AVC sequence header,
     * without the flv codec header,
     * @see: ffmpeg, AVCodecContext::extradata
     */
    std::vector<char> avc_extra_data;
public:
    /**
     * video specified
     */
    // profile_idc, ISO_IEC_14496-10-AVC-2003.pdf, page 45.
    SrsAvcProfile avc_profile;
    // level_idc, ISO_IEC_14496-10-AVC-2003.pdf, page 45.
    SrsAvcLevel avc_level;
    // lengthSizeMinusOne, ISO_IEC_14496-15-AVC-format-2012.pdf, page 16
    int8_t NAL_unit_length;
    std::vector<char> sequenceParameterSetNALUnit;
    std::vector<char> pictureParameterSetNALUnit;
public:
    // the avc payload format.
    SrsAvcPayloadFormat payload_format;
public:
    SrsVideoCodecConfig();
    virtual ~SrsVideoCodecConfig();
public:
    virtual bool is_avc_codec_ok();
};

/**
 * A frame, consists of a codec and a group of samples.
 */
class SrsFrame
{
public:
    // The DTS/PTS in milliseconds, which is TBN=1000.
    int64_t dts;
    // PTS = DTS + CTS.
    int32_t cts;
public:
    // The codec info of frame.
    SrsCodecConfig* codec;
    // The actual parsed number of samples.
    int nb_samples;
    // The sampels cache.
    SrsSample samples[SrsMaxNbSamples];
public:
    SrsFrame();
    virtual ~SrsFrame();
public:
    // Initialize the frame, to parse sampels.
    virtual srs_error_t initialize(SrsCodecConfig* c);
    // Add a sample to frame.
    virtual srs_error_t add_sample(char* bytes, int size);
};

/**
 * A audio frame, besides a frame, contains the audio frame info, such as frame type.
 */
class SrsAudioFrame : public SrsFrame
{
public:
    SrsAudioAacFrameTrait aac_packet_type;
public:
    SrsAudioFrame();
    virtual ~SrsAudioFrame();
public:
    virtual SrsAudioCodecConfig* acodec();
};

/**
 * A video frame, besides a frame, contains the video frame info, such as frame type.
 */
class SrsVideoFrame : public SrsFrame
{
public:
    // video specified
    SrsVideoAvcFrameType frame_type;
    SrsVideoAvcFrameTrait avc_packet_type;
    // whether sample_units contains IDR frame.
    bool has_idr;
    // Whether exists AUD NALU.
    bool has_aud;
    // Whether exists SPS/PPS NALU.
    bool has_sps_pps;
    // The first nalu type.
    SrsAvcNaluType first_nalu_type;
public:
    SrsVideoFrame();
    virtual ~SrsVideoFrame();
public:
    // Add the sample without ANNEXB or IBMF header, or RAW AAC or MP3 data.
    virtual srs_error_t add_sample(char* bytes, int size);
public:
    virtual SrsVideoCodecConfig* vcodec();
};

/**
 * A codec format, including one or many stream, each stream identified by a frame.
 * For example, a typical RTMP stream format, consits of a video and audio frame.
 * Maybe some RTMP stream only has a audio stream, for instance, redio application.
 */
class SrsFormat
{
public:
    SrsAudioFrame* audio;
    SrsAudioCodecConfig* acodec;
    SrsVideoFrame* video;
    SrsVideoCodecConfig* vcodec;
public:
    char* raw;
    int nb_raw;
public:
    // for sequence header, whether parse the h.264 sps.
    // TODO: FIXME: Refine it.
    bool            avc_parse_sps;
public:
    SrsFormat();
    virtual ~SrsFormat();
public:
    // Initialize the format.
    virtual srs_error_t initialize();
    // When got a parsed audio packet.
    // @param data The data in FLV format.
    virtual srs_error_t on_audio(int64_t timestamp, char* data, int size);
    // When got a parsed video packet.
    // @param data The data in FLV format.
    virtual srs_error_t on_video(int64_t timestamp, char* data, int size);
    // When got a audio aac sequence header.
    virtual srs_error_t on_aac_sequence_header(char* data, int size);
public:
    virtual bool is_aac_sequence_header();
    virtual bool is_avc_sequence_header();
private:
    // Demux the video packet in H.264 codec.
    // The packet is muxed in FLV format, defined in flv specification.
    //          Demux the sps/pps from sequence header.
    //          Demux the samples from NALUs.
    virtual srs_error_t video_avc_demux(SrsBuffer* stream, int64_t timestamp);
private:
    // Parse the H.264 SPS/PPS.
    virtual srs_error_t avc_demux_sps_pps(SrsBuffer* stream);
    virtual srs_error_t avc_demux_sps();
    virtual srs_error_t avc_demux_sps_rbsp(char* rbsp, int nb_rbsp);
private:
    // Parse the H.264 NALUs.
    virtual srs_error_t video_nalu_demux(SrsBuffer* stream);
    // Demux the avc NALU in "AnnexB" from ISO_IEC_14496-10-AVC-2003.pdf, page 211.
    virtual srs_error_t avc_demux_annexb_format(SrsBuffer* stream);
    // Demux the avc NALU in "ISO Base Media File Format" from ISO_IEC_14496-15-AVC-format-2012.pdf, page 20
    virtual srs_error_t avc_demux_ibmf_format(SrsBuffer* stream);
private:
    // Demux the audio packet in AAC codec.
    //          Demux the asc from sequence header.
    //          Demux the sampels from RAW data.
    virtual srs_error_t audio_aac_demux(SrsBuffer* stream, int64_t timestamp);
    virtual srs_error_t audio_mp3_demux(SrsBuffer* stream, int64_t timestamp);
public:
    // Directly demux the sequence header, without RTMP packet header.
    virtual srs_error_t audio_aac_sequence_header_demux(char* data, int size);
};

#endif

// following is generated by src/kernel/srs_kernel_io.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_KERNEL_IO_HPP
#define SRS_KERNEL_IO_HPP

//#include <srs_core.hpp>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <sys/uio.h>
#endif

/**
 * The reader to read data from channel.
 */
class ISrsReader
{
public:
    ISrsReader();
    virtual ~ISrsReader();
public:
    /**
     * Read bytes from reader.
     * @param nread How many bytes read from channel. NULL to ignore.
     */
    virtual srs_error_t read(void* buf, size_t size, ssize_t* nread) = 0;
};

/**
 * The seeker to seek with a device.
 */
class ISrsSeeker
{
public:
    ISrsSeeker();
    virtual ~ISrsSeeker();
public:
    /**
     * The lseek() function repositions the offset of the file descriptor fildes to the argument offset, according to the
     * directive whence. lseek() repositions the file pointer fildes as follows:
     *      If whence is SEEK_SET, the offset is set to offset bytes.
     *      If whence is SEEK_CUR, the offset is set to its current location plus offset bytes.
     *      If whence is SEEK_END, the offset is set to the size of the file plus offset bytes.
     * @param seeked Upon successful completion, lseek() returns the resulting offset location as measured in bytes from
     *      the beginning of the file. NULL to ignore.
     */
    virtual srs_error_t lseek(off_t offset, int whence, off_t* seeked) = 0;
};

/**
 * The reader and seeker.
 */
class ISrsReadSeeker : virtual public ISrsReader, virtual public ISrsSeeker
{
public:
    ISrsReadSeeker();
    virtual ~ISrsReadSeeker();
};

/**
 * The writer to write stream data to channel.
 */
class ISrsStreamWriter
{
public:
    ISrsStreamWriter();
    virtual ~ISrsStreamWriter();
public:
    /**
     * write bytes over writer.
     * @nwrite the actual written bytes. NULL to ignore.
     */
    virtual srs_error_t write(void* buf, size_t size, ssize_t* nwrite) = 0;
};

/**
 * The vector writer to write vector(iovc) to channel.
 */
class ISrsVectorWriter
{
public:
    ISrsVectorWriter();
    virtual ~ISrsVectorWriter();
public:
    /**
     * write iov over writer.
     * @nwrite the actual written bytes. NULL to ignore.
     * @remark for the HTTP FLV, to writev to improve performance.
     *      @see https://github.com/ossrs/srs/issues/405
     */
    virtual srs_error_t writev(const iovec *iov, int iov_size, ssize_t* nwrite) = 0;
};

/**
 * The generally writer, stream and vector writer.
 */
class ISrsWriter : virtual public ISrsStreamWriter, virtual public ISrsVectorWriter
{
public:
    ISrsWriter();
    virtual ~ISrsWriter();
};

/**
 * The writer and seeker.
 */
class ISrsWriteSeeker : virtual public ISrsWriter, virtual public ISrsSeeker
{
public:
    ISrsWriteSeeker();
    virtual ~ISrsWriteSeeker();
};

#endif

// following is generated by src/kernel/srs_kernel_consts.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_KERNEL_CONSTS_HPP
#define SRS_KERNEL_CONSTS_HPP

//#include <srs_core.hpp>

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
// RTMP consts values
///////////////////////////////////////////////////////////
// default vhost of rtmp
#define SRS_CONSTS_RTMP_DEFAULT_VHOST "__defaultVhost__"
#define SRS_CONSTS_RTMP_DEFAULT_APP "__defaultApp__"
// default port of rtmp
#define SRS_CONSTS_RTMP_DEFAULT_PORT 1935

// the default chunk size for system.
#define SRS_CONSTS_RTMP_SRS_CHUNK_SIZE 60000
// 6. Chunking, RTMP protocol default chunk size.
#define SRS_CONSTS_RTMP_PROTOCOL_CHUNK_SIZE 128

/**
 * 6. Chunking
 * The chunk size is configurable. It can be set using a control
 * message(Set Chunk Size) as described in section 7.1. The maximum
 * chunk size can be 65536 bytes and minimum 128 bytes. Larger values
 * reduce CPU usage, but also commit to larger writes that can delay
 * other content on lower bandwidth connections. Smaller chunks are not
 * good for high-bit rate streaming. Chunk size is maintained
 * independently for each direction.
 */
#define SRS_CONSTS_RTMP_MIN_CHUNK_SIZE 128
#define SRS_CONSTS_RTMP_MAX_CHUNK_SIZE 65536


// the following is the timeout for rtmp protocol,
// to avoid death connection.

// Never timeout in ms
// @remake Rename from SRS_CONSTS_NO_TIMEOUT
// @see ST_UTIME_NO_TIMEOUT
#define SRS_CONSTS_NO_TMMS ((int64_t) -1LL)

// the common io timeout, for both recv and send.
// TODO: FIXME: use ms for timeout.
#define SRS_CONSTS_RTMP_TMMS (30*1000)

// the timeout to wait for client control message,
// if timeout, we generally ignore and send the data to client,
// generally, it's the pulse time for data seding.
// @remark, recomment to 500ms.
#define SRS_CONSTS_RTMP_PULSE_TMMS (500)

/**
 * max rtmp header size:
 *     1bytes basic header,
 *     11bytes message header,
 *     4bytes timestamp header,
 * that is, 1+11+4=16bytes.
 */
#define SRS_CONSTS_RTMP_MAX_FMT0_HEADER_SIZE 16
/**
 * max rtmp header size:
 *     1bytes basic header,
 *     4bytes timestamp header,
 * that is, 1+4=5bytes.
 */
// always use fmt0 as cache.
#define SRS_CONSTS_RTMP_MAX_FMT3_HEADER_SIZE 5

/**
 * for performance issue,
 * the iovs cache, @see https://github.com/ossrs/srs/issues/194
 * iovs cache for multiple messages for each connections.
 * suppose the chunk size is 64k, each message send in a chunk which needs only 2 iovec,
 * so the iovs max should be (SRS_PERF_MW_MSGS * 2)
 *
 * @remark, SRS will realloc when the iovs not enough.
 */
#define SRS_CONSTS_IOVS_MAX (SRS_PERF_MW_MSGS * 2)
/**
 * for performance issue,
 * the c0c3 cache, @see https://github.com/ossrs/srs/issues/194
 * c0c3 cache for multiple messages for each connections.
 * each c0 <= 16byes, suppose the chunk size is 64k,
 * each message send in a chunk which needs only a c0 header,
 * so the c0c3 cache should be (SRS_PERF_MW_MSGS * 16)
 *
 * @remark, SRS will try another loop when c0c3 cache dry, for we cannot realloc it.
 *       so we use larger c0c3 cache, that is (SRS_PERF_MW_MSGS * 32)
 */
#define SRS_CONSTS_C0C3_HEADERS_MAX (SRS_PERF_MW_MSGS * 32)

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
// SRS consts values
///////////////////////////////////////////////////////////
#define SRS_CONSTS_NULL_FILE "/dev/null"
#define SRS_CONSTS_LOCALHOST "127.0.0.1"

// signal defines.
// reload the config file and apply new config.
#define SRS_SIGNAL_RELOAD SIGHUP
// reopen the log file.
#define SRS_SIGNAL_REOPEN_LOG SIGUSR1
// srs should gracefully quit, do dispose then exit.
#define SRS_SIGNAL_GRACEFULLY_QUIT SIGTERM

// application level signals.
// persistence the config in memory to config file.
// @see https://github.com/ossrs/srs/issues/319#issuecomment-134993922
// @remark we actually don't handle the signal for it's not a valid os signal.
#define SRS_SIGNAL_PERSISTENCE_CONFIG 1000

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
// log consts values
///////////////////////////////////////////////////////////
// downloading speed-up, play to edge, ingest from origin
#define SRS_CONSTS_LOG_EDGE_PLAY "EIG"
// uploading speed-up, publish to edge, foward to origin
#define SRS_CONSTS_LOG_EDGE_PUBLISH "EFW"
// edge/origin forwarder.
#define SRS_CONSTS_LOG_FOWARDER "FWR"
// play stream on edge/origin.
#define SRS_CONSTS_LOG_PLAY "PLA"
// client publish to edge/origin
#define SRS_CONSTS_LOG_CLIENT_PUBLISH "CPB"
// web/flash publish to edge/origin
#define SRS_CONSTS_LOG_WEB_PUBLISH "WPB"
// ingester for edge(play)/origin
#define SRS_CONSTS_LOG_INGESTER "IGS"
// hls log id.
#define SRS_CONSTS_LOG_HLS "HLS"
// encoder log id.
#define SRS_CONSTS_LOG_ENCODER "ENC"
// http stream log id.
#define SRS_CONSTS_LOG_HTTP_STREAM "HTS"
// http stream cache log id.
#define SRS_CONSTS_LOG_HTTP_STREAM_CACHE "HTC"
// stream caster log id.
#define SRS_CONSTS_LOG_STREAM_CASTER "SCS"
// the nginx exec log id.
#define SRS_CONSTS_LOG_EXEC "EXE"

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
// RTMP consts values
///////////////////////////////////////////////////////////
#define SRS_CONSTS_RTMP_SET_DATAFRAME            "@setDataFrame"
#define SRS_CONSTS_RTMP_ON_METADATA              "onMetaData"

///////////////////////////////////////////////////////////
// HTTP/HLS consts values
///////////////////////////////////////////////////////////
// @see hls-m3u8-draft-pantos-http-live-streaming-12.pdf, page 4
// Lines are terminated by either a single LF character or a CR
// character followed by an LF character.
// CR             = <US-ASCII CR, carriage return (13)>
#define SRS_CONSTS_CR '\r' // 0x0D
// LF             = <US-ASCII LF, linefeed (10)>
#define SRS_CONSTS_LF '\n' // 0x0A
// SP             = <US-ASCII SP, space>
#define SRS_CONSTS_SP ' ' // 0x20
// SE             = <US-ASCII SE, semicolon>
#define SRS_CONSTS_SE ';' // 0x3b
// LB             = <US-ASCII SE, left-brace>
#define SRS_CONSTS_LB '{' // 0x7b
// RB             = <US-ASCII SE, right-brace>
#define SRS_CONSTS_RB '}' // 0x7d

///////////////////////////////////////////////////////////
// HTTP consts values
///////////////////////////////////////////////////////////
// the default http port.
#define SRS_CONSTS_HTTP_DEFAULT_PORT 80
// linux path seprator
#define SRS_CONSTS_HTTP_PATH_SEP '/'
// query string seprator
#define SRS_CONSTS_HTTP_QUERY_SEP '?'

// the default recv timeout.
#define SRS_HTTP_RECV_TMMS (60 * 1000)

// 6.1.1 Status Code and Reason Phrase
#define SRS_CONSTS_HTTP_Continue                       100
#define SRS_CONSTS_HTTP_SwitchingProtocols             101
#define SRS_CONSTS_HTTP_OK                             200
#define SRS_CONSTS_HTTP_Created                        201
#define SRS_CONSTS_HTTP_Accepted                       202
#define SRS_CONSTS_HTTP_NonAuthoritativeInformation    203
#define SRS_CONSTS_HTTP_NoContent                      204
#define SRS_CONSTS_HTTP_ResetContent                   205
#define SRS_CONSTS_HTTP_PartialContent                 206
#define SRS_CONSTS_HTTP_MultipleChoices                300
#define SRS_CONSTS_HTTP_MovedPermanently               301
#define SRS_CONSTS_HTTP_Found                          302
#define SRS_CONSTS_HTTP_SeeOther                       303
#define SRS_CONSTS_HTTP_NotModified                    304
#define SRS_CONSTS_HTTP_UseProxy                       305
#define SRS_CONSTS_HTTP_TemporaryRedirect              307
#define SRS_CONSTS_HTTP_BadRequest                     400
#define SRS_CONSTS_HTTP_Unauthorized                   401
#define SRS_CONSTS_HTTP_PaymentRequired                402
#define SRS_CONSTS_HTTP_Forbidden                      403
#define SRS_CONSTS_HTTP_NotFound                       404
#define SRS_CONSTS_HTTP_MethodNotAllowed               405
#define SRS_CONSTS_HTTP_NotAcceptable                  406
#define SRS_CONSTS_HTTP_ProxyAuthenticationRequired    407
#define SRS_CONSTS_HTTP_RequestTimeout                 408
#define SRS_CONSTS_HTTP_Conflict                       409
#define SRS_CONSTS_HTTP_Gone                           410
#define SRS_CONSTS_HTTP_LengthRequired                 411
#define SRS_CONSTS_HTTP_PreconditionFailed             412
#define SRS_CONSTS_HTTP_RequestEntityTooLarge          413
#define SRS_CONSTS_HTTP_RequestURITooLarge             414
#define SRS_CONSTS_HTTP_UnsupportedMediaType           415
#define SRS_CONSTS_HTTP_RequestedRangeNotSatisfiable   416
#define SRS_CONSTS_HTTP_ExpectationFailed              417
#define SRS_CONSTS_HTTP_InternalServerError            500
#define SRS_CONSTS_HTTP_NotImplemented                 501
#define SRS_CONSTS_HTTP_BadGateway                     502
#define SRS_CONSTS_HTTP_ServiceUnavailable             503
#define SRS_CONSTS_HTTP_GatewayTimeout                 504
#define SRS_CONSTS_HTTP_HTTPVersionNotSupported        505

#define SRS_CONSTS_HTTP_Continue_str                           "Continue"
#define SRS_CONSTS_HTTP_SwitchingProtocols_str                 "Switching Protocols"
#define SRS_CONSTS_HTTP_OK_str                                 "OK"
#define SRS_CONSTS_HTTP_Created_str                            "Created"
#define SRS_CONSTS_HTTP_Accepted_str                           "Accepted"
#define SRS_CONSTS_HTTP_NonAuthoritativeInformation_str        "Non Authoritative Information"
#define SRS_CONSTS_HTTP_NoContent_str                          "No Content"
#define SRS_CONSTS_HTTP_ResetContent_str                       "Reset Content"
#define SRS_CONSTS_HTTP_PartialContent_str                     "Partial Content"
#define SRS_CONSTS_HTTP_MultipleChoices_str                    "Multiple Choices"
#define SRS_CONSTS_HTTP_MovedPermanently_str                   "Moved Permanently"
#define SRS_CONSTS_HTTP_Found_str                              "Found"
#define SRS_CONSTS_HTTP_SeeOther_str                           "See Other"
#define SRS_CONSTS_HTTP_NotModified_str                        "Not Modified"
#define SRS_CONSTS_HTTP_UseProxy_str                           "Use Proxy"
#define SRS_CONSTS_HTTP_TemporaryRedirect_str                  "Temporary Redirect"
#define SRS_CONSTS_HTTP_BadRequest_str                         "Bad Request"
#define SRS_CONSTS_HTTP_Unauthorized_str                       "Unauthorized"
#define SRS_CONSTS_HTTP_PaymentRequired_str                    "Payment Required"
#define SRS_CONSTS_HTTP_Forbidden_str                          "Forbidden"
#define SRS_CONSTS_HTTP_NotFound_str                           "Not Found"
#define SRS_CONSTS_HTTP_MethodNotAllowed_str                   "Method Not Allowed"
#define SRS_CONSTS_HTTP_NotAcceptable_str                      "Not Acceptable"
#define SRS_CONSTS_HTTP_ProxyAuthenticationRequired_str        "Proxy Authentication Required"
#define SRS_CONSTS_HTTP_RequestTimeout_str                     "Request Timeout"
#define SRS_CONSTS_HTTP_Conflict_str                           "Conflict"
#define SRS_CONSTS_HTTP_Gone_str                               "Gone"
#define SRS_CONSTS_HTTP_LengthRequired_str                     "Length Required"
#define SRS_CONSTS_HTTP_PreconditionFailed_str                 "Precondition Failed"
#define SRS_CONSTS_HTTP_RequestEntityTooLarge_str              "Request Entity Too Large"
#define SRS_CONSTS_HTTP_RequestURITooLarge_str                 "Request URI Too Large"
#define SRS_CONSTS_HTTP_UnsupportedMediaType_str               "Unsupported Media Type"
#define SRS_CONSTS_HTTP_RequestedRangeNotSatisfiable_str       "Requested Range Not Satisfiable"
#define SRS_CONSTS_HTTP_ExpectationFailed_str                  "Expectation Failed"
#define SRS_CONSTS_HTTP_InternalServerError_str                "Internal Server Error"
#define SRS_CONSTS_HTTP_NotImplemented_str                     "Not Implemented"
#define SRS_CONSTS_HTTP_BadGateway_str                         "Bad Gateway"
#define SRS_CONSTS_HTTP_ServiceUnavailable_str                 "Service Unavailable"
#define SRS_CONSTS_HTTP_GatewayTimeout_str                     "Gateway Timeout"
#define SRS_CONSTS_HTTP_HTTPVersionNotSupported_str            "HTTP Version Not Supported"

///////////////////////////////////////////////////////////
// RTSP consts values
///////////////////////////////////////////////////////////
// 7.1.1 Status Code and Reason Phrase
#define SRS_CONSTS_RTSP_Continue                       100
#define SRS_CONSTS_RTSP_OK                             200
#define SRS_CONSTS_RTSP_Created                        201
#define SRS_CONSTS_RTSP_LowOnStorageSpace              250
#define SRS_CONSTS_RTSP_MultipleChoices                300
#define SRS_CONSTS_RTSP_MovedPermanently               301
#define SRS_CONSTS_RTSP_MovedTemporarily               302
#define SRS_CONSTS_RTSP_SeeOther                       303
#define SRS_CONSTS_RTSP_NotModified                    304
#define SRS_CONSTS_RTSP_UseProxy                       305
#define SRS_CONSTS_RTSP_BadRequest                     400
#define SRS_CONSTS_RTSP_Unauthorized                   401
#define SRS_CONSTS_RTSP_PaymentRequired                402
#define SRS_CONSTS_RTSP_Forbidden                      403
#define SRS_CONSTS_RTSP_NotFound                       404
#define SRS_CONSTS_RTSP_MethodNotAllowed               405
#define SRS_CONSTS_RTSP_NotAcceptable                  406
#define SRS_CONSTS_RTSP_ProxyAuthenticationRequired    407
#define SRS_CONSTS_RTSP_RequestTimeout                 408
#define SRS_CONSTS_RTSP_Gone                           410
#define SRS_CONSTS_RTSP_LengthRequired                 411
#define SRS_CONSTS_RTSP_PreconditionFailed             412
#define SRS_CONSTS_RTSP_RequestEntityTooLarge          413
#define SRS_CONSTS_RTSP_RequestURITooLarge             414
#define SRS_CONSTS_RTSP_UnsupportedMediaType           415
#define SRS_CONSTS_RTSP_ParameterNotUnderstood         451
#define SRS_CONSTS_RTSP_ConferenceNotFound             452
#define SRS_CONSTS_RTSP_NotEnoughBandwidth             453
#define SRS_CONSTS_RTSP_SessionNotFound                454
#define SRS_CONSTS_RTSP_MethodNotValidInThisState      455
#define SRS_CONSTS_RTSP_HeaderFieldNotValidForResource 456
#define SRS_CONSTS_RTSP_InvalidRange                   457
#define SRS_CONSTS_RTSP_ParameterIsReadOnly            458
#define SRS_CONSTS_RTSP_AggregateOperationNotAllowed   459
#define SRS_CONSTS_RTSP_OnlyAggregateOperationAllowed  460
#define SRS_CONSTS_RTSP_UnsupportedTransport           461
#define SRS_CONSTS_RTSP_DestinationUnreachable         462
#define SRS_CONSTS_RTSP_InternalServerError            500
#define SRS_CONSTS_RTSP_NotImplemented                 501
#define SRS_CONSTS_RTSP_BadGateway                     502
#define SRS_CONSTS_RTSP_ServiceUnavailable             503
#define SRS_CONSTS_RTSP_GatewayTimeout                 504
#define SRS_CONSTS_RTSP_RTSPVersionNotSupported        505
#define SRS_CONSTS_RTSP_OptionNotSupported             551

#define SRS_CONSTS_RTSP_Continue_str                            "Continue"
#define SRS_CONSTS_RTSP_OK_str                                  "OK"
#define SRS_CONSTS_RTSP_Created_str                             "Created"
#define SRS_CONSTS_RTSP_LowOnStorageSpace_str                   "Low on Storage Space"
#define SRS_CONSTS_RTSP_MultipleChoices_str                     "Multiple Choices"
#define SRS_CONSTS_RTSP_MovedPermanently_str                    "Moved Permanently"
#define SRS_CONSTS_RTSP_MovedTemporarily_str                    "Moved Temporarily"
#define SRS_CONSTS_RTSP_SeeOther_str                            "See Other"
#define SRS_CONSTS_RTSP_NotModified_str                         "Not Modified"
#define SRS_CONSTS_RTSP_UseProxy_str                            "Use Proxy"
#define SRS_CONSTS_RTSP_BadRequest_str                          "Bad Request"
#define SRS_CONSTS_RTSP_Unauthorized_str                        "Unauthorized"
#define SRS_CONSTS_RTSP_PaymentRequired_str                     "Payment Required"
#define SRS_CONSTS_RTSP_Forbidden_str                           "Forbidden"
#define SRS_CONSTS_RTSP_NotFound_str                            "Not Found"
#define SRS_CONSTS_RTSP_MethodNotAllowed_str                    "Method Not Allowed"
#define SRS_CONSTS_RTSP_NotAcceptable_str                       "Not Acceptable"
#define SRS_CONSTS_RTSP_ProxyAuthenticationRequired_str         "Proxy Authentication Required"
#define SRS_CONSTS_RTSP_RequestTimeout_str                      "Request Timeout"
#define SRS_CONSTS_RTSP_Gone_str                                "Gone"
#define SRS_CONSTS_RTSP_LengthRequired_str                      "Length Required"
#define SRS_CONSTS_RTSP_PreconditionFailed_str                  "Precondition Failed"
#define SRS_CONSTS_RTSP_RequestEntityTooLarge_str               "Request Entity Too Large"
#define SRS_CONSTS_RTSP_RequestURITooLarge_str                  "Request URI Too Large"
#define SRS_CONSTS_RTSP_UnsupportedMediaType_str                "Unsupported Media Type"
#define SRS_CONSTS_RTSP_ParameterNotUnderstood_str              "Invalid parameter"
#define SRS_CONSTS_RTSP_ConferenceNotFound_str                  "Illegal Conference Identifier"
#define SRS_CONSTS_RTSP_NotEnoughBandwidth_str                  "Not Enough Bandwidth"
#define SRS_CONSTS_RTSP_SessionNotFound_str                     "Session Not Found"
#define SRS_CONSTS_RTSP_MethodNotValidInThisState_str           "Method Not Valid In This State"
#define SRS_CONSTS_RTSP_HeaderFieldNotValidForResource_str      "Header Field Not Valid"
#define SRS_CONSTS_RTSP_InvalidRange_str                        "Invalid Range"
#define SRS_CONSTS_RTSP_ParameterIsReadOnly_str                 "Parameter Is Read-Only"
#define SRS_CONSTS_RTSP_AggregateOperationNotAllowed_str        "Aggregate Operation Not Allowed"
#define SRS_CONSTS_RTSP_OnlyAggregateOperationAllowed_str       "Only Aggregate Operation Allowed"
#define SRS_CONSTS_RTSP_UnsupportedTransport_str                "Unsupported Transport"
#define SRS_CONSTS_RTSP_DestinationUnreachable_str              "Destination Unreachable"
#define SRS_CONSTS_RTSP_InternalServerError_str                 "Internal Server Error"
#define SRS_CONSTS_RTSP_NotImplemented_str                      "Not Implemented"
#define SRS_CONSTS_RTSP_BadGateway_str                          "Bad Gateway"
#define SRS_CONSTS_RTSP_ServiceUnavailable_str                  "Service Unavailable"
#define SRS_CONSTS_RTSP_GatewayTimeout_str                      "Gateway Timeout"
#define SRS_CONSTS_RTSP_RTSPVersionNotSupported_str             "RTSP Version Not Supported"
#define SRS_CONSTS_RTSP_OptionNotSupported_str                  "Option not support"

///////////////////////////////////////////////////////////
// KAFKA consts values
///////////////////////////////////////////////////////////
#define SRS_CONSTS_KAFKA_DEFAULT_PORT 9092

// the common io timeout, for both recv and send.
#define SRS_CONSTS_KAFKA_TMMS (30*1000)

#endif

// following is generated by src/kernel/srs_kernel_aac.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_KERNEL_AAC_HPP
#define SRS_KERNEL_AAC_HPP

//#include <srs_core.hpp>

#if !defined(SRS_EXPORT_LIBRTMP)

#include <string>

//#include <srs_kernel_codec.hpp>

class SrsBuffer;
class SrsFileWriter;
class SrsFileReader;

/**
 * Transmux the RTMP packets to AAC stream.
 */
class SrsAacTransmuxer
{
private:
    SrsFileWriter* _fs;
private:
    SrsAacObjectType aac_object;
    int8_t aac_sample_rate;
    int8_t aac_channels;
    bool got_sequence_header;
public:
    SrsAacTransmuxer();
    virtual ~SrsAacTransmuxer();
public:
    /**
     * initialize the underlayer file stream.
     * @remark user can initialize multiple times to encode multiple aac files.
     * @remark, user must free the fs, aac encoder never close/free it.
     */
    virtual srs_error_t initialize(SrsFileWriter* fs);
public:
    /**
     * write audio/video packet.
     * @remark assert data is not NULL.
     */
    virtual srs_error_t write_audio(int64_t timestamp, char* data, int size);
};

#endif

#endif

// following is generated by src/kernel/srs_kernel_mp3.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_KERNEL_MP3_HPP
#define SRS_KERNEL_MP3_HPP

//#include <srs_core.hpp>

#if !defined(SRS_EXPORT_LIBRTMP)

#include <string>

class SrsBuffer;
class SrsFileWriter;

/**
 * Transmux RTMP packet to MP3 stream.
 */
class SrsMp3Transmuxer
{
private:
    SrsFileWriter* writer;
public:
    SrsMp3Transmuxer();
    virtual ~SrsMp3Transmuxer();
public:
    /**
     * initialize the underlayer file stream.
     * @remark user can initialize multiple times to encode multiple mp3 files.
     * @remark, user must free the @param fw, mp3 encoder never close/free it.
     */
    virtual srs_error_t initialize(SrsFileWriter* fw);
public:
    /**
     * write mp3 id3 v2.3 header.
     * @see mp3.id3v2.3.0.pdf, http://id3.org/id3v2.3.0
     */
    virtual srs_error_t write_header();
    /**
     * write audio/video packet.
     * @remark assert data is not NULL.
     */
    virtual srs_error_t write_audio(int64_t timestamp, char* data, int size);
};

#endif

#endif

// following is generated by src/kernel/srs_kernel_ts.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_KERNEL_TS_HPP
#define SRS_KERNEL_TS_HPP

//#include <srs_core.hpp>

#if !defined(SRS_EXPORT_LIBRTMP)

#include <string>
#include <map>
#include <vector>

//#include <srs_kernel_codec.hpp>

class SrsBuffer;
class SrsTsMessageCache;
class SrsTsContextWriter;
class SrsFileWriter;
class SrsFileReader;
class SrsFormat;
class SrsSimpleStream;
class SrsTsAdaptationField;
class SrsTsPayload;
class SrsTsMessage;
class SrsTsPacket;
class SrsTsContext;

// Transport Stream packets are 188 bytes in length.
#define SRS_TS_PACKET_SIZE          188

// the aggregate pure audio for hls, in ts tbn(ms * 90).
#define SRS_CONSTS_HLS_PURE_AUDIO_AGGREGATE 720 * 90

/**
 * the pid of ts packet,
 * Table 2-3 - PID table, hls-mpeg-ts-iso13818-1.pdf, page 37
 * NOTE - The transport packets with PID values 0x0000, 0x0001, and 0x0010-0x1FFE are allowed to carry a PCR.
 */
enum SrsTsPid
{
    // Program Association Table(see Table 2-25).
    SrsTsPidPAT = 0x00,
    // Conditional Access Table (see Table 2-27).
    SrsTsPidCAT = 0x01,
    // Transport Stream Description Table
    SrsTsPidTSDT = 0x02,
    // Reserved
    SrsTsPidReservedStart = 0x03,
    SrsTsPidReservedEnd = 0x0f,
    // May be assigned as network_PID, Program_map_PID, elementary_PID, or for other purposes
    SrsTsPidAppStart = 0x10,
    SrsTsPidAppEnd = 0x1ffe,
    // null packets (see Table 2-3)
    SrsTsPidNULL = 0x01FFF,
};

/**
 * the transport_scrambling_control of ts packet,
 * Table 2-4 - Scrambling control values, hls-mpeg-ts-iso13818-1.pdf, page 38
 */
enum SrsTsScrambled
{
    // Not scrambled
    SrsTsScrambledDisabled = 0x00,
    // User-defined
    SrsTsScrambledUserDefined1 = 0x01,
    // User-defined
    SrsTsScrambledUserDefined2 = 0x02,
    // User-defined
    SrsTsScrambledUserDefined3 = 0x03,
};

/**
 * the adaption_field_control of ts packet,
 * Table 2-5 - Adaptation field control values, hls-mpeg-ts-iso13818-1.pdf, page 38
 */
enum SrsTsAdaptationFieldType
{
    // Reserved for future use by ISO/IEC
    SrsTsAdaptationFieldTypeReserved = 0x00,
    // No adaptation_field, payload only
    SrsTsAdaptationFieldTypePayloadOnly = 0x01,
    // Adaptation_field only, no payload
    SrsTsAdaptationFieldTypeAdaptionOnly = 0x02,
    // Adaptation_field followed by payload
    SrsTsAdaptationFieldTypeBoth = 0x03,
};

/**
 * the actually parsed ts pid,
 * @see SrsTsPid, some pid, for example, PMT/Video/Audio is specified by PAT or other tables.
 */
enum SrsTsPidApply
{
    SrsTsPidApplyReserved = 0, // TSPidTypeReserved, nothing parsed, used reserved.
    
    SrsTsPidApplyPAT, // Program associtate table
    SrsTsPidApplyPMT, // Program map table.
    
    SrsTsPidApplyVideo, // for video
    SrsTsPidApplyAudio, // vor audio
};

/**
 * Table 2-29 - Stream type assignments
 */
enum SrsTsStream
{
    // ITU-T | ISO/IEC Reserved
    SrsTsStreamReserved = 0x00,
    // ISO/IEC 11172 Video
    // ITU-T Rec. H.262 | ISO/IEC 13818-2 Video or ISO/IEC 11172-2 constrained parameter video stream
    // ISO/IEC 11172 Audio
    // ISO/IEC 13818-3 Audio
    SrsTsStreamAudioMp3 = 0x04,
    // ITU-T Rec. H.222.0 | ISO/IEC 13818-1 private_sections
    // ITU-T Rec. H.222.0 | ISO/IEC 13818-1 PES packets containing private data
    // ISO/IEC 13522 MHEG
    // ITU-T Rec. H.222.0 | ISO/IEC 13818-1 Annex A DSM-CC
    // ITU-T Rec. H.222.1
    // ISO/IEC 13818-6 type A
    // ISO/IEC 13818-6 type B
    // ISO/IEC 13818-6 type C
    // ISO/IEC 13818-6 type D
    // ITU-T Rec. H.222.0 | ISO/IEC 13818-1 auxiliary
    // ISO/IEC 13818-7 Audio with ADTS transport syntax
    SrsTsStreamAudioAAC = 0x0f,
    // ISO/IEC 14496-2 Visual
    SrsTsStreamVideoMpeg4 = 0x10,
    // ISO/IEC 14496-3 Audio with the LATM transport syntax as defined in ISO/IEC 14496-3 / AMD 1
    SrsTsStreamAudioMpeg4 = 0x11,
    // ISO/IEC 14496-1 SL-packetized stream or FlexMux stream carried in PES packets
    // ISO/IEC 14496-1 SL-packetized stream or FlexMux stream carried in ISO/IEC14496_sections.
    // ISO/IEC 13818-6 Synchronized Download Protocol
    // ITU-T Rec. H.222.0 | ISO/IEC 13818-1 Reserved
    // 0x15-0x7F
    SrsTsStreamVideoH264 = 0x1b,
    // User Private
    // 0x80-0xFF
    SrsTsStreamAudioAC3 = 0x81,
    SrsTsStreamAudioDTS = 0x8a,
};
std::string srs_ts_stream2string(SrsTsStream stream);

/**
 * the ts channel.
 */
struct SrsTsChannel
{
    int pid;
    SrsTsPidApply apply;
    SrsTsStream stream;
    SrsTsMessage* msg;
    SrsTsContext* context;
    // for encoder.
    uint8_t continuity_counter;
    
    SrsTsChannel();
    virtual ~SrsTsChannel();
};

/**
 * the stream_id of PES payload of ts packet.
 * Table 2-18 - Stream_id assignments, hls-mpeg-ts-iso13818-1.pdf, page 52.
 */
enum SrsTsPESStreamId
{
    // program_stream_map
    SrsTsPESStreamIdProgramStreamMap = 0xbc, // 0b10111100
    // private_stream_1
    SrsTsPESStreamIdPrivateStream1 = 0xbd, // 0b10111101
    // padding_stream
    SrsTsPESStreamIdPaddingStream = 0xbe, // 0b10111110
    // private_stream_2
    SrsTsPESStreamIdPrivateStream2 = 0xbf, // 0b10111111
    
    // 110x xxxx
    // ISO/IEC 13818-3 or ISO/IEC 11172-3 or ISO/IEC 13818-7 or ISO/IEC
    // 14496-3 audio stream number x xxxx
    // ((sid >> 5) & 0x07) == SrsTsPESStreamIdAudio
    // @remark, use SrsTsPESStreamIdAudioCommon as actually audio, SrsTsPESStreamIdAudio to check whether audio.
    SrsTsPESStreamIdAudioChecker = 0x06, // 0b110
    SrsTsPESStreamIdAudioCommon = 0xc0,
    
    // 1110 xxxx
    // ITU-T Rec. H.262 | ISO/IEC 13818-2 or ISO/IEC 11172-2 or ISO/IEC
    // 14496-2 video stream number xxxx
    // ((stream_id >> 4) & 0x0f) == SrsTsPESStreamIdVideo
    // @remark, use SrsTsPESStreamIdVideoCommon as actually video, SrsTsPESStreamIdVideo to check whether video.
    SrsTsPESStreamIdVideoChecker = 0x0e, // 0b1110
    SrsTsPESStreamIdVideoCommon = 0xe0,
    
    // ECM_stream
    SrsTsPESStreamIdEcmStream = 0xf0, // 0b11110000
    // EMM_stream
    SrsTsPESStreamIdEmmStream = 0xf1, // 0b11110001
    // DSMCC_stream
    SrsTsPESStreamIdDsmccStream = 0xf2, // 0b11110010
    // 13522_stream
    SrsTsPESStreamId13522Stream = 0xf3, // 0b11110011
    // H_222_1_type_A
    SrsTsPESStreamIdH2221TypeA = 0xf4, // 0b11110100
    // H_222_1_type_B
    SrsTsPESStreamIdH2221TypeB = 0xf5, // 0b11110101
    // H_222_1_type_C
    SrsTsPESStreamIdH2221TypeC = 0xf6, // 0b11110110
    // H_222_1_type_D
    SrsTsPESStreamIdH2221TypeD = 0xf7, // 0b11110111
    // H_222_1_type_E
    SrsTsPESStreamIdH2221TypeE = 0xf8, // 0b11111000
    // ancillary_stream
    SrsTsPESStreamIdAncillaryStream = 0xf9, // 0b11111001
    // SL_packetized_stream
    SrsTsPESStreamIdSlPacketizedStream = 0xfa, // 0b11111010
    // FlexMux_stream
    SrsTsPESStreamIdFlexMuxStream = 0xfb, // 0b11111011
    // reserved data stream
    // 1111 1100 ... 1111 1110
    // program_stream_directory
    SrsTsPESStreamIdProgramStreamDirectory = 0xff, // 0b11111111
};

/**
 * the media audio/video message parsed from PES packet.
 */
class SrsTsMessage
{
public:
    // decoder only,
    // the ts messgae does not use them,
    // for user to get the channel and packet.
    SrsTsChannel* channel;
    SrsTsPacket* packet;
public:
    // the audio cache buffer start pts, to flush audio if full.
    // @remark the pts is not the adjust one, it's the orignal pts.
    int64_t start_pts;
    // whether this message with pcr info,
    // generally, the video IDR(I frame, the keyframe of h.264) carray the pcr info.
    bool write_pcr;
    // whether got discontinuity ts, for example, sequence header changed.
    bool is_discontinuity;
public:
    // the timestamp in 90khz
    int64_t dts;
    int64_t pts;
    // the id of pes stream to indicates the payload codec.
    // @remark use is_audio() and is_video() to check it, and stream_number() to finger it out.
    SrsTsPESStreamId sid;
    // the size of payload, 0 indicates the length() of payload.
    uint16_t PES_packet_length;
    // the chunk id.
    uint8_t continuity_counter;
    // the payload bytes.
    SrsSimpleStream* payload;
public:
    SrsTsMessage(SrsTsChannel* c = NULL, SrsTsPacket* p = NULL);
    virtual ~SrsTsMessage();
    // decoder
public:
    /**
     * dumps all bytes in stream to ts message.
     */
    virtual srs_error_t dump(SrsBuffer* stream, int* pnb_bytes);
    /**
     * whether ts message is completed to reap.
     * @param payload_unit_start_indicator whether new ts message start.
     *       PES_packet_length is 0, the payload_unit_start_indicator=1 to reap ts message.
     *       PES_packet_length > 0, the payload.length() == PES_packet_length to reap ts message.
     * @remark when PES_packet_length>0, the payload_unit_start_indicator should never be 1 when not completed.
     * @remark when fresh, the payload_unit_start_indicator should be 1.
     */
    virtual bool completed(int8_t payload_unit_start_indicator);
    /**
     * whether the message is fresh.
     */
    virtual bool fresh();
public:
    /**
     * whether the sid indicates the elementary stream audio.
     */
    virtual bool is_audio();
    /**
     * whether the sid indicates the elementary stream video.
     */
    virtual bool is_video();
    /**
     * when audio or video, get the stream number which specifies the format of stream.
     * @return the stream number for audio/video; otherwise, -1.
     */
    virtual int stream_number();
public:
    /**
     * detach the ts message,
     * for user maybe need to parse the message by queue.
     * @remark we always use the payload of original message.
     */
    virtual SrsTsMessage* detach();
};

/**
 * the ts message handler.
 */
class ISrsTsHandler
{
public:
    ISrsTsHandler();
    virtual ~ISrsTsHandler();
public:
    /**
     * when ts context got message, use handler to process it.
     * @param msg the ts msg, user should never free it.
     * @return an int error code.
     */
    virtual srs_error_t on_ts_message(SrsTsMessage* msg) = 0;
};

/**
 * the context of ts, to decode the ts stream.
 */
class SrsTsContext
{
private:
    // Whether context is ready, failed if try to write data when not ready.
    // When PAT and PMT writen, the context is ready.
    // @see https://github.com/ossrs/srs/issues/834
    bool ready;
// codec
private:
    std::map<int, SrsTsChannel*> pids;
    bool pure_audio;
    int8_t sync_byte;
    // encoder
private:
    // when any codec changed, write the PAT/PMT.
    SrsVideoCodecId vcodec;
    SrsAudioCodecId acodec;
public:
    SrsTsContext();
    virtual ~SrsTsContext();
public:
    /**
     * whether the hls stream is pure audio stream.
     */
    // TODO: FIXME: merge with muxer codec detect.
    virtual bool is_pure_audio();
    /**
     * when PMT table parsed, we know some info about stream.
     */
    virtual void on_pmt_parsed();
    /**
     * reset the context for a new ts segment start.
     */
    virtual void reset();
    // codec
public:
    /**
     * get the pid apply, the parsed pid.
     * @return the apply channel; NULL for invalid.
     */
    virtual SrsTsChannel* get(int pid);
    /**
     * set the pid apply, the parsed pid.
     */
    virtual void set(int pid, SrsTsPidApply apply_pid, SrsTsStream stream = SrsTsStreamReserved);
    // decode methods
public:
    /**
     * the stream contains only one ts packet.
     * @param handler the ts message handler to process the msg.
     * @remark we will consume all bytes in stream.
     */
    virtual srs_error_t decode(SrsBuffer* stream, ISrsTsHandler* handler);
    // encode methods
public:
    /**
     * write the PES packet, the video/audio stream.
     * @param msg the video/audio msg to write to ts.
     * @param vc the video codec, write the PAT/PMT table when changed.
     * @param ac the audio codec, write the PAT/PMT table when changed.
     */
    virtual srs_error_t encode(SrsFileWriter* writer, SrsTsMessage* msg, SrsVideoCodecId vc, SrsAudioCodecId ac);
// drm methods
public:
    /**
     * set sync byte of ts segment.
     * replace the standard ts sync byte to bravo sync byte.
     */
    virtual void set_sync_byte(int8_t sb);
private:
    virtual srs_error_t encode_pat_pmt(SrsFileWriter* writer, int16_t vpid, SrsTsStream vs, int16_t apid, SrsTsStream as);
    virtual srs_error_t encode_pes(SrsFileWriter* writer, SrsTsMessage* msg, int16_t pid, SrsTsStream sid, bool pure_audio);
};

/**
 * the packet in ts stream,
 * 2.4.3.2 Transport Stream packet layer, hls-mpeg-ts-iso13818-1.pdf, page 36
 * Transport Stream packets shall be 188 bytes long.
 */
class SrsTsPacket
{
public:
    // 1B
    /**
     * The sync_byte is a fixed 8-bit field whose value is '0100 0111' (0x47). Sync_byte emulation in the choice of
     * values for other regularly occurring fields, such as PID, should be avoided.
     */
    int8_t sync_byte; //8bits
    
    // 2B
    /**
     * The transport_error_indicator is a 1-bit flag. When set to '1' it indicates that at least
     * 1 uncorrectable bit error exists in the associated Transport Stream packet. This bit may be set to '1' by entities external to
     * the transport layer. When set to '1' this bit shall not be reset to '0' unless the bit value(s) in error have been corrected.
     */
    int8_t transport_error_indicator; //1bit
    /**
     * The payload_unit_start_indicator is a 1-bit flag which has normative meaning for
     * Transport Stream packets that carry PES packets (refer to 2.4.3.6) or PSI data (refer to 2.4.4).
     *
     * When the payload of the Transport Stream packet contains PES packet data, the payload_unit_start_indicator has the
     * following significance: a '1' indicates that the payload of this Transport Stream packet will commence(start) with the first byte
     * of a PES packet and a '0' indicates no PES packet shall start in this Transport Stream packet. If the
     * payload_unit_start_indicator is set to '1', then one and only one PES packet starts in this Transport Stream packet. This
     * also applies to private streams of stream_type 6 (refer to Table 2-29).
     *
     * When the payload of the Transport Stream packet contains PSI data, the payload_unit_start_indicator has the following
     * significance: if the Transport Stream packet carries the first byte of a PSI section, the payload_unit_start_indicator value
     * shall be '1', indicating that the first byte of the payload of this Transport Stream packet carries the pointer_field. If the
     * Transport Stream packet does not carry the first byte of a PSI section, the payload_unit_start_indicator value shall be '0',
     * indicating that there is no pointer_field in the payload. Refer to 2.4.4.1 and 2.4.4.2. This also applies to private streams of
     * stream_type 5 (refer to Table 2-29).
     *
     * For null packets the payload_unit_start_indicator shall be set to '0'.
     *
     * The meaning of this bit for Transport Stream packets carrying only private data is not defined in this Specification.
     */
    int8_t payload_unit_start_indicator; //1bit
    /**
     * The transport_priority is a 1-bit indicator. When set to '1' it indicates that the associated packet is
     * of greater priority than other packets having the same PID which do not have the bit set to '1'. The transport mechanism
     * can use this to prioritize its data within an elementary stream. Depending on the application the transport_priority field
     * may be coded regardless of the PID or within one PID only. This field may be changed by channel specific encoders or
     * decoders.
     */
    int8_t transport_priority; //1bit
    /**
     * The PID is a 13-bit field, indicating the type of the data stored in the packet payload. PID value 0x0000 is
     * reserved for the Program Association Table (see Table 2-25). PID value 0x0001 is reserved for the Conditional Access
     * Table (see Table 2-27). PID values 0x0002 - 0x000F are reserved. PID value 0x1FFF is reserved for null packets (see
     * Table 2-3).
     */
    SrsTsPid pid; //13bits
    
    // 1B
    /**
     * This 2-bit field indicates the scrambling mode of the Transport Stream packet payload.
     * The Transport Stream packet header, and the adaptation field when present, shall not be scrambled. In the case of a null
     * packet the value of the transport_scrambling_control field shall be set to '00' (see Table 2-4).
     */
    SrsTsScrambled transport_scrambling_control; //2bits
    /**
     * This 2-bit field indicates whether this Transport Stream packet header is followed by an
     * adaptation field and/or payload (see Table 2-5).
     *
     * ITU-T Rec. H.222.0 | ISO/IEC 13818-1 decoders shall discard Transport Stream packets with the
     * adaptation_field_control field set to a value of '00'. In the case of a null packet the value of the adaptation_field_control
     * shall be set to '01'.
     */
    SrsTsAdaptationFieldType adaption_field_control; //2bits
    /**
     * The continuity_counter is a 4-bit field incrementing with each Transport Stream packet with the
     * same PID. The continuity_counter wraps around to 0 after its maximum value. The continuity_counter shall not be
     * incremented when the adaptation_field_control of the packet equals '00'(reseverd) or '10'(adaptation field only).
     *
     * In Transport Streams, duplicate packets may be sent as two, and only two, consecutive Transport Stream packets of the
     * same PID. The duplicate packets shall have the same continuity_counter value as the original packet and the
     * adaptation_field_control field shall be equal to '01'(payload only) or '11'(both). In duplicate packets each byte of the original packet shall be
     * duplicated, with the exception that in the program clock reference fields, if present, a valid value shall be encoded.
     *
     * The continuity_counter in a particular Transport Stream packet is continuous when it differs by a positive value of one
     * from the continuity_counter value in the previous Transport Stream packet of the same PID, or when either of the nonincrementing
     * conditions (adaptation_field_control set to '00' or '10', or duplicate packets as described above) are met.
     * The continuity counter may be discontinuous when the discontinuity_indicator is set to '1' (refer to 2.4.3.4). In the case of
     * a null packet the value of the continuity_counter is undefined.
     */
    uint8_t continuity_counter; //4bits
private:
    SrsTsAdaptationField* adaptation_field;
    SrsTsPayload* payload;
public:
    SrsTsContext* context;
public:
    SrsTsPacket(SrsTsContext* c);
    virtual ~SrsTsPacket();
public:
    virtual srs_error_t decode(SrsBuffer* stream, SrsTsMessage** ppmsg);
public:
    virtual int size();
    virtual srs_error_t encode(SrsBuffer* stream);
    virtual void padding(int nb_stuffings);
public:
    static SrsTsPacket* create_pat(SrsTsContext* context, int16_t pmt_number, int16_t pmt_pid);
    static SrsTsPacket* create_pmt(SrsTsContext* context, int16_t pmt_number, int16_t pmt_pid,
        int16_t vpid, SrsTsStream vs, int16_t apid, SrsTsStream as);
    static SrsTsPacket* create_pes_first(SrsTsContext* context, int16_t pid, SrsTsPESStreamId sid,
        uint8_t continuity_counter, bool discontinuity, int64_t pcr, int64_t dts, int64_t pts, int size);
    static SrsTsPacket* create_pes_continue(SrsTsContext* context,
        int16_t pid, SrsTsPESStreamId sid, uint8_t continuity_counter);
};

/**
 * the adaption field of ts packet.
 * 2.4.3.5 Semantic definition of fields in adaptation field, hls-mpeg-ts-iso13818-1.pdf, page 39
 * Table 2-6 - Transport Stream adaptation field, hls-mpeg-ts-iso13818-1.pdf, page 40
 */
class SrsTsAdaptationField
{
public:
    // 1B
    /**
     * The adaptation_field_length is an 8-bit field specifying the number of bytes in the
     * adaptation_field immediately following the adaptation_field_length. The value 0 is for inserting a single stuffing byte in
     * a Transport Stream packet. When the adaptation_field_control value is '11', the value of the adaptation_field_length shall
     * be in the range 0 to 182. When the adaptation_field_control value is '10', the value of the adaptation_field_length shall
     * be 183. For Transport Stream packets carrying PES packets, stuffing is needed when there is insufficient PES packet data
     * to completely fill the Transport Stream packet payload bytes. Stuffing is accomplished by defining an adaptation field
     * longer than the sum of the lengths of the data elements in it, so that the payload bytes remaining after the adaptation field
     * exactly accommodates the available PES packet data. The extra space in the adaptation field is filled with stuffing bytes.
     *
     * This is the only method of stuffing allowed for Transport Stream packets carrying PES packets. For Transport Stream
     * packets carrying PSI, an alternative stuffing method is described in 2.4.4.
     */
    uint8_t adaption_field_length; //8bits
    // 1B
    /**
     * This is a 1-bit field which when set to '1' indicates that the discontinuity state is true for the
     * current Transport Stream packet. When the discontinuity_indicator is set to '0' or is not present, the discontinuity state is
     * false. The discontinuity indicator is used to indicate two types of discontinuities, system time-base discontinuities and
     * continuity_counter discontinuities.
     *
     * A system time-base discontinuity is indicated by the use of the discontinuity_indicator in Transport Stream packets of a
     * PID designated as a PCR_PID (refer to 2.4.4.9). When the discontinuity state is true for a Transport Stream packet of a
     * PID designated as a PCR_PID, the next PCR in a Transport Stream packet with that same PID represents a sample of a
     * new system time clock for the associated program. The system time-base discontinuity point is defined to be the instant
     * in time when the first byte of a packet containing a PCR of a new system time-base arrives at the input of the T-STD.
     * The discontinuity_indicator shall be set to '1' in the packet in which the system time-base discontinuity occurs. The
     * discontinuity_indicator bit may also be set to '1' in Transport Stream packets of the same PCR_PID prior to the packet
     * which contains the new system time-base PCR. In this case, once the discontinuity_indicator has been set to '1', it shall
     * continue to be set to '1' in all Transport Stream packets of the same PCR_PID up to and including the Transport Stream
     * packet which contains the first PCR of the new system time-base. After the occurrence of a system time-base
     * discontinuity, no fewer than two PCRs for the new system time-base shall be received before another system time-base
     * discontinuity can occur. Further, except when trick mode status is true, data from no more than two system time-bases
     * shall be present in the set of T-STD buffers for one program at any time.
     *
     * Prior to the occurrence of a system time-base discontinuity, the first byte of a Transport Stream packet which contains a
     * PTS or DTS which refers to the new system time-base shall not arrive at the input of the T-STD. After the occurrence of
     * a system time-base discontinuity, the first byte of a Transport Stream packet which contains a PTS or DTS which refers
     * to the previous system time-base shall not arrive at the input of the T-STD.
     *
     * A continuity_counter discontinuity is indicated by the use of the discontinuity_indicator in any Transport Stream packet.
     * When the discontinuity state is true in any Transport Stream packet of a PID not designated as a PCR_PID, the
     * continuity_counter in that packet may be discontinuous with respect to the previous Transport Stream packet of the same
     * PID. When the discontinuity state is true in a Transport Stream packet of a PID that is designated as a PCR_PID, the
     * continuity_counter may only be discontinuous in the packet in which a system time-base discontinuity occurs. A
     * continuity counter discontinuity point occurs when the discontinuity state is true in a Transport Stream packet and the
     * continuity_counter in the same packet is discontinuous with respect to the previous Transport Stream packet of the same
     * PID. A continuity counter discontinuity point shall occur at most one time from the initiation of the discontinuity state
     * until the conclusion of the discontinuity state. Furthermore, for all PIDs that are not designated as PCR_PIDs, when the
     * discontinuity_indicator is set to '1' in a packet of a specific PID, the discontinuity_indicator may be set to '1' in the next
     * Transport Stream packet of that same PID, but shall not be set to '1' in three consecutive Transport Stream packet of that
     * same PID.
     *
     * For the purpose of this clause, an elementary stream access point is defined as follows:
     *       Video - The first byte of a video sequence header.
     *       Audio - The first byte of an audio frame.
     *
     * After a continuity counter discontinuity in a Transport packet which is designated as containing elementary stream data,
     * the first byte of elementary stream data in a Transport Stream packet of the same PID shall be the first byte of an
     * elementary stream access point or in the case of video, the first byte of an elementary stream access point or a
     * sequence_end_code followed by an access point. Each Transport Stream packet which contains elementary stream data
     * with a PID not designated as a PCR_PID, and in which a continuity counter discontinuity point occurs, and in which a
     * PTS or DTS occurs, shall arrive at the input of the T-STD after the system time-base discontinuity for the associated
     * program occurs. In the case where the discontinuity state is true, if two consecutive Transport Stream packets of the same
     * PID occur which have the same continuity_counter value and have adaptation_field_control values set to '01' or '11', the
     * second packet may be discarded. A Transport Stream shall not be constructed in such a way that discarding such a packet
     * will cause the loss of PES packet payload data or PSI data.
     *
     * After the occurrence of a discontinuity_indicator set to '1' in a Transport Stream packet which contains PSI information,
     * a single discontinuity in the version_number of PSI sections may occur. At the occurrence of such a discontinuity, a
     * version of the TS_program_map_sections of the appropriate program shall be sent with section_length = = 13 and the
     * current_next_indicator = = 1, such that there are no program_descriptors and no elementary streams described. This shall
     * then be followed by a version of the TS_program_map_section for each affected program with the version_number
     * incremented by one and the current_next_indicator = = 1, containing a complete program definition. This indicates a
     * version change in PSI data.
     */
    int8_t discontinuity_indicator; //1bit
    /**
     * The random_access_indicator is a 1-bit field that indicates that the current Transport
     * Stream packet, and possibly subsequent Transport Stream packets with the same PID, contain some information to aid
     * random access at this point. Specifically, when the bit is set to '1', the next PES packet to start in the payload of Transport
     * Stream packets with the current PID shall contain the first byte of a video sequence header if the PES stream type (refer
     * to Table 2-29) is 1 or 2, or shall contain the first byte of an audio frame if the PES stream type is 3 or 4. In addition, in
     * the case of video, a presentation timestamp shall be present in the PES packet containing the first picture following the
     * sequence header. In the case of audio, the presentation timestamp shall be present in the PES packet containing the first
     * byte of the audio frame. In the PCR_PID the random_access_indicator may only be set to '1' in Transport Stream packet
     * containing the PCR fields.
     */
    int8_t random_access_indicator; //1bit
    /**
     * The elementary_stream_priority_indicator is a 1-bit field. It indicates, among
     * packets with the same PID, the priority of the elementary stream data carried within the payload of this Transport Stream
     * packet. A '1' indicates that the payload has a higher priority than the payloads of other Transport Stream packets. In the
     * case of video, this field may be set to '1' only if the payload contains one or more bytes from an intra-coded slice. A
     * value of '0' indicates that the payload has the same priority as all other packets which do not have this bit set to '1'.
     */
    int8_t elementary_stream_priority_indicator; //1bit
    /**
     * The PCR_flag is a 1-bit flag. A value of '1' indicates that the adaptation_field contains a PCR field coded in
     * two parts. A value of '0' indicates that the adaptation field does not contain any PCR field.
     */
    int8_t PCR_flag; //1bit
    /**
     * The OPCR_flag is a 1-bit flag. A value of '1' indicates that the adaptation_field contains an OPCR field
     * coded in two parts. A value of '0' indicates that the adaptation field does not contain any OPCR field.
     */
    int8_t OPCR_flag; //1bit
    /**
     * The splicing_point_flag is a 1-bit flag. When set to '1', it indicates that a splice_countdown field
     * shall be present in the associated adaptation field, specifying the occurrence of a splicing point. A value of '0' indicates
     * that a splice_countdown field is not present in the adaptation field.
     */
    int8_t splicing_point_flag; //1bit
    /**
     * The transport_private_data_flag is a 1-bit flag. A value of '1' indicates that the
     * adaptation field contains one or more private_data bytes. A value of '0' indicates the adaptation field does not contain any
     * private_data bytes.
     */
    int8_t transport_private_data_flag; //1bit
    /**
     * The adaptation_field_extension_flag is a 1-bit field which when set to '1' indicates
     * the presence of an adaptation field extension. A value of '0' indicates that an adaptation field extension is not present in
     * the adaptation field.
     */
    int8_t adaptation_field_extension_flag; //1bit
    
    // if PCR_flag, 6B
    /**
     * The program_clock_reference (PCR) is a
     * 42-bit field coded in two parts. The first part, program_clock_reference_base, is a 33-bit field whose value is given by
     * PCR_base(i), as given in equation 2-2. The second part, program_clock_reference_extension, is a 9-bit field whose value
     * is given by PCR_ext(i), as given in equation 2-3. The PCR indicates the intended time of arrival of the byte containing
     * the last bit of the program_clock_reference_base at the input of the system target decoder.
     */
    int64_t program_clock_reference_base; //33bits
    /**
     * 6bits reserved, must be '1'
     */
    int8_t const1_value0; // 6bits
    int16_t program_clock_reference_extension; //9bits
    
    // if OPCR_flag, 6B
    /**
     * The optional original
     * program reference (OPCR) is a 42-bit field coded in two parts. These two parts, the base and the extension, are coded
     * identically to the two corresponding parts of the PCR field. The presence of the OPCR is indicated by the OPCR_flag.
     * The OPCR field shall be coded only in Transport Stream packets in which the PCR field is present. OPCRs are permitted
     * in both single program and multiple program Transport Streams.
     *
     * OPCR assists in the reconstruction of a single program Transport Stream from another Transport Stream. When
     * reconstructing the original single program Transport Stream, the OPCR may be copied to the PCR field. The resulting
     * PCR value is valid only if the original single program Transport Stream is reconstructed exactly in its entirety. This
     * would include at least any PSI and private data packets which were present in the original Transport Stream and would
     * possibly require other private arrangements. It also means that the OPCR must be an identical copy of its associated PCR
     * in the original single program Transport Stream.
     */
    int64_t original_program_clock_reference_base; //33bits
    /**
     * 6bits reserved, must be '1'
     */
    int8_t const1_value2; // 6bits
    int16_t original_program_clock_reference_extension; //9bits
    
    // if splicing_point_flag, 1B
    /**
     * The splice_countdown is an 8-bit field, representing a value which may be positive or negative. A
     * positive value specifies the remaining number of Transport Stream packets, of the same PID, following the associated
     * Transport Stream packet until a splicing point is reached. Duplicate Transport Stream packets and Transport Stream
     * packets which only contain adaptation fields are excluded. The splicing point is located immediately after the last byte of
     * the Transport Stream packet in which the associated splice_countdown field reaches zero. In the Transport Stream packet
     * where the splice_countdown reaches zero, the last data byte of the Transport Stream packet payload shall be the last byte
     * of a coded audio frame or a coded picture. In the case of video, the corresponding access unit may or may not be
     * terminated by a sequence_end_code. Transport Stream packets with the same PID, which follow, may contain data from
     * a different elementary stream of the same type.
     *
     * The payload of the next Transport Stream packet of the same PID (duplicate packets and packets without payload being
     * excluded) shall commence with the first byte of a PES packet.In the case of audio, the PES packet payload shall
     * commence with an access point. In the case of video, the PES packet payload shall commence with an access point, or
     * with a sequence_end_code, followed by an access point. Thus, the previous coded audio frame or coded picture aligns
     * with the packet boundary, or is padded to make this so. Subsequent to the splicing point, the countdown field may also
     * be present. When the splice_countdown is a negative number whose value is minus n(-n), it indicates that the associated
     * Transport Stream packet is the n-th packet following the splicing point (duplicate packets and packets without payload
     * being excluded).
     *
     * For the purposes of this subclause, an access point is defined as follows:
     *       Video - The first byte of a video_sequence_header.
     *       Audio - The first byte of an audio frame.
     */
    int8_t splice_countdown; //8bits
    
    // if transport_private_data_flag, 1+p[0] B
    std::vector<char> transport_private_data; //[transport_private_data_length]bytes
    
    // if adaptation_field_extension_flag, 2+x B
    /**
     * The adaptation_field_extension_length is an 8-bit field. It indicates the number of
     * bytes of the extended adaptation field data immediately following this field, including reserved bytes if present.
     */
    uint8_t adaptation_field_extension_length; //8bits
    /**
     * This is a 1-bit field which when set to '1' indicates the presence of the ltw_offset
     * field.
     */
    int8_t ltw_flag; //1bit
    /**
     * This is a 1-bit field which when set to '1' indicates the presence of the piecewise_rate field.
     */
    int8_t piecewise_rate_flag; //1bit
    /**
     * This is a 1-bit flag which when set to '1' indicates that the splice_type and DTS_next_AU fields
     * are present. A value of '0' indicates that neither splice_type nor DTS_next_AU fields are present. This field shall not be
     * set to '1' in Transport Stream packets in which the splicing_point_flag is not set to '1'. Once it is set to '1' in a Transport
     * Stream packet in which the splice_countdown is positive, it shall be set to '1' in all the subsequent Transport Stream
     * packets of the same PID that have the splicing_point_flag set to '1', until the packet in which the splice_countdown
     * reaches zero (including this packet). When this flag is set, if the elementary stream carried in this PID is an audio stream,
     * the splice_type field shall be set to '0000'. If the elementary stream carried in this PID is a video stream, it shall fulfil the
     * constraints indicated by the splice_type value.
     */
    int8_t seamless_splice_flag; //1bit
    /**
     * reserved 5bits, must be '1'
     */
    int8_t const1_value1; //5bits
    // if ltw_flag, 2B
    /**
     * (legal time window_valid_flag) - This is a 1-bit field which when set to '1' indicates that the value of the
     * ltw_offset shall be valid. A value of '0' indicates that the value in the ltw_offset field is undefined.
     */
    int8_t ltw_valid_flag; //1bit
    /**
     * (legal time window offset) - This is a 15-bit field, the value of which is defined only if the ltw_valid flag has
     * a value of '1'. When defined, the legal time window offset is in units of (300/fs) seconds, where fs is the system clock
     * frequency of the program that this PID belongs to, and fulfils:
     *       offset = t1(i) - t(i)
     *       ltw_offset = offset//1
     * where i is the index of the first byte of this Transport Stream packet, offset is the value encoded in this field, t(i) is the
     * arrival time of byte i in the T-STD, and t1(i) is the upper bound in time of a time interval called the Legal Time Window
     * which is associated with this Transport Stream packet.
     */
    int16_t ltw_offset; //15bits
    // if piecewise_rate_flag, 3B
    //2bits reserved
    /**
     * The meaning of this 22-bit field is only defined when both the ltw_flag and the ltw_valid_flag are set
     * to '1'. When defined, it is a positive integer specifying a hypothetical bitrate R which is used to define the end times of
     * the Legal Time Windows of Transport Stream packets of the same PID that follow this packet but do not include the
     * legal_time_window_offset field.
     */
    int32_t piecewise_rate; //22bits
    // if seamless_splice_flag, 5B
    /**
     * This is a 4-bit field. From the first occurrence of this field onwards, it shall have the same value in all the
     * subsequent Transport Stream packets of the same PID in which it is present, until the packet in which the
     * splice_countdown reaches zero (including this packet). If the elementary stream carried in that PID is an audio stream,
     * this field shall have the value '0000'. If the elementary stream carried in that PID is a video stream, this field indicates the
     * conditions that shall be respected by this elementary stream for splicing purposes. These conditions are defined as a
     * function of profile, level and splice_type in Table 2-7 through Table 2-16.
     */
    int8_t splice_type; //4bits
    /**
     * (decoding time stamp next access unit) - This is a 33-bit field, coded in three parts. In the case of
     * continuous and periodic decoding through this splicing point it indicates the decoding time of the first access unit
     * following the splicing point. This decoding time is expressed in the time base which is valid in the Transport Stream
     * packet in which the splice_countdown reaches zero. From the first occurrence of this field onwards, it shall have the
     * same value in all the subsequent Transport Stream packets of the same PID in which it is present, until the packet in
     * which the splice_countdown reaches zero (including this packet).
     */
    int8_t DTS_next_AU0; //3bits
    int8_t marker_bit0; //1bit
    int16_t DTS_next_AU1; //15bits
    int8_t marker_bit1; //1bit
    int16_t DTS_next_AU2; //15bits
    int8_t marker_bit2; //1bit
    // left bytes.
    /**
     * This is a fixed 8-bit value equal to '1111 1111' that can be inserted by the encoder. It is discarded by the
     * decoder.
     */
    int nb_af_ext_reserved;
    
    // left bytes.
    /**
     * This is a fixed 8-bit value equal to '1111 1111' that can be inserted by the encoder. It is discarded by the
     * decoder.
     */
    int nb_af_reserved;
private:
    SrsTsPacket* packet;
public:
    SrsTsAdaptationField(SrsTsPacket* pkt);
    virtual ~SrsTsAdaptationField();
public:
    virtual srs_error_t decode(SrsBuffer* stream);
public:
    virtual int size();
    virtual srs_error_t encode(SrsBuffer* stream);
};

/**
 * 2.4.4.4 Table_id assignments, hls-mpeg-ts-iso13818-1.pdf, page 62
 * The table_id field identifies the contents of a Transport Stream PSI section as shown in Table 2-26.
 */
enum SrsTsPsiId
{
    // program_association_section
    SrsTsPsiIdPas = 0x00,
    // conditional_access_section (CA_section)
    SrsTsPsiIdCas = 0x01,
    // TS_program_map_section
    SrsTsPsiIdPms = 0x02,
    // TS_description_section
    SrsTsPsiIdDs = 0x03,
    // ISO_IEC_14496_scene_description_section
    SrsTsPsiIdSds = 0x04,
    // ISO_IEC_14496_object_descriptor_section
    SrsTsPsiIdOds = 0x05,
    // ITU-T Rec. H.222.0 | ISO/IEC 13818-1 reserved
    SrsTsPsiIdIso138181Start = 0x06,
    SrsTsPsiIdIso138181End = 0x37,
    // Defined in ISO/IEC 13818-6
    SrsTsPsiIdIso138186Start = 0x38,
    SrsTsPsiIdIso138186End = 0x3F,
    // User private
    SrsTsPsiIdUserStart = 0x40,
    SrsTsPsiIdUserEnd = 0xFE,
    // forbidden
    SrsTsPsiIdForbidden = 0xFF,
};

/**
 * the payload of ts packet, can be PES or PSI payload.
 */
class SrsTsPayload
{
protected:
    SrsTsPacket* packet;
public:
    SrsTsPayload(SrsTsPacket* p);
    virtual ~SrsTsPayload();
public:
    virtual srs_error_t decode(SrsBuffer* stream, SrsTsMessage** ppmsg) = 0;
public:
    virtual int size() = 0;
    virtual srs_error_t encode(SrsBuffer* stream) = 0;
};

/**
 * the PES payload of ts packet.
 * 2.4.3.6 PES packet, hls-mpeg-ts-iso13818-1.pdf, page 49
 */
class SrsTsPayloadPES : public SrsTsPayload
{
public:
    // 3B
    /**
     * The packet_start_code_prefix is a 24-bit code. Together with the stream_id that follows it
     * constitutes a packet start code that identifies the beginning of a packet. The packet_start_code_prefix is the bit string
     * '0000 0000 0000 0000 0000 0001' (0x000001).
     */
    int32_t packet_start_code_prefix; //24bits
    // 1B
    /**
     * In Program Streams, the stream_id specifies the type and number of the elementary stream as defined by the
     * stream_id Table 2-18. In Transport Streams, the stream_id may be set to any valid value which correctly describes the
     * elementary stream type as defined in Table 2-18. In Transport Streams, the elementary stream type is specified in the
     * Program Specific Information as specified in 2.4.4.
     */
    // @see SrsTsPESStreamId, value can be SrsTsPESStreamIdAudioCommon or SrsTsPESStreamIdVideoCommon.
    uint8_t stream_id; //8bits
    // 2B
    /**
     * A 16-bit field specifying the number of bytes in the PES packet following the last byte of the
     * field. A value of 0 indicates that the PES packet length is neither specified nor bounded and is allowed only in
     * PES packets whose payload consists of bytes from a video elementary stream contained in Transport Stream packets.
     */
    uint16_t PES_packet_length; //16bits
    
    // 1B
    /**
     * 2bits const '10'
     */
    int8_t const2bits; //2bits
    /**
     * The 2-bit PES_scrambling_control field indicates the scrambling mode of the PES packet
     * payload. When scrambling is performed at the PES level, the PES packet header, including the optional fields when
     * present, shall not be scrambled (see Table 2-19).
     */
    int8_t PES_scrambling_control; //2bits
    /**
     * This is a 1-bit field indicating the priority of the payload in this PES packet. A '1' indicates a higher
     * priority of the payload of the PES packet payload than a PES packet payload with this field set to '0'. A multiplexor can
     * use the PES_priority bit to prioritize its data within an elementary stream. This field shall not be changed by the transport
     * mechanism.
     */
    int8_t PES_priority; //1bit
    /**
     * This is a 1-bit flag. When set to a value of '1' it indicates that the PES packet header is
     * immediately followed by the video start code or audio syncword indicated in the data_stream_alignment_descriptor
     * in 2.6.10 if this descriptor is present. If set to a value of '1' and the descriptor is not present, alignment as indicated in
     * alignment_type '01' in Table 2-47 and Table 2-48 is required. When set to a value of '0' it is not defined whether any such
     * alignment occurs or not.
     */
    int8_t data_alignment_indicator; //1bit
    /**
     * This is a 1-bit field. When set to '1' it indicates that the material of the associated PES packet payload is
     * protected by copyright. When set to '0' it is not defined whether the material is protected by copyright. A copyright
     * descriptor described in 2.6.24 is associated with the elementary stream which contains this PES packet and the copyright
     * flag is set to '1' if the descriptor applies to the material contained in this PES packet
     */
    int8_t copyright; //1bit
    /**
     * This is a 1-bit field. When set to '1' the contents of the associated PES packet payload is an original.
     * When set to '0' it indicates that the contents of the associated PES packet payload is a copy.
     */
    int8_t original_or_copy; //1bit
    
    // 1B
    /**
     * This is a 2-bit field. When the PTS_DTS_flags field is set to '10', the PTS fields shall be present in
     * the PES packet header. When the PTS_DTS_flags field is set to '11', both the PTS fields and DTS fields shall be present
     * in the PES packet header. When the PTS_DTS_flags field is set to '00' no PTS or DTS fields shall be present in the PES
     * packet header. The value '01' is forbidden.
     */
    int8_t PTS_DTS_flags; //2bits
    /**
     * A 1-bit flag, which when set to '1' indicates that ESCR base and extension fields are present in the PES
     * packet header. When set to '0' it indicates that no ESCR fields are present.
     */
    int8_t ESCR_flag; //1bit
    /**
     * A 1-bit flag, which when set to '1' indicates that the ES_rate field is present in the PES packet header.
     * When set to '0' it indicates that no ES_rate field is present.
     */
    int8_t ES_rate_flag; //1bit
    /**
     * A 1-bit flag, which when set to '1' it indicates the presence of an 8-bit trick mode field. When
     * set to '0' it indicates that this field is not present.
     */
    int8_t DSM_trick_mode_flag; //1bit
    /**
     * A 1-bit flag, which when set to '1' indicates the presence of the additional_copy_info field.
     * When set to '0' it indicates that this field is not present.
     */
    int8_t additional_copy_info_flag; //1bit
    /**
     * A 1-bit flag, which when set to '1' indicates that a CRC field is present in the PES packet. When set to
     * '0' it indicates that this field is not present.
     */
    int8_t PES_CRC_flag; //1bit
    /**
     * A 1-bit flag, which when set to '1' indicates that an extension field exists in this PES packet
     * header. When set to '0' it indicates that this field is not present.
     */
    int8_t PES_extension_flag; //1bit
    
    // 1B
    /**
     * An 8-bit field specifying the total number of bytes occupied by the optional fields and any
     * stuffing bytes contained in this PES packet header. The presence of optional fields is indicated in the byte that precedes
     * the PES_header_data_length field.
     */
    uint8_t PES_header_data_length; //8bits
    
    // 5B
    /**
     * Presentation times shall be related to decoding times as follows: The PTS is a 33-bit
     * number coded in three separate fields. It indicates the time of presentation, tp n (k), in the system target decoder of a
     * presentation unit k of elementary stream n. The value of PTS is specified in units of the period of the system clock
     * frequency divided by 300 (yielding 90 kHz). The presentation time is derived from the PTS according to equation 2-11
     * below. Refer to 2.7.4 for constraints on the frequency of coding presentation timestamps.
     */
    // ===========1B
    // 4bits const
    // 3bits PTS [32..30]
    // 1bit const '1'
    // ===========2B
    // 15bits PTS [29..15]
    // 1bit const '1'
    // ===========2B
    // 15bits PTS [14..0]
    // 1bit const '1'
    int64_t pts; // 33bits
    
    // 5B
    /**
     * The DTS is a 33-bit number coded in three separate fields. It indicates the decoding time,
     * td n (j), in the system target decoder of an access unit j of elementary stream n. The value of DTS is specified in units of
     * the period of the system clock frequency divided by 300 (yielding 90 kHz).
     */
    // ===========1B
    // 4bits const
    // 3bits DTS [32..30]
    // 1bit const '1'
    // ===========2B
    // 15bits DTS [29..15]
    // 1bit const '1'
    // ===========2B
    // 15bits DTS [14..0]
    // 1bit const '1'
    int64_t dts; // 33bits
    
    // 6B
    /**
     * The elementary stream clock reference is a 42-bit field coded in two parts. The first
     * part, ESCR_base, is a 33-bit field whose value is given by ESCR_base(i), as given in equation 2-14. The second part,
     * ESCR_ext, is a 9-bit field whose value is given by ESCR_ext(i), as given in equation 2-15. The ESCR field indicates the
     * intended time of arrival of the byte containing the last bit of the ESCR_base at the input of the PES-STD for PES streams
     * (refer to 2.5.2.4).
     */
    // 2bits reserved
    // 3bits ESCR_base[32..30]
    // 1bit const '1'
    // 15bits ESCR_base[29..15]
    // 1bit const '1'
    // 15bits ESCR_base[14..0]
    // 1bit const '1'
    // 9bits ESCR_extension
    // 1bit const '1'
    int64_t ESCR_base; //33bits
    int16_t ESCR_extension; //9bits
    
    // 3B
    /**
     * The ES_rate field is a 22-bit unsigned integer specifying the rate at which the
     * system target decoder receives bytes of the PES packet in the case of a PES stream. The ES_rate is valid in the PES
     * packet in which it is included and in subsequent PES packets of the same PES stream until a new ES_rate field is
     * encountered. The value of the ES_rate is measured in units of 50 bytes/second. The value 0 is forbidden. The value of the
     * ES_rate is used to define the time of arrival of bytes at the input of a P-STD for PES streams defined in 2.5.2.4. The
     * value encoded in the ES_rate field may vary from PES_packet to PES_packet.
     */
    // 1bit const '1'
    // 22bits ES_rate
    // 1bit const '1'
    int32_t ES_rate; //22bits
    
    // 1B
    /**
     * A 3-bit field that indicates which trick mode is applied to the associated video stream. In cases of
     * other types of elementary streams, the meanings of this field and those defined by the following five bits are undefined.
     * For the definition of trick_mode status, refer to the trick mode section of 2.4.2.3.
     */
    int8_t trick_mode_control; //3bits
    int8_t trick_mode_value; //5bits
    
    // 1B
    // 1bit const '1'
    /**
     * This 7-bit field contains private data relating to copyright information.
     */
    int8_t additional_copy_info; //7bits
    
    // 2B
    /**
     * The previous_PES_packet_CRC is a 16-bit field that contains the CRC value that yields
     * a zero output of the 16 registers in the decoder similar to the one defined in Annex A,
     */
    int16_t previous_PES_packet_CRC; //16bits
    
    // 1B
    /**
     * A 1-bit flag which when set to '1' indicates that the PES packet header contains private data.
     * When set to a value of '0' it indicates that private data is not present in the PES header.
     */
    int8_t PES_private_data_flag; //1bit
    /**
     * A 1-bit flag which when set to '1' indicates that an ISO/IEC 11172-1 pack header or a
     * Program Stream pack header is stored in this PES packet header. If this field is in a PES packet that is contained in a
     * Program Stream, then this field shall be set to '0'. In a Transport Stream, when set to the value '0' it indicates that no pack
     * header is present in the PES header.
     */
    int8_t pack_header_field_flag; //1bit
    /**
     * A 1-bit flag which when set to '1' indicates that the
     * program_packet_sequence_counter, MPEG1_MPEG2_identifier, and original_stuff_length fields are present in this
     * PES packet. When set to a value of '0' it indicates that these fields are not present in the PES header.
     */
    int8_t program_packet_sequence_counter_flag; //1bit
    /**
     * A 1-bit flag which when set to '1' indicates that the P-STD_buffer_scale and P-STD_buffer_size
     * are present in the PES packet header. When set to a value of '0' it indicates that these fields are not present in the
     * PES header.
     */
    int8_t P_STD_buffer_flag; //1bit
    /**
     * reverved value, must be '1'
     */
    int8_t const1_value0; //3bits
    /**
     * A 1-bit field which when set to '1' indicates the presence of the PES_extension_field_length
     * field and associated fields. When set to a value of '0' this indicates that the PES_extension_field_length field and any
     * associated fields are not present.
     */
    int8_t PES_extension_flag_2; //1bit
    
    // 16B
    /**
     * This is a 16-byte field which contains private data. This data, combined with the fields before and
     * after, shall not emulate the packet_start_code_prefix (0x000001).
     */
    std::vector<char> PES_private_data; //128bits
    
    // (1+x)B
    std::vector<char> pack_field; //[pack_field_length] bytes
    
    // 2B
    // 1bit const '1'
    /**
     * The program_packet_sequence_counter field is a 7-bit field. It is an optional
     * counter that increments with each successive PES packet from a Program Stream or from an ISO/IEC 11172-1 Stream or
     * the PES packets associated with a single program definition in a Transport Stream, providing functionality similar to a
     * continuity counter (refer to 2.4.3.2). This allows an application to retrieve the original PES packet sequence of a Program
     * Stream or the original packet sequence of the original ISO/IEC 11172-1 stream. The counter will wrap around to 0 after
     * its maximum value. Repetition of PES packets shall not occur. Consequently, no two consecutive PES packets in the
     * program multiplex shall have identical program_packet_sequence_counter values.
     */
    int8_t program_packet_sequence_counter; //7bits
    // 1bit const '1'
    /**
     * A 1-bit flag which when set to '1' indicates that this PES packet carries information from
     * an ISO/IEC 11172-1 stream. When set to '0' it indicates that this PES packet carries information from a Program Stream.
     */
    int8_t MPEG1_MPEG2_identifier; //1bit
    /**
     * This 6-bit field specifies the number of stuffing bytes used in the original ITU-T
     * Rec. H.222.0 | ISO/IEC 13818-1 PES packet header or in the original ISO/IEC 11172-1 packet header.
     */
    int8_t original_stuff_length; //6bits
    
    // 2B
    // 2bits const '01'
    /**
     * The P-STD_buffer_scale is a 1-bit field, the meaning of which is only defined if this PES packet
     * is contained in a Program Stream. It indicates the scaling factor used to interpret the subsequent P-STD_buffer_size field.
     * If the preceding stream_id indicates an audio stream, P-STD_buffer_scale shall have the value '0'. If the preceding
     * stream_id indicates a video stream, P-STD_buffer_scale shall have the value '1'. For all other stream types, the value
     * may be either '1' or '0'.
     */
    int8_t P_STD_buffer_scale; //1bit
    /**
     * The P-STD_buffer_size is a 13-bit unsigned integer, the meaning of which is only defined if this
     * PES packet is contained in a Program Stream. It defines the size of the input buffer, BS n , in the P-STD. If
     * P-STD_buffer_scale has the value '0', then the P-STD_buffer_size measures the buffer size in units of 128 bytes. If
     * P-STD_buffer_scale has the value '1', then the P-STD_buffer_size measures the buffer size in units of 1024 bytes.
     */
    int16_t P_STD_buffer_size; //13bits
    
    // (1+x)B
    // 1bit const '1'
    std::vector<char> PES_extension_field; //[PES_extension_field_length] bytes
    
    // NB
    /**
     * This is a fixed 8-bit value equal to '1111 1111' that can be inserted by the encoder, for example to meet
     * the requirements of the channel. It is discarded by the decoder. No more than 32 stuffing bytes shall be present in one
     * PES packet header.
     */
    int nb_stuffings;
    
    // NB
    /**
     * PES_packet_data_bytes shall be contiguous bytes of data from the elementary stream
     * indicated by the packet's stream_id or PID. When the elementary stream data conforms to ITU-T
     * Rec. H.262 | ISO/IEC 13818-2 or ISO/IEC 13818-3, the PES_packet_data_bytes shall be byte aligned to the bytes of this
     * Recommendation | International Standard. The byte-order of the elementary stream shall be preserved. The number of
     * PES_packet_data_bytes, N, is specified by the PES_packet_length field. N shall be equal to the value indicated in the
     * PES_packet_length minus the number of bytes between the last byte of the PES_packet_length field and the first
     * PES_packet_data_byte.
     *
     * In the case of a private_stream_1, private_stream_2, ECM_stream, or EMM_stream, the contents of the
     * PES_packet_data_byte field are user definable and will not be specified by ITU-T | ISO/IEC in the future.
     */
    int nb_bytes;
    
    // NB
    /**
     * This is a fixed 8-bit value equal to '1111 1111'. It is discarded by the decoder.
     */
    int nb_paddings;
public:
    SrsTsPayloadPES(SrsTsPacket* p);
    virtual ~SrsTsPayloadPES();
public:
    virtual srs_error_t decode(SrsBuffer* stream, SrsTsMessage** ppmsg);
public:
    virtual int size();
    virtual srs_error_t encode(SrsBuffer* stream);
private:
    virtual srs_error_t decode_33bits_dts_pts(SrsBuffer* stream, int64_t* pv);
    virtual srs_error_t encode_33bits_dts_pts(SrsBuffer* stream, uint8_t fb, int64_t v);
};

/**
 * the PSI payload of ts packet.
 * 2.4.4 Program specific information, hls-mpeg-ts-iso13818-1.pdf, page 59
 */
class SrsTsPayloadPSI : public SrsTsPayload
{
public:
    // 1B
    /**
     * This is an 8-bit field whose value shall be the number of bytes, immediately following the pointer_field
     * until the first byte of the first section that is present in the payload of the Transport Stream packet (so a value of 0x00 in
     * the pointer_field indicates that the section starts immediately after the pointer_field). When at least one section begins in
     * a given Transport Stream packet, then the payload_unit_start_indicator (refer to 2.4.3.2) shall be set to 1 and the first
     * byte of the payload of that Transport Stream packet shall contain the pointer. When no section begins in a given
     * Transport Stream packet, then the payload_unit_start_indicator shall be set to 0 and no pointer shall be sent in the
     * payload of that packet.
     */
    int8_t pointer_field;
public:
    // 1B
    /**
     * This is an 8-bit field, which shall be set to 0x00 as shown in Table 2-26.
     */
    SrsTsPsiId table_id; //8bits
    
    // 2B
    /**
     * The section_syntax_indicator is a 1-bit field which shall be set to '1'.
     */
    int8_t section_syntax_indicator; //1bit
    /**
     * const value, must be '0'
     */
    int8_t const0_value; //1bit
    /**
     * reverved value, must be '1'
     */
    int8_t const1_value; //2bits
    /**
     * This is a 12-bit field, the first two bits of which shall be '00'. The remaining 10 bits specify the number
     * of bytes of the section, starting immediately following the section_length field, and including the CRC. The value in this
     * field shall not exceed 1021 (0x3FD).
     */
    uint16_t section_length; //12bits
public:
    // the specified psi info, for example, PAT fields.
public:
    // 4B
    /**
     * This is a 32-bit field that contains the CRC value that gives a zero output of the registers in the decoder
     * defined in Annex A after processing the entire section.
     * @remark crc32(bytes without pointer field, before crc32 field)
     */
    int32_t CRC_32; //32bits
public:
    SrsTsPayloadPSI(SrsTsPacket* p);
    virtual ~SrsTsPayloadPSI();
public:
    virtual srs_error_t decode(SrsBuffer* stream, SrsTsMessage** ppmsg);
public:
    virtual int size();
    virtual srs_error_t encode(SrsBuffer* stream);
protected:
    virtual int psi_size() = 0;
    virtual srs_error_t psi_encode(SrsBuffer* stream) = 0;
    virtual srs_error_t psi_decode(SrsBuffer* stream) = 0;
};

/**
 * the program of PAT of PSI ts packet.
 */
class SrsTsPayloadPATProgram
{
public:
    // 4B
    /**
     * Program_number is a 16-bit field. It specifies the program to which the program_map_PID is
     * applicable. When set to 0x0000, then the following PID reference shall be the network PID. For all other cases the value
     * of this field is user defined. This field shall not take any single value more than once within one version of the Program
     * Association Table.
     */
    int16_t number; // 16bits
    /**
     * reverved value, must be '1'
     */
    int8_t const1_value; //3bits
    /**
     * program_map_PID/network_PID 13bits
     * network_PID - The network_PID is a 13-bit field, which is used only in conjunction with the value of the
     * program_number set to 0x0000, specifies the PID of the Transport Stream packets which shall contain the Network
     * Information Table. The value of the network_PID field is defined by the user, but shall only take values as specified in
     * Table 2-3. The presence of the network_PID is optional.
     */
    int16_t pid; //13bits
public:
    SrsTsPayloadPATProgram(int16_t n = 0, int16_t p = 0);
    virtual ~SrsTsPayloadPATProgram();
public:
    virtual srs_error_t decode(SrsBuffer* stream);
public:
    virtual int size();
    virtual srs_error_t encode(SrsBuffer* stream);
};

/**
 * the PAT payload of PSI ts packet.
 * 2.4.4.3 Program association Table, hls-mpeg-ts-iso13818-1.pdf, page 61
 * The Program Association Table provides the correspondence between a program_number and the PID value of the
 * Transport Stream packets which carry the program definition. The program_number is the numeric label associated with
 * a program.
 */
class SrsTsPayloadPAT : public SrsTsPayloadPSI
{
public:
    // 2B
    /**
     * This is a 16-bit field which serves as a label to identify this Transport Stream from any other
     * multiplex within a network. Its value is defined by the user.
     */
    uint16_t transport_stream_id; //16bits
    
    // 1B
    /**
     * reverved value, must be '1'
     */
    int8_t const3_value; //2bits
    /**
     * This 5-bit field is the version number of the whole Program Association Table. The version number
     * shall be incremented by 1 modulo 32 whenever the definition of the Program Association Table changes. When the
     * current_next_indicator is set to '1', then the version_number shall be that of the currently applicable Program Association
     * Table. When the current_next_indicator is set to '0', then the version_number shall be that of the next applicable Program
     * Association Table.
     */
    int8_t version_number; //5bits
    /**
     * A 1-bit indicator, which when set to '1' indicates that the Program Association Table sent is
     * currently applicable. When the bit is set to '0', it indicates that the table sent is not yet applicable and shall be the next
     * table to become valid.
     */
    int8_t current_next_indicator; //1bit
    
    // 1B
    /**
     * This 8-bit field gives the number of this section. The section_number of the first section in the
     * Program Association Table shall be 0x00. It shall be incremented by 1 with each additional section in the Program
     * Association Table.
     */
    uint8_t section_number; //8bits
    
    // 1B
    /**
     * This 8-bit field specifies the number of the last section (that is, the section with the highest
     * section_number) of the complete Program Association Table.
     */
    uint8_t last_section_number; //8bits
    
    // multiple 4B program data.
    std::vector<SrsTsPayloadPATProgram*> programs;
public:
    SrsTsPayloadPAT(SrsTsPacket* p);
    virtual ~SrsTsPayloadPAT();
protected:
    virtual srs_error_t psi_decode(SrsBuffer* stream);
protected:
    virtual int psi_size();
    virtual srs_error_t psi_encode(SrsBuffer* stream);
};

/**
 * the esinfo for PMT program.
 */
class SrsTsPayloadPMTESInfo
{
public:
    // 1B
    /**
     * This is an 8-bit field specifying the type of program element carried within the packets with the PID
     * whose value is specified by the elementary_PID. The values of stream_type are specified in Table 2-29.
     */
    SrsTsStream stream_type; //8bits
    
    // 2B
    /**
     * reverved value, must be '1'
     */
    int8_t const1_value0; //3bits
    /**
     * This is a 13-bit field specifying the PID of the Transport Stream packets which carry the associated
     * program element.
     */
    int16_t elementary_PID; //13bits
    
    // (2+x)B
    /**
     * reverved value, must be '1'
     */
    int8_t const1_value1; //4bits
    std::vector<char> ES_info; //[ES_info_length] bytes.
public:
    SrsTsPayloadPMTESInfo(SrsTsStream st = SrsTsStreamReserved, int16_t epid = 0);
    virtual ~SrsTsPayloadPMTESInfo();
public:
    virtual srs_error_t decode(SrsBuffer* stream);
public:
    virtual int size();
    virtual srs_error_t encode(SrsBuffer* stream);
};

/**
 * the PMT payload of PSI ts packet.
 * 2.4.4.8 Program Map Table, hls-mpeg-ts-iso13818-1.pdf, page 64
 * The Program Map Table provides the mappings between program numbers and the program elements that comprise
 * them. A single instance of such a mapping is referred to as a "program definition". The program map table is the
 * complete collection of all program definitions for a Transport Stream. This table shall be transmitted in packets, the PID
 * values of which are selected by the encoder. More than one PID value may be used, if desired. The table is contained in
 * one or more sections with the following syntax. It may be segmented to occupy multiple sections. In each section, the
 * section number field shall be set to zero. Sections are identified by the program_number field.
 */
class SrsTsPayloadPMT : public SrsTsPayloadPSI
{
public:
    // 2B
    /**
     * program_number is a 16-bit field. It specifies the program to which the program_map_PID is
     * applicable. One program definition shall be carried within only one TS_program_map_section. This implies that a
     * program definition is never longer than 1016 (0x3F8). See Informative Annex C for ways to deal with the cases when
     * that length is not sufficient. The program_number may be used as a designation for a broadcast channel, for example. By
     * describing the different program elements belonging to a program, data from different sources (e.g. sequential events)
     * can be concatenated together to form a continuous set of streams using a program_number. For examples of applications
     * refer to Annex C.
     */
    uint16_t program_number; //16bits
    
    // 1B
    /**
     * reverved value, must be '1'
     */
    int8_t const1_value0; //2bits
    /**
     * This 5-bit field is the version number of the TS_program_map_section. The version number shall be
     * incremented by 1 modulo 32 when a change in the information carried within the section occurs. Version number refers
     * to the definition of a single program, and therefore to a single section. When the current_next_indicator is set to '1', then
     * the version_number shall be that of the currently applicable TS_program_map_section. When the current_next_indicator
     * is set to '0', then the version_number shall be that of the next applicable TS_program_map_section.
     */
    int8_t version_number; //5bits
    /**
     * A 1-bit field, which when set to '1' indicates that the TS_program_map_section sent is
     * currently applicable. When the bit is set to '0', it indicates that the TS_program_map_section sent is not yet applicable
     * and shall be the next TS_program_map_section to become valid.
     */
    int8_t current_next_indicator; //1bit
    
    // 1B
    /**
     * The value of this 8-bit field shall be 0x00.
     */
    uint8_t section_number; //8bits
    
    // 1B
    /**
     * The value of this 8-bit field shall be 0x00.
     */
    uint8_t last_section_number; //8bits
    
    // 2B
    /**
     * reverved value, must be '1'
     */
    int8_t const1_value1; //3bits
    /**
     * This is a 13-bit field indicating the PID of the Transport Stream packets which shall contain the PCR fields
     * valid for the program specified by program_number. If no PCR is associated with a program definition for private
     * streams, then this field shall take the value of 0x1FFF. Refer to the semantic definition of PCR in 2.4.3.5 and Table 2-3
     * for restrictions on the choice of PCR_PID value.
     */
    int16_t PCR_PID; //13bits
    
    // 2B
    int8_t const1_value2; //4bits
    /**
     * This is a 12-bit field, the first two bits of which shall be '00'. The remaining 10 bits specify the
     * number of bytes of the descriptors immediately following the program_info_length field.
     */
    std::vector<char> program_info_desc; //[program_info_length]bytes
    
    // array of TSPMTESInfo.
    std::vector<SrsTsPayloadPMTESInfo*> infos;
public:
    SrsTsPayloadPMT(SrsTsPacket* p);
    virtual ~SrsTsPayloadPMT();
protected:
    virtual srs_error_t psi_decode(SrsBuffer* stream);
protected:
    virtual int psi_size();
    virtual srs_error_t psi_encode(SrsBuffer* stream);
};

/**
 * Write the TS message to TS context.
 */
class SrsTsContextWriter
{
private:
    // User must config the codec in right way.
    // @see https://github.com/ossrs/srs/issues/301
    SrsVideoCodecId vcodec;
    SrsAudioCodecId acodec;
private:
    SrsTsContext* context;
    SrsFileWriter* writer;
    std::string path;
public:
    SrsTsContextWriter(SrsFileWriter* w, SrsTsContext* c, SrsAudioCodecId ac, SrsVideoCodecId vc);
    virtual ~SrsTsContextWriter();
public:
    /**
     * open the writer, donot write the PSI of ts.
     * @param p a string indicates the path of ts file to mux to.
     */
    virtual srs_error_t open(std::string p);
    /**
     * write an audio frame to ts,
     */
    virtual srs_error_t write_audio(SrsTsMessage* audio);
    /**
     * write a video frame to ts,
     */
    virtual srs_error_t write_video(SrsTsMessage* video);
    /**
     * close the writer.
     */
    virtual void close();
public:
    /**
     * get the video codec of ts muxer.
     */
    virtual SrsVideoCodecId video_codec();
};

/**
 * TS messages cache, to group frames to TS message,
 * for example, we may write multiple AAC RAW frames to a TS message.
 */
class SrsTsMessageCache
{
public:
    // current ts message.
    SrsTsMessage* audio;
    SrsTsMessage* video;
public:
    SrsTsMessageCache();
    virtual ~SrsTsMessageCache();
public:
    /**
     * write audio to cache
     */
    virtual srs_error_t cache_audio(SrsAudioFrame* frame, int64_t dts);
    /**
     * write video to muxer.
     */
    virtual srs_error_t cache_video(SrsVideoFrame* frame, int64_t dts);
private:
    virtual srs_error_t do_cache_mp3(SrsAudioFrame* frame);
    virtual srs_error_t do_cache_aac(SrsAudioFrame* frame);
    virtual srs_error_t do_cache_avc(SrsVideoFrame* frame);
};

/**
 * Transmux the RTMP stream to HTTP-TS stream.
 */
class SrsTsTransmuxer
{
private:
    SrsFileWriter* writer;
private:
    SrsFormat* format;
    SrsTsMessageCache* tsmc;
    SrsTsContextWriter* tscw;
    SrsTsContext* context;
public:
    SrsTsTransmuxer();
    virtual ~SrsTsTransmuxer();
public:
    /**
     * initialize the underlayer file stream.
     * @param fw the writer to use for ts encoder, user must free it.
     */
    virtual srs_error_t initialize(SrsFileWriter* fw);
public:
    /**
     * write audio/video packet.
     * @remark assert data is not NULL.
     */
    virtual srs_error_t write_audio(int64_t timestamp, char* data, int size);
    virtual srs_error_t write_video(int64_t timestamp, char* data, int size);
private:
    virtual srs_error_t flush_audio();
    virtual srs_error_t flush_video();
};

#endif

#endif

// following is generated by src/kernel/srs_kernel_stream.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_KERNEL_STREAM_HPP
#define SRS_KERNEL_STREAM_HPP

//#include <srs_core.hpp>

#include <vector>

/**
 * the simple buffer use vector to append bytes,
 * it's for hls and http, and need to be refined in future.
 */
class SrsSimpleStream
{
private:
    std::vector<char> data;
public:
    SrsSimpleStream();
    virtual ~SrsSimpleStream();
public:
    /**
     * get the length of buffer. empty if zero.
     * @remark assert length() is not negative.
     */
    virtual int length();
    /**
     * get the buffer bytes.
     * @return the bytes, NULL if empty.
     */
    virtual char* bytes();
    /**
     * erase size of bytes from begin.
     * @param size to erase size of bytes.
     *       clear if size greater than or equals to length()
     * @remark ignore size is not positive.
     */
    virtual void erase(int size);
    /**
     * append specified bytes to buffer.
     * @param size the size of bytes
     * @remark assert size is positive.
     */
    virtual void append(const char* bytes, int size);
};

#endif
// following is generated by src/kernel/srs_kernel_balance.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_KERNEL_BALANCE_HPP
#define SRS_KERNEL_BALANCE_HPP

//#include <srs_core.hpp>

#include <vector>
#include <string>

/**
 * the round-robin load balance algorithm,
 * used for edge pull, kafka and other multiple server feature.
 */
class SrsLbRoundRobin
{
private:
    // current selected index.
    int index;
    // total scheduled count.
    uint32_t count;
    // current selected server.
    std::string elem;
public:
    SrsLbRoundRobin();
    virtual ~SrsLbRoundRobin();
public:
    virtual uint32_t current();
    virtual std::string selected();
    virtual std::string select(const std::vector<std::string>& servers);
};

#endif

// following is generated by src/kernel/srs_kernel_mp4.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_KERNEL_MP4_HPP
#define SRS_KERNEL_MP4_HPP

//#include <srs_core.hpp>

//#include <srs_kernel_buffer.hpp>
//#include <srs_kernel_codec.hpp>

#include <string>
#include <sstream>
#include <vector>
#include <map>

class ISrsWriter;
class ISrsWriteSeeker;
class ISrsReadSeeker;
class SrsMp4TrackBox;
class SrsMp4MediaBox;
class SrsSimpleStream;
class SrsMp4MovieHeaderBox;
class SrsMp4TrackHeaderBox;
class SrsMp4SampleTableBox;
class SrsMp4MediaInformationBox;
class SrsMp4SampleDescriptionBox;
class SrsMp4AvccBox;
class SrsMp4DecoderSpecificInfo;
class SrsMp4VisualSampleEntry;
class SrsMp4AvccBox;
class SrsMp4AudioSampleEntry;
class SrsMp4EsdsBox;
class SrsMp4ChunkOffsetBox;
class SrsMp4SampleSizeBox;
class SrsMp4Sample2ChunkBox;
class SrsMp4DecodingTime2SampleBox;
class SrsMp4CompositionTime2SampleBox;
class SrsMp4SyncSampleBox;
class SrsMp4MediaHeaderBox;
class SrsMp4HandlerReferenceBox;
class SrsMp4VideoMeidaHeaderBox;
class SrsMp4DataInformationBox;
class SrsMp4DataReferenceBox;
class SrsMp4SoundMeidaHeaderBox;
class SrsMp4MovieExtendsBox;
class SrsMp4TrackExtendsBox;
class SrsMp4MovieFragmentHeaderBox;
class SrsMp4TrackFragmentBox;
class SrsMp4TrackFragmentHeaderBox;
class SrsMp4TrackFragmentDecodeTimeBox;
class SrsMp4TrackFragmentRunBox;

/**
 * 4.2 Object Structure
 * ISO_IEC_14496-12-base-format-2012.pdf, page 16
 */
enum SrsMp4BoxType
{
    SrsMp4BoxTypeForbidden = 0x00,
    
    SrsMp4BoxTypeUUID = 0x75756964, // 'uuid'
    SrsMp4BoxTypeFTYP = 0x66747970, // 'ftyp'
    SrsMp4BoxTypeMDAT = 0x6d646174, // 'mdat'
    SrsMp4BoxTypeFREE = 0x66726565, // 'free'
    SrsMp4BoxTypeSKIP = 0x736b6970, // 'skip'
    SrsMp4BoxTypeMOOV = 0x6d6f6f76, // 'moov'
    SrsMp4BoxTypeMVHD = 0x6d766864, // 'mvhd'
    SrsMp4BoxTypeTRAK = 0x7472616b, // 'trak'
    SrsMp4BoxTypeTKHD = 0x746b6864, // 'tkhd'
    SrsMp4BoxTypeEDTS = 0x65647473, // 'edts'
    SrsMp4BoxTypeELST = 0x656c7374, // 'elst'
    SrsMp4BoxTypeMDIA = 0x6d646961, // 'mdia'
    SrsMp4BoxTypeMDHD = 0x6d646864, // 'mdhd'
    SrsMp4BoxTypeHDLR = 0x68646c72, // 'hdlr'
    SrsMp4BoxTypeMINF = 0x6d696e66, // 'minf'
    SrsMp4BoxTypeVMHD = 0x766d6864, // 'vmhd'
    SrsMp4BoxTypeSMHD = 0x736d6864, // 'smhd'
    SrsMp4BoxTypeDINF = 0x64696e66, // 'dinf'
    SrsMp4BoxTypeURL  = 0x75726c20, // 'url '
    SrsMp4BoxTypeURN  = 0x75726e20, // 'urn '
    SrsMp4BoxTypeDREF = 0x64726566, // 'dref'
    SrsMp4BoxTypeSTBL = 0x7374626c, // 'stbl'
    SrsMp4BoxTypeSTSD = 0x73747364, // 'stsd'
    SrsMp4BoxTypeSTTS = 0x73747473, // 'stts'
    SrsMp4BoxTypeCTTS = 0x63747473, // 'ctts'
    SrsMp4BoxTypeSTSS = 0x73747373, // 'stss'
    SrsMp4BoxTypeSTSC = 0x73747363, // 'stsc'
    SrsMp4BoxTypeSTCO = 0x7374636f, // 'stco'
    SrsMp4BoxTypeCO64 = 0x636f3634, // 'co64'
    SrsMp4BoxTypeSTSZ = 0x7374737a, // 'stsz'
    SrsMp4BoxTypeSTZ2 = 0x73747a32, // 'stz2'
    SrsMp4BoxTypeAVC1 = 0x61766331, // 'avc1'
    SrsMp4BoxTypeAVCC = 0x61766343, // 'avcC'
    SrsMp4BoxTypeMP4A = 0x6d703461, // 'mp4a'
    SrsMp4BoxTypeESDS = 0x65736473, // 'esds'
    SrsMp4BoxTypeUDTA = 0x75647461, // 'udta'
    SrsMp4BoxTypeMVEX = 0x6d766578, // 'mvex'
    SrsMp4BoxTypeTREX = 0x74726578, // 'trex'
    SrsMp4BoxTypePASP = 0x70617370, // 'pasp'
    SrsMp4BoxTypeSTYP = 0x73747970, // 'styp'
    SrsMp4BoxTypeMOOF = 0x6d6f6f66, // 'moof'
    SrsMp4BoxTypeMFHD = 0x6d666864, // 'mfhd'
    SrsMp4BoxTypeTRAF = 0x74726166, // 'traf'
    SrsMp4BoxTypeTFHD = 0x74666864, // 'tfhd'
    SrsMp4BoxTypeTFDT = 0x74666474, // 'tfdt'
    SrsMp4BoxTypeTRUN = 0x7472756e, // 'trun'
};

/**
 * 8.4.3.3 Semantics
 * ISO_IEC_14496-12-base-format-2012.pdf, page 37
 */
enum SrsMp4HandlerType
{
    SrsMp4HandlerTypeForbidden = 0x00,
    
    SrsMp4HandlerTypeVIDE = 0x76696465, // 'vide'
    SrsMp4HandlerTypeSOUN = 0x736f756e, // 'soun'
};

/**
 * File format brands
 * ISO_IEC_14496-12-base-format-2012.pdf, page 166
 */
enum SrsMp4BoxBrand
{
    SrsMp4BoxBrandForbidden = 0x00,
    SrsMp4BoxBrandISOM = 0x69736f6d, // 'isom'
    SrsMp4BoxBrandISO2 = 0x69736f32, // 'iso2'
    SrsMp4BoxBrandAVC1 = 0x61766331, // 'avc1'
    SrsMp4BoxBrandMP41 = 0x6d703431, // 'mp41'
    SrsMp4BoxBrandISO5 = 0x69736f35, // 'iso5'
    SrsMp4BoxBrandMP42 = 0x6d703432, // 'mp42'
    SrsMp4BoxBrandDASH = 0x64617368, // 'dash'
    SrsMp4BoxBrandMSDH = 0x6d736468, // 'msdh'
};

/**
 * The context to dump.
 */
struct SrsMp4DumpContext
{
    int level;
    bool summary;
    
    SrsMp4DumpContext indent();
};

/**
 * 4.2 Object Structure
 * ISO_IEC_14496-12-base-format-2012.pdf, page 16
 */
class SrsMp4Box : public ISrsCodec
{
private:
    // The size is the entire size of the box, including the size and type header, fields,
    // and all contained boxes. This facilitates general parsing of the file.
    //
    // if size is 1 then the actual size is in the field largesize;
    // if size is 0, then this box is the last one in the file, and its contents
    // extend to the end of the file (normally only used for a Media Data Box)
    uint32_t smallsize;
    uint64_t largesize;
public:
    // identifies the box type; standard boxes use a compact type, which is normally four printable
    // characters, to permit ease of identification, and is shown so in the boxes below. User extensions use
    // an extended type; in this case, the type field is set to ‘uuid’.
    SrsMp4BoxType type;
    // For box 'uuid'.
    std::vector<char> usertype;
protected:
    std::vector<SrsMp4Box*> boxes;
private:
    // The position at buffer to start demux the box.
    int start_pos;
public:
    SrsMp4Box();
    virtual ~SrsMp4Box();
public:
    // Get the size of box, whatever small or large size.
    // @remark For general box(except mdat), we use this sz() to create the buffer to codec it.
    virtual uint64_t sz();
    // Get the size of header, without contained boxes.
    // @remark For mdat box, we must codec its header, use this instead of sz().
    virtual int sz_header();
    // Get the left space of box, for decoder.
    virtual int left_space(SrsBuffer* buf);
    // Box type helper.
    virtual bool is_ftyp();
    virtual bool is_moov();
    virtual bool is_mdat();
    // Get the contained box of specific type.
    // @return The first matched box.
    virtual SrsMp4Box* get(SrsMp4BoxType bt);
    // Remove the contained box of specified type.
    // @return The removed count.
    virtual int remove(SrsMp4BoxType bt);
    // Dumps the box and all contained boxes.
    virtual std::stringstream& dumps(std::stringstream& ss, SrsMp4DumpContext dc);
    /**
     * Discovery the box from buffer.
     * @param ppbox Output the discoveried box, which user must free it.
     */
    static srs_error_t discovery(SrsBuffer* buf, SrsMp4Box** ppbox);
// Interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
protected:
    virtual srs_error_t encode_boxes(SrsBuffer* buf);
    virtual srs_error_t decode_boxes(SrsBuffer* buf);
// Sub classes can override these functions for special codec.
// @remark For mdat box, we use completely different codec.
protected:
    // The size of header, not including the contained boxes.
    virtual int nb_header();
    // It's not necessary to check the buffer, because we already know the size in parent function,
    // so we have checked the buffer is ok to write.
    virtual srs_error_t encode_header(SrsBuffer* buf);
    // It's not necessary to check the buffer, unless the box is not only determined by the verson.
    // Generally, it's not necessary, that is, all boxes is determinated by version.
    virtual srs_error_t decode_header(SrsBuffer* buf);
    // Whether there contained boxes in header.
    virtual bool boxes_in_header();
// @remark internal for template methods.
public:
    // Dumps the detail of box.
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 4.2 Object Structure
 * ISO_IEC_14496-12-base-format-2012.pdf, page 17
 */
class SrsMp4FullBox : public SrsMp4Box
{
public:
    // an integer that specifies the version of this format of the box.
    uint8_t version;
    // a map of flags
    uint32_t flags;
public:
    SrsMp4FullBox();
    virtual ~SrsMp4FullBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 4.3 File Type Box (ftyp)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 17
 * Files written to this version of this specification must contain a file-type box. For compatibility with an earlier
 * version of this specification, files may be conformant to this specification and not contain a file-type box. Files
 * with no file-type box should be read as if they contained an FTYP box with Major_brand='mp41', minor_version=0, and
 * the single compatible brand 'mp41'.
 */
class SrsMp4FileTypeBox : public SrsMp4Box
{
public:
    // a brand identifier
    SrsMp4BoxBrand major_brand;
    // an informative integer for the minor version of the major brand
    uint32_t minor_version;
private:
    // a list, to the end of the box, of brands
    std::vector<SrsMp4BoxBrand> compatible_brands;
public:
    SrsMp4FileTypeBox();
    virtual ~SrsMp4FileTypeBox();
public:
    virtual void set_compatible_brands(SrsMp4BoxBrand b0, SrsMp4BoxBrand b1);
    virtual void set_compatible_brands(SrsMp4BoxBrand b0, SrsMp4BoxBrand b1, SrsMp4BoxBrand b2, SrsMp4BoxBrand b3);
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.16.2 Segment Type Box (styp)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 105
 * If segments are stored in separate files (e.g. on a standard HTTP server) it is recommended that these 
 * 'segment files' contain a segment-type box, which must be first if present, to enable identification of those files, 
 * and declaration of the specifications with which they are compliant.
 */
class SrsMp4SegmentTypeBox : public SrsMp4FileTypeBox
{
public:
    SrsMp4SegmentTypeBox();
    virtual ~SrsMp4SegmentTypeBox();
};

/**
 * 8.8.4 Movie Fragment Box (moof)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 66
 * The movie fragments extend the presentation in time. They provide the information that would previously have
 * been in the Movie Box. The actual samples are in Media Data Boxes, as usual, if they are in the same file.
 * The data reference index is in the sample description, so it is possible to build incremental presentations
 * where the media data is in files other than the file containing the Movie Box.
 */
class SrsMp4MovieFragmentBox : public SrsMp4Box
{
public:
    SrsMp4MovieFragmentBox();
    virtual ~SrsMp4MovieFragmentBox();
public:
    // Get the header of moof.
    virtual SrsMp4MovieFragmentHeaderBox* mfhd();
    virtual void set_mfhd(SrsMp4MovieFragmentHeaderBox* v);
    // Get the traf.
    virtual SrsMp4TrackFragmentBox* traf();
    virtual void set_traf(SrsMp4TrackFragmentBox* v);
};

/**
 * 8.8.5 Movie Fragment Header Box (mfhd)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 67
 * The movie fragment header contains a sequence number, as a safety check. The sequence number usually
 * starts at 1 and must increase for each movie fragment in the file, in the order in which they occur. This allows
 * readers to verify integrity of the sequence; it is an error to construct a file where the fragments are out of
 * sequence.
 */
class SrsMp4MovieFragmentHeaderBox : public SrsMp4FullBox
{
public:
    // the ordinal number of this fragment, in increasing order
    uint32_t sequence_number;
public:
    SrsMp4MovieFragmentHeaderBox();
    virtual ~SrsMp4MovieFragmentHeaderBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.8.6 Track Fragment Box (traf)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 67
 * Within the movie fragment there is a set of track fragments, zero or more per track. The track fragments in
 * turn contain zero or more track runs, each of which document a contiguous run of samples for that track.
 * Within these structures, many fields are optional and can be defaulted.
 */
class SrsMp4TrackFragmentBox : public SrsMp4Box
{
public:
    SrsMp4TrackFragmentBox();
    virtual ~SrsMp4TrackFragmentBox();
public:
    // Get the tfhd.
    virtual SrsMp4TrackFragmentHeaderBox* tfhd();
    virtual void set_tfhd(SrsMp4TrackFragmentHeaderBox* v);
    // Get the tfdt.
    virtual SrsMp4TrackFragmentDecodeTimeBox* tfdt();
    virtual void set_tfdt(SrsMp4TrackFragmentDecodeTimeBox* tfdt);
    // Get the trun.
    virtual SrsMp4TrackFragmentRunBox* trun();
    virtual void set_trun(SrsMp4TrackFragmentRunBox* v);
};

/**
 * The tf_flags of tfhd.
 * ISO_IEC_14496-12-base-format-2012.pdf, page 68
 */
enum SrsMp4TfhdFlags
{
    /**
     * indicates the presence of the base-data-offset field. This provides 
     * an explicit anchor for the data offsets in each track run (see below). If not provided, the base-data-
     * offset for the first track in the movie fragment is the position of the first byte of the enclosing Movie
     * Fragment Box, and for second and subsequent track fragments, the default is the end of the data
     * defined by the preceding fragment. Fragments 'inheriting' their offset in this way must all use
     * the same data-reference (i.e., the data for these tracks must be in the same file).
     */
    SrsMp4TfhdFlagsBaseDataOffset = 0x000001,
    /**
     * indicates the presence of this field, which over-rides, in this
     * fragment, the default set up in the Track Extends Box.
     */
    SrsMp4TfhdFlagsSampleDescriptionIndex = 0x000002,
    SrsMp4TfhdFlagsDefaultSampleDuration = 0x000008,
    SrsMp4TfhdFlagsDefautlSampleSize = 0x000010,
    SrsMp4TfhdFlagsDefaultSampleFlags = 0x000020,
    /**
     * this indicates that the duration provided in either default-sample-duration,
     * or by the default-duration in the Track Extends Box, is empty, i.e. that there are no samples for this
     * time interval. It is an error to make a presentation that has both edit lists in the Movie Box, and empty-
     * duration fragments.
     */
    SrsMp4TfhdFlagsDurationIsEmpty = 0x010000,
    /**
     * if base-data-offset-present is zero, this indicates that the base-data-
     * offset for this track fragment is the position of the first byte of the enclosing Movie Fragment Box.
     * Support for the default-base-is-moof flag is required under the ‘iso5’ brand, and it shall not be used in
     * brands or compatible brands earlier than iso5.
     */
    SrsMp4TfhdFlagsDefaultBaseIsMoof = 0x020000,
};

/**
 * 8.8.7 Track Fragment Header Box (tfhd)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 68
 * Each movie fragment can add zero or more fragments to each track; and a track fragment can add zero or
 * more contiguous runs of samples. The track fragment header sets up information and defaults used for those
 * runs of samples.
 */
class SrsMp4TrackFragmentHeaderBox : public SrsMp4FullBox
{
public:
    uint32_t track_id;
// all the following are optional fields
public:
    // the base offset to use when calculating data offsets
    uint64_t base_data_offset;
    uint32_t sample_description_index;
    uint32_t default_sample_duration;
    uint32_t default_sample_size;
    uint32_t default_sample_flags;
public:
    SrsMp4TrackFragmentHeaderBox();
    virtual ~SrsMp4TrackFragmentHeaderBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.8.12 Track fragment decode time (tfdt)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 72
 * The Track Fragment Base Media Decode Time Box provides the absolute decode time, measured on
 * the media timeline, of the first sample in decode order in the track fragment. This can be useful, for example,
 * when performing random access in a file; it is not necessary to sum the sample durations of all preceding
 * samples in previous fragments to find this value (where the sample durations are the deltas in the Decoding
 * Time to Sample Box and the sample_durations in the preceding track runs).
 */
class SrsMp4TrackFragmentDecodeTimeBox : public SrsMp4FullBox
{
public:
    uint64_t base_media_decode_time;
public:
    SrsMp4TrackFragmentDecodeTimeBox();
    virtual ~SrsMp4TrackFragmentDecodeTimeBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * The tr_flags for trun
 * ISO_IEC_14496-12-base-format-2012.pdf, page 69
 */
enum SrsMp4TrunFlags
{
    // data-offset-present.
    SrsMp4TrunFlagsDataOffset = 0x000001,
    // this over-rides the default flags for the first sample only. This
    // makes it possible to record a group of frames where the first is a key and the rest are difference
    // frames, without supplying explicit flags for every sample. If this flag and field are used, sample-flags
    // shall not be present.
    SrsMp4TrunFlagsFirstSample = 0x000004,
    // indicates that each sample has its own duration, otherwise the default is used.
    SrsMp4TrunFlagsSampleDuration = 0x000100,
    // each sample has its own size, otherwise the default is used.
    SrsMp4TrunFlagsSampleSize = 0x000200,
    // each sample has its own flags, otherwise the default is used.
    SrsMp4TrunFlagsSampleFlag = 0x000400,
    // each sample has a composition time offset (e.g. as used for I/P/B video in MPEG).
    SrsMp4TrunFlagsSampleCtsOffset = 0x000800,
};

/**
 * Entry for trun.
 * ISO_IEC_14496-12-base-format-2012.pdf, page 69
 */
struct SrsMp4TrunEntry
{
    SrsMp4FullBox* owner;
    
    uint32_t sample_duration;
    uint32_t sample_size;
    uint32_t sample_flags;
    // if version == 0, unsigned int(32); otherwise, signed int(32).
    int64_t sample_composition_time_offset;
    
    SrsMp4TrunEntry(SrsMp4FullBox* o);
    virtual ~SrsMp4TrunEntry();
    
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.8.8 Track Fragment Run Box (trun)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 69
 * Within the Track Fragment Box, there are zero or more Track Run Boxes. If the duration-is-empty flag is set in
 * the tf_flags, there are no track runs. A track run documents a contiguous set of samples for a track.
 */
class SrsMp4TrackFragmentRunBox : public SrsMp4FullBox
{
public:
    // the number of samples being added in this run; also the number of rows in the following
    // table (the rows can be empty)
    uint32_t sample_count;
// the following are optional fields
public:
    // added to the implicit or explicit data_offset established in the track fragment header.
    int32_t data_offset;
    // provides a set of flags for the first sample only of this run.
    uint32_t first_sample_flags;
// all fields in the following array are optional
public:
    std::vector<SrsMp4TrunEntry*> entries;
public:
    SrsMp4TrackFragmentRunBox();
    virtual ~SrsMp4TrackFragmentRunBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.1.1 Media Data Box (mdat)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 29
 * This box contains the media data. In video tracks, this box would contain video frames.
 * A presentation may contain zero or more Media Data Boxes. The actual media data follows the type field;
 * its structure is described by the metadata (see particularly the sample table, subclause 8.5, and the
 * item location box, subclause 8.11.3).
 * 
 * @remark The mdat box only decode and encode the header,
 *      so user must read and write the data by yourself.
 * To encode mdat:
 *      SrsMp4MediaDataBox* mdat = new SrsMp4MediaDataBox();
 *      mdat->nb_data = 1024000;
 *
 *      char* buffer = new char[mdat->sz_header()];
 *      SrsBuffer* buf = new SrsBuffer(buffer);
 *      mdat->encode(buf);
 *      
 *      file->write(buffer, mdat->sz_header()); // Write the mdat box header.
 *      file->write(data, size); // Write the mdat box data.
 * 
 * To decode mdat:
 *      SrsMp4MediaDataBox* mdat = new SrsMp4MediaDataBox();
 *      char* buffer = new char[mdat->sz_header()];
 *      SrsBuffer* buf = ...; // Read mdat->sz_header() data from io.
 * 
 *      mdat->decode(buf); // The buf should be empty now.
 *      file->lseek(mdat->nb_data, SEEK_CUR); // Skip the mdat data in file.
 * 
 * To discovery any box from file:
 *      SrsSimpleStream* stream = new SrsSimpleStream();
 *      SrsBuffer* buf = new SrsBuffer(stream...); // Create read buffer from stream.
 *      
 *      // We don't know what's the next box, so try to read 4bytes and discovery it.
 *      append(file, stream, 4); // Append 4bytes from file to stream.
 *
 *      SrsMp4Box* box = NULL;
 *      SrsMp4Box::discovery(buf, &box);
 *
 *      required = (box->is_mdat()? box->sz_header():box->sz()); // Now we know how many bytes we needed.
 *      append(file, stream, required);
 *      box->decode(buf);
 *
 *      if (box->is_mdat()) {
 *          file->lseek(mdat->nb_data, SEEK_CUR); // Skip the mdat data in file.
 *      }
 */
class SrsMp4MediaDataBox : public SrsMp4Box
{
public:
    // The contained media data, which we never directly read/write it.
    // TODO: FIXME: Support 64bits size.
    int nb_data;
public:
    SrsMp4MediaDataBox();
    virtual ~SrsMp4MediaDataBox();
// Interface ISrsCodec
public:
    // The total size of bytes, including the sz_header() and nb_data,
    // which used to write the smallsize or largesize of mp4.
    virtual int nb_bytes();
    // To encode the mdat box, the buf should only contains the sz_header(),
    // because the mdata only encode the header.
    virtual srs_error_t encode(SrsBuffer* buf);
    // To decode the mdat box, the buf should only contains the sz_header(),
    // because the mdat only decode the header.
    virtual srs_error_t decode(SrsBuffer* buf);
protected:
    virtual srs_error_t encode_boxes(SrsBuffer* buf);
    virtual srs_error_t decode_boxes(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.1.2 Free Space Box (free or skip)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 29
 */
class SrsMp4FreeSpaceBox : public SrsMp4Box
{
private:
    std::vector<char> data;
public:
    SrsMp4FreeSpaceBox(SrsMp4BoxType v);
    virtual ~SrsMp4FreeSpaceBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.2.1 Movie Box (moov)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 30
 * The metadata for a presentation is stored in the single Movie Box which occurs at the top-level of a file.
 * Normally this box is close to the beginning or end of the file, though this is not required.
 */
class SrsMp4MovieBox : public SrsMp4Box
{
public:
    SrsMp4MovieBox();
    virtual ~SrsMp4MovieBox();
public:
    // Get the header of moov.
    virtual SrsMp4MovieHeaderBox* mvhd();
    virtual void set_mvhd(SrsMp4MovieHeaderBox* v);
    // Get the movie extends header.
    virtual SrsMp4MovieExtendsBox* mvex();
    virtual void set_mvex(SrsMp4MovieExtendsBox* v);
    // Get the first video track.
    virtual SrsMp4TrackBox* video();
    // Get the first audio track.
    virtual SrsMp4TrackBox* audio();
    // Add a new track.
    virtual void add_trak(SrsMp4TrackBox* v);
    // Get the number of video tracks.
    virtual int nb_vide_tracks();
    // Get the number of audio tracks.
    virtual int nb_soun_tracks();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
};

/**
 * 8.2.2 Movie Header Box (mvhd)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 31
 */
class SrsMp4MovieHeaderBox : public SrsMp4FullBox
{
public:
    // an integer that declares the creation time of the presentation (in seconds since
    // midnight, Jan. 1, 1904, in UTC time)
    uint64_t creation_time;
    // an integer that declares the most recent time the presentation was modified (in
    // seconds since midnight, Jan. 1, 1904, in UTC time)
    uint64_t modification_time;
public:
    // an integer that specifies the time-scale for the entire presentation; this is the number of
    // time units that pass in one second. For example, a time coordinate system that measures time in
    // sixtieths of a second has a time scale of 60.
    uint32_t timescale;
    // an integer that declares length of the presentation (in the indicated timescale). This property
    // is derived from the presentation’s tracks: the value of this field corresponds to the duration of the
    // longest track in the presentation. If the duration cannot be determined then duration is set to all 1s.
    uint64_t duration_in_tbn;
public:
    // a fixed point 16.16 number that indicates the preferred rate to play the presentation; 1.0
    // (0x00010000) is normal forward playback
    uint32_t rate;
    // a fixed point 8.8 number that indicates the preferred playback volume. 1.0 (0x0100) is full volume.
    uint16_t volume;
    uint16_t reserved0;
    uint64_t reserved1;
    // a transformation matrix for the video; (u,v,w) are restricted here to (0,0,1), hex values (0,0,0x40000000).
    int32_t matrix[9];
    uint32_t pre_defined[6];
    // a non-zero integer that indicates a value to use for the track ID of the next track to be
    // added to this presentation. Zero is not a valid track ID value. The value of next_track_ID shall be
    // larger than the largest track-ID in use. If this value is equal to all 1s (32-bit maxint), and a new media
    // track is to be added, then a search must be made in the file for an unused track identifier.
    uint32_t next_track_ID;
public:
    SrsMp4MovieHeaderBox();
    virtual ~SrsMp4MovieHeaderBox();
public:
    // Get the duration in ms.
    virtual uint64_t duration();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

// The type of track, maybe combine of types.
enum SrsMp4TrackType
{
    SrsMp4TrackTypeForbidden = 0x00,
    SrsMp4TrackTypeAudio = 0x01,
    SrsMp4TrackTypeVideo = 0x02,
};

/**
 * 8.8.1 Movie Extends Box (mvex)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 64
 * This box warns readers that there might be Movie Fragment Boxes in this file. To know of all samples in the
 * tracks, these Movie Fragment Boxes must be found and scanned in order, and their information logically
 * added to that found in the Movie Box.
 */
class SrsMp4MovieExtendsBox : public SrsMp4Box
{
public:
    SrsMp4MovieExtendsBox();
    virtual ~SrsMp4MovieExtendsBox();
public:
    // Get the track extends box.
    virtual SrsMp4TrackExtendsBox* trex();
    virtual void set_trex(SrsMp4TrackExtendsBox* v);
};

/**
 * 8.8.3 Track Extends Box(trex)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 65
 */
class SrsMp4TrackExtendsBox : public SrsMp4FullBox
{
public:
    // identifies the track; this shall be the track ID of a track in the Movie Box
    uint32_t track_ID;
    // these fields set up defaults used in the track fragments.
    uint32_t default_sample_description_index;
    uint32_t default_sample_duration;
    uint32_t default_sample_size;
    uint32_t default_sample_flags;
public:
    SrsMp4TrackExtendsBox();
    virtual ~SrsMp4TrackExtendsBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.3.1 Track Box (trak)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 32
 * This is a container box for a single track of a presentation. A presentation consists of one or more tracks.
 * Each track is independent of the other tracks in the presentation and carries its own temporal and spatial
 * information. Each track will contain its associated Media Box.
 */
class SrsMp4TrackBox : public SrsMp4Box
{
public:
    SrsMp4TrackBox();
    virtual ~SrsMp4TrackBox();
public:
    // Get the type of track, maybe combine of track type,
    // for example, it maybe Audio|Video when contains both.
    // Generally, only single type, no combination.
    virtual SrsMp4TrackType track_type();
    // Get the track header box.
    virtual SrsMp4TrackHeaderBox* tkhd();
    virtual void set_tkhd(SrsMp4TrackHeaderBox* v);
public:
    // Get the chunk offset box.
    virtual SrsMp4ChunkOffsetBox* stco();
    // Get the sample size box.
    virtual SrsMp4SampleSizeBox* stsz();
    // Get the sample to chunk box.
    virtual SrsMp4Sample2ChunkBox* stsc();
    // Get the dts box.
    virtual SrsMp4DecodingTime2SampleBox* stts();
    // Get the cts/pts box.
    virtual SrsMp4CompositionTime2SampleBox* ctts();
    // Get the sync dts box.
    virtual SrsMp4SyncSampleBox* stss();
    // Get the media header box.
    virtual SrsMp4MediaHeaderBox* mdhd();
public:
    // For vide track, get the video codec.
    virtual SrsVideoCodecId vide_codec();
    // For soun track, get the audio codec.
    virtual SrsAudioCodecId soun_codec();
    // For H.264/AVC codec, get the sps/pps.
    virtual SrsMp4AvccBox* avcc();
    // For AAC codec, get the asc.
    virtual SrsMp4DecoderSpecificInfo* asc();
public:
    // Get the media box.
    virtual SrsMp4MediaBox* mdia();
    virtual void set_mdia(SrsMp4MediaBox* v);
    // Get the media info box.
    virtual SrsMp4MediaInformationBox* minf();
    // Get the sample table box.
    virtual SrsMp4SampleTableBox* stbl();
    // Get the sample description box
    virtual SrsMp4SampleDescriptionBox* stsd();
public:
    // For H.264/AVC, get the avc1 box.
    virtual SrsMp4VisualSampleEntry* avc1();
    // For AAC, get the mp4a box.
    virtual SrsMp4AudioSampleEntry* mp4a();
};

/**
 * 8.3.2 Track Header Box (tkhd)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 32
 */
class SrsMp4TrackHeaderBox : public SrsMp4FullBox
{
public:
    // an integer that declares the creation time of the presentation (in seconds since
    // midnight, Jan. 1, 1904, in UTC time)
    uint64_t creation_time;
    // an integer that declares the most recent time the presentation was modified (in
    // seconds since midnight, Jan. 1, 1904, in UTC time)
    uint64_t modification_time;
    // an integer that uniquely identifies this track over the entire life-time of this presentation.
    // Track IDs are never re-used and cannot be zero.
    uint32_t track_ID;
    uint32_t reserved0;
    // an integer that indicates the duration of this track (in the timescale indicated in the Movie
    // Header Box). The value of this field is equal to the sum of the durations of all of the track’s edits. If
    // there is no edit list, then the duration is the sum of the sample durations, converted into the timescale
    // in the Movie Header Box. If the duration of this track cannot be determined then duration is set to all
    // 1s.
    uint64_t duration;
public:
    uint64_t reserved1;
    // specifies the front-to-back ordering of video tracks; tracks with lower numbers are closer to the
    // viewer. 0 is the normal value, and -1 would be in front of track 0, and so on.
    int16_t layer;
    // an integer that specifies a group or collection of tracks. If this field is 0 there is no
    // information on possible relations to other tracks. If this field is not 0, it should be the same for tracks
    // that contain alternate data for one another and different for tracks belonging to different such groups.
    // Only one track within an alternate group should be played or streamed at any one time, and must be
    // distinguishable from other tracks in the group via attributes such as bitrate, codec, language, packet
    // size etc. A group may have only one member.
    int16_t alternate_group;
    // a fixed 8.8 value specifying the track's relative audio volume. Full volume is 1.0 (0x0100) and
    // is the normal value. Its value is irrelevant for a purely visual track. Tracks may be composed by
    // combining them according to their volume, and then using the overall Movie Header Box volume
    // setting; or more complex audio composition (e.g. MPEG-4 BIFS) may be used.
    int16_t volume;
    uint16_t reserved2;
    // a transformation matrix for the video; (u,v,w) are restricted here to (0,0,1), hex (0,0,0x40000000).
    int32_t matrix[9];
    // the track's visual presentation size as fixed-point 16.16 values. These need
    // not be the same as the pixel dimensions of the images, which is documented in the sample
    // description(s); all images in the sequence are scaled to this size, before any overall transformation of
    // the track represented by the matrix. The pixel dimensions of the images are the default values.
    int32_t width;
    int32_t height;
public:
    SrsMp4TrackHeaderBox();
    virtual ~SrsMp4TrackHeaderBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.6.5 Edit Box (edts)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 54
 * An Edit Box maps the presentation time-line to the media time-line as it is stored in the file.
 * The Edit Box is a container for the edit lists.
 */
class SrsMp4EditBox : public SrsMp4Box
{
public:
    SrsMp4EditBox();
    virtual ~SrsMp4EditBox();
};

/**
 * 8.6.6 Edit List Box
 * ISO_IEC_14496-12-base-format-2012.pdf, page 55
 */
struct SrsMp4ElstEntry
{
public:
    // an integer that specifies the duration of this edit segment in units of the timescale
    // in the Movie Header Box
    uint64_t segment_duration;
    // an integer containing the starting time within the media of this edit segment (in media time
    // scale units, in composition time). If this field is set to –1, it is an empty edit. The last edit in a track
    // shall never be an empty edit. Any difference between the duration in the Movie Header Box, and the
    // track’s duration is expressed as an implicit empty edit at the end.
    int64_t media_time;
public:
    // specifies the relative rate at which to play the media corresponding to this edit segment. If this value is 0,
    // then the edit is specifying a ‘dwell’: the media at media-time is presented for the segment-duration. Otherwise
    // this field shall contain the value 1.
    int16_t media_rate_integer;
    int16_t media_rate_fraction;
public:
    SrsMp4ElstEntry();
public:
    virtual std::stringstream& dumps(std::stringstream& ss, SrsMp4DumpContext dc);
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.6.6 Edit List Box (elst)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 54
 * This box contains an explicit timeline map. Each entry defines part of the track time-line: by mapping part of
 * the media time-line, or by indicating ‘empty’ time, or by defining a ‘dwell’, where a single time-point in the
 * media is held for a period.
 */
class SrsMp4EditListBox : public SrsMp4FullBox
{
public:
    // an integer that gives the number of entries in the following table
    std::vector<SrsMp4ElstEntry> entries;
public:
    SrsMp4EditListBox();
    virtual ~SrsMp4EditListBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.4.1 Media Box (mdia)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 36
 * The media declaration container contains all the objects that declare information about the media data within a
 * track.
 */
class SrsMp4MediaBox : public SrsMp4Box
{
public:
    SrsMp4MediaBox();
    virtual ~SrsMp4MediaBox();
public:
    // Get the type of track, maybe combine of track type,
    // for example, it maybe Audio|Video when contains both.
    // Generally, only single type, no combination.
    virtual SrsMp4TrackType track_type();
    // Get the media header box.
    virtual SrsMp4MediaHeaderBox* mdhd();
    virtual void set_mdhd(SrsMp4MediaHeaderBox* v);
    // Get the hdlr box.
    virtual SrsMp4HandlerReferenceBox* hdlr();
    virtual void set_hdlr(SrsMp4HandlerReferenceBox* v);
    // Get the media info box.
    virtual SrsMp4MediaInformationBox* minf();
    virtual void set_minf(SrsMp4MediaInformationBox* v);
};

/**
 * 8.4.2 Media Header Box (mdhd)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 36
 * The media declaration container contains all the objects that declare information about the media data within a
 * track.
 */
class SrsMp4MediaHeaderBox : public SrsMp4FullBox
{
public:
    // an integer that declares the creation time of the presentation (in seconds since
    // midnight, Jan. 1, 1904, in UTC time)
    uint64_t creation_time;
    // an integer that declares the most recent time the presentation was modified (in
    // seconds since midnight, Jan. 1, 1904, in UTC time)
    uint64_t modification_time;
    // an integer that specifies the time-scale for the entire presentation; this is the number of
    // time units that pass in one second. For example, a time coordinate system that measures time in
    // sixtieths of a second has a time scale of 60.
    uint32_t timescale;
    // an integer that declares length of the presentation (in the indicated timescale). This property
    // is derived from the presentation’s tracks: the value of this field corresponds to the duration of the
    // longest track in the presentation. If the duration cannot be determined then duration is set to all 1s.
    uint64_t duration;
private:
    // the language code for this media. See ISO 639-2/T for the set of three character
    // codes. Each character is packed as the difference between its ASCII value and 0x60. Since the code
    // is confined to being three lower-case letters, these values are strictly positive.
    uint16_t language;
    uint16_t pre_defined;
public:
    SrsMp4MediaHeaderBox();
    virtual ~SrsMp4MediaHeaderBox();
public:
    // the language code for this media. See ISO 639-2/T for the set of three character
    // codes. Each character is packed as the difference between its ASCII value and 0x60. Since the code
    // is confined to being three lower-case letters, these values are strictly positive.
    // @param v The ASCII, for example, 'u'.
    virtual char language0();
    virtual void set_language0(char v);
    // @param v The ASCII, for example, 'n'.
    virtual char language1();
    virtual void set_language1(char v);
    // @param v The ASCII, for example, 'd'.
    virtual char language2();
    virtual void set_language2(char v);
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.4.3 Handler Reference Box (hdlr)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 37
 * This box within a Media Box declares the process by which the media-data in the track is presented, and thus,
 * the nature of the media in a track. For example, a video track would be handled by a video handler.
 */
class SrsMp4HandlerReferenceBox : public SrsMp4FullBox
{
public:
    uint32_t pre_defined;
    // an integer containing one of the following values, or a value from a derived specification:
    //      ‘vide’, Video track
    //      ‘soun’, Audio track
    SrsMp4HandlerType handler_type;
    uint32_t reserved[3];
    // a null-terminated string in UTF-8 characters which gives a human-readable name for the track
    // type (for debugging and inspection purposes).
    std::string name;
public:
    SrsMp4HandlerReferenceBox();
    virtual ~SrsMp4HandlerReferenceBox();
public:
    virtual bool is_video();
    virtual bool is_audio();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.4.4 Media Information Box (minf)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 38
 * This box contains all the objects that declare characteristic information of the media in the track.
 */
class SrsMp4MediaInformationBox : public SrsMp4Box
{
public:
    SrsMp4MediaInformationBox();
    virtual ~SrsMp4MediaInformationBox();
public:
    // Get the vmhd box.
    virtual SrsMp4VideoMeidaHeaderBox* vmhd();
    virtual void set_vmhd(SrsMp4VideoMeidaHeaderBox* v);
    // Get the smhd box.
    virtual SrsMp4SoundMeidaHeaderBox* smhd();
    virtual void set_smhd(SrsMp4SoundMeidaHeaderBox* v);
    // Get the dinf box.
    virtual SrsMp4DataInformationBox* dinf();
    virtual void set_dinf(SrsMp4DataInformationBox* v);
    // Get the sample table box.
    virtual SrsMp4SampleTableBox* stbl();
    virtual void set_stbl(SrsMp4SampleTableBox* v);
};

/**
 * 8.4.5.2 Video Media Header Box (vmhd)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 38
 * The video media header contains general presentation information, independent of the coding, for video
 * media. Note that the flags field has the value 1.
 */
class SrsMp4VideoMeidaHeaderBox : public SrsMp4FullBox
{
public:
    // a composition mode for this video track, from the following enumerated set,
    // which may be extended by derived specifications:
    //      copy = 0 copy over the existing image
    uint16_t graphicsmode;
    // a set of 3 colour values (red, green, blue) available for use by graphics modes
    uint16_t opcolor[3];
public:
    SrsMp4VideoMeidaHeaderBox();
    virtual ~SrsMp4VideoMeidaHeaderBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
};

/**
 * 8.4.5.3 Sound Media Header Box (smhd)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 39
 * The sound media header contains general presentation information, independent of the coding, for audio
 * media. This header is used for all tracks containing audio.
 */
class SrsMp4SoundMeidaHeaderBox : public SrsMp4FullBox
{
public:
    // a fixed-point 8.8 number that places mono audio tracks in a stereo space; 0 is centre (the
    // normal value); full left is -1.0 and full right is 1.0.
    int16_t balance;
    uint16_t reserved;
public:
    SrsMp4SoundMeidaHeaderBox();
    virtual ~SrsMp4SoundMeidaHeaderBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
};

/**
 * 8.7.1 Data Information Box (dinf)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 56
 * The data information box contains objects that declare the location of the media information in a track.
 */
class SrsMp4DataInformationBox : public SrsMp4Box
{
public:
    SrsMp4DataInformationBox();
    virtual ~SrsMp4DataInformationBox();
public:
    // Get the dref box.
    virtual SrsMp4DataReferenceBox* dref();
    virtual void set_dref(SrsMp4DataReferenceBox* v);
};

/**
 * 8.7.2 Data Reference Box
 * ISO_IEC_14496-12-base-format-2012.pdf, page 56
 * a 24-bit integer with flags; one flag is defined (x000001) which means that the media
 * data is in the same file as the Movie Box containing this data reference.
 */
class SrsMp4DataEntryBox : public SrsMp4FullBox
{
public:
    std::string location;
public:
    SrsMp4DataEntryBox();
    virtual ~SrsMp4DataEntryBox();
};

/**
 * 8.7.2 Data Reference Box (url )
 * ISO_IEC_14496-12-base-format-2012.pdf, page 56
 */
class SrsMp4DataEntryUrlBox : public SrsMp4DataEntryBox
{
public:
    SrsMp4DataEntryUrlBox();
    virtual ~SrsMp4DataEntryUrlBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.7.2 Data Reference Box (urn )
 * ISO_IEC_14496-12-base-format-2012.pdf, page 56
 */
class SrsMp4DataEntryUrnBox : public SrsMp4DataEntryBox
{
public:
    std::string name;
public:
    SrsMp4DataEntryUrnBox();
    virtual ~SrsMp4DataEntryUrnBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.7.2 Data Reference Box (dref)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 56
 * The data reference object contains a table of data references (normally URLs) that declare the location(s) of
 * the media data used within the presentation. The data reference index in the sample description ties entries
 * in this table to the samples in the track. A track may be split over several sources in this way.
 */
class SrsMp4DataReferenceBox : public SrsMp4FullBox
{
private:
    std::vector<SrsMp4DataEntryBox*> entries;
public:
    SrsMp4DataReferenceBox();
    virtual ~SrsMp4DataReferenceBox();
public:
    virtual uint32_t entry_count();
    virtual SrsMp4DataEntryBox* entry_at(int index);
    virtual SrsMp4DataReferenceBox* append(SrsMp4DataEntryBox* v);
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.5.1 Sample Table Box (stbl)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 40
 * The sample table contains all the time and data indexing of the media samples in a track. Using the tables
 * here, it is possible to locate samples in time, determine their type (e.g. I-frame or not), and determine their
 * size, container, and offset into that container.
 */
class SrsMp4SampleTableBox : public SrsMp4Box
{
public:
    SrsMp4SampleTableBox();
    virtual ~SrsMp4SampleTableBox();
public:
    // Get the sample description box
    virtual SrsMp4SampleDescriptionBox* stsd();
    virtual void set_stsd(SrsMp4SampleDescriptionBox* v);
    // Get the chunk offset box.
    virtual SrsMp4ChunkOffsetBox* stco();
    virtual void set_stco(SrsMp4ChunkOffsetBox* v);
    // Get the sample size box.
    virtual SrsMp4SampleSizeBox* stsz();
    virtual void set_stsz(SrsMp4SampleSizeBox* v);
    // Get the sample to chunk box.
    virtual SrsMp4Sample2ChunkBox* stsc();
    virtual void set_stsc(SrsMp4Sample2ChunkBox* v);
    // Get the dts box.
    virtual SrsMp4DecodingTime2SampleBox* stts();
    virtual void set_stts(SrsMp4DecodingTime2SampleBox* v);
    // Get the cts/pts box.
    virtual SrsMp4CompositionTime2SampleBox* ctts();
    virtual void set_ctts(SrsMp4CompositionTime2SampleBox* v);
    // Get the sync dts box.
    virtual SrsMp4SyncSampleBox* stss();
    virtual void set_stss(SrsMp4SyncSampleBox* v);
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
};

/**
 * 8.5.2 Sample Description Box
 * ISO_IEC_14496-12-base-format-2012.pdf, page 43
 */
class SrsMp4SampleEntry : public SrsMp4Box
{
public:
    uint8_t reserved[6];
    // an integer that contains the index of the data reference to use to retrieve
    // data associated with samples that use this sample description. Data references are stored in Data
    // Reference Boxes. The index ranges from 1 to the number of data references.
    uint16_t data_reference_index;
public:
    SrsMp4SampleEntry();
    virtual ~SrsMp4SampleEntry();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.5.2 Sample Description Box (avc1)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 44
 */
class SrsMp4VisualSampleEntry : public SrsMp4SampleEntry
{
public:
    uint16_t pre_defined0;
    uint16_t reserved0;
    uint32_t pre_defined1[3];
    // the maximum visual width and height of the stream described by this sample
    // description, in pixels
    uint16_t width;
    uint16_t height;
    uint32_t horizresolution;
    uint32_t vertresolution;
    uint32_t reserved1;
    // how many frames of compressed video are stored in each sample. The default is
    // 1, for one frame per sample; it may be more than 1 for multiple frames per sample
    uint16_t frame_count;
    // a name, for informative purposes. It is formatted in a fixed 32-byte field, with the first
    // byte set to the number of bytes to be displayed, followed by that number of bytes of displayable data,
    // and then padding to complete 32 bytes total (including the size byte). The field may be set to 0.
    char compressorname[32];
    // one of the following values
    //      0x0018 – images are in colour with no alpha
    uint16_t depth;
    int16_t pre_defined2;
public:
    SrsMp4VisualSampleEntry();
    virtual ~SrsMp4VisualSampleEntry();
public:
    // For avc1, get the avcc box.
    virtual SrsMp4AvccBox* avcC();
    virtual void set_avcC(SrsMp4AvccBox* v);
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 5.3.4 AVC Video Stream Definition (avcC)
 * ISO_IEC_14496-15-AVC-format-2012.pdf, page 19
 */
class SrsMp4AvccBox : public SrsMp4Box
{
public:
    std::vector<char> avc_config;
public:
    SrsMp4AvccBox();
    virtual ~SrsMp4AvccBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.5.2 Sample Description Box (mp4a)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 45
 */
class SrsMp4AudioSampleEntry : public SrsMp4SampleEntry
{
public:
    uint64_t reserved0;
    uint16_t channelcount;
    uint16_t samplesize;
    uint16_t pre_defined0;
    uint16_t reserved1;
    uint32_t samplerate;
public:
    SrsMp4AudioSampleEntry();
    virtual ~SrsMp4AudioSampleEntry();
public:
    // For AAC codec, get the esds.
    virtual SrsMp4EsdsBox* esds();
    virtual void set_esds(SrsMp4EsdsBox* v);
    // For AAC codec, get the asc.
    virtual SrsMp4DecoderSpecificInfo* asc();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

// Table 1 — List of Class Tags for Descriptors
// ISO_IEC_14496-1-System-2010.pdf, page 31
enum SrsMp4ESTagEs {
    SrsMp4ESTagESforbidden = 0x00,
    SrsMp4ESTagESObjectDescrTag = 0x01,
    SrsMp4ESTagESInitialObjectDescrTag = 0x02,
    SrsMp4ESTagESDescrTag = 0x03,
    SrsMp4ESTagESDecoderConfigDescrTag = 0x04,
    SrsMp4ESTagESDecSpecificInfoTag = 0x05,
    SrsMp4ESTagESSLConfigDescrTag = 0x06,
    SrsMp4ESTagESExtSLConfigDescrTag = 0x064,
};

/**
 * 7.2.2.2 BaseDescriptor
 * ISO_IEC_14496-1-System-2010.pdf, page 32
 */
class SrsMp4BaseDescriptor : public ISrsCodec
{
public:
    // The values of the class tags are
    // defined in Table 2. As an expandable class the size of each class instance in bytes is encoded and accessible
    // through the instance variable sizeOfInstance (see 8.3.3).
    SrsMp4ESTagEs tag; // bit(8)
    // The decoded or encoded variant length.
    int32_t vlen; // bit(28)
private:
    // The position at buffer to start demux the box.
    int start_pos;
public:
    SrsMp4BaseDescriptor();
    virtual ~SrsMp4BaseDescriptor();
public:
    // Get the left space of box, for decoder.
    virtual int left_space(SrsBuffer* buf);
// Interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
protected:
    virtual int32_t nb_payload() = 0;
    virtual srs_error_t encode_payload(SrsBuffer* buf) = 0;
    virtual srs_error_t decode_payload(SrsBuffer* buf) = 0;
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

// Table 5 — objectTypeIndication Values
// ISO_IEC_14496-1-System-2010.pdf, page 49
enum SrsMp4ObjectType
{
    SrsMp4ObjectTypeForbidden = 0x00,
    // Audio ISO/IEC 14496-3
    SrsMp4ObjectTypeAac = 0x40,
};

// Table 6 — streamType Values
// ISO_IEC_14496-1-System-2010.pdf, page 51
enum SrsMp4StreamType
{
    SrsMp4StreamTypeForbidden = 0x00,
    SrsMp4StreamTypeAudioStream = 0x05,
};

/**
 * 7.2.6.7 DecoderSpecificInfo
 * ISO_IEC_14496-1-System-2010.pdf, page 51
 */
class SrsMp4DecoderSpecificInfo : public SrsMp4BaseDescriptor
{
public:
    // AAC Audio Specific Config.
    // 1.6.2.1 AudioSpecificConfig, in ISO_IEC_14496-3-AAC-2001.pdf, page 33.
    std::vector<char> asc;
public:
    SrsMp4DecoderSpecificInfo();
    virtual ~SrsMp4DecoderSpecificInfo();
protected:
    virtual int32_t nb_payload();
    virtual srs_error_t encode_payload(SrsBuffer* buf);
    virtual srs_error_t decode_payload(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 7.2.6.6 DecoderConfigDescriptor
 * ISO_IEC_14496-1-System-2010.pdf, page 48
 */
class SrsMp4DecoderConfigDescriptor : public SrsMp4BaseDescriptor
{
public:
    // an indication of the object or scene description type that needs to be supported
    // by the decoder for this elementary stream as per Table 5.
    SrsMp4ObjectType objectTypeIndication; // bit(8)
    SrsMp4StreamType streamType; // bit(6)
    uint8_t upStream; // bit(1)
    uint8_t reserved; // bit(1)
    uint32_t bufferSizeDB; // bit(24)
    uint32_t maxBitrate;
    uint32_t avgBitrate;
    SrsMp4DecoderSpecificInfo* decSpecificInfo; // optional.
public:
    SrsMp4DecoderConfigDescriptor();
    virtual ~SrsMp4DecoderConfigDescriptor();
protected:
    virtual int32_t nb_payload();
    virtual srs_error_t encode_payload(SrsBuffer* buf);
    virtual srs_error_t decode_payload(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 7.3.2.3 SL Packet Header Configuration
 * ISO_IEC_14496-1-System-2010.pdf, page 92
 */
class SrsMp4SLConfigDescriptor : public SrsMp4BaseDescriptor
{
public:
    uint8_t predefined;
public:
    SrsMp4SLConfigDescriptor();
    virtual ~SrsMp4SLConfigDescriptor();
protected:
    virtual int32_t nb_payload();
    virtual srs_error_t encode_payload(SrsBuffer* buf);
    virtual srs_error_t decode_payload(SrsBuffer* buf);
};

/**
 * 7.2.6.5 ES_Descriptor
 * ISO_IEC_14496-1-System-2010.pdf, page 47
 */
class SrsMp4ES_Descriptor : public SrsMp4BaseDescriptor
{
public:
    uint16_t ES_ID;
    uint8_t streamDependenceFlag; // bit(1)
    uint8_t URL_Flag; // bit(1)
    uint8_t OCRstreamFlag; // bit(1)
    uint8_t streamPriority; // bit(5)
    // if (streamDependenceFlag)
    uint16_t dependsOn_ES_ID;
    // if (URL_Flag)
    std::vector<char> URLstring;
    // if (OCRstreamFlag)
    uint16_t OCR_ES_Id;
    SrsMp4DecoderConfigDescriptor decConfigDescr;
    SrsMp4SLConfigDescriptor slConfigDescr;
public:
    SrsMp4ES_Descriptor();
    virtual ~SrsMp4ES_Descriptor();
protected:
    virtual int32_t nb_payload();
    virtual srs_error_t encode_payload(SrsBuffer* buf);
    virtual srs_error_t decode_payload(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 5.6 Sample Description Boxes
 * Elementary Stream Descriptors (esds)
 * ISO_IEC_14496-14-MP4-2003.pdf, page 15
 * @see http://www.mp4ra.org/codecs.html
 */
class SrsMp4EsdsBox : public SrsMp4FullBox
{
public:
    SrsMp4ES_Descriptor* es;
public:
    SrsMp4EsdsBox();
    virtual ~SrsMp4EsdsBox();
public:
    // For AAC codec, get the asc.
    virtual SrsMp4DecoderSpecificInfo* asc();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.5.2 Sample Description Box (stsd), for Audio/Video.
 * ISO_IEC_14496-12-base-format-2012.pdf, page 40
 * The sample description table gives detailed information about the coding type used, and any initialization
 * information needed for that coding.
 */
class SrsMp4SampleDescriptionBox : public SrsMp4FullBox
{
private:
    std::vector<SrsMp4SampleEntry*> entries;
public:
    SrsMp4SampleDescriptionBox();
    virtual ~SrsMp4SampleDescriptionBox();
public:
    // For H.264/AVC, get the avc1 box.
    virtual SrsMp4VisualSampleEntry* avc1();
    // For AAC, get the mp4a box.
    virtual SrsMp4AudioSampleEntry* mp4a();
public:
    virtual uint32_t entry_count();
    virtual SrsMp4SampleEntry* entrie_at(int index);
    virtual SrsMp4SampleDescriptionBox* append(SrsMp4SampleEntry* v);
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
    virtual bool boxes_in_header();
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.6.1.2 Decoding Time to Sample Box (stts), for Audio/Video.
 * ISO_IEC_14496-12-base-format-2012.pdf, page 48
 */
struct SrsMp4SttsEntry
{
    // an integer that counts the number of consecutive samples that have the given
    // duration.
    uint32_t sample_count;
    // an integer that gives the delta of these samples in the time-scale of the media.
    uint32_t sample_delta;
    // Constructor
    SrsMp4SttsEntry();
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.6.1.2 Decoding Time to Sample Box (stts), for Audio/Video.
 * ISO_IEC_14496-12-base-format-2012.pdf, page 48
 * This box contains a compact version of a table that allows indexing from decoding time to sample number.
 * Other tables give sample sizes and pointers, from the sample number. Each entry in the table gives the
 * number of consecutive samples with the same time delta, and the delta of those samples. By adding the
 * deltas a complete time-to-sample map may be built.
 */
class SrsMp4DecodingTime2SampleBox : public SrsMp4FullBox
{
public:
    // an integer that gives the number of entries in the following table.
    std::vector<SrsMp4SttsEntry> entries;
private:
    // The index for counter to calc the dts for samples.
    uint32_t index;
    uint32_t count;
public:
    SrsMp4DecodingTime2SampleBox();
    virtual ~SrsMp4DecodingTime2SampleBox();
public:
    // Initialize the counter.
    virtual srs_error_t initialize_counter();
    // When got an sample, index starts from 0.
    virtual srs_error_t on_sample(uint32_t sample_index, SrsMp4SttsEntry** ppentry);
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.6.1.3 Composition Time to Sample Box (ctts), for Video.
 * ISO_IEC_14496-12-base-format-2012.pdf, page 49
 */
struct SrsMp4CttsEntry
{
    // an integer that counts the number of consecutive samples that have the given offset.
    uint32_t sample_count;
    // uint32_t for version=0
    // int32_t for version=1
    // an integer that gives the offset between CT and DT, such that CT(n) = DT(n) +
    // CTTS(n).
    int64_t sample_offset;
    // Constructor
    SrsMp4CttsEntry();
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.6.1.3 Composition Time to Sample Box (ctts), for Video.
 * ISO_IEC_14496-12-base-format-2012.pdf, page 49
 * This box provides the offset between decoding time and composition time. In version 0 of this box the
 * decoding time must be less than the composition time, and the offsets are expressed as unsigned numbers
 * such that CT(n) = DT(n) + CTTS(n) where CTTS(n) is the (uncompressed) table entry for sample n. In version
 * 1 of this box, the composition timeline and the decoding timeline are still derived from each other, but the
 * offsets are signed. It is recommended that for the computed composition timestamps, there is exactly one with
 * the value 0 (zero).
 */
class SrsMp4CompositionTime2SampleBox : public SrsMp4FullBox
{
public:
    // an integer that gives the number of entries in the following table.
    std::vector<SrsMp4CttsEntry> entries;
private:
    // The index for counter to calc the dts for samples.
    uint32_t index;
    uint32_t count;
public:
    SrsMp4CompositionTime2SampleBox();
    virtual ~SrsMp4CompositionTime2SampleBox();
public:
    // Initialize the counter.
    virtual srs_error_t initialize_counter();
    // When got an sample, index starts from 0.
    virtual srs_error_t on_sample(uint32_t sample_index, SrsMp4CttsEntry** ppentry);
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.6.2 Sync Sample Box (stss), for Video.
 * ISO_IEC_14496-12-base-format-2012.pdf, page 51
 * This box provides a compact marking of the sync samples within the stream. The table is arranged in strictly
 * increasing order of sample number.
 */
class SrsMp4SyncSampleBox : public SrsMp4FullBox
{
public:
    // an integer that gives the number of entries in the following table. If entry_count is zero,
    // there are no sync samples within the stream and the following table is empty.
    uint32_t entry_count;
    // the numbers of the samples that are sync samples in the stream.
    uint32_t* sample_numbers;
public:
    SrsMp4SyncSampleBox();
    virtual ~SrsMp4SyncSampleBox();
public:
    // Whether the sample is sync, index starts from 0.
    virtual bool is_sync(uint32_t sample_index);
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.7.4 Sample To Chunk Box (stsc), for Audio/Video.
 * ISO_IEC_14496-12-base-format-2012.pdf, page 58
 */
struct SrsMp4StscEntry
{
    // an integer that gives the index of the first chunk in this run of chunks that share the
    // same samples-per-chunk and sample-description-index; the index of the first chunk in a track has the
    // value 1 (the first_chunk field in the first record of this box has the value 1, identifying that the first
    // sample maps to the first chunk).
    uint32_t first_chunk;
    // an integer that gives the number of samples in each of these chunks
    uint32_t samples_per_chunk;
    // an integer that gives the index of the sample entry that describes the
    // samples in this chunk. The index ranges from 1 to the number of sample entries in the Sample
    // Description Box
    uint32_t sample_description_index;
    // Constructor
    SrsMp4StscEntry();
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.7.4 Sample To Chunk Box (stsc), for Audio/Video.
 * ISO_IEC_14496-12-base-format-2012.pdf, page 58
 * Samples within the media data are grouped into chunks. Chunks can be of different sizes, and the samples
 * within a chunk can have different sizes. This table can be used to find the chunk that contains a sample,
 * its position, and the associated sample description.
 */
class SrsMp4Sample2ChunkBox : public SrsMp4FullBox
{
public:
    // an integer that gives the number of entries in the following table
    uint32_t entry_count;
    // the numbers of the samples that are sync samples in the stream.
    SrsMp4StscEntry* entries;
private:
    // The index for counter to calc the dts for samples.
    uint32_t index;
public:
    SrsMp4Sample2ChunkBox();
    virtual ~SrsMp4Sample2ChunkBox();
public:
    // Initialize the counter.
    virtual void initialize_counter();
    // When got an chunk, index starts from 0.
    virtual SrsMp4StscEntry* on_chunk(uint32_t chunk_index);
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.7.5 Chunk Offset Box (stco), for Audio/Video.
 * ISO_IEC_14496-12-base-format-2012.pdf, page 59
 * The chunk offset table gives the index of each chunk into the containing file. There are two variants, permitting
 * the use of 32-bit or 64-bit offsets. The latter is useful when managing very large presentations. At most one of
 * these variants will occur in any single instance of a sample table.
 */
class SrsMp4ChunkOffsetBox : public SrsMp4FullBox
{
public:
    // an integer that gives the number of entries in the following table
    uint32_t entry_count;
    // a 32 bit integer that gives the offset of the start of a chunk into its containing
    // media file.
    uint32_t* entries;
public:
    SrsMp4ChunkOffsetBox();
    virtual ~SrsMp4ChunkOffsetBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.7.5 Chunk Large Offset Box (co64), for Audio/Video.
 * ISO_IEC_14496-12-base-format-2012.pdf, page 59
 * The chunk offset table gives the index of each chunk into the containing file. There are two variants, permitting
 * the use of 32-bit or 64-bit offsets. The latter is useful when managing very large presentations. At most one of
 * these variants will occur in any single instance of a sample table.
 */
class SrsMp4ChunkLargeOffsetBox : public SrsMp4FullBox
{
public:
    // an integer that gives the number of entries in the following table
    uint32_t entry_count;
    // a 64 bit integer that gives the offset of the start of a chunk into its containing
    // media file.
    uint64_t* entries;
public:
    SrsMp4ChunkLargeOffsetBox();
    virtual ~SrsMp4ChunkLargeOffsetBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.7.3.2 Sample Size Box (stsz), for Audio/Video.
 * ISO_IEC_14496-12-base-format-2012.pdf, page 58
 * This box contains the sample count and a table giving the size in bytes of each sample. This allows the media data
 * itself to be unframed. The total number of samples in the media is always indicated in the sample count.
 */
class SrsMp4SampleSizeBox : public SrsMp4FullBox
{
public:
    // the default sample size. If all the samples are the same size, this field
    // contains that size value. If this field is set to 0, then the samples have different sizes, and those sizes
    // are stored in the sample size table. If this field is not 0, it specifies the constant sample size, and no
    // array follows.
    uint32_t sample_size;
    // an integer that gives the number of samples in the track; if sample-size is 0, then it is
    // also the number of entries in the following table.
    uint32_t sample_count;
    // each entry_size is an integer specifying the size of a sample, indexed by its number.
    uint32_t* entry_sizes;
public:
    SrsMp4SampleSizeBox();
    virtual ~SrsMp4SampleSizeBox();
public:
    // Get the size of sample.
    virtual srs_error_t get_sample_size(uint32_t sample_index, uint32_t* psample_size);
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * 8.10.1 User Data Box (udta)
 * ISO_IEC_14496-12-base-format-2012.pdf, page 78
 * This box contains objects that declare user information about the containing box and its data (presentation or
 * track).
 */
class SrsMp4UserDataBox : public SrsMp4Box
{
public:
    std::vector<char> data;
public:
    SrsMp4UserDataBox();
    virtual ~SrsMp4UserDataBox();
protected:
    virtual int nb_header();
    virtual srs_error_t encode_header(SrsBuffer* buf);
    virtual srs_error_t decode_header(SrsBuffer* buf);
public:
    virtual std::stringstream& dumps_detail(std::stringstream& ss, SrsMp4DumpContext dc);
};

/**
 * Generally, a MP4 sample contains a frame, for example, a video frame or audio frame.
 */
class SrsMp4Sample
{
public:
    // The type of sample, audio or video.
    SrsFrameType type;
    // The offset of sample in file.
    off_t offset;
    // The index of sample with a track, start from 0.
    uint32_t index;
    // The dts in tbn.
    uint64_t dts;
    // For video, the pts in tbn.
    uint64_t pts;
    // The tbn(timebase).
    uint32_t tbn;
    // For video, the frame type, whether keyframe.
    SrsVideoAvcFrameType frame_type;
    // The adjust timestamp in milliseconds.
    // For example, we can adjust a timestamp for A/V to monotonically increase.
    int32_t adjust;
    // The sample data.
    uint32_t nb_data;
    uint8_t* data;
public:
    SrsMp4Sample();
    virtual ~SrsMp4Sample();
public:
    // Get the adjusted dts in ms.
    virtual uint32_t dts_ms();
    // Get the adjusted pts in ms.
    virtual uint32_t pts_ms();
};

/**
 * Build samples from moov, or write samples to moov.
 * One or more sample are grouped to a chunk, each track contains one or more chunks.
 *      The offset of chunk is specified by stco.
 *      The chunk-sample series is speicified by stsc.
 *      The sample size is specified by stsz.
 *      The dts is specified by stts.
 * For video:
 *      The cts/pts is specified by ctts.
 *      The keyframe is specified by stss.
 */
class SrsMp4SampleManager
{
public:
    std::vector<SrsMp4Sample*> samples;
public:
    SrsMp4SampleManager();
    virtual ~SrsMp4SampleManager();
public:
    // Load the samples from moov. There must be atleast one track.
    virtual srs_error_t load(SrsMp4MovieBox* moov);
    // Get the sample at index position.
    // @remark NULL if exceed the max index.
    virtual SrsMp4Sample* at(uint32_t index);
    // Append the sample to the tail of manager.
    virtual void append(SrsMp4Sample* sample);
    // Write the samples info to moov.
    virtual srs_error_t write(SrsMp4MovieBox* moov);
    // Write the samples info to moof.
    // @param The dts is the dts of last segment.
    virtual srs_error_t write(SrsMp4MovieFragmentBox* moof, uint64_t& dts);
private:
    virtual srs_error_t write_track(SrsFrameType track,
        SrsMp4DecodingTime2SampleBox* stts, SrsMp4SyncSampleBox* stss, SrsMp4CompositionTime2SampleBox* ctts,
        SrsMp4Sample2ChunkBox* stsc, SrsMp4SampleSizeBox* stsz, SrsMp4ChunkOffsetBox* stco);
    virtual srs_error_t do_load(std::map<uint64_t, SrsMp4Sample*>& tses, SrsMp4MovieBox* moov);
private:
    // Load the samples of track from stco, stsz and stsc.
    // @param tses The temporary samples, key is offset, value is sample.
    // @param tt The type of sample, convert to flv tag type.
    // TODO: Support co64 for stco.
    virtual srs_error_t load_trak(std::map<uint64_t, SrsMp4Sample*>& tses, SrsFrameType tt,
        SrsMp4MediaHeaderBox* mdhd, SrsMp4ChunkOffsetBox* stco, SrsMp4SampleSizeBox* stsz, SrsMp4Sample2ChunkBox* stsc,
        SrsMp4DecodingTime2SampleBox* stts, SrsMp4CompositionTime2SampleBox* ctts, SrsMp4SyncSampleBox* stss);
};

/**
 * The MP4 box reader, to get the RAW boxes without decode.
 * @remark For mdat box, we only decode the header, then skip the data.
 */
class SrsMp4BoxReader
{
private:
    ISrsReadSeeker* rsio;
    // The temporary buffer to read from buffer.
    char* buf;
public:
    SrsMp4BoxReader();
    virtual ~SrsMp4BoxReader();
public:
    virtual srs_error_t initialize(ISrsReadSeeker* rs);
public:
    // Read a MP4 box to pbox, the stream is fill with the bytes of box to decode.
    virtual srs_error_t read(SrsSimpleStream* stream, SrsMp4Box** ppbox);
    // Skip the box from stream, and skip in file if need.
    virtual srs_error_t skip(SrsMp4Box* box, SrsSimpleStream* stream);
};

/**
 * The MP4 demuxer.
 */
class SrsMp4Decoder
{
private:
    // The major brand of decoder, parse from ftyp.
    SrsMp4BoxBrand brand;
    // The samples build from moov.
    SrsMp4SampleManager* samples;
    // The current written sample information.
    uint32_t current_index;
    off_t current_offset;
public:
    // The video codec of first track, generally there is zero or one track.
    // Forbidden if no video stream.
    // TODO: FIXME: Use SrsFormat instead.
    SrsVideoCodecId vcodec;
private:
    // For H.264/AVC, the avcc contains the sps/pps.
    std::vector<char> pavcc;
    // Whether avcc is written to reader.
    bool avcc_written;
public:
    // The audio codec of first track, generally there is zero or one track.
    // Forbidden if no audio stream.
    SrsAudioCodecId acodec;
    // The audio sample rate.
    SrsAudioSampleRate sample_rate;
    // The audio sound bits.
    SrsAudioSampleBits sound_bits;
    // The audio sound type.
    SrsAudioChannels channels;
private:
    // For AAC, the asc in esds box.
    std::vector<char> pasc;
    // Whether asc is written to reader.
    bool asc_written;
private:
    // Underlayer reader and seeker.
    // @remark The demuxer must use seeker for general MP4 to seek the moov.
    ISrsReadSeeker* rsio;
    // The MP4 box reader.
    SrsMp4BoxReader* br;
    // The stream used to demux the boxes.
    // TODO: FIXME: refine for performance issue.
    SrsSimpleStream* stream;
public:
    SrsMp4Decoder();
    virtual ~SrsMp4Decoder();
public:
    /**
     * Initialize the decoder with a reader r.
     * @param r The underlayer io reader, user must manage it.
     */
    virtual srs_error_t initialize(ISrsReadSeeker* rs);
    /**
     * Read a sample from mp4.
     * @param pht The sample hanler type, audio/soun or video/vide.
     * @param pft, The frame type. For video, it's SrsVideoAvcFrameType. For audio, ignored.
     * @param pct, The codec type. For video, it's SrsVideoAvcFrameTrait. For audio, it's SrsAudioAacFrameTrait.
     * @param pdts The output dts in milliseconds.
     * @param ppts The output pts in milliseconds.
     * @param pnb_sample The output size of payload.
     * @param psample The output payload, user must free it.
     * @remark The decoder will generate the first two audio/video sequence header.
     */
    virtual srs_error_t read_sample(SrsMp4HandlerType* pht, uint16_t* pft, uint16_t* pct,
        uint32_t* pdts, uint32_t* ppts, uint8_t** psample, uint32_t* pnb_sample);
private:
    virtual srs_error_t parse_ftyp(SrsMp4FileTypeBox* ftyp);
    virtual srs_error_t parse_moov(SrsMp4MovieBox* moov);
private:
    // Load the next box from reader.
    // @param required_box_type The box type required, 0 for any box.
    virtual srs_error_t load_next_box(SrsMp4Box** ppbox, uint32_t required_box_type);
    // @remark Never load the mdat box content, for it's too large.
    virtual srs_error_t do_load_next_box(SrsMp4Box** ppbox, uint32_t required_box_type);
};

/**
 * The MP4 muxer.
 */
class SrsMp4Encoder
{
private:
    ISrsWriteSeeker* wsio;
    // The mdat offset at file, we must update the header when flush.
    off_t mdat_offset;
    // The mdat size in bytes, we must update it to the mdat box header.
    uint64_t mdat_bytes;
    // The samples build from moov.
    SrsMp4SampleManager* samples;
public:
    // The audio codec of first track, generally there is zero or one track.
    // Forbidden if no audio stream.
    SrsAudioCodecId acodec;
    // The audio sample rate.
    SrsAudioSampleRate sample_rate;
    // The audio sound bits.
    SrsAudioSampleBits sound_bits;
    // The audio sound type.
    SrsAudioChannels channels;
private:
    // For AAC, the asc in esds box.
    std::vector<char> pasc;
    // The number of audio samples.
    uint32_t nb_audios;
    // The duration of audio stream.
    uint64_t aduration;
public:
    // The video codec of first track, generally there is zero or one track.
    // Forbidden if no video stream.
    SrsVideoCodecId vcodec;
private:
    // For H.264/AVC, the avcc contains the sps/pps.
    std::vector<char> pavcc;
    // The number of video samples.
    uint32_t nb_videos;
    // The duration of video stream.
    uint64_t vduration;
    // The size width/height of video.
    uint32_t width;
    uint32_t height;
public:
    SrsMp4Encoder();
    virtual ~SrsMp4Encoder();
public:
    // Initialize the encoder with a writer and seeker ws.
    // @param ws The underlayer io writer and seeker, user must manage it.
    virtual srs_error_t initialize(ISrsWriteSeeker* ws);
    // Write a sample to mp4.
    // @param ht, The sample handler type, audio/soun or video/vide.
    // @param ft, The frame type. For video, it's SrsVideoAvcFrameType.
    // @param ct, The codec type. For video, it's SrsVideoAvcFrameTrait. For audio, it's SrsAudioAacFrameTrait.
    // @param dts The output dts in milliseconds.
    // @param pts The output pts in milliseconds.
    // @param sample The output payload, user must free it.
    // @param nb_sample The output size of payload.
    virtual srs_error_t write_sample(SrsMp4HandlerType ht, uint16_t ft, uint16_t ct,
        uint32_t dts, uint32_t pts, uint8_t* sample, uint32_t nb_sample);
    // Flush the encoder, to write the moov.
    virtual srs_error_t flush();
private:
    virtual srs_error_t copy_sequence_header(bool vsh, uint8_t* sample, uint32_t nb_sample);
    virtual srs_error_t do_write_sample(SrsMp4Sample* ps, uint8_t* sample, uint32_t nb_sample);
};

/**
 * A fMP4 encoder, to write the init.mp4 with sequence header.
 */
class SrsMp4M2tsInitEncoder
{
private:
    ISrsWriter* writer;
public:
    SrsMp4M2tsInitEncoder();
    virtual ~SrsMp4M2tsInitEncoder();
public:
    // Initialize the encoder with a writer w.
    virtual srs_error_t initialize(ISrsWriter* w);
    // Write the sequence header.
    virtual srs_error_t write(SrsFormat* format, bool video, int tid);
};

/**
 * A fMP4 encoder, to cache segments then flush to disk, because the fMP4 should write
 * trun box before mdat.
 */
class SrsMp4M2tsSegmentEncoder
{
private:
    ISrsWriter* writer;
    SrsBuffer* buffer;
    uint32_t sequence_number;
    uint64_t decode_basetime;
    uint32_t track_id;
private:
    uint32_t nb_audios;
    uint32_t nb_videos;
    uint64_t mdat_bytes;
    SrsMp4SampleManager* samples;
private:
    uint64_t data_offset;
public:
    SrsMp4M2tsSegmentEncoder();
    virtual ~SrsMp4M2tsSegmentEncoder();
public:
    // Initialize the encoder with a writer w.
    virtual srs_error_t initialize(ISrsWriter* w, uint32_t sequence, uint64_t basetime, uint32_t tid);
    // Cache a sample.
    // @param ht, The sample handler type, audio/soun or video/vide.
    // @param ft, The frame type. For video, it's SrsVideoAvcFrameType.
    // @param dts The output dts in milliseconds.
    // @param pts The output pts in milliseconds.
    // @param sample The output payload, user must free it.
    // @param nb_sample The output size of payload.
    // @remark All samples are RAW AAC/AVC data, because sequence header is writen to init.mp4.
    virtual srs_error_t write_sample(SrsMp4HandlerType ht, uint16_t ft,
        uint32_t dts, uint32_t pts, uint8_t* sample, uint32_t nb_sample);
    // Flush the encoder, to write the moof and mdat.
    virtual srs_error_t flush(uint64_t& dts);
};

#endif

// following is generated by src/kernel/srs_kernel_file.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_KERNEL_FILE_HPP
#define SRS_KERNEL_FILE_HPP

//#include <srs_core.hpp>

//#include <srs_kernel_io.hpp>

#include <string>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <sys/uio.h>
#endif

/**
 * file writer, to write to file.
 */
class SrsFileWriter : public ISrsWriteSeeker
{
private:
    std::string path;
    int fd;
public:
    SrsFileWriter();
    virtual ~SrsFileWriter();
public:
    /**
     * open file writer, in truncate mode.
     * @param p a string indicates the path of file to open.
     */
    virtual srs_error_t open(std::string p);
    /**
     * open file writer, in append mode.
     * @param p a string indicates the path of file to open.
     */
    virtual srs_error_t open_append(std::string p);
    /**
     * close current writer.
     * @remark user can reopen again.
     */
    virtual void close();
public:
    virtual bool is_open();
    virtual void seek2(int64_t offset);
    virtual int64_t tellg();
// Interface ISrsWriteSeeker
public:
    virtual srs_error_t write(void* buf, size_t count, ssize_t* pnwrite);
    virtual srs_error_t writev(const iovec* iov, int iovcnt, ssize_t* pnwrite);
    virtual srs_error_t lseek(off_t offset, int whence, off_t* seeked);
};

/**
 * file reader, to read from file.
 */
class SrsFileReader : public ISrsReadSeeker
{
private:
    std::string path;
    int fd;
public:
    SrsFileReader();
    virtual ~SrsFileReader();
public:
    /**
     * open file reader.
     * @param p a string indicates the path of file to open.
     */
    virtual srs_error_t open(std::string p);
    /**
     * close current reader.
     * @remark user can reopen again.
     */
    virtual void close();
public:
    // TODO: FIXME: extract interface.
    virtual bool is_open();
    virtual int64_t tellg();
    virtual void skip(int64_t size);
    virtual int64_t seek2(int64_t offset);
    virtual int64_t filesize();
// Interface ISrsReadSeeker
public:
    virtual srs_error_t read(void* buf, size_t count, ssize_t* pnread);
    virtual srs_error_t lseek(off_t offset, int whence, off_t* seeked);
};

#endif

// following is generated by src/protocol/srs_protocol_amf0.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_PROTOCOL_AMF0_HPP
#define SRS_PROTOCOL_AMF0_HPP

//#include <srs_core.hpp>

#include <string>
#include <vector>

class SrsBuffer;
class SrsAmf0Object;
class SrsAmf0EcmaArray;
class SrsAmf0StrictArray;
class SrsJsonAny;

// internal objects, user should never use it.
namespace _srs_internal
{
    class SrsUnSortedHashtable;
    class SrsAmf0ObjectEOF;
    class SrsAmf0Date;
}

/*
 ////////////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////////////
 Usages:
 
 1. the bytes proxy: SrsBuffer
 // when we got some bytes from file or network,
 // use SrsBuffer proxy to read/write bytes
 
 // for example, read bytes from file or network.
 char* bytes = ...;
 
 // initialize the stream, proxy for bytes.
 SrsBuffer stream;
 stream.initialize(bytes);
 
 // use stream instead.
 
 2. directly read AMF0 any instance from stream:
 SrsAmf0Any* pany = NULL;
 srs_amf0_read_any(&stream, &pany);
 
 3. use SrsAmf0Any to discovery instance from stream:
 SrsAmf0Any* pany = NULL;
 SrsAmf0Any::discovery(&stream, &pany);
 
 4. directly read specified AMF0 instance value from stream:
 string value;
 srs_amf0_read_string(&stream, value);
 
 5. directly read specified AMF0 instance from stream:
 SrsAmf0Any* str = SrsAmf0Any::str();
 str->read(&stream);
 
 6. get value from AMF0 instance:
 // parse or set by other user
 SrsAmf0Any* any = ...;
 
 if (any->is_string()) {
 string str = any->to_string();
 }
 
 7. get complex object from AMF0 insance:
 // parse or set by other user
 SrsAmf0Any* any = ...;
 
 if (any->is_object()) {
 SrsAmf0Object* obj = any->to_object();
 obj->set("width", SrsAmf0Any::number(1024));
 obj->set("height", SrsAmf0Any::number(576));
 }
 
 8. serialize AMF0 instance to bytes:
 // parse or set by other user
 SrsAmf0Any* any = ...;
 
 char* bytes = new char[any->total_size()];
 
 SrsBuffer stream;
 stream.initialize(bytes);
 
 any->write(&stream);
 
 @remark: for detail usage, see interfaces of each object.
 @remark: all examples ignore the error process.
 ////////////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////////////
 ////////////////////////////////////////////////////////////////////////
 */

/**
 * any amf0 value.
 * 2.1 Types Overview
 * value-type = number-type | boolean-type | string-type | object-type
 *         | null-marker | undefined-marker | reference-type | ecma-array-type
 *         | strict-array-type | date-type | long-string-type | xml-document-type
 *         | typed-object-type
 */
class SrsAmf0Any
{
public:
    char marker;
public:
    SrsAmf0Any();
    virtual ~SrsAmf0Any();
    // type identify, user should identify the type then convert from/to value.
public:
    /**
     * whether current instance is an AMF0 string.
     * @return true if instance is an AMF0 string; otherwise, false.
     * @remark, if true, use to_string() to get its value.
     */
    virtual bool is_string();
    /**
     * whether current instance is an AMF0 boolean.
     * @return true if instance is an AMF0 boolean; otherwise, false.
     * @remark, if true, use to_boolean() to get its value.
     */
    virtual bool is_boolean();
    /**
     * whether current instance is an AMF0 number.
     * @return true if instance is an AMF0 number; otherwise, false.
     * @remark, if true, use to_number() to get its value.
     */
    virtual bool is_number();
    /**
     * whether current instance is an AMF0 null.
     * @return true if instance is an AMF0 null; otherwise, false.
     */
    virtual bool is_null();
    /**
     * whether current instance is an AMF0 undefined.
     * @return true if instance is an AMF0 undefined; otherwise, false.
     */
    virtual bool is_undefined();
    /**
     * whether current instance is an AMF0 object.
     * @return true if instance is an AMF0 object; otherwise, false.
     * @remark, if true, use to_object() to get its value.
     */
    virtual bool is_object();
    /**
     * whether current instance is an AMF0 object-EOF.
     * @return true if instance is an AMF0 object-EOF; otherwise, false.
     */
    virtual bool is_object_eof();
    /**
     * whether current instance is an AMF0 ecma-array.
     * @return true if instance is an AMF0 ecma-array; otherwise, false.
     * @remark, if true, use to_ecma_array() to get its value.
     */
    virtual bool is_ecma_array();
    /**
     * whether current instance is an AMF0 strict-array.
     * @return true if instance is an AMF0 strict-array; otherwise, false.
     * @remark, if true, use to_strict_array() to get its value.
     */
    virtual bool is_strict_array();
    /**
     * whether current instance is an AMF0 date.
     * @return true if instance is an AMF0 date; otherwise, false.
     * @remark, if true, use to_date() to get its value.
     */
    virtual bool is_date();
    /**
     * whether current instance is an AMF0 object, object-EOF, ecma-array or strict-array.
     */
    virtual bool is_complex_object();
    // get value of instance
public:
    /**
     * get a string copy of instance.
     * @remark assert is_string(), user must ensure the type then convert.
     */
    virtual std::string to_str();
    /**
     * get the raw str of instance,
     * user can directly set the content of str.
     * @remark assert is_string(), user must ensure the type then convert.
     */
    virtual const char* to_str_raw();
    /**
     * convert instance to amf0 boolean,
     * @remark assert is_boolean(), user must ensure the type then convert.
     */
    virtual bool to_boolean();
    /**
     * convert instance to amf0 number,
     * @remark assert is_number(), user must ensure the type then convert.
     */
    virtual double to_number();
    /**
     * convert instance to date,
     * @remark assert is_date(), user must ensure the type then convert.
     */
    virtual int64_t to_date();
    virtual int16_t to_date_time_zone();
    /**
     * convert instance to amf0 object,
     * @remark assert is_object(), user must ensure the type then convert.
     */
    virtual SrsAmf0Object* to_object();
    /**
     * convert instance to ecma array,
     * @remark assert is_ecma_array(), user must ensure the type then convert.
     */
    virtual SrsAmf0EcmaArray* to_ecma_array();
    /**
     * convert instance to strict array,
     * @remark assert is_strict_array(), user must ensure the type then convert.
     */
    virtual SrsAmf0StrictArray* to_strict_array();
    // set value of instance
public:
    /**
     * set the number of any when is_number() indicates true.
     * user must ensure the type is a number, or assert failed.
     */
    virtual void set_number(double value);
    // serialize/deseriaize instance.
public:
    /**
     * get the size of amf0 any, including the marker size.
     * the size is the bytes which instance serialized to.
     */
    virtual int total_size() = 0;
    /**
     * read AMF0 instance from stream.
     */
    virtual srs_error_t read(SrsBuffer* stream) = 0;
    /**
     * write AMF0 instance to stream.
     */
    virtual srs_error_t write(SrsBuffer* stream) = 0;
    /**
     * copy current AMF0 instance.
     */
    virtual SrsAmf0Any* copy() = 0;
    /**
     * human readable print
     * @param pdata, output the heap data, NULL to ignore.
     * @return return the *pdata for print. NULL to ignore.
     * @remark user must free the data returned or output by pdata.
     */
    virtual char* human_print(char** pdata, int* psize);
    /**
     * convert amf0 to json.
     */
    virtual SrsJsonAny* to_json();
    // create AMF0 instance.
public:
    /**
     * create an AMF0 string instance, set string content by value.
     */
    static SrsAmf0Any* str(const char* value = NULL);
    /**
     * create an AMF0 boolean instance, set boolean content by value.
     */
    static SrsAmf0Any* boolean(bool value = false);
    /**
     * create an AMF0 number instance, set number content by value.
     */
    static SrsAmf0Any* number(double value = 0.0);
    /**
     * create an AMF0 date instance
     */
    static SrsAmf0Any* date(int64_t value = 0);
    /**
     * create an AMF0 null instance
     */
    static SrsAmf0Any* null();
    /**
     * create an AMF0 undefined instance
     */
    static SrsAmf0Any* undefined();
    /**
     * create an AMF0 empty object instance
     */
    static SrsAmf0Object* object();
    /**
     * create an AMF0 object-EOF instance
     */
    static SrsAmf0Any* object_eof();
    /**
     * create an AMF0 empty ecma-array instance
     */
    static SrsAmf0EcmaArray* ecma_array();
    /**
     * create an AMF0 empty strict-array instance
     */
    static SrsAmf0StrictArray* strict_array();
    // discovery instance from stream
public:
    /**
     * discovery AMF0 instance from stream
     * @param ppvalue, output the discoveried AMF0 instance.
     *       NULL if error.
     * @remark, instance is created without read from stream, user must
     *       use (*ppvalue)->read(stream) to get the instance.
     */
    static srs_error_t discovery(SrsBuffer* stream, SrsAmf0Any** ppvalue);
};

/**
 * 2.5 Object Type
 * anonymous-object-type = object-marker *(object-property)
 * object-property = (UTF-8 value-type) | (UTF-8-empty object-end-marker)
 */
class SrsAmf0Object : public SrsAmf0Any
{
private:
    _srs_internal::SrsUnSortedHashtable* properties;
    _srs_internal::SrsAmf0ObjectEOF* eof;
private:
    friend class SrsAmf0Any;
    /**
     * make amf0 object to private,
     * use should never declare it, use SrsAmf0Any::object() to create it.
     */
    SrsAmf0Object();
public:
    virtual ~SrsAmf0Object();
    // serialize/deserialize to/from stream.
public:
    virtual int total_size();
    virtual srs_error_t read(SrsBuffer* stream);
    virtual srs_error_t write(SrsBuffer* stream);
    virtual SrsAmf0Any* copy();
    /**
     * convert amf0 to json.
     */
    virtual SrsJsonAny* to_json();
    // properties iteration
public:
    /**
     * clear all propergies.
     */
    virtual void clear();
    /**
     * get the count of properties(key:value).
     */
    virtual int count();
    /**
     * get the property(key:value) key at index.
     * @remark: max index is count().
     */
    virtual std::string key_at(int index);
    /**
     * get the property(key:value) key raw bytes at index.
     * user can directly set the key bytes.
     * @remark: max index is count().
     */
    virtual const char* key_raw_at(int index);
    /**
     * get the property(key:value) value at index.
     * @remark: max index is count().
     */
    virtual SrsAmf0Any* value_at(int index);
    // property set/get.
public:
    /**
     * set the property(key:value) of object,
     * @param key, string property name.
     * @param value, an AMF0 instance property value.
     * @remark user should never free the value, this instance will manage it.
     */
    virtual void set(std::string key, SrsAmf0Any* value);
    /**
     * get the property(key:value) of object,
     * @param name, the property name/key
     * @return the property AMF0 value, NULL if not found.
     * @remark user should never free the returned value, copy it if needed.
     */
    virtual SrsAmf0Any* get_property(std::string name);
    /**
     * get the string property, ensure the property is_string().
     * @return the property AMF0 value, NULL if not found, or not a string.
     * @remark user should never free the returned value, copy it if needed.
     */
    virtual SrsAmf0Any* ensure_property_string(std::string name);
    /**
     * get the number property, ensure the property is_number().
     * @return the property AMF0 value, NULL if not found, or not a number.
     * @remark user should never free the returned value, copy it if needed.
     */
    virtual SrsAmf0Any* ensure_property_number(std::string name);
    /**
     * remove the property specified by name.
     */
    virtual void remove(std::string name);
};

/**
 * 2.10 ECMA Array Type
 * ecma-array-type = associative-count *(object-property)
 * associative-count = U32
 * object-property = (UTF-8 value-type) | (UTF-8-empty object-end-marker)
 */
class SrsAmf0EcmaArray : public SrsAmf0Any
{
private:
    _srs_internal::SrsUnSortedHashtable* properties;
    _srs_internal::SrsAmf0ObjectEOF* eof;
    int32_t _count;
private:
    friend class SrsAmf0Any;
    /**
     * make amf0 object to private,
     * use should never declare it, use SrsAmf0Any::ecma_array() to create it.
     */
    SrsAmf0EcmaArray();
public:
    virtual ~SrsAmf0EcmaArray();
    // serialize/deserialize to/from stream.
public:
    virtual int total_size();
    virtual srs_error_t read(SrsBuffer* stream);
    virtual srs_error_t write(SrsBuffer* stream);
    virtual SrsAmf0Any* copy();
    /**
     * convert amf0 to json.
     */
    virtual SrsJsonAny* to_json();
    // properties iteration
public:
    /**
     * clear all propergies.
     */
    virtual void clear();
    /**
     * get the count of properties(key:value).
     */
    virtual int count();
    /**
     * get the property(key:value) key at index.
     * @remark: max index is count().
     */
    virtual std::string key_at(int index);
    /**
     * get the property(key:value) key raw bytes at index.
     * user can directly set the key bytes.
     * @remark: max index is count().
     */
    virtual const char* key_raw_at(int index);
    /**
     * get the property(key:value) value at index.
     * @remark: max index is count().
     */
    virtual SrsAmf0Any* value_at(int index);
    // property set/get.
public:
    /**
     * set the property(key:value) of array,
     * @param key, string property name.
     * @param value, an AMF0 instance property value.
     * @remark user should never free the value, this instance will manage it.
     */
    virtual void set(std::string key, SrsAmf0Any* value);
    /**
     * get the property(key:value) of array,
     * @param name, the property name/key
     * @return the property AMF0 value, NULL if not found.
     * @remark user should never free the returned value, copy it if needed.
     */
    virtual SrsAmf0Any* get_property(std::string name);
    /**
     * get the string property, ensure the property is_string().
     * @return the property AMF0 value, NULL if not found, or not a string.
     * @remark user should never free the returned value, copy it if needed.
     */
    virtual SrsAmf0Any* ensure_property_string(std::string name);
    /**
     * get the number property, ensure the property is_number().
     * @return the property AMF0 value, NULL if not found, or not a number.
     * @remark user should never free the returned value, copy it if needed.
     */
    virtual SrsAmf0Any* ensure_property_number(std::string name);
};

/**
 * 2.12 Strict Array Type
 * array-count = U32
 * strict-array-type = array-count *(value-type)
 */
class SrsAmf0StrictArray : public SrsAmf0Any
{
private:
    std::vector<SrsAmf0Any*> properties;
    int32_t _count;
private:
    friend class SrsAmf0Any;
    /**
     * make amf0 object to private,
     * use should never declare it, use SrsAmf0Any::strict_array() to create it.
     */
    SrsAmf0StrictArray();
public:
    virtual ~SrsAmf0StrictArray();
    // serialize/deserialize to/from stream.
public:
    virtual int total_size();
    virtual srs_error_t read(SrsBuffer* stream);
    virtual srs_error_t write(SrsBuffer* stream);
    virtual SrsAmf0Any* copy();
    /**
     * convert amf0 to json.
     */
    virtual SrsJsonAny* to_json();
    // properties iteration
public:
    /**
     * clear all elements.
     */
    virtual void clear();
    /**
     * get the count of elements
     */
    virtual int count();
    /**
     * get the elements key at index.
     * @remark: max index is count().
     */
    virtual SrsAmf0Any* at(int index);
    // property set/get.
public:
    /**
     * append new element to array
     * @param any, an AMF0 instance property value.
     * @remark user should never free the any, this instance will manage it.
     */
    virtual void append(SrsAmf0Any* any);
};

/**
 * the class to get amf0 object size
 */
class SrsAmf0Size
{
public:
    static int utf8(std::string value);
    static int str(std::string value);
    static int number();
    static int date();
    static int null();
    static int undefined();
    static int boolean();
    static int object(SrsAmf0Object* obj);
    static int object_eof();
    static int ecma_array(SrsAmf0EcmaArray* arr);
    static int strict_array(SrsAmf0StrictArray* arr);
    static int any(SrsAmf0Any* o);
};

/**
 * read anything from stream.
 * @param ppvalue, the output amf0 any elem.
 *         NULL if error; otherwise, never NULL and user must free it.
 */
extern srs_error_t srs_amf0_read_any(SrsBuffer* stream, SrsAmf0Any** ppvalue);

/**
 * read amf0 string from stream.
 * 2.4 String Type
 * string-type = string-marker UTF-8
 */
extern srs_error_t srs_amf0_read_string(SrsBuffer* stream, std::string& value);
extern srs_error_t srs_amf0_write_string(SrsBuffer* stream, std::string value);

/**
 * read amf0 boolean from stream.
 * 2.4 String Type
 * boolean-type = boolean-marker U8
 *         0 is false, <> 0 is true
 */
extern srs_error_t srs_amf0_read_boolean(SrsBuffer* stream, bool& value);
extern srs_error_t srs_amf0_write_boolean(SrsBuffer* stream, bool value);

/**
 * read amf0 number from stream.
 * 2.2 Number Type
 * number-type = number-marker DOUBLE
 */
extern srs_error_t srs_amf0_read_number(SrsBuffer* stream, double& value);
extern srs_error_t srs_amf0_write_number(SrsBuffer* stream, double value);

/**
 * read amf0 null from stream.
 * 2.7 null Type
 * null-type = null-marker
 */
extern srs_error_t srs_amf0_read_null(SrsBuffer* stream);
extern srs_error_t srs_amf0_write_null(SrsBuffer* stream);

/**
 * read amf0 undefined from stream.
 * 2.8 undefined Type
 * undefined-type = undefined-marker
 */
extern srs_error_t srs_amf0_read_undefined(SrsBuffer* stream);
extern srs_error_t srs_amf0_write_undefined(SrsBuffer* stream);

// internal objects, user should never use it.
namespace _srs_internal
{
    /**
     * read amf0 string from stream.
     * 2.4 String Type
     * string-type = string-marker UTF-8
     * @return default value is empty string.
     * @remark: use SrsAmf0Any::str() to create it.
     */
    class SrsAmf0String : public SrsAmf0Any
    {
    public:
        std::string value;
    private:
        friend class SrsAmf0Any;
        /**
         * make amf0 string to private,
         * use should never declare it, use SrsAmf0Any::str() to create it.
         */
        SrsAmf0String(const char* _value);
    public:
        virtual ~SrsAmf0String();
    public:
        virtual int total_size();
        virtual srs_error_t read(SrsBuffer* stream);
        virtual srs_error_t write(SrsBuffer* stream);
        virtual SrsAmf0Any* copy();
    };
    
    /**
     * read amf0 boolean from stream.
     * 2.4 String Type
     * boolean-type = boolean-marker U8
     *         0 is false, <> 0 is true
     * @return default value is false.
     */
    class SrsAmf0Boolean : public SrsAmf0Any
    {
    public:
        bool value;
    private:
        friend class SrsAmf0Any;
        /**
         * make amf0 boolean to private,
         * use should never declare it, use SrsAmf0Any::boolean() to create it.
         */
        SrsAmf0Boolean(bool _value);
    public:
        virtual ~SrsAmf0Boolean();
    public:
        virtual int total_size();
        virtual srs_error_t read(SrsBuffer* stream);
        virtual srs_error_t write(SrsBuffer* stream);
        virtual SrsAmf0Any* copy();
    };
    
    /**
     * read amf0 number from stream.
     * 2.2 Number Type
     * number-type = number-marker DOUBLE
     * @return default value is 0.
     */
    class SrsAmf0Number : public SrsAmf0Any
    {
    public:
        double value;
    private:
        friend class SrsAmf0Any;
        /**
         * make amf0 number to private,
         * use should never declare it, use SrsAmf0Any::number() to create it.
         */
        SrsAmf0Number(double _value);
    public:
        virtual ~SrsAmf0Number();
    public:
        virtual int total_size();
        virtual srs_error_t read(SrsBuffer* stream);
        virtual srs_error_t write(SrsBuffer* stream);
        virtual SrsAmf0Any* copy();
    };
    
    /**
     * 2.13 Date Type
     * time-zone = S16 ; reserved, not supported should be set to 0x0000
     * date-type = date-marker DOUBLE time-zone
     * @see: https://github.com/ossrs/srs/issues/185
     */
    class SrsAmf0Date : public SrsAmf0Any
    {
    private:
        int64_t _date_value;
        int16_t _time_zone;
    private:
        friend class SrsAmf0Any;
        /**
         * make amf0 date to private,
         * use should never declare it, use SrsAmf0Any::date() to create it.
         */
        SrsAmf0Date(int64_t value);
    public:
        virtual ~SrsAmf0Date();
        // serialize/deserialize to/from stream.
    public:
        virtual int total_size();
        virtual srs_error_t read(SrsBuffer* stream);
        virtual srs_error_t write(SrsBuffer* stream);
        virtual SrsAmf0Any* copy();
    public:
        /**
         * get the date value.
         */
        virtual int64_t date();
        /**
         * get the time_zone.
         */
        virtual int16_t time_zone();
    };
    
    /**
     * read amf0 null from stream.
     * 2.7 null Type
     * null-type = null-marker
     */
    class SrsAmf0Null : public SrsAmf0Any
    {
    private:
        friend class SrsAmf0Any;
        /**
         * make amf0 null to private,
         * use should never declare it, use SrsAmf0Any::null() to create it.
         */
        SrsAmf0Null();
    public:
        virtual ~SrsAmf0Null();
    public:
        virtual int total_size();
        virtual srs_error_t read(SrsBuffer* stream);
        virtual srs_error_t write(SrsBuffer* stream);
        virtual SrsAmf0Any* copy();
    };
    
    /**
     * read amf0 undefined from stream.
     * 2.8 undefined Type
     * undefined-type = undefined-marker
     */
    class SrsAmf0Undefined : public SrsAmf0Any
    {
    private:
        friend class SrsAmf0Any;
        /**
         * make amf0 undefined to private,
         * use should never declare it, use SrsAmf0Any::undefined() to create it.
         */
        SrsAmf0Undefined();
    public:
        virtual ~SrsAmf0Undefined();
    public:
        virtual int total_size();
        virtual srs_error_t read(SrsBuffer* stream);
        virtual srs_error_t write(SrsBuffer* stream);
        virtual SrsAmf0Any* copy();
    };
    
    /**
     * to ensure in inserted order.
     * for the FMLE will crash when AMF0Object is not ordered by inserted,
     * if ordered in map, the string compare order, the FMLE will creash when
     * get the response of connect app.
     */
    class SrsUnSortedHashtable
    {
    private:
        typedef std::pair<std::string, SrsAmf0Any*> SrsAmf0ObjectPropertyType;
        std::vector<SrsAmf0ObjectPropertyType> properties;
    public:
        SrsUnSortedHashtable();
        virtual ~SrsUnSortedHashtable();
    public:
        virtual int count();
        virtual void clear();
        virtual std::string key_at(int index);
        virtual const char* key_raw_at(int index);
        virtual SrsAmf0Any* value_at(int index);
        /**
         * set the value of hashtable.
         * @param value, the value to set. NULL to delete the property.
         */
        virtual void set(std::string key, SrsAmf0Any* value);
    public:
        virtual SrsAmf0Any* get_property(std::string name);
        virtual SrsAmf0Any* ensure_property_string(std::string name);
        virtual SrsAmf0Any* ensure_property_number(std::string name);
        virtual void remove(std::string name);
    public:
        virtual void copy(SrsUnSortedHashtable* src);
    };
    
    /**
     * 2.11 Object End Type
     * object-end-type = UTF-8-empty object-end-marker
     * 0x00 0x00 0x09
     */
    class SrsAmf0ObjectEOF : public SrsAmf0Any
    {
    public:
        SrsAmf0ObjectEOF();
        virtual ~SrsAmf0ObjectEOF();
    public:
        virtual int total_size();
        virtual srs_error_t read(SrsBuffer* stream);
        virtual srs_error_t write(SrsBuffer* stream);
        virtual SrsAmf0Any* copy();
    };
    
    /**
     * read amf0 utf8 string from stream.
     * 1.3.1 Strings and UTF-8
     * UTF-8 = U16 *(UTF8-char)
     * UTF8-char = UTF8-1 | UTF8-2 | UTF8-3 | UTF8-4
     * UTF8-1 = %x00-7F
     * @remark only support UTF8-1 char.
     */
    extern srs_error_t srs_amf0_read_utf8(SrsBuffer* stream, std::string& value);
    extern srs_error_t srs_amf0_write_utf8(SrsBuffer* stream, std::string value);
    
    extern bool srs_amf0_is_object_eof(SrsBuffer* stream);
    extern srs_error_t srs_amf0_write_object_eof(SrsBuffer* stream, SrsAmf0ObjectEOF* value);
    
    extern srs_error_t srs_amf0_write_any(SrsBuffer* stream, SrsAmf0Any* value);
};

#endif
// following is generated by src/protocol/srs_protocol_io.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_PROTOCOL_IO_HPP
#define SRS_PROTOCOL_IO_HPP

//#include <srs_core.hpp>

//#include <srs_kernel_io.hpp>

/**
 * the system io reader/writer architecture:
 *                                         +---------------+  +---------------+
 *                                         | IStreamWriter |  | IVectorWriter |
 *                                         +---------------+  +---------------+
 *                                         | + write()     |  | + writev()    |
 *                                         +-------------+-+  ++--------------+
 * +----------+     +--------------------+               /\   /\
 * | IReader  |     |    IStatistic      |                 \ /
 * +----------+     +--------------------+                  V
 * | + read() |     | + get_recv_bytes() |           +------+----+
 * +------+---+     | + get_send_bytes() |           |  IWriter  |
 *       / \        +---+--------------+-+           +-------+---+
 *        |            / \            / \                   / \
 *        |             |              |                     |
 * +------+-------------+------+      ++---------------------+--+
 * | IProtocolReader           |      | IProtocolWriter         |
 * +---------------------------+      +-------------------------+
 * | + readfully()             |      | + set_send_timeout()    |
 * | + set_recv_timeout()      |      +-------+-----------------+
 * +------------+--------------+             / \
 *             / \                            |
 *              |                             |
 *           +--+-----------------------------+-+
 *           |       IProtocolReaderWriter      |
 *           +----------------------------------+
 *           | + is_never_timeout()             |
 *           +----------------------------------+
 */

/**
 * get the statistic of channel.
 */
class ISrsProtocolStatistic
{
public:
    ISrsProtocolStatistic();
    virtual ~ISrsProtocolStatistic();
    // for protocol
public:
    /**
     * get the total recv bytes over underlay fd.
     */
    virtual int64_t get_recv_bytes() = 0;
    /**
     * get the total send bytes over underlay fd.
     */
    virtual int64_t get_send_bytes() = 0;
};

/**
 * the reader for the protocol to read from whatever channel.
 */
class ISrsProtocolReader : public virtual ISrsReader, public virtual ISrsProtocolStatistic
{
public:
    ISrsProtocolReader();
    virtual ~ISrsProtocolReader();
    // for protocol
public:
    /**
     * Set the timeout tm in ms for recv bytes from peer.
     * @remark Use SRS_CONSTS_NO_TMMS to never timeout.
     */
    virtual void set_recv_timeout(int64_t tm) = 0;
    /**
     * Get the timeout in ms for recv bytes from peer.
     */
    virtual int64_t get_recv_timeout() = 0;
    // for handshake.
public:
    /**
     * read specified size bytes of data
     * @param nread, the actually read size, NULL to ignore.
     */
    virtual srs_error_t read_fully(void* buf, size_t size, ssize_t* nread) = 0;
};

/**
 * the writer for the protocol to write to whatever channel.
 */
class ISrsProtocolWriter : public virtual ISrsWriter, public virtual ISrsProtocolStatistic
{
public:
    ISrsProtocolWriter();
    virtual ~ISrsProtocolWriter();
    // for protocol
public:
    /**
     * Set the timeout tm in ms for send bytes to peer.
     * @remark Use SRS_CONSTS_NO_TMMS to never timeout.
     */
    virtual void set_send_timeout(int64_t tm) = 0;
    /**
     * Get the timeout in ms for send bytes to peer.
     */
    virtual int64_t get_send_timeout() = 0;
};

/**
 * the reader and writer.
 */
class ISrsProtocolReaderWriter : public virtual ISrsProtocolReader, public virtual ISrsProtocolWriter
{
public:
    ISrsProtocolReaderWriter();
    virtual ~ISrsProtocolReaderWriter();
    // for protocol
public:
    /**
     * Whether the specified tm in ms is never timeout.
     */
    virtual bool is_never_timeout(int64_t tm) = 0;
};

#endif

// following is generated by src/protocol/srs_rtmp_stack.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_PROTOCOL_RTMP_HPP
#define SRS_PROTOCOL_RTMP_HPP

//#include <srs_core.hpp>

#include <map>
#include <vector>
#include <string>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <sys/uio.h>
#endif

//#include <srs_kernel_log.hpp>
//#include <srs_kernel_error.hpp>
//#include <srs_kernel_consts.hpp>
//#include <srs_core_performance.hpp>
//#include <srs_kernel_flv.hpp>

class ISrsProtocolReaderWriter;
class SrsFastStream;
class SrsPacket;
class SrsBuffer;
class SrsAmf0Object;
class SrsAmf0Any;
class SrsMessageHeader;
class SrsCommonMessage;
class SrsChunkStream;
class SrsSharedPtrMessage;
class IMergeReadHandler;

class SrsProtocol;
class ISrsProtocolReaderWriter;
class SrsCommonMessage;
class SrsCreateStreamPacket;
class SrsFMLEStartPacket;
class SrsPublishPacket;
class SrsOnMetaDataPacket;
class SrsPlayPacket;
class SrsCommonMessage;
class SrsPacket;
class SrsAmf0Object;
class IMergeReadHandler;
class SrsCallPacket;

/****************************************************************************
 *****************************************************************************
 ****************************************************************************/
/**
 * amf0 command message, command name macros
 */
#define RTMP_AMF0_COMMAND_CONNECT               "connect"
#define RTMP_AMF0_COMMAND_CREATE_STREAM         "createStream"
#define RTMP_AMF0_COMMAND_CLOSE_STREAM          "closeStream"
#define RTMP_AMF0_COMMAND_PLAY                  "play"
#define RTMP_AMF0_COMMAND_PAUSE                 "pause"
#define RTMP_AMF0_COMMAND_ON_BW_DONE            "onBWDone"
#define RTMP_AMF0_COMMAND_ON_STATUS             "onStatus"
#define RTMP_AMF0_COMMAND_RESULT                "_result"
#define RTMP_AMF0_COMMAND_ERROR                 "_error"
#define RTMP_AMF0_COMMAND_RELEASE_STREAM        "releaseStream"
#define RTMP_AMF0_COMMAND_FC_PUBLISH            "FCPublish"
#define RTMP_AMF0_COMMAND_UNPUBLISH             "FCUnpublish"
#define RTMP_AMF0_COMMAND_PUBLISH               "publish"
#define RTMP_AMF0_DATA_SAMPLE_ACCESS            "|RtmpSampleAccess"

/**
 * the signature for packets to client.
 */
#define RTMP_SIG_FMS_VER                        "3,5,3,888"
#define RTMP_SIG_AMF0_VER                       0
#define RTMP_SIG_CLIENT_ID                      "ASAICiss"

/**
 * onStatus consts.
 */
#define StatusLevel                             "level"
#define StatusCode                              "code"
#define StatusDescription                       "description"
#define StatusDetails                           "details"
#define StatusClientId                          "clientid"
// status value
#define StatusLevelStatus                       "status"
// status error
#define StatusLevelError                        "error"
// code value
#define StatusCodeConnectSuccess                "NetConnection.Connect.Success"
#define StatusCodeConnectRejected               "NetConnection.Connect.Rejected"
#define StatusCodeStreamReset                   "NetStream.Play.Reset"
#define StatusCodeStreamStart                   "NetStream.Play.Start"
#define StatusCodeStreamPause                   "NetStream.Pause.Notify"
#define StatusCodeStreamUnpause                 "NetStream.Unpause.Notify"
#define StatusCodePublishStart                  "NetStream.Publish.Start"
#define StatusCodeDataStart                     "NetStream.Data.Start"
#define StatusCodeUnpublishSuccess              "NetStream.Unpublish.Success"

/****************************************************************************
 *****************************************************************************
 ****************************************************************************/

/**
 * the decoded message payload.
 * @remark we seperate the packet from message,
 *        for the packet focus on logic and domain data,
 *        the message bind to the protocol and focus on protocol, such as header.
 *         we can merge the message and packet, using OOAD hierachy, packet extends from message,
 *         it's better for me to use components -- the message use the packet as payload.
 */
class SrsPacket
{
public:
    SrsPacket();
    virtual ~SrsPacket();
public:
    /**
     * the subpacket can override this encode,
     * for example, video and audio will directly set the payload withou memory copy,
     * other packet which need to serialize/encode to bytes by override the
     * get_size and encode_packet.
     */
    virtual srs_error_t encode(int& size, char*& payload);
// decode functions for concrete packet to override.
public:
    /**
     * subpacket must override to decode packet from stream.
     * @remark never invoke the super.decode, it always failed.
     */
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    /**
     * the cid(chunk id) specifies the chunk to send data over.
     * generally, each message perfer some cid, for example,
     * all protocol control messages perfer RTMP_CID_ProtocolControl,
     * SrsSetWindowAckSizePacket is protocol control message.
     */
    virtual int get_prefer_cid();
    /**
     * subpacket must override to provide the right message type.
     * the message type set the RTMP message type in header.
     */
    virtual int get_message_type();
protected:
    /**
     * subpacket can override to calc the packet size.
     */
    virtual int get_size();
    /**
     * subpacket can override to encode the payload to stream.
     * @remark never invoke the super.encode_packet, it always failed.
     */
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

/**
 * the protocol provides the rtmp-message-protocol services,
 * to recv RTMP message from RTMP chunk stream,
 * and to send out RTMP message over RTMP chunk stream.
 */
class SrsProtocol
{
private:
    class AckWindowSize
    {
    public:
        uint32_t window;
        // number of received bytes.
        int64_t nb_recv_bytes;
        // previous responsed sequence number.
        uint32_t sequence_number;
        
        AckWindowSize();
    };
    // peer in/out
private:
    /**
     * underlayer socket object, send/recv bytes.
     */
    ISrsProtocolReaderWriter* skt;
    /**
     * requests sent out, used to build the response.
     * key: transactionId
     * value: the request command name
     */
    std::map<double, std::string> requests;
// peer in
private:
    /**
     * chunk stream to decode RTMP messages.
     */
    std::map<int, SrsChunkStream*> chunk_streams;
    /**
     * cache some frequently used chunk header.
     * cs_cache, the chunk stream cache.
     * @see https://github.com/ossrs/srs/issues/249
     */
    SrsChunkStream** cs_cache;
    /**
     * bytes buffer cache, recv from skt, provide services for stream.
     */
    SrsFastStream* in_buffer;
    /**
     * input chunk size, default to 128, set by peer packet.
     */
    int32_t in_chunk_size;
    // The input ack window, to response acknowledge to peer,
    // for example, to respose the encoder, for server got lots of packets.
    AckWindowSize in_ack_size;
    // The output ack window, to require peer to response the ack.
    AckWindowSize out_ack_size;
    // The buffer length set by peer.
    int32_t in_buffer_length;
    // Whether print the protocol level debug info.
    // Generally we print the debug info when got or send first A/V packet.
    bool show_debug_info;
    /**
     * whether auto response when recv messages.
     * default to true for it's very easy to use the protocol stack.
     * @see: https://github.com/ossrs/srs/issues/217
     */
    bool auto_response_when_recv;
    /**
     * when not auto response message, manual flush the messages in queue.
     */
    std::vector<SrsPacket*> manual_response_queue;
// peer out
private:
    /**
     * cache for multiple messages send,
     * initialize to iovec[SRS_CONSTS_IOVS_MAX] and realloc when consumed,
     * it's ok to realloc the iovs cache, for all ptr is ok.
     */
    iovec* out_iovs;
    int nb_out_iovs;
    /**
     * output header cache.
     * used for type0, 11bytes(or 15bytes with extended timestamp) header.
     * or for type3, 1bytes(or 5bytes with extended timestamp) header.
     * the c0c3 caches must use unit SRS_CONSTS_RTMP_MAX_FMT0_HEADER_SIZE bytes.
     *
     * @remark, the c0c3 cache cannot be realloc.
     */
    char out_c0c3_caches[SRS_CONSTS_C0C3_HEADERS_MAX];
    // whether warned user to increase the c0c3 header cache.
    bool warned_c0c3_cache_dry;
    /**
     * output chunk size, default to 128, set by config.
     */
    int32_t out_chunk_size;
public:
    SrsProtocol(ISrsProtocolReaderWriter* io);
    virtual ~SrsProtocol();
public:
    /**
     * set the auto response message when recv for protocol stack.
     * @param v, whether auto response message when recv message.
     * @see: https://github.com/ossrs/srs/issues/217
     */
    virtual void set_auto_response(bool v);
    /**
     * flush for manual response when the auto response is disabled
     * by set_auto_response(false), we default use auto response, so donot
     * need to call this api(the protocol sdk will auto send message).
     * @see the auto_response_when_recv and manual_response_queue.
     */
    virtual srs_error_t manual_response_flush();
public:
#ifdef SRS_PERF_MERGED_READ
    /**
     * to improve read performance, merge some packets then read,
     * when it on and read small bytes, we sleep to wait more data.,
     * that is, we merge some data to read together.
     * @param v true to ename merged read.
     * @param handler the handler when merge read is enabled.
     * @see https://github.com/ossrs/srs/issues/241
     */
    virtual void set_merge_read(bool v, IMergeReadHandler* handler);
    /**
     * create buffer with specifeid size.
     * @param buffer the size of buffer.
     * @remark when MR(SRS_PERF_MERGED_READ) disabled, always set to 8K.
     * @remark when buffer changed, the previous ptr maybe invalid.
     * @see https://github.com/ossrs/srs/issues/241
     */
    virtual void set_recv_buffer(int buffer_size);
#endif
public:
    /**
     * set/get the recv timeout in ms.
     * if timeout, recv/send message return ERROR_SOCKET_TIMEOUT.
     */
    virtual void set_recv_timeout(int64_t tm);
    virtual int64_t get_recv_timeout();
    /**
     * set/get the send timeout in ms.
     * if timeout, recv/send message return ERROR_SOCKET_TIMEOUT.
     */
    virtual void set_send_timeout(int64_t tm);
    virtual int64_t get_send_timeout();
    /**
     * get recv/send bytes.
     */
    virtual int64_t get_recv_bytes();
    virtual int64_t get_send_bytes();
public:
    // Set the input default ack size. This is generally set by the message from peer,
    // but for some encoder, it never send the ack message while it default to a none zone size.
    // This will cause the encoder to block after publishing some messages to server,
    // because it wait for server to send acknowledge, but server default to 0 which means no need
    // to ack encoder. We can change the default input ack size. We will always response the
    // ack size whatever the encoder set or not.
    virtual srs_error_t set_in_window_ack_size(int ack_size);
public:
    /**
     * recv a RTMP message, which is bytes oriented.
     * user can use decode_message to get the decoded RTMP packet.
     * @param pmsg, set the received message,
     *       always NULL if error,
     *       NULL for unknown packet but return success.
     *       never NULL if decode success.
     * @remark, drop message when msg is empty or payload length is empty.
     */
    virtual srs_error_t recv_message(SrsCommonMessage** pmsg);
    /**
     * decode bytes oriented RTMP message to RTMP packet,
     * @param ppacket, output decoded packet,
     *       always NULL if error, never NULL if success.
     * @return error when unknown packet, error when decode failed.
     */
    virtual srs_error_t decode_message(SrsCommonMessage* msg, SrsPacket** ppacket);
    /**
     * send the RTMP message and always free it.
     * user must never free or use the msg after this method,
     * for it will always free the msg.
     * @param msg, the msg to send out, never be NULL.
     * @param stream_id, the stream id of packet to send over, 0 for control message.
     */
    virtual srs_error_t send_and_free_message(SrsSharedPtrMessage* msg, int stream_id);
    /**
     * send the RTMP message and always free it.
     * user must never free or use the msg after this method,
     * for it will always free the msg.
     * @param msgs, the msgs to send out, never be NULL.
     * @param nb_msgs, the size of msgs to send out.
     * @param stream_id, the stream id of packet to send over, 0 for control message.
     */
    virtual srs_error_t send_and_free_messages(SrsSharedPtrMessage** msgs, int nb_msgs, int stream_id);
    /**
     * send the RTMP packet and always free it.
     * user must never free or use the packet after this method,
     * for it will always free the packet.
     * @param packet, the packet to send out, never be NULL.
     * @param stream_id, the stream id of packet to send over, 0 for control message.
     */
    virtual srs_error_t send_and_free_packet(SrsPacket* packet, int stream_id);
public:
    /**
     * expect a specified message, drop others util got specified one.
     * @pmsg, user must free it. NULL if not success.
     * @ppacket, user must free it, which decode from payload of message. NULL if not success.
     * @remark, only when success, user can use and must free the pmsg and ppacket.
     * for example:
     *          SrsCommonMessage* msg = NULL;
     *          SrsConnectAppResPacket* pkt = NULL;
     *          if ((ret = protocol->expect_message<SrsConnectAppResPacket>(protocol, &msg, &pkt)) != ERROR_SUCCESS) {
     *              return ret;
     *          }
     *          // use then free msg and pkt
     *          srs_freep(msg);
     *          srs_freep(pkt);
     * user should never recv message and convert it, use this method instead.
     * if need to set timeout, use set timeout of SrsProtocol.
     */
    template<class T>
    srs_error_t expect_message(SrsCommonMessage** pmsg, T** ppacket)
    {
        *pmsg = NULL;
        *ppacket = NULL;
        
        srs_error_t err = srs_success;
        
        while (true) {
            SrsCommonMessage* msg = NULL;
            if ((err = recv_message(&msg)) != srs_success) {
                return srs_error_wrap(err, "recv message");
            }
            
            SrsPacket* packet = NULL;
            if ((err = decode_message(msg, &packet)) != srs_success) {
                srs_freep(msg);
                srs_freep(packet);
                return srs_error_wrap(err, "decode message");
            }
            
            T* pkt = dynamic_cast<T*>(packet);
            if (!pkt) {
                srs_freep(msg);
                srs_freep(packet);
                continue;
            }
            
            *pmsg = msg;
            *ppacket = pkt;
            break;
        }
        
        return err;
    }
private:
    /**
     * send out the messages, donot free it,
     * the caller must free the param msgs.
     */
    virtual srs_error_t do_send_messages(SrsSharedPtrMessage** msgs, int nb_msgs);
    /**
     * send iovs. send multiple times if exceed limits.
     */
    virtual srs_error_t do_iovs_send(iovec* iovs, int size);
    /**
     * underlayer api for send and free packet.
     */
    virtual srs_error_t do_send_and_free_packet(SrsPacket* packet, int stream_id);
    /**
     * use simple algorithm to send the header and bytes.
     * @remark, for do_send_and_free_packet to send.
     */
    virtual srs_error_t do_simple_send(SrsMessageHeader* mh, char* payload, int size);
    /**
     * imp for decode_message
     */
    virtual srs_error_t do_decode_message(SrsMessageHeader& header, SrsBuffer* stream, SrsPacket** ppacket);
    /**
     * recv bytes oriented RTMP message from protocol stack.
     * return error if error occur and nerver set the pmsg,
     * return success and pmsg set to NULL if no entire message got,
     * return success and pmsg set to entire message if got one.
     */
    virtual srs_error_t recv_interlaced_message(SrsCommonMessage** pmsg);
    /**
     * read the chunk basic header(fmt, cid) from chunk stream.
     * user can discovery a SrsChunkStream by cid.
     */
    virtual srs_error_t read_basic_header(char& fmt, int& cid);
    /**
     * read the chunk message header(timestamp, payload_length, message_type, stream_id)
     * from chunk stream and save to SrsChunkStream.
     */
    virtual srs_error_t read_message_header(SrsChunkStream* chunk, char fmt);
    /**
     * read the chunk payload, remove the used bytes in buffer,
     * if got entire message, set the pmsg.
     */
    virtual srs_error_t read_message_payload(SrsChunkStream* chunk, SrsCommonMessage** pmsg);
    /**
     * when recv message, update the context.
     */
    virtual srs_error_t on_recv_message(SrsCommonMessage* msg);
    /**
     * when message sentout, update the context.
     */
    virtual srs_error_t on_send_packet(SrsMessageHeader* mh, SrsPacket* packet);
private:
    /**
     * auto response the ack message.
     */
    virtual srs_error_t response_acknowledgement_message();
    /**
     * auto response the ping message.
     */
    virtual srs_error_t response_ping_message(int32_t timestamp);
private:
    virtual void print_debug_info();
};

/**
 * incoming chunk stream maybe interlaced,
 * use the chunk stream to cache the input RTMP chunk streams.
 */
class SrsChunkStream
{
public:
    /**
     * represents the basic header fmt,
     * which used to identify the variant message header type.
     */
    char fmt;
    /**
     * represents the basic header cid,
     * which is the chunk stream id.
     */
    int cid;
    /**
     * cached message header
     */
    SrsMessageHeader header;
    /**
     * whether the chunk message header has extended timestamp.
     */
    bool extended_timestamp;
    /**
     * partially read message.
     */
    SrsCommonMessage* msg;
    /**
     * decoded msg count, to identify whether the chunk stream is fresh.
     */
    int64_t msg_count;
public:
    SrsChunkStream(int _cid);
    virtual ~SrsChunkStream();
};

/**
 * the original request from client.
 */
class SrsRequest
{
public:
    // client ip.
    std::string ip;
public:
    /**
     * tcUrl: rtmp://request_vhost:port/app/stream
     * support pass vhost in query string, such as:
     *    rtmp://ip:port/app?vhost=request_vhost/stream
     *    rtmp://ip:port/app...vhost...request_vhost/stream
     */
    std::string tcUrl;
    std::string pageUrl;
    std::string swfUrl;
    double objectEncoding;
    // data discovery from request.
public:
    // discovery from tcUrl and play/publish.
    std::string schema;
    // the vhost in tcUrl.
    std::string vhost;
    // the host in tcUrl.
    std::string host;
    // the port in tcUrl.
    int port;
    // the app in tcUrl, without param.
    std::string app;
    // the param in tcUrl(app).
    std::string param;
    // the stream in play/publish
    std::string stream;
    // for play live stream,
    // used to specified the stop when exceed the duration.
    // @see https://github.com/ossrs/srs/issues/45
    // in ms.
    double duration;
    // the token in the connect request,
    // used for edge traverse to origin authentication,
    // @see https://github.com/ossrs/srs/issues/104
    SrsAmf0Object* args;
public:
    SrsRequest();
    virtual ~SrsRequest();
public:
    /**
     * deep copy the request, for source to use it to support reload,
     * for when initialize the source, the request is valid,
     * when reload it, the request maybe invalid, so need to copy it.
     */
    virtual SrsRequest* copy();
    /**
     * update the auth info of request,
     * to keep the current request ptr is ok,
     * for many components use the ptr of request.
     */
    virtual void update_auth(SrsRequest* req);
    /**
     * get the stream identify, vhost/app/stream.
     */
    virtual std::string get_stream_url();
    /**
     * strip url, user must strip when update the url.
     */
    virtual void strip();
};

/**
 * the response to client.
 */
class SrsResponse
{
public:
    /**
     * the stream id to response client createStream.
     */
    int stream_id;
public:
    SrsResponse();
    virtual ~SrsResponse();
};

/**
 * the rtmp client type.
 */
enum SrsRtmpConnType
{
    SrsRtmpConnUnknown,
    SrsRtmpConnPlay,
    SrsRtmpConnFMLEPublish,
    SrsRtmpConnFlashPublish,
    SrsRtmpConnHaivisionPublish,
};
std::string srs_client_type_string(SrsRtmpConnType type);
bool srs_client_type_is_publish(SrsRtmpConnType type);

/**
 * store the handshake bytes,
 * for smart switch between complex and simple handshake.
 */
class SrsHandshakeBytes
{
public:
    // [1+1536]
    char* c0c1;
    // [1+1536+1536]
    char* s0s1s2;
    // [1536]
    char* c2;
public:
    SrsHandshakeBytes();
    virtual ~SrsHandshakeBytes();
public:
    virtual srs_error_t read_c0c1(ISrsProtocolReaderWriter* io);
    virtual srs_error_t read_s0s1s2(ISrsProtocolReaderWriter* io);
    virtual srs_error_t read_c2(ISrsProtocolReaderWriter* io);
    virtual srs_error_t create_c0c1();
    virtual srs_error_t create_s0s1s2(const char* c1 = NULL);
    virtual srs_error_t create_c2();
};

/**
 * The information return from RTMP server.
 */
struct SrsServerInfo
{
    std::string ip;
    std::string sig;
    int pid;
    int cid;
    int major;
    int minor;
    int revision;
    int build;
    
    SrsServerInfo();
};

/**
 * implements the client role protocol.
 */
class SrsRtmpClient
{
private:
    SrsHandshakeBytes* hs_bytes;
protected:
    SrsProtocol* protocol;
    ISrsProtocolReaderWriter* io;
public:
    SrsRtmpClient(ISrsProtocolReaderWriter* skt);
    virtual ~SrsRtmpClient();
// protocol methods proxy
public:
    virtual void set_recv_timeout(int64_t tm);
    virtual void set_send_timeout(int64_t tm);
    virtual int64_t get_recv_bytes();
    virtual int64_t get_send_bytes();
    virtual srs_error_t recv_message(SrsCommonMessage** pmsg);
    virtual srs_error_t decode_message(SrsCommonMessage* msg, SrsPacket** ppacket);
    virtual srs_error_t send_and_free_message(SrsSharedPtrMessage* msg, int stream_id);
    virtual srs_error_t send_and_free_messages(SrsSharedPtrMessage** msgs, int nb_msgs, int stream_id);
    virtual srs_error_t send_and_free_packet(SrsPacket* packet, int stream_id);
public:
    /**
     * handshake with server, try complex, then simple handshake.
     */
    virtual srs_error_t handshake();
    /**
     * only use simple handshake
     */
    virtual srs_error_t simple_handshake();
    /**
     * only use complex handshake
     */
    virtual srs_error_t complex_handshake();
    /**
     * Connect to RTMP tcUrl and app, get the server info.
     *
     * @param app, The app to connect at, for example, live.
     * @param tcUrl, The tcUrl to connect at, for example, rtmp://ossrs.net/live.
     * @param req, the optional req object, use the swfUrl/pageUrl if specified. NULL to ignore.
     * @param dsu, Whether debug SRS upnode. For edge, set to true to send its info to upnode.
     * @param si, The server information, retrieve from response of connect app request. NULL to ignore.
     */
    virtual srs_error_t connect_app(std::string app, std::string tcUrl, SrsRequest* r, bool dsu, SrsServerInfo* si);
    /**
     * create a stream, then play/publish data over this stream.
     */
    virtual srs_error_t create_stream(int& stream_id);
    /**
     * start play stream.
     */
    virtual srs_error_t play(std::string stream, int stream_id, int chunk_size);
    /**
     * start publish stream. use flash publish workflow:
     *       connect-app => create-stream => flash-publish
     */
    virtual srs_error_t publish(std::string stream, int stream_id, int chunk_size);
    /**
     * start publish stream. use FMLE publish workflow:
     *       connect-app => FMLE publish
     */
    virtual srs_error_t fmle_publish(std::string stream, int& stream_id);
public:
    /**
     * expect a specified message, drop others util got specified one.
     * @pmsg, user must free it. NULL if not success.
     * @ppacket, user must free it, which decode from payload of message. NULL if not success.
     * @remark, only when success, user can use and must free the pmsg and ppacket.
     * for example:
     *          SrsCommonMessage* msg = NULL;
     *          SrsConnectAppResPacket* pkt = NULL;
     *          if ((ret = client->expect_message<SrsConnectAppResPacket>(protocol, &msg, &pkt)) != ERROR_SUCCESS) {
     *              return ret;
     *          }
     *          // use then free msg and pkt
     *          srs_freep(msg);
     *          srs_freep(pkt);
     * user should never recv message and convert it, use this method instead.
     * if need to set timeout, use set timeout of SrsProtocol.
     */
    template<class T>
    srs_error_t expect_message(SrsCommonMessage** pmsg, T** ppacket)
    {
        return protocol->expect_message<T>(pmsg, ppacket);
    }
};

/**
 * the rtmp provices rtmp-command-protocol services,
 * a high level protocol, media stream oriented services,
 * such as connect to vhost/app, play stream, get audio/video data.
 */
class SrsRtmpServer
{
private:
    SrsHandshakeBytes* hs_bytes;
    SrsProtocol* protocol;
    ISrsProtocolReaderWriter* io;
public:
    SrsRtmpServer(ISrsProtocolReaderWriter* skt);
    virtual ~SrsRtmpServer();
// protocol methods proxy
public:
    /**
     * set the auto response message when recv for protocol stack.
     * @param v, whether auto response message when recv message.
     * @see: https://github.com/ossrs/srs/issues/217
     */
    virtual void set_auto_response(bool v);
#ifdef SRS_PERF_MERGED_READ
    /**
     * to improve read performance, merge some packets then read,
     * when it on and read small bytes, we sleep to wait more data.,
     * that is, we merge some data to read together.
     * @param v true to ename merged read.
     * @param handler the handler when merge read is enabled.
     * @see https://github.com/ossrs/srs/issues/241
     */
    virtual void set_merge_read(bool v, IMergeReadHandler* handler);
    /**
     * create buffer with specifeid size.
     * @param buffer the size of buffer.
     * @remark when MR(SRS_PERF_MERGED_READ) disabled, always set to 8K.
     * @remark when buffer changed, the previous ptr maybe invalid.
     * @see https://github.com/ossrs/srs/issues/241
     */
    virtual void set_recv_buffer(int buffer_size);
#endif
    /**
     * set/get the recv timeout in ms.
     * if timeout, recv/send message return ERROR_SOCKET_TIMEOUT.
     */
    virtual void set_recv_timeout(int64_t tm);
    virtual int64_t get_recv_timeout();
    /**
     * set/get the send timeout in ms.
     * if timeout, recv/send message return ERROR_SOCKET_TIMEOUT.
     */
    virtual void set_send_timeout(int64_t tm);
    virtual int64_t get_send_timeout();
    /**
     * get recv/send bytes.
     */
    virtual int64_t get_recv_bytes();
    virtual int64_t get_send_bytes();
    /**
     * recv a RTMP message, which is bytes oriented.
     * user can use decode_message to get the decoded RTMP packet.
     * @param pmsg, set the received message,
     *       always NULL if error,
     *       NULL for unknown packet but return success.
     *       never NULL if decode success.
     * @remark, drop message when msg is empty or payload length is empty.
     */
    virtual srs_error_t recv_message(SrsCommonMessage** pmsg);
    /**
     * decode bytes oriented RTMP message to RTMP packet,
     * @param ppacket, output decoded packet,
     *       always NULL if error, never NULL if success.
     * @return error when unknown packet, error when decode failed.
     */
    virtual srs_error_t decode_message(SrsCommonMessage* msg, SrsPacket** ppacket);
    /**
     * send the RTMP message and always free it.
     * user must never free or use the msg after this method,
     * for it will always free the msg.
     * @param msg, the msg to send out, never be NULL.
     * @param stream_id, the stream id of packet to send over, 0 for control message.
     */
    virtual srs_error_t send_and_free_message(SrsSharedPtrMessage* msg, int stream_id);
    /**
     * send the RTMP message and always free it.
     * user must never free or use the msg after this method,
     * for it will always free the msg.
     * @param msgs, the msgs to send out, never be NULL.
     * @param nb_msgs, the size of msgs to send out.
     * @param stream_id, the stream id of packet to send over, 0 for control message.
     *
     * @remark performance issue, to support 6k+ 250kbps client,
     *       @see https://github.com/ossrs/srs/issues/194
     */
    virtual srs_error_t send_and_free_messages(SrsSharedPtrMessage** msgs, int nb_msgs, int stream_id);
    /**
     * send the RTMP packet and always free it.
     * user must never free or use the packet after this method,
     * for it will always free the packet.
     * @param packet, the packet to send out, never be NULL.
     * @param stream_id, the stream id of packet to send over, 0 for control message.
     */
    virtual srs_error_t send_and_free_packet(SrsPacket* packet, int stream_id);
public:
    /**
     * handshake with client, try complex then simple.
     */
    virtual srs_error_t handshake();
    /**
     * do connect app with client, to discovery tcUrl.
     */
    virtual srs_error_t connect_app(SrsRequest* req);
    /**
     * set output ack size to client, client will send ack-size for each ack window
     */
    virtual srs_error_t set_window_ack_size(int ack_size);
    // Set the default input ack size value.
    virtual srs_error_t set_in_window_ack_size(int ack_size);
    /**
     * @type: The sender can mark this message hard (0), soft (1), or dynamic (2)
     * using the Limit type field.
     */
    virtual srs_error_t set_peer_bandwidth(int bandwidth, int type);
    /**
     * @param server_ip the ip of server.
     */
    virtual srs_error_t response_connect_app(SrsRequest* req, const char* server_ip = NULL);
    /**
     * redirect the connection to another rtmp server.
     * @param the hostname or ip of target.
     * @param whether the client accept the redirect.
     */
    virtual srs_error_t redirect(SrsRequest* r, std::string host, int port, bool& accepted);
    /**
     * reject the connect app request.
     */
    virtual void response_connect_reject(SrsRequest* req, const char* desc);
    /**
     * response client the onBWDone message.
     */
    virtual srs_error_t on_bw_done();
    /**
     * recv some message to identify the client.
     * @stream_id, client will createStream to play or publish by flash,
     *         the stream_id used to response the createStream request.
     * @type, output the client type.
     * @stream_name, output the client publish/play stream name. @see: SrsRequest.stream
     * @duration, output the play client duration. @see: SrsRequest.duration
     */
    virtual srs_error_t identify_client(int stream_id, SrsRtmpConnType& type, std::string& stream_name, double& duration);
    /**
     * set the chunk size when client type identified.
     */
    virtual srs_error_t set_chunk_size(int chunk_size);
    /**
     * when client type is play, response with packets:
     * StreamBegin,
     * onStatus(NetStream.Play.Reset), onStatus(NetStream.Play.Start).,
     * |RtmpSampleAccess(false, false),
     * onStatus(NetStream.Data.Start).
     */
    virtual srs_error_t start_play(int stream_id);
    /**
     * when client(type is play) send pause message,
     * if is_pause, response the following packets:
     *     onStatus(NetStream.Pause.Notify)
     *     StreamEOF
     * if not is_pause, response the following packets:
     *     onStatus(NetStream.Unpause.Notify)
     *     StreamBegin
     */
    virtual srs_error_t on_play_client_pause(int stream_id, bool is_pause);
    /**
     * when client type is publish, response with packets:
     * releaseStream response
     * FCPublish
     * FCPublish response
     * createStream response
     * onFCPublish(NetStream.Publish.Start)
     * onStatus(NetStream.Publish.Start)
     */
    virtual srs_error_t start_fmle_publish(int stream_id);
    /**
     * For encoder of Haivision, response the startup request.
     * @see https://github.com/ossrs/srs/issues/844
     */
    virtual srs_error_t start_haivision_publish(int stream_id);
    /**
     * process the FMLE unpublish event.
     * @unpublish_tid the unpublish request transaction id.
     */
    virtual srs_error_t fmle_unpublish(int stream_id, double unpublish_tid);
    /**
     * when client type is publish, response with packets:
     * onStatus(NetStream.Publish.Start)
     */
    virtual srs_error_t start_flash_publish(int stream_id);
public:
    /**
     * expect a specified message, drop others util got specified one.
     * @pmsg, user must free it. NULL if not success.
     * @ppacket, user must free it, which decode from payload of message. NULL if not success.
     * @remark, only when success, user can use and must free the pmsg and ppacket.
     * for example:
     *          SrsCommonMessage* msg = NULL;
     *          SrsConnectAppResPacket* pkt = NULL;
     *          if ((ret = server->expect_message<SrsConnectAppResPacket>(&msg, &pkt)) != ERROR_SUCCESS) {
     *              return ret;
     *          }
     *          // use then free msg and pkt
     *          srs_freep(msg);
     *          srs_freep(pkt);
     * user should never recv message and convert it, use this method instead.
     * if need to set timeout, use set timeout of SrsProtocol.
     */
    template<class T>
    srs_error_t expect_message(SrsCommonMessage** pmsg, T** ppacket)
    {
        return protocol->expect_message<T>(pmsg, ppacket);
    }
private:
    virtual srs_error_t identify_create_stream_client(SrsCreateStreamPacket* req, int stream_id, SrsRtmpConnType& type, std::string& stream_name, double& duration);
    virtual srs_error_t identify_fmle_publish_client(SrsFMLEStartPacket* req, SrsRtmpConnType& type, std::string& stream_name);
    virtual srs_error_t identify_haivision_publish_client(SrsFMLEStartPacket* req, SrsRtmpConnType& type, std::string& stream_name);
    virtual srs_error_t identify_flash_publish_client(SrsPublishPacket* req, SrsRtmpConnType& type, std::string& stream_name);
private:
    virtual srs_error_t identify_play_client(SrsPlayPacket* req, SrsRtmpConnType& type, std::string& stream_name, double& duration);
};

/**
 * 4.1.1. connect
 * The client sends the connect command to the server to request
 * connection to a server application instance.
 */
class SrsConnectAppPacket : public SrsPacket
{
public:
    /**
     * Name of the command. Set to "connect".
     */
    std::string command_name;
    /**
     * Always set to 1.
     */
    double transaction_id;
    /**
     * Command information object which has the name-value pairs.
     * @remark: alloc in packet constructor, user can directly use it,
     *       user should never alloc it again which will cause memory leak.
     * @remark, never be NULL.
     */
    SrsAmf0Object* command_object;
    /**
     * Any optional information
     * @remark, optional, init to and maybe NULL.
     */
    SrsAmf0Object* args;
public:
    SrsConnectAppPacket();
    virtual ~SrsConnectAppPacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};
/**
 * response for SrsConnectAppPacket.
 */
class SrsConnectAppResPacket : public SrsPacket
{
public:
    /**
     * _result or _error; indicates whether the response is result or error.
     */
    std::string command_name;
    /**
     * Transaction ID is 1 for call connect responses
     */
    double transaction_id;
    /**
     * Name-value pairs that describe the properties(fmsver etc.) of the connection.
     * @remark, never be NULL.
     */
    SrsAmf0Object* props;
    /**
     * Name-value pairs that describe the response from|the server. 'code',
     * 'level', 'description' are names of few among such information.
     * @remark, never be NULL.
     */
    SrsAmf0Object* info;
public:
    SrsConnectAppResPacket();
    virtual ~SrsConnectAppResPacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

/**
 * 4.1.2. Call
 * The call method of the NetConnection object runs remote procedure
 * calls (RPC) at the receiving end. The called RPC name is passed as a
 * parameter to the call command.
 */
class SrsCallPacket : public SrsPacket
{
public:
    /**
     * Name of the remote procedure that is called.
     */
    std::string command_name;
    /**
     * If a response is expected we give a transaction Id. Else we pass a value of 0
     */
    double transaction_id;
    /**
     * If there exists any command info this
     * is set, else this is set to null type.
     * @remark, optional, init to and maybe NULL.
     */
    SrsAmf0Any* command_object;
    /**
     * Any optional arguments to be provided
     * @remark, optional, init to and maybe NULL.
     */
    SrsAmf0Any* arguments;
public:
    SrsCallPacket();
    virtual ~SrsCallPacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};
/**
 * response for SrsCallPacket.
 */
class SrsCallResPacket : public SrsPacket
{
public:
    /**
     * Name of the command.
     */
    std::string command_name;
    /**
     * ID of the command, to which the response belongs to
     */
    double transaction_id;
    /**
     * If there exists any command info this is set, else this is set to null type.
     * @remark, optional, init to and maybe NULL.
     */
    SrsAmf0Any* command_object;
    /**
     * Response from the method that was called.
     * @remark, optional, init to and maybe NULL.
     */
    SrsAmf0Any* response;
public:
    SrsCallResPacket(double _transaction_id);
    virtual ~SrsCallResPacket();
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

/**
 * 4.1.3. createStream
 * The client sends this command to the server to create a logical
 * channel for message communication The publishing of audio, video, and
 * metadata is carried out over stream channel created using the
 * createStream command.
 */
class SrsCreateStreamPacket : public SrsPacket
{
public:
    /**
     * Name of the command. Set to "createStream".
     */
    std::string command_name;
    /**
     * Transaction ID of the command.
     */
    double transaction_id;
    /**
     * If there exists any command info this is set, else this is set to null type.
     * @remark, never be NULL, an AMF0 null instance.
     */
    SrsAmf0Any* command_object; // null
public:
    SrsCreateStreamPacket();
    virtual ~SrsCreateStreamPacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};
/**
 * response for SrsCreateStreamPacket.
 */
class SrsCreateStreamResPacket : public SrsPacket
{
public:
    /**
     * _result or _error; indicates whether the response is result or error.
     */
    std::string command_name;
    /**
     * ID of the command that response belongs to.
     */
    double transaction_id;
    /**
     * If there exists any command info this is set, else this is set to null type.
     * @remark, never be NULL, an AMF0 null instance.
     */
    SrsAmf0Any* command_object; // null
    /**
     * The return value is either a stream ID or an error information object.
     */
    double stream_id;
public:
    SrsCreateStreamResPacket(double _transaction_id, double _stream_id);
    virtual ~SrsCreateStreamResPacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

/**
 * client close stream packet.
 */
class SrsCloseStreamPacket : public SrsPacket
{
public:
    /**
     * Name of the command, set to "closeStream".
     */
    std::string command_name;
    /**
     * Transaction ID set to 0.
     */
    double transaction_id;
    /**
     * Command information object does not exist. Set to null type.
     * @remark, never be NULL, an AMF0 null instance.
     */
    SrsAmf0Any* command_object; // null
public:
    SrsCloseStreamPacket();
    virtual ~SrsCloseStreamPacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
};

/**
 * FMLE start publish: ReleaseStream/PublishStream/FCPublish/FCUnpublish
 */
class SrsFMLEStartPacket : public SrsPacket
{
public:
    /**
     * Name of the command
     */
    std::string command_name;
    /**
     * the transaction ID to get the response.
     */
    double transaction_id;
    /**
     * If there exists any command info this is set, else this is set to null type.
     * @remark, never be NULL, an AMF0 null instance.
     */
    SrsAmf0Any* command_object; // null
    /**
     * the stream name to start publish or release.
     */
    std::string stream_name;
public:
    SrsFMLEStartPacket();
    virtual ~SrsFMLEStartPacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
// factory method to create specified FMLE packet.
public:
    static SrsFMLEStartPacket* create_release_stream(std::string stream);
    static SrsFMLEStartPacket* create_FC_publish(std::string stream);
};
/**
 * response for SrsFMLEStartPacket.
 */
class SrsFMLEStartResPacket : public SrsPacket
{
public:
    /**
     * Name of the command
     */
    std::string command_name;
    /**
     * the transaction ID to get the response.
     */
    double transaction_id;
    /**
     * If there exists any command info this is set, else this is set to null type.
     * @remark, never be NULL, an AMF0 null instance.
     */
    SrsAmf0Any* command_object; // null
    /**
     * the optional args, set to undefined.
     * @remark, never be NULL, an AMF0 undefined instance.
     */
    SrsAmf0Any* args; // undefined
public:
    SrsFMLEStartResPacket(double _transaction_id);
    virtual ~SrsFMLEStartResPacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

/**
 * FMLE/flash publish
 * 4.2.6. Publish
 * The client sends the publish command to publish a named stream to the
 * server. Using this name, any client can play this stream and receive
 * the published audio, video, and data messages.
 */
class SrsPublishPacket : public SrsPacket
{
public:
    /**
     * Name of the command, set to "publish".
     */
    std::string command_name;
    /**
     * Transaction ID set to 0.
     */
    double transaction_id;
    /**
     * Command information object does not exist. Set to null type.
     * @remark, never be NULL, an AMF0 null instance.
     */
    SrsAmf0Any* command_object; // null
    /**
     * Name with which the stream is published.
     */
    std::string stream_name;
    /**
     * Type of publishing. Set to "live", "record", or "append".
     *   record: The stream is published and the data is recorded to a new file.The file
     *           is stored on the server in a subdirectory within the directory that
     *           contains the server application. If the file already exists, it is
     *           overwritten.
     *   append: The stream is published and the data is appended to a file. If no file
     *           is found, it is created.
     *   live: Live data is published without recording it in a file.
     * @remark, SRS only support live.
     * @remark, optional, default to live.
     */
    std::string type;
public:
    SrsPublishPacket();
    virtual ~SrsPublishPacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

/**
 * 4.2.8. pause
 * The client sends the pause command to tell the server to pause or
 * start playing.
 */
class SrsPausePacket : public SrsPacket
{
public:
    /**
     * Name of the command, set to "pause".
     */
    std::string command_name;
    /**
     * There is no transaction ID for this command. Set to 0.
     */
    double transaction_id;
    /**
     * Command information object does not exist. Set to null type.
     * @remark, never be NULL, an AMF0 null instance.
     */
    SrsAmf0Any* command_object; // null
    /**
     * true or false, to indicate pausing or resuming play
     */
    bool is_pause;
    /**
     * Number of milliseconds at which the the stream is paused or play resumed.
     * This is the current stream time at the Client when stream was paused. When the
     * playback is resumed, the server will only send messages with timestamps
     * greater than this value.
     */
    double time_ms;
public:
    SrsPausePacket();
    virtual ~SrsPausePacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
};

/**
 * 4.2.1. play
 * The client sends this command to the server to play a stream.
 */
class SrsPlayPacket : public SrsPacket
{
public:
    /**
     * Name of the command. Set to "play".
     */
    std::string command_name;
    /**
     * Transaction ID set to 0.
     */
    double transaction_id;
    /**
     * Command information does not exist. Set to null type.
     * @remark, never be NULL, an AMF0 null instance.
     */
    SrsAmf0Any* command_object; // null
    /**
     * Name of the stream to play.
     * To play video (FLV) files, specify the name of the stream without a file
     *       extension (for example, "sample").
     * To play back MP3 or ID3 tags, you must precede the stream name with mp3:
     *       (for example, "mp3:sample".)
     * To play H.264/AAC files, you must precede the stream name with mp4: and specify the
     *       file extension. For example, to play the file sample.m4v, specify
     *       "mp4:sample.m4v"
     */
    std::string stream_name;
    /**
     * An optional parameter that specifies the start time in seconds.
     * The default value is -2, which means the subscriber first tries to play the live
     *       stream specified in the Stream Name field. If a live stream of that name is
     *       not found, it plays the recorded stream specified in the Stream Name field.
     * If you pass -1 in the Start field, only the live stream specified in the Stream
     *       Name field is played.
     * If you pass 0 or a positive number in the Start field, a recorded stream specified
     *       in the Stream Name field is played beginning from the time specified in the
     *       Start field.
     * If no recorded stream is found, the next item in the playlist is played.
     */
    double start;
    /**
     * An optional parameter that specifies the duration of playback in seconds.
     * The default value is -1. The -1 value means a live stream is played until it is no
     *       longer available or a recorded stream is played until it ends.
     * If u pass 0, it plays the single frame since the time specified in the Start field
     *       from the beginning of a recorded stream. It is assumed that the value specified
     *       in the Start field is equal to or greater than 0.
     * If you pass a positive number, it plays a live stream for the time period specified
     *       in the Duration field. After that it becomes available or plays a recorded
     *       stream for the time specified in the Duration field. (If a stream ends before the
     *       time specified in the Duration field, playback ends when the stream ends.)
     * If you pass a negative number other than -1 in the Duration field, it interprets the
     *       value as if it were -1.
     */
    double duration;
    /**
     * An optional Boolean value or number that specifies whether to flush any
     * previous playlist.
     */
    bool reset;
public:
    SrsPlayPacket();
    virtual ~SrsPlayPacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

/**
 * response for SrsPlayPacket.
 * @remark, user must set the stream_id in header.
 */
class SrsPlayResPacket : public SrsPacket
{
public:
    /**
     * Name of the command. If the play command is successful, the command
     * name is set to onStatus.
     */
    std::string command_name;
    /**
     * Transaction ID set to 0.
     */
    double transaction_id;
    /**
     * Command information does not exist. Set to null type.
     * @remark, never be NULL, an AMF0 null instance.
     */
    SrsAmf0Any* command_object; // null
    /**
     * If the play command is successful, the client receives OnStatus message from
     * server which is NetStream.Play.Start. If the specified stream is not found,
     * NetStream.Play.StreamNotFound is received.
     * @remark, never be NULL, an AMF0 object instance.
     */
    SrsAmf0Object* desc;
public:
    SrsPlayResPacket();
    virtual ~SrsPlayResPacket();
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

/**
 * when bandwidth test done, notice client.
 */
class SrsOnBWDonePacket : public SrsPacket
{
public:
    /**
     * Name of command. Set to "onBWDone"
     */
    std::string command_name;
    /**
     * Transaction ID set to 0.
     */
    double transaction_id;
    /**
     * Command information does not exist. Set to null type.
     * @remark, never be NULL, an AMF0 null instance.
     */
    SrsAmf0Any* args; // null
public:
    SrsOnBWDonePacket();
    virtual ~SrsOnBWDonePacket();
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

/**
 * onStatus command, AMF0 Call
 * @remark, user must set the stream_id by SrsCommonMessage.set_packet().
 */
class SrsOnStatusCallPacket : public SrsPacket
{
public:
    /**
     * Name of command. Set to "onStatus"
     */
    std::string command_name;
    /**
     * Transaction ID set to 0.
     */
    double transaction_id;
    /**
     * Command information does not exist. Set to null type.
     * @remark, never be NULL, an AMF0 null instance.
     */
    SrsAmf0Any* args; // null
    /**
     * Name-value pairs that describe the response from the server.
     * 'code','level', 'description' are names of few among such information.
     * @remark, never be NULL, an AMF0 object instance.
     */
    SrsAmf0Object* data;
public:
    SrsOnStatusCallPacket();
    virtual ~SrsOnStatusCallPacket();
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

/**
 * the special packet for the bandwidth test.
 * actually, it's a SrsOnStatusCallPacket, but
 * 1. encode with data field, to send data to client.
 * 2. decode ignore the data field, donot care.
 */
class SrsBandwidthPacket : public SrsPacket
{
public:
    /**
     * Name of command.
     */
    std::string command_name;
    /**
     * Transaction ID set to 0.
     */
    double transaction_id;
    /**
     * Command information does not exist. Set to null type.
     * @remark, never be NULL, an AMF0 null instance.
     */
    SrsAmf0Any* args; // null
    /**
     * Name-value pairs that describe the response from the server.
     * 'code','level', 'description' are names of few among such information.
     * @remark, never be NULL, an AMF0 object instance.
     */
    SrsAmf0Object* data;
public:
    SrsBandwidthPacket();
    virtual ~SrsBandwidthPacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
// help function for bandwidth packet.
public:
    virtual bool is_start_play();
    virtual bool is_starting_play();
    virtual bool is_stop_play();
    virtual bool is_stopped_play();
    virtual bool is_start_publish();
    virtual bool is_starting_publish();
    virtual bool is_stop_publish();
    virtual bool is_stopped_publish();
    virtual bool is_finish();
    virtual bool is_final();
    static SrsBandwidthPacket* create_start_play();
    static SrsBandwidthPacket* create_starting_play();
    static SrsBandwidthPacket* create_playing();
    static SrsBandwidthPacket* create_stop_play();
    static SrsBandwidthPacket* create_stopped_play();
    static SrsBandwidthPacket* create_start_publish();
    static SrsBandwidthPacket* create_starting_publish();
    static SrsBandwidthPacket* create_publishing();
    static SrsBandwidthPacket* create_stop_publish();
    static SrsBandwidthPacket* create_stopped_publish();
    static SrsBandwidthPacket* create_finish();
    static SrsBandwidthPacket* create_final();
private:
    virtual SrsBandwidthPacket* set_command(std::string command);
};

/**
 * onStatus data, AMF0 Data
 * @remark, user must set the stream_id by SrsCommonMessage.set_packet().
 */
class SrsOnStatusDataPacket : public SrsPacket
{
public:
    /**
     * Name of command. Set to "onStatus"
     */
    std::string command_name;
    /**
     * Name-value pairs that describe the response from the server.
     * 'code', are names of few among such information.
     * @remark, never be NULL, an AMF0 object instance.
     */
    SrsAmf0Object* data;
public:
    SrsOnStatusDataPacket();
    virtual ~SrsOnStatusDataPacket();
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

/**
 * AMF0Data RtmpSampleAccess
 * @remark, user must set the stream_id by SrsCommonMessage.set_packet().
 */
class SrsSampleAccessPacket : public SrsPacket
{
public:
    /**
     * Name of command. Set to "|RtmpSampleAccess".
     */
    std::string command_name;
    /**
     * whether allow access the sample of video.
     * @see: https://github.com/ossrs/srs/issues/49
     * @see: http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/net/NetStream.html#videoSampleAccess
     */
    bool video_sample_access;
    /**
     * whether allow access the sample of audio.
     * @see: https://github.com/ossrs/srs/issues/49
     * @see: http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/flash/net/NetStream.html#audioSampleAccess
     */
    bool audio_sample_access;
public:
    SrsSampleAccessPacket();
    virtual ~SrsSampleAccessPacket();
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

/**
 * the stream metadata.
 * FMLE: @setDataFrame
 * others: onMetaData
 */
class SrsOnMetaDataPacket : public SrsPacket
{
public:
    /**
     * Name of metadata. Set to "onMetaData"
     */
    std::string name;
    /**
     * Metadata of stream.
     * @remark, never be NULL, an AMF0 object instance.
     */
    SrsAmf0Object* metadata;
public:
    SrsOnMetaDataPacket();
    virtual ~SrsOnMetaDataPacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

/**
 * 5.5. Window Acknowledgement Size (5)
 * The client or the server sends this message to inform the peer which
 * window size to use when sending acknowledgment.
 */
class SrsSetWindowAckSizePacket : public SrsPacket
{
public:
    int32_t ackowledgement_window_size;
public:
    SrsSetWindowAckSizePacket();
    virtual ~SrsSetWindowAckSizePacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

/**
 * 5.3. Acknowledgement (3)
 * The client or the server sends the acknowledgment to the peer after
 * receiving bytes equal to the window size.
 */
class SrsAcknowledgementPacket : public SrsPacket
{
public:
    uint32_t sequence_number;
public:
    SrsAcknowledgementPacket();
    virtual ~SrsAcknowledgementPacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

/**
 * 7.1. Set Chunk Size
 * Protocol control message 1, Set Chunk Size, is used to notify the
 * peer about the new maximum chunk size.
 */
class SrsSetChunkSizePacket : public SrsPacket
{
public:
    /**
     * The maximum chunk size can be 65536 bytes. The chunk size is
     * maintained independently for each direction.
     */
    int32_t chunk_size;
public:
    SrsSetChunkSizePacket();
    virtual ~SrsSetChunkSizePacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

// 5.6. Set Peer Bandwidth (6)
enum SrsPeerBandwidthType
{
    // The sender can mark this message hard (0), soft (1), or dynamic (2)
    // using the Limit type field.
    SrsPeerBandwidthHard = 0,
    SrsPeerBandwidthSoft = 1,
    SrsPeerBandwidthDynamic = 2,
};

/**
 * 5.6. Set Peer Bandwidth (6)
 * The client or the server sends this message to update the output
 * bandwidth of the peer.
 */
class SrsSetPeerBandwidthPacket : public SrsPacket
{
public:
    int32_t bandwidth;
    // @see: SrsPeerBandwidthType
    int8_t type;
public:
    SrsSetPeerBandwidthPacket();
    virtual ~SrsSetPeerBandwidthPacket();
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

// 3.7. User Control message
enum SrcPCUCEventType
{
    // generally, 4bytes event-data
    
    /**
     * The server sends this event to notify the client
     * that a stream has become functional and can be
     * used for communication. By default, this event
     * is sent on ID 0 after the application connect
     * command is successfully received from the
     * client. The event data is 4-byte and represents
     * the stream ID of the stream that became
     * functional.
     */
    SrcPCUCStreamBegin = 0x00,
    
    /**
     * The server sends this event to notify the client
     * that the playback of data is over as requested
     * on this stream. No more data is sent without
     * issuing additional commands. The client discards
     * the messages received for the stream. The
     * 4 bytes of event data represent the ID of the
     * stream on which playback has ended.
     */
    SrcPCUCStreamEOF = 0x01,
    
    /**
     * The server sends this event to notify the client
     * that there is no more data on the stream. If the
     * server does not detect any message for a time
     * period, it can notify the subscribed clients
     * that the stream is dry. The 4 bytes of event
     * data represent the stream ID of the dry stream.
     */
    SrcPCUCStreamDry = 0x02,
    
    /**
     * The client sends this event to inform the server
     * of the buffer size (in milliseconds) that is
     * used to buffer any data coming over a stream.
     * This event is sent before the server starts
     * processing the stream. The first 4 bytes of the
     * event data represent the stream ID and the next
     * 4 bytes represent the buffer length, in
     * milliseconds.
     */
    SrcPCUCSetBufferLength = 0x03, // 8bytes event-data
    
    /**
     * The server sends this event to notify the client
     * that the stream is a recorded stream. The
     * 4 bytes event data represent the stream ID of
     * the recorded stream.
     */
    SrcPCUCStreamIsRecorded = 0x04,
    
    /**
     * The server sends this event to test whether the
     * client is reachable. Event data is a 4-byte
     * timestamp, representing the local server time
     * when the server dispatched the command. The
     * client responds with kMsgPingResponse on
     * receiving kMsgPingRequest.
     */
    SrcPCUCPingRequest = 0x06,
    
    /**
     * The client sends this event to the server in
     * response to the ping request. The event data is
     * a 4-byte timestamp, which was received with the
     * kMsgPingRequest request.
     */
    SrcPCUCPingResponse = 0x07,
    
    /**
     * For PCUC size=3, for example the payload is "00 1A 01",
     * it's a FMS control event, where the event type is 0x001a and event data is 0x01,
     * please notice that the event data is only 1 byte for this event.
     */
    SrsPCUCFmsEvent0 = 0x1a,
};

/**
 * 5.4. User Control Message (4)
 *
 * for the EventData is 4bytes.
 * Stream Begin(=0)              4-bytes stream ID
 * Stream EOF(=1)                4-bytes stream ID
 * StreamDry(=2)                 4-bytes stream ID
 * SetBufferLength(=3)           8-bytes 4bytes stream ID, 4bytes buffer length.
 * StreamIsRecorded(=4)          4-bytes stream ID
 * PingRequest(=6)               4-bytes timestamp local server time
 * PingResponse(=7)              4-bytes timestamp received ping request.
 *
 * 3.7. User Control message
 * +------------------------------+-------------------------
 * | Event Type ( 2- bytes ) | Event Data
 * +------------------------------+-------------------------
 * Figure 5 Pay load for the 'User Control Message'.
 */
class SrsUserControlPacket : public SrsPacket
{
public:
    /**
     * Event type is followed by Event data.
     * @see: SrcPCUCEventType
     */
    int16_t event_type;
    /**
     * the event data generally in 4bytes.
     * @remark for event type is 0x001a, only 1bytes.
     * @see SrsPCUCFmsEvent0
     */
    int32_t event_data;
    /**
     * 4bytes if event_type is SetBufferLength; otherwise 0.
     */
    int32_t extra_data;
public:
    SrsUserControlPacket();
    virtual ~SrsUserControlPacket();
// decode functions for concrete packet to override.
public:
    virtual srs_error_t decode(SrsBuffer* stream);
// encode functions for concrete packet to override.
public:
    virtual int get_prefer_cid();
    virtual int get_message_type();
protected:
    virtual int get_size();
    virtual srs_error_t encode_packet(SrsBuffer* stream);
};

#endif

// following is generated by src/protocol/srs_rtmp_handshake.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_PROTOCOL_HANDSHAKE_HPP
#define SRS_PROTOCOL_HANDSHAKE_HPP

//#include <srs_core.hpp>

class ISrsProtocolReaderWriter;
class SrsComplexHandshake;
class SrsHandshakeBytes;
class SrsBuffer;

#ifdef SRS_AUTO_SSL

// for openssl.
#include <openssl/hmac.h>

namespace _srs_internal
{
    // the digest key generate size.
#define SRS_OpensslHashSize 512
    extern uint8_t SrsGenuineFMSKey[];
    extern uint8_t SrsGenuineFPKey[];
    srs_error_t openssl_HMACsha256(const void* key, int key_size, const void* data, int data_size, void* digest);
    srs_error_t openssl_generate_key(char* public_key, int32_t size);
    
    /**
     * the DH wrapper.
     */
    class SrsDH
    {
    private:
        DH* pdh;
    public:
        SrsDH();
        virtual ~SrsDH();
    private:
        virtual void close();
    public:
        /**
         * initialize dh, generate the public and private key.
         * @param ensure_128bytes_public_key whether ensure public key is 128bytes,
         *       sometimes openssl generate 127bytes public key.
         *       default to false to donot ensure.
         */
        virtual srs_error_t initialize(bool ensure_128bytes_public_key = false);
        /**
         * copy the public key.
         * @param pkey the bytes to copy the public key.
         * @param pkey_size the max public key size, output the actual public key size.
         *       user should never ignore this size.
         * @remark, when ensure_128bytes_public_key, the size always 128.
         */
        virtual srs_error_t copy_public_key(char* pkey, int32_t& pkey_size);
        /**
         * generate and copy the shared key.
         * generate the shared key with peer public key.
         * @param ppkey peer public key.
         * @param ppkey_size the size of ppkey.
         * @param skey the computed shared key.
         * @param skey_size the max shared key size, output the actual shared key size.
         *       user should never ignore this size.
         */
        virtual srs_error_t copy_shared_key(const char* ppkey, int32_t ppkey_size, char* skey, int32_t& skey_size);
    private:
        virtual srs_error_t do_initialize();
    };
    /**
     * the schema type.
     */
    enum srs_schema_type
    {
        srs_schema_invalid = 2,
        
        /**
         * key-digest sequence
         */
        srs_schema0 = 0,
        
        /**
         * digest-key sequence
         * @remark, FMS requires the schema1(digest-key), or connect failed.
         */
        //
        srs_schema1 = 1,
    };
    
    /**
     * 764bytes key structure
     *     random-data: (offset)bytes
     *     key-data: 128bytes
     *     random-data: (764-offset-128-4)bytes
     *     offset: 4bytes
     * @see also: http://blog.csdn.net/win_lin/article/details/13006803
     */
    class key_block
    {
    public:
        // (offset)bytes
        char* random0;
        int random0_size;
        
        // 128bytes
        char key[128];
        
        // (764-offset-128-4)bytes
        char* random1;
        int random1_size;
        
        // 4bytes
        int32_t offset;
    public:
        key_block();
        virtual ~key_block();
    public:
        // parse key block from c1s1.
        // if created, user must free it by srs_key_block_free
        // @stream contains c1s1_key_bytes the key start bytes
        srs_error_t parse(SrsBuffer* stream);
    private:
        // calc the offset of key,
        // the key->offset cannot be used as the offset of key.
        int calc_valid_offset();
    };
    
    /**
     * 764bytes digest structure
     *     offset: 4bytes
     *     random-data: (offset)bytes
     *     digest-data: 32bytes
     *     random-data: (764-4-offset-32)bytes
     * @see also: http://blog.csdn.net/win_lin/article/details/13006803
     */
    class digest_block
    {
    public:
        // 4bytes
        int32_t offset;
        
        // (offset)bytes
        char* random0;
        int random0_size;
        
        // 32bytes
        char digest[32];
        
        // (764-4-offset-32)bytes
        char* random1;
        int random1_size;
    public:
        digest_block();
        virtual ~digest_block();
    public:
        // parse digest block from c1s1.
        // if created, user must free it by srs_digest_block_free
        // @stream contains c1s1_digest_bytes the digest start bytes
        srs_error_t parse(SrsBuffer* stream);
    private:
        // calc the offset of digest,
        // the key->offset cannot be used as the offset of digest.
        int calc_valid_offset();
    };
    
    class c1s1;
    
    /**
     * the c1s1 strategy, use schema0 or schema1.
     * the template method class to defines common behaviors,
     * while the concrete class to implements in schema0 or schema1.
     */
    class c1s1_strategy
    {
    protected:
        key_block key;
        digest_block digest;
    public:
        c1s1_strategy();
        virtual ~c1s1_strategy();
    public:
        /**
         * get the scema.
         */
        virtual srs_schema_type schema() = 0;
        /**
         * get the digest.
         */
        virtual char* get_digest();
        /**
         * get the key.
         */
        virtual char* get_key();
        /**
         * copy to bytes.
         * @param size must be 1536.
         */
        virtual srs_error_t dump(c1s1* owner, char* _c1s1, int size);
        /**
         * server: parse the c1s1, discovery the key and digest by schema.
         * use the c1_validate_digest() to valid the digest of c1.
         */
        virtual srs_error_t parse(char* _c1s1, int size) = 0;
    public:
        /**
         * client: create and sign c1 by schema.
         * sign the c1, generate the digest.
         *         calc_c1_digest(c1, schema) {
         *            get c1s1-joined from c1 by specified schema
         *            digest-data = HMACsha256(c1s1-joined, FPKey, 30)
         *            return digest-data;
         *        }
         *        random fill 1536bytes c1 // also fill the c1-128bytes-key
         *        time = time() // c1[0-3]
         *        version = [0x80, 0x00, 0x07, 0x02] // c1[4-7]
         *        schema = choose schema0 or schema1
         *        digest-data = calc_c1_digest(c1, schema)
         *        copy digest-data to c1
         */
        virtual srs_error_t c1_create(c1s1* owner);
        /**
         * server: validate the parsed c1 schema
         */
        virtual srs_error_t c1_validate_digest(c1s1* owner, bool& is_valid);
        /**
         * server: create and sign the s1 from c1.
         *       // decode c1 try schema0 then schema1
         *       c1-digest-data = get-c1-digest-data(schema0)
         *       if c1-digest-data equals to calc_c1_digest(c1, schema0) {
         *           c1-key-data = get-c1-key-data(schema0)
         *           schema = schema0
         *       } else {
         *           c1-digest-data = get-c1-digest-data(schema1)
         *           if c1-digest-data not equals to calc_c1_digest(c1, schema1) {
         *               switch to simple handshake.
         *               return
         *           }
         *           c1-key-data = get-c1-key-data(schema1)
         *           schema = schema1
         *       }
         *
         *       // generate s1
         *       random fill 1536bytes s1
         *       time = time() // c1[0-3]
         *       version = [0x04, 0x05, 0x00, 0x01] // s1[4-7]
         *       s1-key-data=shared_key=DH_compute_key(peer_pub_key=c1-key-data)
         *       get c1s1-joined by specified schema
         *       s1-digest-data = HMACsha256(c1s1-joined, FMSKey, 36)
         *       copy s1-digest-data and s1-key-data to s1.
         * @param c1, to get the peer_pub_key of client.
         */
        virtual srs_error_t s1_create(c1s1* owner, c1s1* c1);
        /**
         * server: validate the parsed s1 schema
         */
        virtual srs_error_t s1_validate_digest(c1s1* owner, bool& is_valid);
    public:
        /**
         * calc the digest for c1
         */
        virtual srs_error_t calc_c1_digest(c1s1* owner, char*& c1_digest);
        /**
         * calc the digest for s1
         */
        virtual srs_error_t calc_s1_digest(c1s1* owner, char*& s1_digest);
        /**
         * copy whole c1s1 to bytes.
         * @param size must always be 1536 with digest, and 1504 without digest.
         */
        virtual srs_error_t copy_to(c1s1* owner, char* bytes, int size, bool with_digest) = 0;
        /**
         * copy time and version to stream.
         */
        virtual void copy_time_version(SrsBuffer* stream, c1s1* owner);
        /**
         * copy key to stream.
         */
        virtual void copy_key(SrsBuffer* stream);
        /**
         * copy digest to stream.
         */
        virtual void copy_digest(SrsBuffer* stream, bool with_digest);
    };
    
    /**
     * c1s1 schema0
     *     key: 764bytes
     *     digest: 764bytes
     */
    class c1s1_strategy_schema0 : public c1s1_strategy
    {
    public:
        c1s1_strategy_schema0();
        virtual ~c1s1_strategy_schema0();
    public:
        virtual srs_schema_type schema();
        virtual srs_error_t parse(char* _c1s1, int size);
    public:
        virtual srs_error_t copy_to(c1s1* owner, char* bytes, int size, bool with_digest);
    };
    
    /**
     * c1s1 schema1
     *     digest: 764bytes
     *     key: 764bytes
     */
    class c1s1_strategy_schema1 : public c1s1_strategy
    {
    public:
        c1s1_strategy_schema1();
        virtual ~c1s1_strategy_schema1();
    public:
        virtual srs_schema_type schema();
        virtual srs_error_t parse(char* _c1s1, int size);
    public:
        virtual srs_error_t copy_to(c1s1* owner, char* bytes, int size, bool with_digest);
    };
    
    /**
     * c1s1 schema0
     *     time: 4bytes
     *     version: 4bytes
     *     key: 764bytes
     *     digest: 764bytes
     * c1s1 schema1
     *     time: 4bytes
     *     version: 4bytes
     *     digest: 764bytes
     *     key: 764bytes
     * @see also: http://blog.csdn.net/win_lin/article/details/13006803
     */
    class c1s1
    {
    public:
        // 4bytes
        int32_t time;
        // 4bytes
        int32_t version;
        // 764bytes+764bytes
        c1s1_strategy* payload;
    public:
        c1s1();
        virtual ~c1s1();
    public:
        /**
         * get the scema.
         */
        virtual srs_schema_type schema();
        /**
         * get the digest key.
         */
        virtual char* get_digest();
        /**
         * get the key.
         */
        virtual char* get_key();
    public:
        /**
         * copy to bytes.
         * @param size, must always be 1536.
         */
        virtual srs_error_t dump(char* _c1s1, int size);
        /**
         * server: parse the c1s1, discovery the key and digest by schema.
         * @param size, must always be 1536.
         * use the c1_validate_digest() to valid the digest of c1.
         * use the s1_validate_digest() to valid the digest of s1.
         */
        virtual srs_error_t parse(char* _c1s1, int size, srs_schema_type _schema);
    public:
        /**
         * client: create and sign c1 by schema.
         * sign the c1, generate the digest.
         *         calc_c1_digest(c1, schema) {
         *            get c1s1-joined from c1 by specified schema
         *            digest-data = HMACsha256(c1s1-joined, FPKey, 30)
         *            return digest-data;
         *        }
         *        random fill 1536bytes c1 // also fill the c1-128bytes-key
         *        time = time() // c1[0-3]
         *        version = [0x80, 0x00, 0x07, 0x02] // c1[4-7]
         *        schema = choose schema0 or schema1
         *        digest-data = calc_c1_digest(c1, schema)
         *        copy digest-data to c1
         */
        virtual srs_error_t c1_create(srs_schema_type _schema);
        /**
         * server: validate the parsed c1 schema
         */
        virtual srs_error_t c1_validate_digest(bool& is_valid);
    public:
        /**
         * server: create and sign the s1 from c1.
         *       // decode c1 try schema0 then schema1
         *       c1-digest-data = get-c1-digest-data(schema0)
         *       if c1-digest-data equals to calc_c1_digest(c1, schema0) {
         *           c1-key-data = get-c1-key-data(schema0)
         *           schema = schema0
         *       } else {
         *           c1-digest-data = get-c1-digest-data(schema1)
         *           if c1-digest-data not equals to calc_c1_digest(c1, schema1) {
         *               switch to simple handshake.
         *               return
         *           }
         *           c1-key-data = get-c1-key-data(schema1)
         *           schema = schema1
         *       }
         *
         *       // generate s1
         *       random fill 1536bytes s1
         *       time = time() // c1[0-3]
         *       version = [0x04, 0x05, 0x00, 0x01] // s1[4-7]
         *       s1-key-data=shared_key=DH_compute_key(peer_pub_key=c1-key-data)
         *       get c1s1-joined by specified schema
         *       s1-digest-data = HMACsha256(c1s1-joined, FMSKey, 36)
         *       copy s1-digest-data and s1-key-data to s1.
         */
        virtual srs_error_t s1_create(c1s1* c1);
        /**
         * server: validate the parsed s1 schema
         */
        virtual srs_error_t s1_validate_digest(bool& is_valid);
    };
    
    /**
     * the c2s2 complex handshake structure.
     * random-data: 1504bytes
     * digest-data: 32bytes
     * @see also: http://blog.csdn.net/win_lin/article/details/13006803
     */
    class c2s2
    {
    public:
        char random[1504];
        char digest[32];
    public:
        c2s2();
        virtual ~c2s2();
    public:
        /**
         * copy to bytes.
         * @param size, must always be 1536.
         */
        virtual srs_error_t dump(char* _c2s2, int size);
        /**
         * parse the c2s2
         * @param size, must always be 1536.
         */
        virtual srs_error_t parse(char* _c2s2, int size);
    public:
        /**
         * create c2.
         * random fill c2s2 1536 bytes
         *
         * // client generate C2, or server valid C2
         * temp-key = HMACsha256(s1-digest, FPKey, 62)
         * c2-digest-data = HMACsha256(c2-random-data, temp-key, 32)
         */
        virtual srs_error_t c2_create(c1s1* s1);
        
        /**
         * validate the c2 from client.
         */
        virtual srs_error_t c2_validate(c1s1* s1, bool& is_valid);
    public:
        /**
         * create s2.
         * random fill c2s2 1536 bytes
         *
         * // server generate S2, or client valid S2
         * temp-key = HMACsha256(c1-digest, FMSKey, 68)
         * s2-digest-data = HMACsha256(s2-random-data, temp-key, 32)
         */
        virtual srs_error_t s2_create(c1s1* c1);
        
        /**
         * validate the s2 from server.
         */
        virtual srs_error_t s2_validate(c1s1* c1, bool& is_valid);
    };
}

#endif

/**
 * simple handshake.
 * user can try complex handshake first,
 * rollback to simple handshake if error ERROR_RTMP_TRY_SIMPLE_HS
 */
class SrsSimpleHandshake
{
public:
    SrsSimpleHandshake();
    virtual ~SrsSimpleHandshake();
public:
    /**
     * simple handshake.
     */
    virtual srs_error_t handshake_with_client(SrsHandshakeBytes* hs_bytes, ISrsProtocolReaderWriter* io);
    virtual srs_error_t handshake_with_server(SrsHandshakeBytes* hs_bytes, ISrsProtocolReaderWriter* io);
};

/**
 * rtmp complex handshake,
 * @see also crtmp(crtmpserver) or librtmp,
 * @see also: http://blog.csdn.net/win_lin/article/details/13006803
 */
class SrsComplexHandshake
{
public:
    SrsComplexHandshake();
    virtual ~SrsComplexHandshake();
public:
    /**
     * complex hanshake.
     * @return user must:
     *     continue connect app if success,
     *     try simple handshake if error is ERROR_RTMP_TRY_SIMPLE_HS,
     *     otherwise, disconnect
     */
    virtual srs_error_t handshake_with_client(SrsHandshakeBytes* hs_bytes, ISrsProtocolReaderWriter* io);
    virtual srs_error_t handshake_with_server(SrsHandshakeBytes* hs_bytes, ISrsProtocolReaderWriter* io);
};

#endif
// following is generated by src/protocol/srs_protocol_utility.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_PROTOCOL_UTILITY_HPP
#define SRS_PROTOCOL_UTILITY_HPP

//#include <srs_core.hpp>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <sys/uio.h>
#endif

#include <string>
#include <vector>
#include <map>

//#include <srs_kernel_consts.hpp>

class SrsMessageHeader;
class SrsSharedPtrMessage;
class SrsCommonMessage;
class ISrsProtocolReaderWriter;

/**
 * parse the tcUrl, output the schema, host, vhost, app and port.
 * @param tcUrl, the input tcUrl, for example,
 *       rtmp://192.168.1.10:19350/live?vhost=vhost.ossrs.net
 * @param schema, for example, rtmp
 * @param host, for example, 192.168.1.10
 * @param vhost, for example, vhost.ossrs.net.
 *       vhost default to host, when user not set vhost in query of app.
 * @param app, for example, live
 * @param port, for example, 19350
 *       default to 1935 if not specified.
 * param param, for example, vhost=vhost.ossrs.net
 * @remark The param stream is input and output param, that is:
 *       input: tcUrl+stream
 *       output: schema, host, vhost, app, stream, port, param
 */
extern void srs_discovery_tc_url(std::string tcUrl, std::string& schema, std::string& host, std::string& vhost, std::string& app,
    std::string& stream, int& port, std::string& param);

// parse query string to map(k,v).
// must format as key=value&...&keyN=valueN
extern void srs_parse_query_string(std::string q, std::map<std::string, std::string>& query);

/**
 * generate ramdom data for handshake.
 */
extern void srs_random_generate(char* bytes, int size);

/**
 * generate the tcUrl without param.
 * @remark Use host as tcUrl.vhost if vhost is default vhost.
 */
extern std::string srs_generate_tc_url(std::string host, std::string vhost, std::string app, int port);

/**
 * Generate the stream with param.
 * @remark Append vhost in query string if not default vhost.
 */
extern std::string srs_generate_stream_with_query(std::string host, std::string vhost, std::string stream, std::string param);

/**
 * create shared ptr message from bytes.
 * @param data the packet bytes. user should never free it.
 * @param ppmsg output the shared ptr message. user should free it.
 */
extern srs_error_t srs_rtmp_create_msg(char type, uint32_t timestamp, char* data, int size, int stream_id, SrsSharedPtrMessage** ppmsg);
extern srs_error_t srs_rtmp_create_msg(char type, uint32_t timestamp, char* data, int size, int stream_id, SrsCommonMessage** ppmsg);

// get the stream identify, vhost/app/stream.
extern std::string srs_generate_stream_url(std::string vhost, std::string app, std::string stream);

// parse the rtmp url to tcUrl/stream,
// for example, rtmp://v.ossrs.net/live/livestream to
//      tcUrl: rtmp://v.ossrs.net/live
//      stream: livestream
extern void srs_parse_rtmp_url(std::string url, std::string& tcUrl, std::string& stream);

// Genereate the rtmp url, for instance, rtmp://server:port/app/stream?param
// @remark We always put vhost in param, in the query of url.
extern std::string srs_generate_rtmp_url(std::string server, int port, std::string host, std::string vhost, std::string app, std::string stream, std::string param);

// write large numbers of iovs.
extern srs_error_t srs_write_large_iovs(ISrsProtocolReaderWriter* skt, iovec* iovs, int size, ssize_t* pnwrite = NULL);

// join string in vector with indicated separator
extern std::string srs_join_vector_string(std::vector<std::string>& vs, std::string separator);

// Whether domain is an IPv4 address.
extern bool srs_is_ipv4(std::string domain);

#endif

// following is generated by src/protocol/srs_rtmp_msg_array.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_PROTOCOL_MESSAGE_ARRAY_HPP
#define SRS_PROTOCOL_MESSAGE_ARRAY_HPP

//#include <srs_core.hpp>

class SrsSharedPtrMessage;

/**
 * the class to auto free the shared ptr message array.
 * when need to get some messages, for instance, from Consumer queue,
 * create a message array, whose msgs can used to accept the msgs,
 * then send each message and set to NULL.
 *
 * @remark: user must free all msgs in array, for the SRS2.0 protocol stack
 *       provides an api to send messages, @see send_and_free_messages
 */
class SrsMessageArray
{
public:
    /**
     * when user already send the msg in msgs, please set to NULL,
     * for instance, msg= msgs.msgs[i], msgs.msgs[i]=NULL, send(msg),
     * where send(msg) will always send and free it.
     */
    SrsSharedPtrMessage** msgs;
    int max;
public:
    /**
     * create msg array, initialize array to NULL ptrs.
     */
    SrsMessageArray(int max_msgs);
    /**
     * free the msgs not sent out(not NULL).
     */
    virtual ~SrsMessageArray();
public:
    /**
     * free specified count of messages.
     */
    virtual void free(int count);
private:
    /**
     * zero initialize the message array.
     */
    virtual void zero(int count);
};

#endif

// following is generated by src/protocol/srs_protocol_stream.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_PROTOCOL_STREAM_HPP
#define SRS_PROTOCOL_STREAM_HPP

//#include <srs_core.hpp>

//#include <srs_protocol_io.hpp>
//#include <srs_core_performance.hpp>
//#include <srs_kernel_stream.hpp>

#ifdef SRS_PERF_MERGED_READ
/**
 * to improve read performance, merge some packets then read,
 * when it on and read small bytes, we sleep to wait more data.,
 * that is, we merge some data to read together.
 * @see https://github.com/ossrs/srs/issues/241
 */
class IMergeReadHandler
{
public:
    IMergeReadHandler();
    virtual ~IMergeReadHandler();
public:
    /**
     * when read from channel, notice the merge handler to sleep for
     * some small bytes.
     * @remark, it only for server-side, client srs-librtmp just ignore.
     */
    virtual void on_read(ssize_t nread) = 0;
};
#endif

/**
 * the buffer provices bytes cache for protocol. generally,
 * protocol recv data from socket, put into buffer, decode to RTMP message.
 * Usage:
 *       ISrsReader* r = ......;
 *       SrsFastStream* fb = ......;
 *       fb->grow(r, 1024);
 *       char* header = fb->read_slice(100);
 *       char* payload = fb->read_payload(924);
 */
// TODO: FIXME: add utest for it.
class SrsFastStream
{
private:
#ifdef SRS_PERF_MERGED_READ
    // the merged handler
    bool merged_read;
    IMergeReadHandler* _handler;
#endif
    // the user-space buffer to fill by reader,
    // which use fast index and reset when chunk body read ok.
    // @see https://github.com/ossrs/srs/issues/248
    // ptr to the current read position.
    char* p;
    // ptr to the content end.
    char* end;
    // ptr to the buffer.
    //      buffer <= p <= end <= buffer+nb_buffer
    char* buffer;
    // the size of buffer.
    int nb_buffer;
public:
    SrsFastStream();
    virtual ~SrsFastStream();
public:
    /**
     * get the size of current bytes in buffer.
     */
    virtual int size();
    /**
     * get the current bytes in buffer.
     * @remark user should use read_slice() if possible,
     *       the bytes() is used to test bytes, for example, to detect the bytes schema.
     */
    virtual char* bytes();
    /**
     * create buffer with specifeid size.
     * @param buffer the size of buffer. ignore when smaller than SRS_MAX_SOCKET_BUFFER.
     * @remark when MR(SRS_PERF_MERGED_READ) disabled, always set to 8K.
     * @remark when buffer changed, the previous ptr maybe invalid.
     * @see https://github.com/ossrs/srs/issues/241
     */
    virtual void set_buffer(int buffer_size);
public:
    /**
     * read 1byte from buffer, move to next bytes.
     * @remark assert buffer already grow(1).
     */
    virtual char read_1byte();
    /**
     * read a slice in size bytes, move to next bytes.
     * user can use this char* ptr directly, and should never free it.
     * @remark user can use the returned ptr util grow(size),
     *       for the ptr returned maybe invalid after grow(x).
     */
    virtual char* read_slice(int size);
    /**
     * skip some bytes in buffer.
     * @param size the bytes to skip. positive to next; negative to previous.
     * @remark assert buffer already grow(size).
     * @remark always use read_slice to consume bytes, which will reset for EOF.
     *       while skip never consume bytes.
     */
    virtual void skip(int size);
public:
    /**
     * grow buffer to the required size, loop to read from skt to fill.
     * @param reader, read more bytes from reader to fill the buffer to required size.
     * @param required_size, loop to fill to ensure buffer size to required.
     * @return an int error code, error if required_size negative.
     * @remark, we actually maybe read more than required_size, maybe 4k for example.
     */
    virtual srs_error_t grow(ISrsReader* reader, int required_size);
public:
#ifdef SRS_PERF_MERGED_READ
    /**
     * to improve read performance, merge some packets then read,
     * when it on and read small bytes, we sleep to wait more data.,
     * that is, we merge some data to read together.
     * @param v true to ename merged read.
     * @param handler the handler when merge read is enabled.
     * @see https://github.com/ossrs/srs/issues/241
     * @remark the merged read is optional, ignore if not specifies.
     */
    virtual void set_merge_read(bool v, IMergeReadHandler* handler);
#endif
};

#endif
// following is generated by src/protocol/srs_raw_avc.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_PROTOCOL_RAW_AVC_HPP
#define SRS_PROTOCOL_RAW_AVC_HPP

//#include <srs_core.hpp>

#include <string>

//#include <srs_kernel_codec.hpp>

class SrsBuffer;

/**
 * the raw h.264 stream, in annexb.
 */
class SrsRawH264Stream
{
public:
    SrsRawH264Stream();
    virtual ~SrsRawH264Stream();
public:
    /**
     * demux the stream in annexb format.
     * @param stream the input stream bytes.
     * @param pframe the output h.264 frame in stream. user should never free it.
     * @param pnb_frame the output h.264 frame size.
     */
    virtual srs_error_t annexb_demux(SrsBuffer* stream, char** pframe, int* pnb_frame);
    /**
     * whether the frame is sps or pps.
     */
    virtual bool is_sps(char* frame, int nb_frame);
    virtual bool is_pps(char* frame, int nb_frame);
    /**
     * demux the sps or pps to string.
     * @param sps/pps output the sps/pps.
     */
    virtual srs_error_t sps_demux(char* frame, int nb_frame, std::string& sps);
    virtual srs_error_t pps_demux(char* frame, int nb_frame, std::string& pps);
public:
    /**
     * h264 raw data to h264 packet, without flv payload header.
     * mux the sps/pps to flv sequence header packet.
     * @param sh output the sequence header.
     */
    virtual srs_error_t mux_sequence_header(std::string sps, std::string pps, uint32_t dts, uint32_t pts, std::string& sh);
    /**
     * h264 raw data to h264 packet, without flv payload header.
     * mux the ibp to flv ibp packet.
     * @param ibp output the packet.
     * @param frame_type output the frame type.
     */
    virtual srs_error_t mux_ipb_frame(char* frame, int nb_frame, std::string& ibp);
    /**
     * mux the avc video packet to flv video packet.
     * @param frame_type, SrsVideoAvcFrameTypeKeyFrame or SrsVideoAvcFrameTypeInterFrame.
     * @param avc_packet_type, SrsVideoAvcFrameTraitSequenceHeader or SrsVideoAvcFrameTraitNALU.
     * @param video the h.264 raw data.
     * @param flv output the muxed flv packet.
     * @param nb_flv output the muxed flv size.
     */
    virtual srs_error_t mux_avc2flv(std::string video, int8_t frame_type, int8_t avc_packet_type, uint32_t dts, uint32_t pts, char** flv, int* nb_flv);
};

/**
 * the header of adts sample.
 */
struct SrsRawAacStreamCodec
{
    int8_t protection_absent;
    SrsAacObjectType aac_object;
    int8_t sampling_frequency_index;
    int8_t channel_configuration;
    int16_t frame_length;
    
    char sound_format;
    char sound_rate;
    char sound_size;
    char sound_type;
    // 0 for sh; 1 for raw data.
    int8_t aac_packet_type;
};

/**
 * the raw aac stream, in adts.
 */
class SrsRawAacStream
{
public:
    SrsRawAacStream();
    virtual ~SrsRawAacStream();
public:
    /**
     * demux the stream in adts format.
     * @param stream the input stream bytes.
     * @param pframe the output aac frame in stream. user should never free it.
     * @param pnb_frame the output aac frame size.
     * @param codec the output codec info.
     */
    virtual srs_error_t adts_demux(SrsBuffer* stream, char** pframe, int* pnb_frame, SrsRawAacStreamCodec& codec);
    /**
     * aac raw data to aac packet, without flv payload header.
     * mux the aac specific config to flv sequence header packet.
     * @param sh output the sequence header.
     */
    virtual srs_error_t mux_sequence_header(SrsRawAacStreamCodec* codec, std::string& sh);
    /**
     * mux the aac audio packet to flv audio packet.
     * @param frame the aac raw data.
     * @param nb_frame the count of aac frame.
     * @param codec the codec info of aac.
     * @param flv output the muxed flv packet.
     * @param nb_flv output the muxed flv size.
     */
    virtual srs_error_t mux_aac2flv(char* frame, int nb_frame, SrsRawAacStreamCodec* codec, uint32_t dts, char** flv, int* nb_flv);
};

#endif
// following is generated by src/protocol/srs_rtsp_stack.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_PROTOCOL_RTSP_HPP
#define SRS_PROTOCOL_RTSP_HPP

//#include <srs_core.hpp>

#if !defined(SRS_EXPORT_LIBRTMP)

#include <string>
#include <sstream>

//#include <srs_kernel_consts.hpp>

#ifdef SRS_AUTO_STREAM_CASTER

class SrsBuffer;
class SrsSimpleStream;
class SrsAudioFrame;
class ISrsProtocolReaderWriter;

// rtsp specification
// CR = <US-ASCII CR, carriage return (13)>
#define SRS_RTSP_CR SRS_CONSTS_CR // 0x0D
// LF = <US-ASCII LF, linefeed (10)>
#define SRS_RTSP_LF SRS_CONSTS_LF // 0x0A
// SP = <US-ASCII SP, space (32)>
#define SRS_RTSP_SP ' ' // 0x20

// 4 RTSP Message, @see rfc2326-1998-rtsp.pdf, page 37
// Lines are terminated by CRLF, but
// receivers should be prepared to also interpret CR and LF by
// themselves as line terminators.
#define SRS_RTSP_CRLF "\r\n" // 0x0D0A
#define SRS_RTSP_CRLFCRLF "\r\n\r\n" // 0x0D0A0D0A

// RTSP token
#define SRS_RTSP_TOKEN_CSEQ "CSeq"
#define SRS_RTSP_TOKEN_PUBLIC "Public"
#define SRS_RTSP_TOKEN_CONTENT_TYPE "Content-Type"
#define SRS_RTSP_TOKEN_CONTENT_LENGTH "Content-Length"
#define SRS_RTSP_TOKEN_TRANSPORT "Transport"
#define SRS_RTSP_TOKEN_SESSION "Session"

// RTSP methods
#define SRS_METHOD_OPTIONS            "OPTIONS"
#define SRS_METHOD_DESCRIBE           "DESCRIBE"
#define SRS_METHOD_ANNOUNCE           "ANNOUNCE"
#define SRS_METHOD_SETUP              "SETUP"
#define SRS_METHOD_PLAY               "PLAY"
#define SRS_METHOD_PAUSE              "PAUSE"
#define SRS_METHOD_TEARDOWN           "TEARDOWN"
#define SRS_METHOD_GET_PARAMETER      "GET_PARAMETER"
#define SRS_METHOD_SET_PARAMETER      "SET_PARAMETER"
#define SRS_METHOD_REDIRECT           "REDIRECT"
#define SRS_METHOD_RECORD             "RECORD"
// Embedded (Interleaved) Binary Data

// RTSP-Version
#define SRS_RTSP_VERSION "RTSP/1.0"

/**
 * the rtsp sdp parse state.
 */
enum SrsRtspSdpState
{
    /**
     * other sdp properties.
     */
    SrsRtspSdpStateOthers,
    /**
     * parse sdp audio state.
     */
    SrsRtspSdpStateAudio,
    /**
     * parse sdp video state.
     */
    SrsRtspSdpStateVideo,
};

/**
 * 10 Method Definitions, @see rfc2326-1998-rtsp.pdf, page 57
 * The method token indicates the method to be performed on the resource
 * identified by the Request-URI. The method is case-sensitive. New
 * methods may be defined in the future. Method names may not start with
 * a $ character (decimal 24) and must be a token. Methods are
 * summarized in Table 2.
 * Notes on Table 2: PAUSE is recommended, but not required in that a
 * fully functional server can be built that does not support this
 * method, for example, for live feeds. If a server does not support a
 * particular method, it MUST return "501 Not Implemented" and a client
 * SHOULD not try this method again for this server.
 */
enum SrsRtspMethod
{
    SrsRtspMethodDescribe = 0x0001,
    SrsRtspMethodAnnounce = 0x0002,
    SrsRtspMethodGetParameter = 0x0004,
    SrsRtspMethodOptions = 0x0008,
    SrsRtspMethodPause = 0x0010,
    SrsRtspMethodPlay = 0x0020,
    SrsRtspMethodRecord = 0x0040,
    SrsRtspMethodRedirect = 0x0080,
    SrsRtspMethodSetup = 0x0100,
    SrsRtspMethodSetParameter = 0x0200,
    SrsRtspMethodTeardown = 0x0400,
};

/**
 * the state of rtsp token.
 */
enum SrsRtspTokenState
{
    /**
     * parse token failed, default state.
     */
    SrsRtspTokenStateError = 100,
    /**
     * when SP follow the token.
     */
    SrsRtspTokenStateNormal = 101,
    /**
     * when CRLF follow the token.
     */
    SrsRtspTokenStateEOF = 102,
};

/**
 * the rtp packet.
 * 5. RTP Data Transfer Protocol, @see rfc3550-2003-rtp.pdf, page 12
 */
class SrsRtpPacket
{
public:
    /**
     * version (V): 2 bits
     * This field identifies the version of RTP. The version defined by this specification is two (2).
     * (The value 1 is used by the first draft version of RTP and the value 0 is used by the protocol
     * initially implemented in the \vat" audio tool.)
     */
    int8_t version; //2bits
    /**
     * padding (P): 1 bit
     * If the padding bit is set, the packet contains one or more additional padding octets at the
     * end which are not part of the payload. The last octet of the padding contains a count of
     * how many padding octets should be ignored, including itself. Padding may be needed by
     * some encryption algorithms with fixed block sizes or for carrying several RTP packets in a
     * lower-layer protocol data unit.
     */
    int8_t padding; //1bit
    /**
     * extension (X): 1 bit
     * If the extension bit is set, the fixed header must be followed by exactly one header extension,
     * with a format defined in Section 5.3.1.
     */
    int8_t extension; //1bit
    /**
     * CSRC count (CC): 4 bits
     * The CSRC count contains the number of CSRC identifiers that follow the fixed header.
     */
    int8_t csrc_count; //4bits
    /**
     * marker (M): 1 bit
     * The interpretation of the marker is defined by a profile. It is intended to allow significant
     * events such as frame boundaries to be marked in the packet stream. A profile may define
     * additional marker bits or specify that there is no marker bit by changing the number of bits
     * in the payload type field (see Section 5.3).
     */
    int8_t marker; //1bit
    /**
     * payload type (PT): 7 bits
     * This field identifies the format of the RTP payload and determines its interpretation by the
     * application. A profile may specify a default static mapping of payload type codes to payload
     * formats. Additional payload type codes may be defined dynamically through non-RTP means
     * (see Section 3). A set of default mappings for audio and video is specified in the companion
     * RFC 3551 [1]. An RTP source may change the payload type during a session, but this field
     * should not be used for multiplexing separate media streams (see Section 5.2).
     * A receiver must ignore packets with payload types that it does not understand.
     */
    int8_t payload_type; //7bits
    /**
     * sequence number: 16 bits
     * The sequence number increments by one for each RTP data packet sent, and may be used
     * by the receiver to detect packet loss and to restore packet sequence. The initial value of the
     * sequence number should be random (unpredictable) to make known-plaintext attacks on
     * encryption more dicult, even if the source itself does not encrypt according to the method
     * in Section 9.1, because the packets may flow through a translator that does. Techniques for
     * choosing unpredictable numbers are discussed in [17].
     */
    uint16_t sequence_number; //16bits
    /**
     * timestamp: 32 bits
     * The timestamp reflects the sampling instant of the first octet in the RTP data packet. The
     * sampling instant must be derived from a clock that increments monotonically and linearly
     * in time to allow synchronization and jitter calculations (see Section 6.4.1). The resolution
     * of the clock must be sucient for the desired synchronization accuracy and for measuring
     * packet arrival jitter (one tick per video frame is typically not sucient). The clock frequency
     * is dependent on the format of data carried as payload and is specified statically in the profile
     * or payload format specification that defines the format, or may be specified dynamically for
     * payload formats defined through non-RTP means. If RTP packets are generated periodically,
     * the nominal sampling instant as determined from the sampling clock is to be used, not a
     * reading of the system clock. As an example, for fixed-rate audio the timestamp clock would
     * likely increment by one for each sampling period. If an audio application reads blocks covering
     * 160 sampling periods from the input device, the timestamp would be increased by 160 for
     * each such block, regardless of whether the block is transmitted in a packet or dropped as
     * silent.
     *
     * The initial value of the timestamp should be random, as for the sequence number. Several
     * consecutive RTP packets will have equal timestamps if they are (logically) generated at once,
     * e.g., belong to the same video frame. Consecutive RTP packets may contain timestamps that
     * are not monotonic if the data is not transmitted in the order it was sampled, as in the case
     * of MPEG interpolated video frames. (The sequence numbers of the packets as transmitted
     * will still be monotonic.)
     *
     * RTP timestamps from different media streams may advance at different rates and usually
     * have independent, random offsets. Therefore, although these timestamps are sucient to
     * reconstruct the timing of a single stream, directly comparing RTP timestamps from different
     * media is not effective for synchronization. Instead, for each medium the RTP timestamp
     * is related to the sampling instant by pairing it with a timestamp from a reference clock
     * (wallclock) that represents the time when the data corresponding to the RTP timestamp was
     * sampled. The reference clock is shared by all media to be synchronized. The timestamp
     * pairs are not transmitted in every data packet, but at a lower rate in RTCP SR packets as
     * described in Section 6.4.
     *
     * The sampling instant is chosen as the point of reference for the RTP timestamp because it is
     * known to the transmitting endpoint and has a common definition for all media, independent
     * of encoding delays or other processing. The purpose is to allow synchronized presentation of
     * all media sampled at the same time.
     *
     * Applications transmitting stored data rather than data sampled in real time typically use a
     * virtual presentation timeline derived from wallclock time to determine when the next frame
     * or other unit of each medium in the stored data should be presented. In this case, the RTP
     * timestamp would reflect the presentation time for each unit. That is, the RTP timestamp for
     * each unit would be related to the wallclock time at which the unit becomes current on the
     * virtual presentation timeline. Actual presentation occurs some time later as determined by
     * the receiver.
     *
     * An example describing live audio narration of prerecorded video illustrates the significance
     * of choosing the sampling instant as the reference point. In this scenario, the video would
     * be presented locally for the narrator to view and would be simultaneously transmitted using
     * RTP. The sampling instant" of a video frame transmitted in RTP would be established by
     * referencing its timestamp to the wallclock time when that video frame was presented to the
     * narrator. The sampling instant for the audio RTP packets containing the narrator's speech
     * would be established by referencing the same wallclock time when the audio was sampled.
     * The audio and video may even be transmitted by different hosts if the reference clocks on
     * the two hosts are synchronized by some means such as NTP. A receiver can then synchronize
     * presentation of the audio and video packets by relating their RTP timestamps using the
     * timestamp pairs in RTCP SR packets.
     */
    uint32_t timestamp; //32bits
    /**
     * SSRC: 32 bits
     * The SSRC field identifies the synchronization source. This identifier should be chosen
     * randomly, with the intent that no two synchronization sources within the same RTP session
     * will have the same SSRC identifier. An example algorithm for generating a random identifier
     * is presented in Appendix A.6. Although the probability of multiple sources choosing the same
     * identifier is low, all RTP implementations must be prepared to detect and resolve collisions.
     * Section 8 describes the probability of collision along with a mechanism for resolving collisions
     * and detecting RTP-level forwarding loops based on the uniqueness of the SSRC identifier. If
     * a source changes its source transport address, it must also choose a new SSRC identifier to
     * avoid being interpreted as a looped source (see Section 8.2).
     */
    uint32_t ssrc; //32bits
    
    // the payload.
    SrsSimpleStream* payload;
    // whether transport in chunked payload.
    bool chunked;
    // whether message is completed.
    // normal message always completed.
    // while chunked completed when the last chunk arriaved.
    bool completed;
    
    /**
     * the audio samples, one rtp packets may contains multiple audio samples.
     */
    SrsAudioFrame* audio;
public:
    SrsRtpPacket();
    virtual ~SrsRtpPacket();
public:
    /**
     * copy the header from src.
     */
    virtual void copy(SrsRtpPacket* src);
    /**
     * reap the src to this packet, reap the payload.
     */
    virtual void reap(SrsRtpPacket* src);
    /**
     * decode rtp packet from stream.
     */
    virtual srs_error_t decode(SrsBuffer* stream);
private:
    virtual srs_error_t decode_97(SrsBuffer* stream);
    virtual srs_error_t decode_96(SrsBuffer* stream);
};

/**
 * the sdp in announce, @see rfc2326-1998-rtsp.pdf, page 159
 * Appendix C: Use of SDP for RTSP Session Descriptions
 * The Session Description Protocol (SDP, RFC 2327 [6]) may be used to
 * describe streams or presentations in RTSP.
 */
class SrsRtspSdp
{
private:
    SrsRtspSdpState state;
public:
    /**
     * the version of sdp.
     */
    std::string version;
    /**
     * the owner/creator of sdp.
     */
    std::string owner_username;
    std::string owner_session_id;
    std::string owner_session_version;
    std::string owner_network_type;
    std::string owner_address_type;
    std::string owner_address;
    /**
     * the session name of sdp.
     */
    std::string session_name;
    /**
     * the connection info of sdp.
     */
    std::string connection_network_type;
    std::string connection_address_type;
    std::string connection_address;
    /**
     * the tool attribute of sdp.
     */
    std::string tool;
    /**
     * the video attribute of sdp.
     */
    std::string video_port;
    std::string video_protocol;
    std::string video_transport_format;
    std::string video_bandwidth_kbps;
    std::string video_codec;
    std::string video_sample_rate;
    std::string video_stream_id;
    // fmtp
    std::string video_packetization_mode;
    std::string video_sps; // sequence header: sps.
    std::string video_pps; // sequence header: pps.
    /**
     * the audio attribute of sdp.
     */
    std::string audio_port;
    std::string audio_protocol;
    std::string audio_transport_format;
    std::string audio_bandwidth_kbps;
    std::string audio_codec;
    std::string audio_sample_rate;
    std::string audio_channel;
    std::string audio_stream_id;
    // fmtp
    std::string audio_profile_level_id;
    std::string audio_mode;
    std::string audio_size_length;
    std::string audio_index_length;
    std::string audio_index_delta_length;
    std::string audio_sh; // sequence header.
public:
    SrsRtspSdp();
    virtual ~SrsRtspSdp();
public:
    /**
     * parse a line of token for sdp.
     */
    virtual srs_error_t parse(std::string token);
private:
    /**
     * generally, the fmtp is the sequence header for video or audio.
     */
    virtual srs_error_t parse_fmtp_attribute(std::string attr);
    /**
     * generally, the control is the stream info for video or audio.
     */
    virtual srs_error_t parse_control_attribute(std::string attr);
    /**
     * decode the string by base64.
     */
    virtual std::string base64_decode(std::string value);
};

/**
 * the rtsp transport.
 * 12.39 Transport, @see rfc2326-1998-rtsp.pdf, page 115
 * This request header indicates which transport protocol is to be used
 * and configures its parameters such as destination address,
 * compression, multicast time-to-live and destination port for a single
 * stream. It sets those values not already determined by a presentation
 * description.
 */
class SrsRtspTransport
{
public:
    // The syntax for the transport specifier is
    //      transport/profile/lower-transport
    std::string transport;
    std::string profile;
    std::string lower_transport;
    // unicast | multicast
    // mutually exclusive indication of whether unicast or multicast
    // delivery will be attempted. Default value is multicast.
    // Clients that are capable of handling both unicast and
    // multicast transmission MUST indicate such capability by
    // including two full transport-specs with separate parameters
    // for each.
    std::string cast_type;
    // The mode parameter indicates the methods to be supported for
    // this session. Valid values are PLAY and RECORD. If not
    // provided, the default is PLAY.
    std::string mode;
    // This parameter provides the unicast RTP/RTCP port pair on
    // which the client has chosen to receive media data and control
    // information. It is specified as a range, e.g.,
    //      client_port=3456-3457.
    // where client will use port in:
    //      [client_port_min, client_port_max)
    int client_port_min;
    int client_port_max;
public:
    SrsRtspTransport();
    virtual ~SrsRtspTransport();
public:
    /**
     * parse a line of token for transport.
     */
    virtual srs_error_t parse(std::string attr);
};

/**
 * the rtsp request message.
 * 6 Request, @see rfc2326-1998-rtsp.pdf, page 39
 * A request message from a client to a server or vice versa includes,
 * within the first line of that message, the method to be applied to
 * the resource, the identifier of the resource, and the protocol
 * version in use.
 * Request = Request-Line ; Section 6.1
 *           *( general-header ; Section 5
 *           | request-header ; Section 6.2
 *           | entity-header ) ; Section 8.1
 *           CRLF
 *           [ message-body ] ; Section 4.3
 */
class SrsRtspRequest
{
public:
    /**
     * 6.1 Request Line
     * Request-Line = Method SP Request-URI SP RTSP-Version CRLF
     */
    std::string method;
    std::string uri;
    std::string version;
    /**
     * 12.17 CSeq
     * The CSeq field specifies the sequence number for an RTSP requestresponse
     * pair. This field MUST be present in all requests and
     * responses. For every RTSP request containing the given sequence
     * number, there will be a corresponding response having the same
     * number. Any retransmitted request must contain the same sequence
     * number as the original (i.e. the sequence number is not incremented
     * for retransmissions of the same request).
     */
    long seq;
    /**
     * 12.16 Content-Type, @see rfc2326-1998-rtsp.pdf, page 99
     * See [H14.18]. Note that the content types suitable for RTSP are
     * likely to be restricted in practice to presentation descriptions and
     * parameter-value types.
     */
    std::string content_type;
    /**
     * 12.14 Content-Length, @see rfc2326-1998-rtsp.pdf, page 99
     * This field contains the length of the content of the method (i.e.
     * after the double CRLF following the last header). Unlike HTTP, it
     * MUST be included in all messages that carry content beyond the header
     * portion of the message. If it is missing, a default value of zero is
     * assumed. It is interpreted according to [H14.14].
     */
    long content_length;
    /**
     * the session id.
     */
    std::string session;
    
    /**
     * the sdp in announce, NULL for no sdp.
     */
    SrsRtspSdp* sdp;
    /**
     * the transport in setup, NULL for no transport.
     */
    SrsRtspTransport* transport;
    /**
     * for setup message, parse the stream id from uri.
     */
    int stream_id;
public:
    SrsRtspRequest();
    virtual ~SrsRtspRequest();
public:
    virtual bool is_options();
    virtual bool is_announce();
    virtual bool is_setup();
    virtual bool is_record();
};

/**
 * the rtsp response message.
 * 7 Response, @see rfc2326-1998-rtsp.pdf, page 43
 * [H6] applies except that HTTP-Version is replaced by RTSP-Version.
 * Also, RTSP defines additional status codes and does not define some
 * HTTP codes. The valid response codes and the methods they can be used
 * with are defined in Table 1.
 * After receiving and interpreting a request message, the recipient
 * responds with an RTSP response message.
 *       Response = Status-Line ; Section 7.1
 *                   *( general-header ; Section 5
 *                   | response-header ; Section 7.1.2
 *                   | entity-header ) ; Section 8.1
 *                   CRLF
 *                   [ message-body ] ; Section 4.3
 */
class SrsRtspResponse
{
public:
    /**
     * 7.1 Status-Line
     * The first line of a Response message is the Status-Line, consisting
     * of the protocol version followed by a numeric status code, and the
     * textual phrase associated with the status code, with each element
     * separated by SP characters. No CR or LF is allowed except in the
     * final CRLF sequence.
     *       Status-Line = RTSP-Version SP Status-Code SP Reason-Phrase CRLF
     */
    // @see about the version of rtsp, see SRS_RTSP_VERSION
    // @see about the status of rtsp, see SRS_CONSTS_RTSP_OK
    int status;
    /**
     * 12.17 CSeq, @see rfc2326-1998-rtsp.pdf, page 99
     * The CSeq field specifies the sequence number for an RTSP requestresponse
     * pair. This field MUST be present in all requests and
     * responses. For every RTSP request containing the given sequence
     * number, there will be a corresponding response having the same
     * number. Any retransmitted request must contain the same sequence
     * number as the original (i.e. the sequence number is not incremented
     * for retransmissions of the same request).
     */
    long seq;
    /**
     * the session id.
     */
    std::string session;
public:
    SrsRtspResponse(int cseq);
    virtual ~SrsRtspResponse();
public:
    /**
     * encode message to string.
     */
    virtual srs_error_t encode(std::stringstream& ss);
protected:
    /**
     * sub classes override this to encode the headers.
     */
    virtual srs_error_t encode_header(std::stringstream& ss);
};

/**
 * 10.1 OPTIONS, @see rfc2326-1998-rtsp.pdf, page 59
 * The behavior is equivalent to that described in [H9.2]. An OPTIONS
 * request may be issued at any time, e.g., if the client is about to
 * try a nonstandard request. It does not influence server state.
 */
class SrsRtspOptionsResponse : public SrsRtspResponse
{
public:
    /**
     * join of SrsRtspMethod
     */
    SrsRtspMethod methods;
public:
    SrsRtspOptionsResponse(int cseq);
    virtual ~SrsRtspOptionsResponse();
protected:
    virtual srs_error_t encode_header(std::stringstream& ss);
};

/**
 * 10.4 SETUP, @see rfc2326-1998-rtsp.pdf, page 65
 * The SETUP request for a URI specifies the transport mechanism to be
 * used for the streamed media. A client can issue a SETUP request for a
 * stream that is already playing to change transport parameters, which
 * a server MAY allow. If it does not allow this, it MUST respond with
 * error "455 Method Not Valid In This State". For the benefit of any
 * intervening firewalls, a client must indicate the transport
 * parameters even if it has no influence over these parameters, for
 * example, where the server advertises a fixed multicast address.
 */
class SrsRtspSetupResponse : public SrsRtspResponse
{
public:
    // the client specified port.
    int client_port_min;
    int client_port_max;
    // client will use the port in:
    //      [local_port_min, local_port_max)
    int local_port_min;
    int local_port_max;
    // session.
    std::string session;
public:
    SrsRtspSetupResponse(int cseq);
    virtual ~SrsRtspSetupResponse();
protected:
    virtual srs_error_t encode_header(std::stringstream& ss);
};

/**
 * the rtsp protocol stack to parse the rtsp packets.
 */
class SrsRtspStack
{
private:
    /**
     * cached bytes buffer.
     */
    SrsSimpleStream* buf;
    /**
     * underlayer socket object, send/recv bytes.
     */
    ISrsProtocolReaderWriter* skt;
public:
    SrsRtspStack(ISrsProtocolReaderWriter* s);
    virtual ~SrsRtspStack();
public:
    /**
     * recv rtsp message from underlayer io.
     * @param preq the output rtsp request message, which user must free it.
     * @return an int error code.
     *       ERROR_RTSP_REQUEST_HEADER_EOF indicates request header EOF.
     */
    virtual srs_error_t recv_message(SrsRtspRequest** preq);
    /**
     * send rtsp message over underlayer io.
     * @param res the rtsp response message, which user should never free it.
     * @return an int error code.
     */
    virtual srs_error_t send_message(SrsRtspResponse* res);
private:
    /**
     * recv the rtsp message.
     */
    virtual srs_error_t do_recv_message(SrsRtspRequest* req);
    /**
     * read a normal token from io, error when token state is not normal.
     */
    virtual srs_error_t recv_token_normal(std::string& token);
    /**
     * read a normal token from io, error when token state is not eof.
     */
    virtual srs_error_t recv_token_eof(std::string& token);
    /**
     * read the token util got eof, for example, to read the response status Reason-Phrase
     * @param pconsumed, output the token parsed length. NULL to ignore.
     */
    virtual srs_error_t recv_token_util_eof(std::string& token, int* pconsumed = NULL);
    /**
     * read a token from io, split by SP, endswith CRLF:
     *       token1 SP token2 SP ... tokenN CRLF
     * @param token, output the read token.
     * @param state, output the token parse state.
     * @param normal_ch, the char to indicates the normal token.
     *       the SP use to indicates the normal token, @see SRS_RTSP_SP
     *       the 0x00 use to ignore normal token flag. @see recv_token_util_eof
     * @param pconsumed, output the token parsed length. NULL to ignore.
     */
    virtual srs_error_t recv_token(std::string& token, SrsRtspTokenState& state, char normal_ch = SRS_RTSP_SP, int* pconsumed = NULL);
};

#endif

#endif

#endif

// following is generated by src/protocol/srs_http_stack.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_PROTOCOL_HTTP_HPP
#define SRS_PROTOCOL_HTTP_HPP

//#include <srs_core.hpp>

// default http listen port.
#define SRS_DEFAULT_HTTP_PORT 80

#if !defined(SRS_EXPORT_LIBRTMP)

#include <map>
#include <string>
#include <vector>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <sys/uio.h>
#endif

class SrsFileReader;
class SrsHttpHeader;
class ISrsHttpMessage;
class SrsHttpMuxEntry;
class ISrsHttpResponseWriter;

// http specification
// CR             = <US-ASCII CR, carriage return (13)>
#define SRS_HTTP_CR SRS_CONSTS_CR // 0x0D
// LF             = <US-ASCII LF, linefeed (10)>
#define SRS_HTTP_LF SRS_CONSTS_LF // 0x0A
// SP             = <US-ASCII SP, space (32)>
#define SRS_HTTP_SP ' ' // 0x20
// HT             = <US-ASCII HT, horizontal-tab (9)>
#define SRS_HTTP_HT '\x09' // 0x09

// HTTP/1.1 defines the sequence CR LF as the end-of-line marker for all
// protocol elements except the entity-body (see appendix 19.3 for
// tolerant applications).
#define SRS_HTTP_CRLF "\r\n" // 0x0D0A
#define SRS_HTTP_CRLFCRLF "\r\n\r\n" // 0x0D0A0D0A

// @see ISrsHttpMessage._http_ts_send_buffer
#define SRS_HTTP_TS_SEND_BUFFER_SIZE 4096

// for ead all of http body, read each time.
#define SRS_HTTP_READ_CACHE_BYTES 4096

// for http parser macros
#define SRS_CONSTS_HTTP_OPTIONS HTTP_OPTIONS
#define SRS_CONSTS_HTTP_GET HTTP_GET
#define SRS_CONSTS_HTTP_POST HTTP_POST
#define SRS_CONSTS_HTTP_PUT HTTP_PUT
#define SRS_CONSTS_HTTP_DELETE HTTP_DELETE

// Error replies to the request with the specified error message and HTTP code.
// The error message should be plain text.
extern srs_error_t srs_go_http_error(ISrsHttpResponseWriter* w, int code);
extern srs_error_t srs_go_http_error(ISrsHttpResponseWriter* w, int code, std::string error);

// get the status text of code.
extern std::string srs_generate_http_status_text(int status);

// bodyAllowedForStatus reports whether a given response status code
// permits a body.  See RFC2616, section 4.4.
extern bool srs_go_http_body_allowd(int status);

// DetectContentType implements the algorithm described
// at http://mimesniff.spec.whatwg.org/ to determine the
// Content-Type of the given data.  It considers at most the
// first 512 bytes of data.  DetectContentType always returns
// a valid MIME type: if it cannot determine a more specific one, it
// returns "application/octet-stream".
extern std::string srs_go_http_detect(char* data, int size);

// state of message
enum SrsHttpParseState {
    SrsHttpParseStateInit = 0,
    SrsHttpParseStateStart,
    SrsHttpParseStateHeaderComplete,
    SrsHttpParseStateMessageComplete
};

// A Header represents the key-value pairs in an HTTP header.
class SrsHttpHeader
{
private:
    std::map<std::string, std::string> headers;
public:
    SrsHttpHeader();
    virtual ~SrsHttpHeader();
public:
    // Add adds the key, value pair to the header.
    // It appends to any existing values associated with key.
    virtual void set(std::string key, std::string value);
    // Get gets the first value associated with the given key.
    // If there are no values associated with the key, Get returns "".
    // To access multiple values of a key, access the map directly
    // with CanonicalHeaderKey.
    virtual std::string get(std::string key);
public:
    /**
     * get the content length. -1 if not set.
     */
    virtual int64_t content_length();
    /**
     * set the content length by header "Content-Length"
     */
    virtual void set_content_length(int64_t size);
public:
    /**
     * get the content type. empty string if not set.
     */
    virtual std::string content_type();
    /**
     * set the content type by header "Content-Type"
     */
    virtual void set_content_type(std::string ct);
public:
    /**
     * write all headers to string stream.
     */
    virtual void write(std::stringstream& ss);
};

// A ResponseWriter interface is used by an HTTP handler to
// construct an HTTP response.
// Usage 1, response with specified length content:
//      ISrsHttpResponseWriter* w; // create or get response.
//      std::string msg = "Hello, HTTP!";
//      w->header()->set_content_type("text/plain; charset=utf-8");
//      w->header()->set_content_length(msg.length());
//      w->write_header(SRS_CONSTS_HTTP_OK);
//      w->write((char*)msg.data(), (int)msg.length());
//      w->final_request(); // optional flush.
// Usage 2, response with HTTP code only, zero content length.
//      ISrsHttpResponseWriter* w; // create or get response.
//      w->header()->set_content_length(0);
//      w->write_header(SRS_CONSTS_HTTP_OK);
//      w->final_request();
// Usage 3, response in chunked encoding.
//      ISrsHttpResponseWriter* w; // create or get response.
//      std::string msg = "Hello, HTTP!";
//      w->header()->set_content_type("application/octet-stream");
//      w->write_header(SRS_CONSTS_HTTP_OK);
//      w->write((char*)msg.data(), (int)msg.length());
//      w->write((char*)msg.data(), (int)msg.length());
//      w->write((char*)msg.data(), (int)msg.length());
//      w->write((char*)msg.data(), (int)msg.length());
//      w->final_request(); // required to end the chunked and flush.
class ISrsHttpResponseWriter
{
public:
    ISrsHttpResponseWriter();
    virtual ~ISrsHttpResponseWriter();
public:
    // when chunked mode,
    // final the request to complete the chunked encoding.
    // for no-chunked mode,
    // final to send request, for example, content-length is 0.
    virtual srs_error_t final_request() = 0;
    
    // Header returns the header map that will be sent by WriteHeader.
    // Changing the header after a call to WriteHeader (or Write) has
    // no effect.
    virtual SrsHttpHeader* header() = 0;
    
    // Write writes the data to the connection as part of an HTTP reply.
    // If WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK)
    // before writing the data.  If the Header does not contain a
    // Content-Type line, Write adds a Content-Type set to the result of passing
    // the initial 512 bytes of written data to DetectContentType.
    // @param data, the data to send. NULL to flush header only.
    virtual srs_error_t write(char* data, int size) = 0;
    /**
     * for the HTTP FLV, to writev to improve performance.
     * @see https://github.com/ossrs/srs/issues/405
     */
    virtual srs_error_t writev(const iovec* iov, int iovcnt, ssize_t* pnwrite) = 0;
    
    // WriteHeader sends an HTTP response header with status code.
    // If WriteHeader is not called explicitly, the first call to Write
    // will trigger an implicit WriteHeader(http.StatusOK).
    // Thus explicit calls to WriteHeader are mainly used to
    // send error codes.
    // @remark, user must set header then write or write_header.
    virtual void write_header(int code) = 0;
};

/**
 * the reader interface for http response.
 */
class ISrsHttpResponseReader
{
public:
    ISrsHttpResponseReader();
    virtual ~ISrsHttpResponseReader();
public:
    /**
     * whether response read EOF.
     */
    virtual bool eof() = 0;
    /**
     * read from the response body.
     * @param data, the buffer to read data buffer to.
     * @param nb_data, the max size of data buffer.
     * @param nb_read, the actual read size of bytes. NULL to ignore.
     * @remark when eof(), return error.
     * @remark for some server, the content-length not specified and not chunked,
     *      which is actually the infinite chunked encoding, which after http header
     *      is http response data, it's ok for browser. that is,
     *      when user call this read, please ensure there is data to read(by content-length
     *      or by chunked), because the sdk never know whether there is no data or
     *      infinite chunked.
     */
    virtual srs_error_t read(char* data, int nb_data, int* nb_read) = 0;
};

// Objects implementing the Handler interface can be
// registered to serve a particular path or subtree
// in the HTTP server.
//
// ServeHTTP should write reply headers and data to the ResponseWriter
// and then return.  Returning signals that the request is finished
// and that the HTTP server can move on to the next request on
// the connection.
class ISrsHttpHandler
{
public:
    SrsHttpMuxEntry* entry;
public:
    ISrsHttpHandler();
    virtual ~ISrsHttpHandler();
public:
    virtual bool is_not_found();
    virtual srs_error_t serve_http(ISrsHttpResponseWriter* w, ISrsHttpMessage* r) = 0;
};

// Redirect to a fixed URL
class SrsHttpRedirectHandler : public ISrsHttpHandler
{
private:
    std::string url;
    int code;
public:
    SrsHttpRedirectHandler(std::string u, int c);
    virtual ~SrsHttpRedirectHandler();
public:
    virtual srs_error_t serve_http(ISrsHttpResponseWriter* w, ISrsHttpMessage* r);
};

// NotFound replies to the request with an HTTP 404 not found error.
class SrsHttpNotFoundHandler : public ISrsHttpHandler
{
public:
    SrsHttpNotFoundHandler();
    virtual ~SrsHttpNotFoundHandler();
public:
    virtual bool is_not_found();
    virtual srs_error_t serve_http(ISrsHttpResponseWriter* w, ISrsHttpMessage* r);
};

// FileServer returns a handler that serves HTTP requests
// with the contents of the file system rooted at root.
//
// To use the operating system's file system implementation,
// use http.Dir:
//
//     http.Handle("/", SrsHttpFileServer("/tmp"))
//     http.Handle("/", SrsHttpFileServer("static-dir"))
class SrsHttpFileServer : public ISrsHttpHandler
{
protected:
    std::string dir;
public:
    SrsHttpFileServer(std::string root_dir);
    virtual ~SrsHttpFileServer();
public:
    virtual srs_error_t serve_http(ISrsHttpResponseWriter* w, ISrsHttpMessage* r);
private:
    /**
     * serve the file by specified path
     */
    virtual srs_error_t serve_file(ISrsHttpResponseWriter* w, ISrsHttpMessage* r, std::string fullpath);
    virtual srs_error_t serve_flv_file(ISrsHttpResponseWriter* w, ISrsHttpMessage* r, std::string fullpath);
    virtual srs_error_t serve_mp4_file(ISrsHttpResponseWriter* w, ISrsHttpMessage* r, std::string fullpath);
protected:
    /**
     * when access flv file with x.flv?start=xxx
     */
    virtual srs_error_t serve_flv_stream(ISrsHttpResponseWriter* w, ISrsHttpMessage* r, std::string fullpath, int offset);
    /**
     * when access mp4 file with x.mp4?range=start-end
     * @param start the start offset in bytes.
     * @param end the end offset in bytes. -1 to end of file.
     * @remark response data in [start, end].
     */
    virtual srs_error_t serve_mp4_stream(ISrsHttpResponseWriter* w, ISrsHttpMessage* r, std::string fullpath, int start, int end);
protected:
    /**
     * copy the fs to response writer in size bytes.
     */
    virtual srs_error_t copy(ISrsHttpResponseWriter* w, SrsFileReader* fs, ISrsHttpMessage* r, int size);
};

// the mux entry for server mux.
// the matcher info, for example, the pattern and handler.
class SrsHttpMuxEntry
{
public:
    bool explicit_match;
    ISrsHttpHandler* handler;
    std::string pattern;
    bool enabled;
public:
    SrsHttpMuxEntry();
    virtual ~SrsHttpMuxEntry();
};

/**
 * the hijacker for http pattern match.
 */
class ISrsHttpMatchHijacker
{
public:
    ISrsHttpMatchHijacker();
    virtual ~ISrsHttpMatchHijacker();
public:
    /**
     * when match the request failed, no handler to process request.
     * @param request the http request message to match the handler.
     * @param ph the already matched handler, hijack can rewrite it.
     */
    virtual srs_error_t hijack(ISrsHttpMessage* request, ISrsHttpHandler** ph) = 0;
};

/**
 * the server mux, all http server should implements it.
 */
class ISrsHttpServeMux
{
public:
    ISrsHttpServeMux();
    virtual ~ISrsHttpServeMux();
public:
    virtual srs_error_t serve_http(ISrsHttpResponseWriter* w, ISrsHttpMessage* r) = 0;
};

// ServeMux is an HTTP request multiplexer.
// It matches the URL of each incoming request against a list of registered
// patterns and calls the handler for the pattern that
// most closely matches the URL.
//
// Patterns name fixed, rooted paths, like "/favicon.ico",
// or rooted subtrees, like "/images/" (note the trailing slash).
// Longer patterns take precedence over shorter ones, so that
// if there are handlers registered for both "/images/"
// and "/images/thumbnails/", the latter handler will be
// called for paths beginning "/images/thumbnails/" and the
// former will receive requests for any other paths in the
// "/images/" subtree.
//
// Note that since a pattern ending in a slash names a rooted subtree,
// the pattern "/" matches all paths not matched by other registered
// patterns, not just the URL with Path == "/".
//
// Patterns may optionally begin with a host name, restricting matches to
// URLs on that host only.  Host-specific patterns take precedence over
// general patterns, so that a handler might register for the two patterns
// "/codesearch" and "codesearch.google.com/" without also taking over
// requests for "http://www.google.com/".
//
// ServeMux also takes care of sanitizing the URL request path,
// redirecting any request containing . or .. elements to an
// equivalent .- and ..-free URL.
class SrsHttpServeMux : public ISrsHttpServeMux
{
private:
    // the pattern handler, to handle the http request.
    std::map<std::string, SrsHttpMuxEntry*> entries;
    // the vhost handler.
    // when find the handler to process the request,
    // append the matched vhost when pattern not starts with /,
    // for example, for pattern /live/livestream.flv of vhost ossrs.net,
    // the path will rewrite to ossrs.net/live/livestream.flv
    std::map<std::string, ISrsHttpHandler*> vhosts;
    // all hijackers for http match.
    // for example, the hstrs(http stream trigger rtmp source)
    // can hijack and install handler when request incoming and no handler.
    std::vector<ISrsHttpMatchHijacker*> hijackers;
public:
    SrsHttpServeMux();
    virtual ~SrsHttpServeMux();
public:
    /**
     * initialize the http serve mux.
     */
    virtual srs_error_t initialize();
    /**
     * hijack the http match.
     */
    virtual void hijack(ISrsHttpMatchHijacker* h);
    virtual void unhijack(ISrsHttpMatchHijacker* h);
public:
    // Handle registers the handler for the given pattern.
    // If a handler already exists for pattern, Handle panics.
    virtual srs_error_t handle(std::string pattern, ISrsHttpHandler* handler);
// interface ISrsHttpServeMux
public:
    virtual srs_error_t serve_http(ISrsHttpResponseWriter* w, ISrsHttpMessage* r);
public:
    virtual srs_error_t find_handler(ISrsHttpMessage* r, ISrsHttpHandler** ph);
private:
    virtual srs_error_t match(ISrsHttpMessage* r, ISrsHttpHandler** ph);
    virtual bool path_match(std::string pattern, std::string path);
};

/**
 * The filter http mux, directly serve the http CORS requests,
 * while proxy to the worker mux for services.
 */
class SrsHttpCorsMux : public ISrsHttpServeMux
{
private:
    bool required;
    bool enabled;
    ISrsHttpServeMux* next;
public:
    SrsHttpCorsMux();
    virtual ~SrsHttpCorsMux();
public:
    virtual srs_error_t initialize(ISrsHttpServeMux* worker, bool cros_enabled);
// interface ISrsHttpServeMux
public:
    virtual srs_error_t serve_http(ISrsHttpResponseWriter* w, ISrsHttpMessage* r);
};

// for http header.
typedef std::pair<std::string, std::string> SrsHttpHeaderField;

// A Request represents an HTTP request received by a server
// or to be sent by a client.
//
// The field semantics differ slightly between client and server
// usage. In addition to the notes on the fields below, see the
// documentation for Request.Write and RoundTripper.
//
// There are some modes to determine the length of body:
//      1. content-length and chunked.
//      2. user confirmed infinite chunked.
//      3. no body or user not confirmed infinite chunked.
// For example:
//      ISrsHttpMessage* r = ...;
//      while (!r->eof()) r->read(); // read in mode 1 or 3.
// For some server, we can confirm the body is infinite chunked:
//      ISrsHttpMessage* r = ...;
//      r->enter_infinite_chunked();
//      while (!r->eof()) r->read(); // read in mode 2
// @rmark for mode 2, the infinite chunked, all left data is body.
class ISrsHttpMessage
{
private:
    /**
     * use a buffer to read and send ts file.
     */
    // TODO: FIXME: remove it.
    char* _http_ts_send_buffer;
public:
    ISrsHttpMessage();
    virtual ~ISrsHttpMessage();
public:
    /**
     * the http request level cache.
     */
    virtual char* http_ts_send_buffer();
public:
    virtual uint8_t method() = 0;
    virtual uint16_t status_code() = 0;
    /**
     * method helpers.
     */
    virtual std::string method_str() = 0;
    virtual bool is_http_get() = 0;
    virtual bool is_http_put() = 0;
    virtual bool is_http_post() = 0;
    virtual bool is_http_delete() = 0;
    virtual bool is_http_options() = 0;
public:
    /**
     * whether should keep the connection alive.
     */
    virtual bool is_keep_alive() = 0;
    /**
     * the uri contains the host and path.
     */
    virtual std::string uri() = 0;
    /**
     * the url maybe the path.
     */
    virtual std::string url() = 0;
    virtual std::string host() = 0;
    virtual std::string path() = 0;
    virtual std::string query() = 0;
    virtual std::string ext() = 0;
    /**
     * get the RESTful id,
     * for example, pattern is /api/v1/streams, path is /api/v1/streams/100,
     * then the rest id is 100.
     * @param pattern the handler pattern which will serve the request.
     * @return the REST id; -1 if not matched.
     */
    virtual int parse_rest_id(std::string pattern) = 0;
public:
    /**
     * the left all data is chunked body, the infinite chunked mode,
     * which is chunked encoding without chunked header.
     * @remark error when message is in chunked or content-length specified.
     */
    virtual srs_error_t enter_infinite_chunked() = 0;
    /**
     * read body to string.
     * @remark for small http body.
     */
    virtual srs_error_t body_read_all(std::string& body) = 0;
    /**
     * get the body reader, to read one by one.
     * @remark when body is very large, or chunked, use this.
     */
    virtual ISrsHttpResponseReader* body_reader() = 0;
    /**
     * the content length, -1 for chunked or not set.
     */
    virtual int64_t content_length() = 0;
public:
    /**
     * get the param in query string,
     * for instance, query is "start=100&end=200",
     * then query_get("start") is "100", and query_get("end") is "200"
     */
    virtual std::string query_get(std::string key) = 0;
    /**
     * get the headers.
     */
    virtual int request_header_count() = 0;
    virtual std::string request_header_key_at(int index) = 0;
    virtual std::string request_header_value_at(int index) = 0;
public:
    /**
     * whether the current request is JSONP,
     * which has a "callback=xxx" in QueryString.
     */
    virtual bool is_jsonp() = 0;
};

#endif

/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
#ifndef http_parser_h
#define http_parser_h
#ifdef __cplusplus
extern "C" {
#endif
    
#define HTTP_PARSER_VERSION_MAJOR 2
#define HTTP_PARSER_VERSION_MINOR 1
    
#include <sys/types.h>
#if defined(_WIN32) && !defined(__MINGW32__) && (!defined(_MSC_VER) || _MSC_VER<1600)
#include <BaseTsd.h>
#include <stddef.h>
    typedef __int8 int8_t;
    typedef unsigned __int8 uint8_t;
    typedef __int16 int16_t;
    typedef unsigned __int16 uint16_t;
    typedef __int32 int32_t;
    typedef unsigned __int32 uint32_t;
    typedef __int64 int64_t;
    typedef unsigned __int64 uint64_t;
#else
#include <stdint.h>
#endif
    
    /* Compile with -DHTTP_PARSER_STRICT=0 to make less checks, but run
     * faster
     */
#ifndef HTTP_PARSER_STRICT
# define HTTP_PARSER_STRICT 1
#endif
    
    /* Maximium header size allowed */
#define HTTP_MAX_HEADER_SIZE (80*1024)
    
    
    typedef struct http_parser http_parser;
    typedef struct http_parser_settings http_parser_settings;
    
    
    /* Callbacks should return non-zero to indicate an error. The parser will
     * then halt execution.
     *
     * The one exception is on_headers_complete. In a HTTP_RESPONSE parser
     * returning '1' from on_headers_complete will tell the parser that it
     * should not expect a body. This is used when receiving a response to a
     * HEAD request which may contain 'Content-Length' or 'Transfer-Encoding:
     * chunked' headers that indicate the presence of a body.
     *
     * http_data_cb does not return data chunks. It will be call arbitrarally
     * many times for each string. E.G. you might get 10 callbacks for "on_url"
     * each providing just a few characters more data.
     */
    typedef int (*http_data_cb) (http_parser*, const char *at, size_t length);
    typedef int (*http_cb) (http_parser*);
    
    
    /* Request Methods */
#define HTTP_METHOD_MAP(XX)         \
    XX(0,  DELETE,      DELETE)       \
    XX(1,  GET,         GET)          \
    XX(2,  HEAD,        HEAD)         \
    XX(3,  POST,        POST)         \
    XX(4,  PUT,         PUT)          \
    /* pathological */                \
    XX(5,  CONNECT,     CONNECT)      \
    XX(6,  OPTIONS,     OPTIONS)      \
    XX(7,  TRACE,       TRACE)        \
    /* webdav */                      \
    XX(8,  COPY,        COPY)         \
    XX(9,  LOCK,        LOCK)         \
    XX(10, MKCOL,       MKCOL)        \
    XX(11, MOVE,        MOVE)         \
    XX(12, PROPFIND,    PROPFIND)     \
    XX(13, PROPPATCH,   PROPPATCH)    \
    XX(14, SEARCH,      SEARCH)       \
    XX(15, UNLOCK,      UNLOCK)       \
    /* subversion */                  \
    XX(16, REPORT,      REPORT)       \
    XX(17, MKACTIVITY,  MKACTIVITY)   \
    XX(18, CHECKOUT,    CHECKOUT)     \
    XX(19, MERGE,       MERGE)        \
    /* upnp */                        \
    XX(20, MSEARCH,     M-SEARCH)     \
    XX(21, NOTIFY,      NOTIFY)       \
    XX(22, SUBSCRIBE,   SUBSCRIBE)    \
    XX(23, UNSUBSCRIBE, UNSUBSCRIBE)  \
    /* RFC-5789 */                    \
    XX(24, PATCH,       PATCH)        \
    XX(25, PURGE,       PURGE)        \

    enum http_method
    {
#define XX(num, name, string) HTTP_##name = num,
        HTTP_METHOD_MAP(XX)
#undef XX
    };
    
    
    enum http_parser_type { HTTP_REQUEST, HTTP_RESPONSE, HTTP_BOTH };
    
    
    /* Flag values for http_parser.flags field */
    enum flags
    { F_CHUNKED               = 1 << 0
        , F_CONNECTION_KEEP_ALIVE = 1 << 1
        , F_CONNECTION_CLOSE      = 1 << 2
        , F_TRAILING              = 1 << 3
        , F_UPGRADE               = 1 << 4
        , F_SKIPBODY              = 1 << 5
    };
    
    
    /* Map for errno-related constants
     *
     * The provided argument should be a macro that takes 2 arguments.
     */
#define HTTP_ERRNO_MAP(XX)                                           \
    /* No error */                                                     \
    XX(OK, "success")                                                  \
    \
    /* Callback-related errors */                                      \
    XX(CB_message_begin, "the on_message_begin callback failed")       \
    XX(CB_status_complete, "the on_status_complete callback failed")   \
    XX(CB_url, "the on_url callback failed")                           \
    XX(CB_header_field, "the on_header_field callback failed")         \
    XX(CB_header_value, "the on_header_value callback failed")         \
    XX(CB_headers_complete, "the on_headers_complete callback failed") \
    XX(CB_body, "the on_body callback failed")                         \
    XX(CB_message_complete, "the on_message_complete callback failed") \
    \
    /* Parsing-related errors */                                       \
    XX(INVALID_EOF_STATE, "stream ended at an unexpected time")        \
    XX(HEADER_OVERFLOW,                                                \
    "too many header bytes seen; overflow detected")                \
    XX(CLOSED_CONNECTION,                                              \
    "data received after completed connection: close message")      \
    XX(INVALID_VERSION, "invalid HTTP version")                        \
    XX(INVALID_STATUS, "invalid HTTP status code")                     \
    XX(INVALID_METHOD, "invalid HTTP method")                          \
    XX(INVALID_URL, "invalid URL")                                     \
    XX(INVALID_HOST, "invalid host")                                   \
    XX(INVALID_PORT, "invalid port")                                   \
    XX(INVALID_PATH, "invalid path")                                   \
    XX(INVALID_QUERY_STRING, "invalid query string")                   \
    XX(INVALID_FRAGMENT, "invalid fragment")                           \
    XX(LF_EXPECTED, "LF character expected")                           \
    XX(INVALID_HEADER_TOKEN, "invalid character in header")            \
    XX(INVALID_CONTENT_LENGTH,                                         \
    "invalid character in content-length header")                   \
    XX(INVALID_CHUNK_SIZE,                                             \
    "invalid character in chunk size header")                       \
    XX(INVALID_CONSTANT, "invalid constant string")                    \
    XX(INVALID_INTERNAL_STATE, "encountered unexpected internal state")\
    XX(STRICT, "strict mode assertion failed")                         \
    XX(PAUSED, "parser is paused")                                     \
    XX(UNKNOWN, "an unknown error occurred")
    
    
    /* Define HPE_* values for each errno value above */
#define HTTP_ERRNO_GEN(n, s) HPE_##n,
    enum http_errno {
        HTTP_ERRNO_MAP(HTTP_ERRNO_GEN)
    };
#undef HTTP_ERRNO_GEN
    
    
    /* Get an http_errno value from an http_parser */
#define HTTP_PARSER_ERRNO(p)            ((enum http_errno) (p)->http_errno)
    
    
    struct http_parser {
        /** PRIVATE **/
        unsigned char type : 2;     /* enum http_parser_type */
        unsigned char flags : 6;    /* F_* values from 'flags' enum; semi-public */
        unsigned char state;        /* enum state from http_parser.c */
        unsigned char header_state; /* enum header_state from http_parser.c */
        unsigned char index;        /* index into current matcher */
        
        uint32_t nread;          /* # bytes read in various scenarios */
        uint64_t content_length; /* # bytes in body (0 if no Content-Length header) */
        
        /** READ-ONLY **/
        unsigned short http_major;
        unsigned short http_minor;
        unsigned short status_code; /* responses only */
        unsigned char method;       /* requests only */
        unsigned char http_errno : 7;
        
        /* 1 = Upgrade header was present and the parser has exited because of that.
         * 0 = No upgrade header present.
         * Should be checked when http_parser_execute() returns in addition to
         * error checking.
         */
        unsigned char upgrade : 1;
        
        /** PUBLIC **/
        void *data; /* A pointer to get hook to the "connection" or "socket" object */
    };
    
    
    struct http_parser_settings {
        http_cb      on_message_begin;
        http_data_cb on_url;
        http_cb      on_status_complete;
        http_data_cb on_header_field;
        http_data_cb on_header_value;
        http_cb      on_headers_complete;
        http_data_cb on_body;
        http_cb      on_message_complete;
    };
    
    
    enum http_parser_url_fields
    { UF_SCHEMA           = 0
        , UF_HOST             = 1
        , UF_PORT             = 2
        , UF_PATH             = 3
        , UF_QUERY            = 4
        , UF_FRAGMENT         = 5
        , UF_USERINFO         = 6
        , UF_MAX              = 7
    };
    
    
    /* Result structure for http_parser_parse_url().
     *
     * Callers should index into field_data[] with UF_* values iff field_set
     * has the relevant (1 << UF_*) bit set. As a courtesy to clients (and
     * because we probably have padding left over), we convert any port to
     * a uint16_t.
     */
    struct http_parser_url {
        uint16_t field_set;           /* Bitmask of (1 << UF_*) values */
        uint16_t port;                /* Converted UF_PORT string */
        
        struct {
            uint16_t off;               /* Offset into buffer in which field starts */
            uint16_t len;               /* Length of run in buffer */
        } field_data[UF_MAX];
    };
    
    
    void http_parser_init(http_parser *parser, enum http_parser_type type);
    
    
    size_t http_parser_execute(http_parser *parser,
                               const http_parser_settings *settings,
                               const char *data,
                               size_t len);
    
    
    /* If http_should_keep_alive() in the on_headers_complete or
     * on_message_complete callback returns 0, then this should be
     * the last message on the connection.
     * If you are the server, respond with the "Connection: close" header.
     * If you are the client, close the connection.
     */
    int http_should_keep_alive(const http_parser *parser);
    
    /* Returns a string version of the HTTP method. */
    const char *http_method_str(enum http_method m);
    
    /* Return a string name of the given error */
    const char *http_errno_name(enum http_errno err);
    
    /* Return a string description of the given error */
    const char *http_errno_description(enum http_errno err);
    
    /* Parse a URL; return nonzero on failure */
    int http_parser_parse_url(const char *buf, size_t buflen,
                              int is_connect,
                              struct http_parser_url *u);
    
    /* Pause or un-pause the parser; a nonzero value pauses */
    void http_parser_pause(http_parser *parser, int paused);
    
    /* Checks if this is the final chunk of the body. */
    int http_body_is_final(const http_parser *parser);
    
#ifdef __cplusplus
}
#endif
#endif

/**
 * used to resolve the http uri.
 */
class SrsHttpUri
{
private:
    std::string url;
    std::string schema;
    std::string host;
    int port;
    std::string path;
    std::string query;
public:
    SrsHttpUri();
    virtual ~SrsHttpUri();
public:
    /**
     * initialize the http uri.
     */
    virtual srs_error_t initialize(std::string _url);
public:
    virtual std::string get_url();
    virtual std::string get_schema();
    virtual std::string get_host();
    virtual int get_port();
    virtual std::string get_path();
    virtual std::string get_query();
private:
    /**
     * get the parsed url field.
     * @return return empty string if not set.
     */
    virtual std::string get_uri_field(std::string uri, http_parser_url* hp_u, http_parser_url_fields field);
};

#endif

// following is generated by src/protocol/srs_protocol_kbps.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_PROTOCOL_KBPS_HPP
#define SRS_PROTOCOL_KBPS_HPP

//#include <srs_core.hpp>

//#include <srs_protocol_io.hpp>

/**
 * a kbps sample, for example, 1minute kbps,
 * 10minute kbps sample.
 */
class SrsKbpsSample
{
public:
    int64_t bytes;
    int64_t time;
    int kbps;
public:
    SrsKbpsSample();
};

/**
 * a slice of kbps statistic, for input or output.
 * a slice contains a set of sessions, which has a base offset of bytes,
 * where a slice is:
 *       starttime(oldest session startup time)
 *               bytes(total bytes of previous sessions)
 *               io_bytes_base(bytes offset of current session)
 *                       last_bytes(bytes of current session)
 * so, the total send bytes now is:
 *       send_bytes = bytes + last_bytes - io_bytes_base
 * so, the bytes sent duration current session is:
 *       send_bytes = last_bytes - io_bytes_base
 * @remark use set_io to start new session.
 * @remakr the slice is a data collection object driven by SrsKbps.
 */
class SrsKbpsSlice
{
private:
    union slice_io {
        ISrsProtocolStatistic* in;
        ISrsProtocolStatistic* out;
    };
public:
    // the slice io used for SrsKbps to invoke,
    // the SrsKbpsSlice itself never use it.
    slice_io io;
    // session startup bytes
    // @remark, use total_bytes() to get the total bytes of slice.
    int64_t bytes;
    // slice starttime, the first time to record bytes.
    int64_t starttime;
    // session startup bytes number for io when set it,
    // the base offset of bytes for io.
    int64_t io_bytes_base;
    // last updated bytes number,
    // cache for io maybe freed.
    int64_t last_bytes;
    // samples
    SrsKbpsSample sample_30s;
    SrsKbpsSample sample_1m;
    SrsKbpsSample sample_5m;
    SrsKbpsSample sample_60m;
public:
    // for the delta bytes.
    int64_t delta_bytes;
public:
    SrsKbpsSlice();
    virtual ~SrsKbpsSlice();
public:
    // Get current total bytes, not depend on sample().
    virtual int64_t get_total_bytes();
    // Resample the slice to calculate the kbps.
    virtual void sample();
};

/**
 * the interface which provices delta of bytes.
 * for a delta, for example, a live stream connection, we can got the delta by:
 *       IKbpsDelta* delta = ...;
 *       delta->resample();
 *       kbps->add_delta(delta);
 *       delta->cleanup();
 */
class IKbpsDelta
{
public:
    IKbpsDelta();
    virtual ~IKbpsDelta();
public:
    /**
     * resample to generate the value of delta bytes.
     */
    virtual void resample() = 0;
    /**
     * get the send or recv bytes delta.
     */
    virtual int64_t get_send_bytes_delta() = 0;
    virtual int64_t get_recv_bytes_delta() = 0;
    /**
     * cleanup the value of delta bytes.
     */
    virtual void cleanup() = 0;
};

/**
 * to statistic the kbps of io.
 * itself can be a statistic source, for example, used for SRS bytes stat.
 * there are some usage scenarios:
 * 1. connections to calc kbps by sample():
 *       SrsKbps* kbps = ...;
 *       kbps->set_io(in, out)
 *       kbps->sample()
 *       kbps->get_xxx_kbps().
 *   the connections know how many bytes already send/recv.
 * 2. server to calc kbps by add_delta():
 *       SrsKbps* kbps = ...;
 *       kbps->set_io(NULL, NULL)
 *       for each connection in connections:
 *           IKbpsDelta* delta = connection; // where connection implements IKbpsDelta
 *           delta->resample()
 *           kbps->add_delta(delta)
 *           delta->cleanup()
 *       kbps->sample()
 *       kbps->get_xxx_kbps().
 * 3. kbps used as IKbpsDelta, to provides delta bytes:
 *      SrsKbps* kbps = ...;
 *      kbps->set_io(in, out);
 *      IKbpsDelta* delta = (IKbpsDelta*)kbps;
 *      delta->resample();
 *      printf("delta is %d/%d", delta->get_send_bytes_delta(), delta->get_recv_bytes_delta());
 *      delta->cleanup();
 * 4. kbps used as ISrsProtocolStatistic, to provides raw bytes:
 *      SrsKbps* kbps = ...;
 *      kbps->set_io(in, out);
 *      // both kbps->get_recv_bytes() and kbps->get_send_bytes() are available.
 *       // we can use the kbps as the data source of another kbps:
 *      SrsKbps* user = ...;
 *      user->set_io(kbps, kbps);
 *   the server never know how many bytes already send/recv, for the connection maybe closed.
 */
class SrsKbps : public virtual ISrsProtocolStatistic, public virtual IKbpsDelta
{
private:
    SrsKbpsSlice is;
    SrsKbpsSlice os;
public:
    SrsKbps();
    virtual ~SrsKbps();
public:
    /**
     * set io to start new session.
     * set the underlayer reader/writer,
     * if the io destroied, for instance, the forwarder reconnect,
     * user must set the io of SrsKbps to NULL to continue to use the kbps object.
     * @param in the input stream statistic. can be NULL.
     * @param out the output stream statistic. can be NULL.
     * @remark if in/out is NULL, use the cached data for kbps.
     * @remark User must set_io(NULL, NULL) then free the in and out.
     */
    virtual void set_io(ISrsProtocolStatistic* in, ISrsProtocolStatistic* out);
public:
    /**
     * get total kbps, duration is from the startup of io.
     * @remark, use sample() to update data.
     */
    virtual int get_send_kbps();
    virtual int get_recv_kbps();
    // 30s
    virtual int get_send_kbps_30s();
    virtual int get_recv_kbps_30s();
    // 5m
    virtual int get_send_kbps_5m();
    virtual int get_recv_kbps_5m();
// interface ISrsProtocolStatistic
public:
    virtual int64_t get_send_bytes();
    virtual int64_t get_recv_bytes();
// interface IKbpsDelta
public:
    virtual void resample();
    virtual int64_t get_send_bytes_delta();
    virtual int64_t get_recv_bytes_delta();
    virtual void cleanup();
public:
    /**
     * add delta to kbps clac mechenism.
     * we donot know the total bytes, but know the delta, for instance,
     * for rtmp server to calc total bytes and kbps.
     * @remark user must invoke sample() to calc result after invoke this method.
     * @param delta, assert should never be NULL.
     */
    virtual void add_delta(IKbpsDelta* delta);
    /**
     * resample all samples, ignore if in/out is NULL.
     * used for user to calc the kbps, to sample new kbps value.
     * @remark if user, for instance, the rtmp server to calc the total bytes,
     *       use the add_delta() is better solutions.
     */
    virtual void sample();
// interface ISrsMemorySizer
public:
    virtual int size_memory();
};

#endif
// following is generated by src/protocol/srs_protocol_json.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_PROTOCOL_JSON_HPP
#define SRS_PROTOCOL_JSON_HPP

//#include <srs_core.hpp>

#include <string>
#include <vector>

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
// json decode
// 1. SrsJsonAny: read any from str:char*
//        SrsJsonAny* any = NULL;
//        if ((any = SrsJsonAny::loads(str)) == NULL) {
//            return -1;
//         }
//        srs_assert(pany); // if success, always valid object.
// 2. SrsJsonAny: convert to specifid type, for instance, string
//        SrsJsonAny* any = ...
//        if (any->is_string()) {
//            string v = any->to_str();
//        }
//
// for detail usage, see interfaces of each object.
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
// @see: https://github.com/udp/json-parser

class SrsAmf0Any;
class SrsJsonArray;
class SrsJsonObject;

class SrsJsonAny
{
public:
    char marker;
    // donot directly create this object,
    // instead, for examle, use SrsJsonAny::str() to create a concreated one.
protected:
    SrsJsonAny();
public:
    virtual ~SrsJsonAny();
public:
    virtual bool is_string();
    virtual bool is_boolean();
    virtual bool is_integer();
    virtual bool is_number();
    virtual bool is_object();
    virtual bool is_array();
    virtual bool is_null();
public:
    /**
     * get the string of any when is_string() indicates true.
     * user must ensure the type is a string, or assert failed.
     */
    virtual std::string to_str();
    /**
     * get the boolean of any when is_boolean() indicates true.
     * user must ensure the type is a boolean, or assert failed.
     */
    virtual bool to_boolean();
    /**
     * get the integer of any when is_integer() indicates true.
     * user must ensure the type is a integer, or assert failed.
     */
    virtual int64_t to_integer();
    /**
     * get the number of any when is_number() indicates true.
     * user must ensure the type is a number, or assert failed.
     */
    virtual double to_number();
    /**
     * get the object of any when is_object() indicates true.
     * user must ensure the type is a object, or assert failed.
     */
    virtual SrsJsonObject* to_object();
    /**
     * get the ecma array of any when is_ecma_array() indicates true.
     * user must ensure the type is a ecma array, or assert failed.
     */
    virtual SrsJsonArray* to_array();
public:
    virtual std::string dumps();
    virtual SrsAmf0Any* to_amf0();
public:
    static SrsJsonAny* str(const char* value = NULL);
    static SrsJsonAny* str(const char* value, int length);
    static SrsJsonAny* boolean(bool value = false);
    static SrsJsonAny* integer(int64_t value = 0);
    static SrsJsonAny* number(double value = 0.0);
    static SrsJsonAny* null();
    static SrsJsonObject* object();
    static SrsJsonArray* array();
public:
    /**
     * read json tree from string.
     * @return json object. NULL if error.
     */
    static SrsJsonAny* loads(const std::string& str);
};

class SrsJsonObject : public SrsJsonAny
{
private:
    typedef std::pair<std::string, SrsJsonAny*> SrsJsonObjectPropertyType;
    std::vector<SrsJsonObjectPropertyType> properties;
private:
    // use SrsJsonAny::object() to create it.
    friend class SrsJsonAny;
    SrsJsonObject();
public:
    virtual ~SrsJsonObject();
public:
    virtual int count();
    // @remark: max index is count().
    virtual std::string key_at(int index);
    // @remark: max index is count().
    virtual SrsJsonAny* value_at(int index);
public:
    virtual std::string dumps();
    virtual SrsAmf0Any* to_amf0();
public:
    virtual SrsJsonObject* set(std::string key, SrsJsonAny* value);
    virtual SrsJsonAny* get_property(std::string name);
    virtual SrsJsonAny* ensure_property_string(std::string name);
    virtual SrsJsonAny* ensure_property_integer(std::string name);
    virtual SrsJsonAny* ensure_property_number(std::string name);
    virtual SrsJsonAny* ensure_property_boolean(std::string name);
    virtual SrsJsonAny* ensure_property_object(std::string name);
    virtual SrsJsonAny* ensure_property_array(std::string name);
};

class SrsJsonArray : public SrsJsonAny
{
private:
    std::vector<SrsJsonAny*> properties;
    
private:
    // use SrsJsonAny::array() to create it.
    friend class SrsJsonAny;
    SrsJsonArray();
public:
    virtual ~SrsJsonArray();
public:
    virtual int count();
    // @remark: max index is count().
    virtual SrsJsonAny* at(int index);
    virtual void add(SrsJsonAny* value);
    // alias to add.
    virtual SrsJsonArray* append(SrsJsonAny* value);
public:
    virtual std::string dumps();
    virtual SrsAmf0Any* to_amf0();
};

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
// json encode, please use JSON.dumps() to encode json object.

#endif
// following is generated by src/protocol/srs_kafka_stack.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_PROTOCOL_KAFKA_HPP
#define SRS_PROTOCOL_KAFKA_HPP

//#include <srs_core.hpp>

#include <vector>
#include <string>
#include <map>

//#include <srs_kernel_buffer.hpp>
//#include <srs_kernel_error.hpp>
//#include <srs_kernel_log.hpp>

class SrsFastStream;
class ISrsProtocolReaderWriter;
class SrsJsonObject;

#ifdef SRS_AUTO_KAFKA

/**
 * the api key used to identify the request type.
 * @see https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-ApiKeys
 */
enum SrsKafkaApiKey
{
    SrsKafkaApiKeyUnknown = -1,
    
    SrsKafkaApiKeyProduceRequest = 0,
    SrsKafkaApiKeyFetchRequest = 1,
    SrsKafkaApiKeyOffsetRequest = 2,
    SrsKafkaApiKeyMetadataRequest = 3,
    /* Non-user facing control APIs 4-7 */
    SrsKafkaApiKeyOffsetCommitRequest = 8,
    SrsKafkaApiKeyOffsetFetchRequest = 9,
    SrsKafkaApiKeyConsumerMetadataRequest = 10,
};

/**
 * These types consist of a signed integer giving a length N followed by N bytes of content.
 * A length of -1 indicates null. string uses an int16 for its size, and bytes uses an int32.
 * @see https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-ProtocolPrimitiveTypes
 */
class SrsKafkaString : public ISrsCodec
{
private:
    int16_t _size;
    char* data;
public:
    SrsKafkaString();
    SrsKafkaString(std::string v);
    virtual ~SrsKafkaString();
public:
    virtual bool null();
    virtual bool empty();
    virtual std::string to_str();
    virtual void set_value(std::string v);
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};

/**
 * These types consist of a signed integer giving a length N followed by N bytes of content.
 * A length of -1 indicates null. string uses an int16 for its size, and bytes uses an int32.
 * @see https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-ProtocolPrimitiveTypes
 */
class SrsKafkaBytes : public ISrsCodec
{
private:
    int32_t _size;
    char* _data;
public:
    SrsKafkaBytes();
    SrsKafkaBytes(const char* v, int nb_v);
    virtual ~SrsKafkaBytes();
public:
    virtual char* data();
    virtual int size();
    virtual bool null();
    virtual bool empty();
    virtual void set_value(std::string v);
    virtual void set_value(const char* v, int nb_v);
    virtual uint32_t crc32(uint32_t previous);
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};

/**
 * This is a notation for handling repeated structures. These will always be encoded as an
 * int32 size containing the length N followed by N repetitions of the structure which can
 * itself be made up of other primitive types. In the BNF grammars below we will show an
 * array of a structure foo as [foo].
 *
 * Usage:
 *      SrsKafkaArray<SrsKafkaBytes> body;
 *      body.append(new SrsKafkaBytes());
 * @remark array elem is the T*, which must be ISrsCodec*
 *
 * @see https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-Requests
 */
template<typename T>
class SrsKafkaArray : public ISrsCodec
{
private:
    int32_t length;
    std::vector<T*> elems;
    typedef typename std::vector<T*>::iterator SrsIterator;
public:
    SrsKafkaArray()
    {
        length = 0;
    }
    virtual ~SrsKafkaArray()
    {
        for (SrsIterator it = elems.begin(); it != elems.end(); ++it) {
            T* elem = *it;
            srs_freep(elem);
        }
        elems.clear();
    }
public:
    virtual void append(T* elem)
    {
        length++;
        elems.push_back(elem);
    }
    virtual int size()
    {
        return length;
    }
    virtual bool empty()
    {
        return elems.empty();
    }
    virtual T* at(int index)
    {
        return elems.at(index);
    }
// interface ISrsCodec
public:
    virtual int nb_bytes()
    {
        int s = 4;
        
        for (SrsIterator it = elems.begin(); it != elems.end(); ++it) {
            T* elem = *it;
            s += elem->nb_bytes();
        }
        
        return s;
    }
    virtual srs_error_t encode(SrsBuffer* buf)
    {
        srs_error_t err = srs_success;
        
        if (!buf->require(4)) {
            return srs_error_new(ERROR_KAFKA_CODEC_ARRAY, "requires 4 only %d bytes", buf->left());
        }
        buf->write_4bytes(length);
        
        for (SrsIterator it = elems.begin(); it != elems.end(); ++it) {
            T* elem = *it;
            if ((err = elem->encode(buf)) != srs_success) {
                return srs_error_wrap(err, "encode elem");
            }
        }
        
        return err;
    }
    virtual srs_error_t decode(SrsBuffer* buf)
    {
        srs_error_t err = srs_success;
        
        if (!buf->require(4)) {
            return srs_error_new(ERROR_KAFKA_CODEC_ARRAY, "requires 4 only %d bytes", buf->left());
        }
        length = buf->read_4bytes();
        
        for (int i = 0; i < length; i++) {
            T* elem = new T();
            if ((err = elem->decode(buf)) != srs_success) {
                srs_freep(elem);
                return srs_error_wrap(err, "decode elem");
            }
            
            elems.push_back(elem);
        }
        
        return err;
    }
};
template<>
class SrsKafkaArray<int32_t> : public ISrsCodec
{
private:
    int32_t length;
    std::vector<int32_t> elems;
    typedef std::vector<int32_t>::iterator SrsIterator;
public:
    SrsKafkaArray()
    {
        length = 0;
    }
    virtual ~SrsKafkaArray()
    {
        elems.clear();
    }
public:
    virtual void append(int32_t elem)
    {
        length++;
        elems.push_back(elem);
    }
    virtual int size()
    {
        return length;
    }
    virtual bool empty()
    {
        return elems.empty();
    }
    virtual int32_t at(int index)
    {
        return elems.at(index);
    }
// interface ISrsCodec
public:
    virtual int nb_bytes()
    {
        return 4 + 4 * (int)elems.size();
    }
    virtual srs_error_t encode(SrsBuffer* buf)
    {
        srs_error_t err = srs_success;
        
        int nb_required = 4 + sizeof(int32_t) * (int)elems.size();
        if (!buf->require(nb_required)) {
            return srs_error_new(ERROR_KAFKA_CODEC_ARRAY, "requires %d only %d bytes", nb_required, buf->left());
        }
        buf->write_4bytes(length);
        
        for (SrsIterator it = elems.begin(); it != elems.end(); ++it) {
            int32_t elem = *it;
            buf->write_4bytes(elem);
        }
        
        return err;
    }
    virtual srs_error_t decode(SrsBuffer* buf)
    {
        srs_error_t err = srs_success;
        
        if (!buf->require(4)) {
            return srs_error_new(ERROR_KAFKA_CODEC_ARRAY, "requires 4 only %d bytes", buf->left());
        }
        length = buf->read_4bytes();
        
        for (int i = 0; i < length; i++) {
            if (!buf->require(sizeof(int32_t))) {
                return srs_error_new(ERROR_KAFKA_CODEC_ARRAY, "requires %d only %d bytes", sizeof(int32_t), buf->left());
                
            }
            
            int32_t elem = buf->read_4bytes();
            elems.push_back(elem);
        }
        
        return err;
    }
};

/**
 * the header of request, includes the size of request.
 * @see https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-Requests
 */
class SrsKafkaRequestHeader : public ISrsCodec
{
private:
    /**
     * The MessageSize field gives the size of the subsequent request or response
     * message in bytes. The client can read requests by first reading this 4 byte
     * size as an integer N, and then reading and parsing the subsequent N bytes
     * of the request.
     */
    int32_t _size;
private:
    /**
     * This is a numeric id for the API being invoked (i.e. is it
     * a metadata request, a produce request, a fetch request, etc).
     * @remark MetadataRequest | ProduceRequest | FetchRequest | OffsetRequest | OffsetCommitRequest | OffsetFetchRequest
     */
    int16_t _api_key;
    /**
     * This is a numeric version number for this api. We version each API and
     * this version number allows the server to properly interpret the request
     * as the protocol evolves. Responses will always be in the format corresponding
     * to the request version. Currently the supported version for all APIs is 0.
     */
    int16_t api_version;
    /**
     * This is a user-supplied integer. It will be passed back in
     * the response by the server, unmodified. It is useful for matching
     * request and response between the client and server.
     */
    int32_t _correlation_id;
    /**
     * This is a user supplied identifier for the client application.
     * The user can use any identifier they like and it will be used
     * when logging errors, monitoring aggregates, etc. For example,
     * one might want to monitor not just the requests per second overall,
     * but the number coming from each client application (each of
     * which could reside on multiple servers). This id acts as a
     * logical grouping across all requests from a particular client.
     */
    SrsKafkaString* client_id;
public:
    SrsKafkaRequestHeader();
    virtual ~SrsKafkaRequestHeader();
private:
    /**
     * the layout of request:
     *      +-----------+----------------------------------+
     *      |  4B _size |      [_size] bytes               |
     *      +-----------+------------+---------------------+
     *      |  4B _size |   header   |    message          |
     *      +-----------+------------+---------------------+
     *      |  total size = 4 + header + message           |
     *      +----------------------------------------------+
     * where the header is specifies this request header without the start 4B size.
     * @remark size = 4 + header + message.
     */
    virtual int header_size();
    /**
     * the size of message, the bytes left after the header.
     */
    virtual int message_size();
    /**
     * the total size of the request, includes the 4B size.
     */
    virtual int total_size();
public:
    /**
     * when got the whole message size, update the header.
     * @param s the whole message, including the 4 bytes size size.
     */
    virtual void set_total_size(int s);
    /**
     * get the correlation id for message.
     */
    virtual int32_t correlation_id();
    /**
     * set the correlation id for message.
     */
    virtual void set_correlation_id(int32_t cid);
    /**
     * get the api key of header for message.
     */
    virtual SrsKafkaApiKey api_key();
    /**
     * set the api key of header for message.
     */
    virtual void set_api_key(SrsKafkaApiKey key);
public:
    /**
     * the api key enumeration.
     * @see https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-ApiKeys
     */
    virtual bool is_producer_request();
    virtual bool is_fetch_request();
    virtual bool is_offset_request();
    virtual bool is_metadata_request();
    virtual bool is_offset_commit_request();
    virtual bool is_offset_fetch_request();
    virtual bool is_consumer_metadata_request();
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};

/**
 * the header of response, include the size of response.
 * The response will always match the paired request (e.g. we will
 * send a MetadataResponse in return to a MetadataRequest).
 * @see https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-Responses
 */
class SrsKafkaResponseHeader : public ISrsCodec
{
private:
    /**
     * The MessageSize field gives the size of the subsequent request or response
     * message in bytes. The client can read requests by first reading this 4 byte
     * size as an integer N, and then reading and parsing the subsequent N bytes
     * of the request.
     */
    int32_t _size;
private:
    /**
     * This is a user-supplied integer. It will be passed back in
     * the response by the server, unmodified. It is useful for matching
     * request and response between the client and server.
     */
    int32_t _correlation_id;
public:
    SrsKafkaResponseHeader();
    virtual ~SrsKafkaResponseHeader();
private:
    /**
     * the layout of response:
     *      +-----------+----------------------------------+
     *      |  4B _size |      [_size] bytes               |
     *      +-----------+------------+---------------------+
     *      |  4B _size |  4B header |    message          |
     *      +-----------+------------+---------------------+
     *      |  total size = 4 + 4 + message                |
     *      +----------------------------------------------+
     * where the header is specifies this request header without the start 4B size.
     * @remark size = 4 + 4 + message.
     */
    virtual int header_size();
    /**
     * the size of message, the bytes left after the header.
     */
    virtual int message_size();
public:
    /**
     * the total size of the request, includes the 4B size and message body.
     */
    virtual int total_size();
public:
    /**
     * when got the whole message size, update the header.
     * @param s the whole message, including the 4 bytes size size.
     */
    virtual void set_total_size(int s);
    /**
     * get the correlation id of response message.
     */
    virtual int32_t correlation_id();
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};

/**
 * the kafka message in message set.
 * @see https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-Messagesets
 */
struct SrsKafkaRawMessage : public ISrsCodec
{
    // metadata.
public:
    /**
     * This is the offset used in kafka as the log sequence number. When the
     * producer is sending messages it doesn't actually know the offset and
     * can fill in any value here it likes.
     */
    int64_t offset;
    /**
     * the size of this message.
     */
    int32_t message_size;
    // message.
public:
    /**
     * The CRC is the CRC32 of the remainder of the message bytes.
     * This is used to check the integrity of the message on the broker and consumer.
     */
    int32_t crc;
    /**
     * This is a version id used to allow backwards compatible evolution
     * of the message binary format. The current value is 0.
     */
    int8_t magic_byte;
    /**
     * This byte holds metadata attributes about the message.
     * The lowest 2 bits contain the compression codec used
     * for the message. The other bits should be set to 0.
     */
    int8_t attributes;
    /**
     * The key is an optional message key that was used for
     * partition assignment. The key can be null.
     */
    SrsKafkaBytes* key;
    /**
     * The value is the actual message contents as an opaque byte array.
     * Kafka supports recursive messages in which case this may itself
     * contain a message set. The message can be null.
     */
    SrsKafkaBytes* value;
public:
    SrsKafkaRawMessage();
    virtual ~SrsKafkaRawMessage();
public:
    /**
     * create message from json object.
     */
    virtual srs_error_t create(SrsJsonObject* obj);
private:
    /**
     * get the raw message, bytes after the message_size.
     */
    virtual int raw_message_size();
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};

/**
 * a set of kafka message.
 * @see https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-Messagesets
 * @remark because the message set are not preceded by int32, so we decode the buffer util empty.
 */
class SrsKafkaRawMessageSet : public ISrsCodec
{
private:
    std::vector<SrsKafkaRawMessage*> messages;
public:
    SrsKafkaRawMessageSet();
    virtual ~SrsKafkaRawMessageSet();
public:
    virtual void append(SrsKafkaRawMessage* msg);
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};

/**
 * the kafka request message, for protocol to send.
 */
class SrsKafkaRequest : public ISrsCodec
{
protected:
    SrsKafkaRequestHeader header;
public:
    SrsKafkaRequest();
    virtual ~SrsKafkaRequest();
public:
    /**
     * update the size in header.
     * @param s an int value specifies the size of message in header.
     */
    virtual void update_header(int s);
    /**
     * get the correlation id of header for message.
     */
    virtual int32_t correlation_id();
    /**
     * get the api key of request.
     */
    virtual SrsKafkaApiKey api_key();
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};

/**
 * the kafka response message, for protocol to recv.
 */
class SrsKafkaResponse : public ISrsCodec
{
protected:
    SrsKafkaResponseHeader header;
public:
    SrsKafkaResponse();
    virtual ~SrsKafkaResponse();
public:
    /**
     * update the size in header.
     * @param s an int value specifies the size of message in header.
     */
    virtual void update_header(int s);
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};

/**
 * request the metadata from broker.
 * This API answers the following questions:
 *      What topics exist?
 *      How many partitions does each topic have?
 *      Which broker is currently the leader for each partition?
 *      What is the host and port for each of these brokers?
 * This is the only request that can be addressed to any broker in the cluster.
 *
 * Since there may be many topics the client can give an optional list of topic
 * names in order to only return metadata for a subset of topics.
 *
 * @see https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-MetadataAPI
 */
class SrsKafkaTopicMetadataRequest : public SrsKafkaRequest
{
private:
    SrsKafkaArray<SrsKafkaString> topics;
public:
    SrsKafkaTopicMetadataRequest();
    virtual ~SrsKafkaTopicMetadataRequest();
public:
    virtual void add_topic(std::string topic);
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};

/**
 * the metadata response data.
 * @see https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-MetadataResponse
 */
struct SrsKafkaBroker : public ISrsCodec
{
public:
    int32_t node_id;
    SrsKafkaString host;
    int32_t port;
public:
    SrsKafkaBroker();
    virtual ~SrsKafkaBroker();
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};
struct SrsKafkaPartitionMetadata : public ISrsCodec
{
public:
    int16_t error_code;
    int32_t partition_id;
    int32_t leader;
    SrsKafkaArray<int32_t> replicas;
    SrsKafkaArray<int32_t> isr;
public:
    SrsKafkaPartitionMetadata();
    virtual ~SrsKafkaPartitionMetadata();
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};
struct SrsKafkaTopicMetadata : public ISrsCodec
{
public:
    int16_t error_code;
    SrsKafkaString name;
    SrsKafkaArray<SrsKafkaPartitionMetadata> metadatas;
public:
    SrsKafkaTopicMetadata();
    virtual ~SrsKafkaTopicMetadata();
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};

/**
 * response for the metadata request from broker.
 * The response contains metadata for each partition,
 * with partitions grouped together by topic. This
 * metadata refers to brokers by their broker id.
 * The brokers each have a host and port.
 * @see https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-MetadataResponse
 */
class SrsKafkaTopicMetadataResponse : public SrsKafkaResponse
{
public:
    SrsKafkaArray<SrsKafkaBroker> brokers;
    SrsKafkaArray<SrsKafkaTopicMetadata> metadatas;
public:
    SrsKafkaTopicMetadataResponse();
    virtual ~SrsKafkaTopicMetadataResponse();
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};


/**
 * the messages for producer to send.
 * @see https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-ProduceRequest
 */
struct SrsKafkaProducerPartitionMessages : public ISrsCodec
{
public:
    /**
     * The partition that data is being published to.
     */
    int32_t partition;
    /**
     * The size, in bytes, of the message set that follows.
     */
    int32_t message_set_size;
    /**
     * messages in set.
     */
    SrsKafkaRawMessageSet messages;
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};
struct SrsKafkaProducerTopicMessages : public ISrsCodec
{
public:
    /**
     * The topic that data is being published to.
     */
    SrsKafkaString topic_name;
    /**
     * messages of partitions.
     */
    SrsKafkaArray<SrsKafkaProducerPartitionMessages> partitions;
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};

/**
 * the request for producer to send message.
 * @see https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-ProduceRequest
 */
class SrsKafkaProducerRequest : public SrsKafkaRequest
{
public:
    /**
     * This field indicates how many acknowledgements the servers should receive
     * before responding to the request. If it is 0 the server will not send any
     * response (this is the only case where the server will not reply to a request).
     * If it is 1, the server will wait the data is written to the local log
     * before sending a response. If it is -1 the server will block until the
     * message is committed by all in sync replicas before sending a response.
     * For any number > 1 the server will block waiting for this number of
     * acknowledgements to occur (but the server will never wait for more
     * acknowledgements than there are in-sync replicas).
     */
    int16_t required_acks;
    /**
     * This provides a maximum time in milliseconds the server can await the receipt
     * of the number of acknowledgements in RequiredAcks. The timeout is not an exact
     * limit on the request time for a few reasons: (1) it does not include network
     * latency, (2) the timer begins at the beginning of the processing of this request
     * so if many requests are queued due to server overload that wait time will not
     * be included, (3) we will not terminate a local write so if the local write
     * time exceeds this timeout it will not be respected. To get a hard timeout of
     * this type the client should use the socket timeout.
     */
    int32_t timeout;
    /**
     * messages of topics.
     */
    SrsKafkaArray<SrsKafkaProducerTopicMessages> topics;
public:
    SrsKafkaProducerRequest();
    virtual ~SrsKafkaProducerRequest();
// interface ISrsCodec
public:
    virtual int nb_bytes();
    virtual srs_error_t encode(SrsBuffer* buf);
    virtual srs_error_t decode(SrsBuffer* buf);
};

/**
 * the poll to discovery reponse.
 * @param CorrelationId This is a user-supplied integer. It will be passed back
 *          in the response by the server, unmodified. It is useful for matching
 *          request and response between the client and server.
 * @see https://cwiki.apache.org/confluence/display/KAFKA/A+Guide+To+The+Kafka+Protocol#AGuideToTheKafkaProtocol-Requests
 */
class SrsKafkaCorrelationPool
{
private:
    static SrsKafkaCorrelationPool* _instance;
public:
    static SrsKafkaCorrelationPool* instance();
private:
    std::map<int32_t, SrsKafkaApiKey> correlation_ids;
private:
    SrsKafkaCorrelationPool();
public:
    virtual ~SrsKafkaCorrelationPool();
public:
    /**
     * generate a global correlation id.
     */
    virtual int32_t generate_correlation_id();
    /**
     * set the correlation id to specified request key.
     */
    virtual SrsKafkaApiKey set(int32_t correlation_id, SrsKafkaApiKey request);
    /**
     * unset the correlation id.
     * @return the previous api key; unknown if not set.
     */
    virtual SrsKafkaApiKey unset(int32_t correlation_id);
    /**
     * get the key by specified correlation id.
     * @return the specified api key; unknown if no correlation id.
     */
    virtual SrsKafkaApiKey get(int32_t correlation_id);
};

/**
 * the kafka protocol stack, use to send and recv kakfa messages.
 */
class SrsKafkaProtocol
{
private:
    ISrsProtocolReaderWriter* skt;
    SrsFastStream* reader;
public:
    SrsKafkaProtocol(ISrsProtocolReaderWriter* io);
    virtual ~SrsKafkaProtocol();
public:
    /**
     * write the message to kafka server.
     * @param msg the msg to send. user must not free it again.
     */
    virtual srs_error_t send_and_free_message(SrsKafkaRequest* msg);
    /**
     * read the message from kafka server.
     * @param pmsg output the received message. user must free it.
     */
    virtual srs_error_t recv_message(SrsKafkaResponse** pmsg);
public:
    /**
     * expect specified message.
     */
    template<typename T>
    srs_error_t expect_message(T** pmsg)
    {
        srs_error_t err = srs_success;
        
        while (true) {
            SrsKafkaResponse* res = NULL;
            if ((err = recv_message(&res)) != srs_success) {
                return srs_error_wrap(err, "recv message");
            }
            
            // drop not matched.
            T* msg = dynamic_cast<T*>(res);
            if (!msg) {
                srs_info("kafka drop response.");
                srs_freep(res);
                continue;
            }
            
            *pmsg = msg;
            break;
        }
        
        return err;
    }
};

/**
 * the kafka client, for producer or consumer.
 */
class SrsKafkaClient
{
private:
    SrsKafkaProtocol* protocol;
public:
    SrsKafkaClient(ISrsProtocolReaderWriter* io);
    virtual ~SrsKafkaClient();
public:
    /**
     * fetch the metadata from broker for topic.
     */
    virtual srs_error_t fetch_metadata(std::string topic, SrsKafkaTopicMetadataResponse** pmsg);
    /**
     * write the messages to partition of topic.
     */
    virtual srs_error_t write_messages(std::string topic, int32_t partition, std::vector<SrsJsonObject*>& msgs);
};

// convert kafka array[string] to vector[string]
extern std::vector<std::string> srs_kafka_array2vector(SrsKafkaArray<SrsKafkaString>* arr);
extern std::vector<std::string> srs_kafka_array2vector(SrsKafkaArray<int32_t>* arr);

#endif

#endif

// following is generated by src/protocol/srs_protocol_format.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_PROTOCOL_FORMAT_HPP
#define SRS_PROTOCOL_FORMAT_HPP

//#include <srs_core.hpp>

//#include <srs_kernel_codec.hpp>

class SrsOnMetaDataPacket;
class SrsSharedPtrMessage;

/**
 * Create special structure from RTMP stream, for example, the metadata.
 */
class SrsRtmpFormat : public SrsFormat
{
public:
    SrsRtmpFormat();
    virtual ~SrsRtmpFormat();
public:
    // Initialize the format from metadata, optional.
    virtual srs_error_t on_metadata(SrsOnMetaDataPacket* meta);
    // When got a parsed audio packet.
    virtual srs_error_t on_audio(SrsSharedPtrMessage* shared_audio);
    virtual srs_error_t on_audio(int64_t timestamp, char* data, int size);
    // When got a parsed video packet.
    virtual srs_error_t on_video(SrsSharedPtrMessage* shared_video);
    virtual srs_error_t on_video(int64_t timestamp, char* data, int size);
};

#endif

// following is generated by src/libs/srs_librtmp.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_LIB_RTMP_HPP
#define SRS_LIB_RTMP_HPP

/**
 * srs-librtmp is a librtmp like library,
 * used to play/publish rtmp stream from/to rtmp server.
 * socket: use sync and block socket to connect/recv/send data with server.
 * depends: no need other libraries; depends on ssl if use srs_complex_handshake.
 * thread-safe: no
 */

// @see http://blog.csdn.net/win_lin/article/details/7912693
#ifndef __STDC_FORMAT_MACROS
    #define __STDC_FORMAT_MACROS
#endif

/*************************************************************
 **************************************************************
 * Windows SRS-LIBRTMP pre-declare
 **************************************************************
 *************************************************************/
// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifdef _WIN32
// include windows first.
#include <windows.h>
// the type used by this header for windows.
typedef unsigned long long u_int64_t;
typedef u_int64_t uint64_t;
typedef long long int64_t;
typedef unsigned int u_int32_t;
typedef u_int32_t uint32_t;
typedef int int32_t;
typedef unsigned char u_int8_t;
typedef u_int8_t uint8_t;
typedef char int8_t;
typedef unsigned short u_int16_t;
typedef u_int16_t uint16_t;
typedef short int16_t;
typedef int64_t ssize_t;
struct iovec {
    void  *iov_base;    /* Starting address */
    size_t iov_len;     /* Number of bytes to transfer */
};

// for pid.
typedef int pid_t;
pid_t getpid(void);
#endif

#include <stdint.h>
#include <sys/types.h>

#ifdef __cplusplus
extern "C"{
#endif
    
/**
 * The schema of RTMP url, the following are legal urls:
 *     srs_url_schema_normal:    rtmp://vhost:port/app/stream
 *     srs_url_schema_via   :    rtmp://ip:port/vhost/app/stream
 *     srs_url_schema_vis   :    rtmp://ip:port/app/stream?vhost=xxx
 *     srs_url_schema_vis2  :    rtmp://ip:port/app/stream?domain=xxx
 */
enum srs_url_schema
{
    // Forbidden.
    srs_url_schema_forbidden = 0,
    // Normal RTMP URL, the vhost put in host field, using DNS to resolve the server ip.
    // For example, rtmp://vhost:port/app/stream
    srs_url_schema_normal,
    // VIA(vhost in app), the vhost put in app field.
    // For example, rtmp://ip:port/vhost/app/stream
    srs_url_schema_via,
    // VIS(vhost in stream), the vhost put in query string, keyword use vhost=xxx.
    // For example, rtmp://ip:port/app/stream?vhost=xxx
    srs_url_schema_vis,
    // VIS, keyword use domain=xxx.
    // For example, rtmp://ip:port/app/stream?domain=xxx
    srs_url_schema_vis2
};

// typedefs
typedef int srs_bool;

/*************************************************************
 **************************************************************
 * srs-librtmp version
 **************************************************************
 *************************************************************/
extern int srs_version_major();
extern int srs_version_minor();
extern int srs_version_revision();

/*************************************************************
 **************************************************************
 * RTMP protocol context
 **************************************************************
 *************************************************************/
// the RTMP handler.
typedef void* srs_rtmp_t;
typedef void* srs_amf0_t;

/**
 * Create a RTMP handler.
 * @param url The RTMP url, for example, rtmp://localhost/live/livestream
 * @remark default timeout to 30s if not set by srs_rtmp_set_timeout.
 * @remark default schema to srs_url_schema_normal, use srs_rtmp_set_schema to change it.
 *
 * @return a rtmp handler, or NULL if error occured.
 */
extern srs_rtmp_t srs_rtmp_create(const char* url);
/**
 * set socket timeout
 * @param recv_timeout_ms the timeout for receiving messages in ms.
 * @param send_timeout_ms the timeout for sending message in ms.
 * @remark user can set timeout once srs_rtmp_create/srs_rtmp_create2,
 *      or before srs_rtmp_handshake or srs_rtmp_dns_resolve to connect to server.
 * @remark default timeout to 30s if not set by srs_rtmp_set_timeout.
 *
 * @return 0, success; otherswise, failed.
 */
extern int srs_rtmp_set_timeout(srs_rtmp_t rtmp, int recv_timeout_ms, int send_timeout_ms);
/**
 * close and destroy the rtmp stack.
 * @remark, user should never use the rtmp again.
 */
extern void srs_rtmp_destroy(srs_rtmp_t rtmp);

/*************************************************************
 **************************************************************
 * RTMP protocol stack
 **************************************************************
 *************************************************************/
/**
 * connect and handshake with server
 * category: publish/play
 * previous: rtmp-create
 * next: connect-app
 *
 * @return 0, success; otherswise, failed.
 */
/**
 * simple handshake specifies in rtmp 1.0,
 * not depends on ssl.
 */
/**
 * srs_rtmp_handshake equals to invoke:
 *       srs_rtmp_dns_resolve()
 *       srs_rtmp_connect_server()
 *       srs_rtmp_do_simple_handshake()
 * user can use these functions if needed.
 */
extern int srs_rtmp_handshake(srs_rtmp_t rtmp);
// parse uri, create socket, resolve host
extern int srs_rtmp_dns_resolve(srs_rtmp_t rtmp);
// connect socket to server
extern int srs_rtmp_connect_server(srs_rtmp_t rtmp);
// do simple handshake over socket.
extern int srs_rtmp_do_simple_handshake(srs_rtmp_t rtmp);
// do complex handshake over socket.
extern int srs_rtmp_do_complex_handshake(srs_rtmp_t rtmp);

/**
 * set the args of connect packet for rtmp.
 * @param args, the extra amf0 object args.
 * @remark, all params can be NULL to ignore.
 * @remark, user should never free the args for we directly use it.
 */
extern int srs_rtmp_set_connect_args(srs_rtmp_t rtmp, const char* tcUrl, const char* swfUrl, const char* pageUrl, srs_amf0_t args);

/**
 * Set the schema of URL when connect to tcUrl by srs_rtmp_connect_app.
 * @param schema, The schema of URL, @see srs_url_schema.
 * @return 0, success; otherswise, failed.
 */
extern int srs_rtmp_set_schema(srs_rtmp_t rtmp, enum srs_url_schema schema);

/**
 * Connect to RTMP tcUrl(Vhost/App), similar to flash AS3 NetConnection.connect(tcUrl).
 * @remark When connected to server, user can retrieve informations from RTMP handler,
 *      for example, use srs_rtmp_get_server_id to get server ip/pid/cid.
 * @return 0, success; otherswise, failed.
 */
extern int srs_rtmp_connect_app(srs_rtmp_t rtmp);

/**
 * Retrieve server ip from RTMP handler.
 * @param ip A NULL terminated string specifies the server ip.
 * @param pid An int specifies the PID of server. -1 is no PID information.
 * @param cid An int specifies the CID of connection. -1 is no CID information.
 * @remark For SRS, ip/pid/cid is the UUID of a client. For other server, these values maybe unknown.
 * @remark When connected to server by srs_rtmp_connect_app, the information is ready to be retrieved.
 * @return 0, success; otherswise, failed.
 */
extern int srs_rtmp_get_server_id(srs_rtmp_t rtmp, char** ip, int* pid, int* cid);

/**
 * Retrieve server signature from RTMP handler.
 * @param sig A NULL terminated string specifies the server signature.
 * @remark When connected to server by srs_rtmp_connect_app, the information is ready to be retrieved.
 * @return 0, success; otherswise, failed.
 */
extern int srs_rtmp_get_server_sig(srs_rtmp_t rtmp, char** sig);

/**
 * Retrieve server version from RTMP handler, which in major.minor.revision.build format.
 * @remark When connected to server by srs_rtmp_connect_app, the information is ready to be retrieved.
 * @return 0, success; otherswise, failed.
 */
extern int srs_rtmp_get_server_version(srs_rtmp_t rtmp, int* major, int* minor, int* revision, int* build);

/**
 * play a live/vod stream.
 * category: play
 * previous: connect-app
 * next: destroy
 * @return 0, success; otherwise, failed.
 */
extern int srs_rtmp_play_stream(srs_rtmp_t rtmp);

/**
 * publish a live stream.
 * category: publish
 * previous: connect-app
 * next: destroy
 * @return 0, success; otherwise, failed.
 */
extern int srs_rtmp_publish_stream(srs_rtmp_t rtmp);

/**
 * do bandwidth check with srs server.
 *
 * bandwidth info:
 * @param start_time, output the start time, in ms.
 * @param end_time, output the end time, in ms.
 * @param play_kbps, output the play/download kbps.
 * @param publish_kbps, output the publish/upload kbps.
 * @param play_bytes, output the play/download bytes.
 * @param publish_bytes, output the publish/upload bytes.
 * @param play_duration, output the play/download test duration, in ms.
 * @param publish_duration, output the publish/upload test duration, in ms.
 *
 * @return 0, success; otherswise, failed.
 */
extern int srs_rtmp_bandwidth_check(srs_rtmp_t rtmp,
    int64_t* start_time, int64_t* end_time,
    int* play_kbps, int* publish_kbps,
    int* play_bytes, int* publish_bytes,
    int* play_duration, int* publish_duration);

/**
 * E.4.1 FLV Tag, page 75
 */
// 8 = audio
#define SRS_RTMP_TYPE_AUDIO 8
// 9 = video
#define SRS_RTMP_TYPE_VIDEO 9
// 18 = script data
#define SRS_RTMP_TYPE_SCRIPT 18
/**
 * read a audio/video/script-data packet from rtmp stream.
 * @param type, output the packet type, macros:
 *            SRS_RTMP_TYPE_AUDIO, FlvTagAudio
 *            SRS_RTMP_TYPE_VIDEO, FlvTagVideo
 *            SRS_RTMP_TYPE_SCRIPT, FlvTagScript
 *            otherswise, invalid type.
 * @param timestamp, in ms, overflow in 50days
 * @param data, the packet data, according to type:
 *             FlvTagAudio, @see "E.4.2.1 AUDIODATA"
 *            FlvTagVideo, @see "E.4.3.1 VIDEODATA"
 *            FlvTagScript, @see "E.4.4.1 SCRIPTDATA"
 *            User can free the packet by srs_rtmp_free_packet.
 * @param size, size of packet.
 * @return the error code. 0 for success; otherwise, error.
 *
 * @remark: for read, user must free the data.
 * @remark: for write, user should never free the data, even if error.
 * @example /trunk/research/librtmp/srs_play.c
 * @example /trunk/research/librtmp/srs_publish.c
 *
 * @return 0, success; otherswise, failed.
 */
extern int srs_rtmp_read_packet(srs_rtmp_t rtmp, char* type, uint32_t* timestamp, char** data, int* size);
// @param data User should never free it anymore.
extern int srs_rtmp_write_packet(srs_rtmp_t rtmp, char type, uint32_t timestamp, char* data, int size);

/**
 * Free the packet allocated by srs_rtmp_read_packet.
 */
extern void srs_rtmp_free_packet(char* data);

/**
 * whether type is script data and the data is onMetaData.
 */
extern srs_bool srs_rtmp_is_onMetaData(char type, char* data, int size);

/*************************************************************
 **************************************************************
 * audio raw codec
 **************************************************************
 *************************************************************/
/**
 * write an audio raw frame to srs.
 * not similar to h.264 video, the audio never aggregated, always
 * encoded one frame by one, so this api is used to write a frame.
 *
 * @param sound_format Format of SoundData. The following values are defined:
 *               0 = Linear PCM, platform endian
 *               1 = ADPCM
 *               2 = MP3
 *               3 = Linear PCM, little endian
 *               4 = Nellymoser 16 kHz mono
 *               5 = Nellymoser 8 kHz mono
 *               6 = Nellymoser
 *               7 = G.711 A-law logarithmic PCM
 *               8 = G.711 mu-law logarithmic PCM
 *               9 = reserved
 *               10 = AAC
 *               11 = Speex
 *               14 = MP3 8 kHz
 *               15 = Device-specific sound
 *               Formats 7, 8, 14, and 15 are reserved.
 *               AAC is supported in Flash Player 9,0,115,0 and higher.
 *               Speex is supported in Flash Player 10 and higher.
 * @param sound_rate Sampling rate. The following values are defined:
 *               0 = 5.5 kHz
 *               1 = 11 kHz
 *               2 = 22 kHz
 *               3 = 44 kHz
 * @param sound_size Size of each audio sample. This parameter only pertains to
 *               uncompressed formats. Compressed formats always decode
 *               to 16 bits internally.
 *               0 = 8-bit samples
 *               1 = 16-bit samples
 * @param sound_type Mono or stereo sound
 *               0 = Mono sound
 *               1 = Stereo sound
 * @param timestamp The timestamp of audio.
 *
 * @example /trunk/research/librtmp/srs_aac_raw_publish.c
 * @example /trunk/research/librtmp/srs_audio_raw_publish.c
 *
 * @remark for aac, the frame must be in ADTS format.
 *       @see ISO_IEC_14496-3-AAC-2001.pdf, page 75, 1.A.2.2 ADTS
 * @remark for aac, only support profile 1-4, AAC main/LC/SSR/LTP,
 *       @see ISO_IEC_14496-3-AAC-2001.pdf, page 23, 1.5.1.1 Audio object type
 *
 * @see https://github.com/ossrs/srs/issues/212
 * @see E.4.2.1 AUDIODATA of video_file_format_spec_v10_1.pdf
 *
 * @return 0, success; otherswise, failed.
 */
extern int srs_audio_write_raw_frame(srs_rtmp_t rtmp,
    char sound_format, char sound_rate, char sound_size, char sound_type,
    char* frame, int frame_size, uint32_t timestamp);

/**
 * whether aac raw data is in adts format,
 * which bytes sequence matches '1111 1111 1111'B, that is 0xFFF.
 * @param aac_raw_data the input aac raw data, a encoded aac frame data.
 * @param ac_raw_size the size of aac raw data.
 *
 * @reamrk used to check whether current frame is in adts format.
 *       @see ISO_IEC_14496-3-AAC-2001.pdf, page 75, 1.A.2.2 ADTS
 * @example /trunk/research/librtmp/srs_aac_raw_publish.c
 *
 * @return 0 false; otherwise, true.
 */
extern srs_bool srs_aac_is_adts(char* aac_raw_data, int ac_raw_size);

/**
 * parse the adts header to get the frame size,
 * which bytes sequence matches '1111 1111 1111'B, that is 0xFFF.
 * @param aac_raw_data the input aac raw data, a encoded aac frame data.
 * @param ac_raw_size the size of aac raw data.
 *
 * @return failed when <=0 failed; otherwise, ok.
 */
extern int srs_aac_adts_frame_size(char* aac_raw_data, int ac_raw_size);

/*************************************************************
 **************************************************************
 * h264 raw codec
 **************************************************************
 *************************************************************/
/**
 * write h.264 raw frame over RTMP to rtmp server.
 * @param frames the input h264 raw data, encoded h.264 I/P/B frames data.
 *       frames can be one or more than one frame,
 *       each frame prefixed h.264 annexb header, by N[00] 00 00 01, where N>=0,
 *       for instance, frame = header(00 00 00 01) + payload(67 42 80 29 95 A0 14 01 6E 40)
 *       about annexb, @see ISO_IEC_14496-10-AVC-2003.pdf, page 211.
 * @param frames_size the size of h264 raw data.
 *       assert frames_size > 0, at least has 1 bytes header.
 * @param dts the dts of h.264 raw data.
 * @param pts the pts of h.264 raw data.
 *
 * @remark, user should free the frames.
 * @remark, the tbn of dts/pts is 1/1000 for RTMP, that is, in ms.
 * @remark, cts = pts - dts
 * @remark, use srs_h264_startswith_annexb to check whether frame is annexb format.
 * @example /trunk/research/librtmp/srs_h264_raw_publish.c
 * @see https://github.com/ossrs/srs/issues/66
 *
 * @return 0, success; otherswise, failed.
 *       for dvbsp error, @see srs_h264_is_dvbsp_error().
 *       for duplictated sps error, @see srs_h264_is_duplicated_sps_error().
 *       for duplictated pps error, @see srs_h264_is_duplicated_pps_error().
 */
/**
 For the example file:
 http://winlinvip.github.io/srs.release/3rdparty/720p.h264.raw
 The data sequence is:
 // SPS
 000000016742802995A014016E40
 // PPS
 0000000168CE3880
 // IFrame
 0000000165B8041014C038008B0D0D3A071.....
 // PFrame
 0000000141E02041F8CDDC562BBDEFAD2F.....
 User can send the SPS+PPS, then each frame:
 // SPS+PPS
 srs_h264_write_raw_frames('000000016742802995A014016E400000000168CE3880', size, dts, pts)
 // IFrame
 srs_h264_write_raw_frames('0000000165B8041014C038008B0D0D3A071......', size, dts, pts)
 // PFrame
 srs_h264_write_raw_frames('0000000141E02041F8CDDC562BBDEFAD2F......', size, dts, pts)
 User also can send one by one:
 // SPS
 srs_h264_write_raw_frames('000000016742802995A014016E4', size, dts, pts)
 // PPS
 srs_h264_write_raw_frames('00000000168CE3880', size, dts, pts)
 // IFrame
 srs_h264_write_raw_frames('0000000165B8041014C038008B0D0D3A071......', size, dts, pts)
 // PFrame
 srs_h264_write_raw_frames('0000000141E02041F8CDDC562BBDEFAD2F......', size, dts, pts)
 */
extern int srs_h264_write_raw_frames(srs_rtmp_t rtmp, char* frames, int frames_size, uint32_t dts, uint32_t pts);
/**
 * whether error_code is dvbsp(drop video before sps/pps/sequence-header) error.
 *
 * @see https://github.com/ossrs/srs/issues/203
 * @example /trunk/research/librtmp/srs_h264_raw_publish.c
 * @remark why drop video?
 *       some encoder, for example, ipcamera, will send sps/pps before each IFrame,
 *       so, when error and reconnect the rtmp, the first video is not sps/pps(sequence header),
 *       this will cause SRS server to disable HLS.
 */
extern srs_bool srs_h264_is_dvbsp_error(int error_code);
/**
 * whether error_code is duplicated sps error.
 *
 * @see https://github.com/ossrs/srs/issues/204
 * @example /trunk/research/librtmp/srs_h264_raw_publish.c
 */
extern srs_bool srs_h264_is_duplicated_sps_error(int error_code);
/**
 * whether error_code is duplicated pps error.
 *
 * @see https://github.com/ossrs/srs/issues/204
 * @example /trunk/research/librtmp/srs_h264_raw_publish.c
 */
extern srs_bool srs_h264_is_duplicated_pps_error(int error_code);
/**
 * whether h264 raw data starts with the annexb,
 * which bytes sequence matches N[00] 00 00 01, where N>=0.
 * @param h264_raw_data the input h264 raw data, a encoded h.264 I/P/B frame data.
 * @paam h264_raw_size the size of h264 raw data.
 * @param pnb_start_code output the size of start code, must >=3.
 *       NULL to ignore.
 *
 * @reamrk used to check whether current frame is in annexb format.
 * @example /trunk/research/librtmp/srs_h264_raw_publish.c
 *
 * @return 0 false; otherwise, true.
 */
extern srs_bool srs_h264_startswith_annexb(char* h264_raw_data, int h264_raw_size, int* pnb_start_code);

/*************************************************************
 *************************************************************
 * MP4 muxer and demuxer.
 * @example /trunk/research/librtmp/srs_ingest_mp4.c
 *************************************************************
 *************************************************************/
typedef void* srs_mp4_t;
// The sample struct of mp4.
typedef struct {
    // The handler type, it's SrsMp4HandlerType.
    uint32_t handler_type;
    
    // The dts in milliseconds.
    uint32_t dts;
    // The codec id.
    //      video: SrsVideoCodecId.
    //      audio: SrsAudioCodecId.
    uint16_t codec;
    // The frame trait, some characteristic:
    //      video: SrsVideoAvcFrameTrait.
    //      audio: SrsAudioAacFrameTrait.
    uint16_t frame_trait;
    
    // The video pts in milliseconds. Ignore for audio.
    uint32_t pts;
    // The video frame type, it's SrsVideoAvcFrameType.
    uint16_t frame_type;
    
    // The audio sample rate, it's SrsAudioSampleRate.
    uint8_t sample_rate;
    // The audio sound bits, it's SrsAudioSampleBits.
    uint8_t sound_bits;
    // The audio sound type, it's SrsAudioChannels.
    uint8_t channels;
    
    // The size of sample payload in bytes.
    uint32_t nb_sample;
    // The output sample data, user must free it by srs_mp4_free_sample.
    uint8_t* sample;
} srs_mp4_sample_t;
/**
 * Open mp4 file for muxer(write) or demuxer(read).
 * @return A MP4 demuxer, NULL if failed.
 */
extern srs_mp4_t srs_mp4_open_read(const char* file);
/**
 * Close the MP4 demuxer.
 */
extern void srs_mp4_close(srs_mp4_t mp4);
/**
 * Initialize mp4 demuxer in non-seek mode.
 * @remark Only support non-seek mode, that is fmp4 or moov before mdata.
 *      For the live streaming, we must feed stream frame by frame.
 */
extern int srs_mp4_init_demuxer(srs_mp4_t mp4);
/**
 * Read a sample form mp4.
 * @remark User can use srs_mp4_sample_to_flv_tag to convert mp4 sampel to flv tag.
 *      Use the srs_mp4_to_flv_tag_size to calc the flv tag data size to alloc.
 */
extern int srs_mp4_read_sample(srs_mp4_t mp4, srs_mp4_sample_t* sample);
/**
 * Free the allocated mp4 sample.
 */
extern void srs_mp4_free_sample(srs_mp4_sample_t* sample);
/**
 * Calc the size of flv tag, for the mp4 sample to convert to.
 */
extern int32_t srs_mp4_sizeof(srs_mp4_t mp4, srs_mp4_sample_t* sample);
/**
 * Covert mp4 sample to flv tag.
 */
extern int srs_mp4_to_flv_tag(srs_mp4_t mp4, srs_mp4_sample_t* sample, char* type, uint32_t* time, char* data, int32_t size);
/* error code */
/* whether the error code indicates EOF */
extern srs_bool srs_mp4_is_eof(int error_code);

/*************************************************************
 **************************************************************
 * flv codec
 * @example /trunk/research/librtmp/srs_flv_injecter.c
 * @example /trunk/research/librtmp/srs_flv_parser.c
 * @example /trunk/research/librtmp/srs_ingest_flv.c
 * @example /trunk/research/librtmp/srs_ingest_rtmp.c
 **************************************************************
 *************************************************************/
typedef void* srs_flv_t;
/**
 * Open FLV file in demux mode.
 * @return A FLV demuxer, NULL if failed.
 */
extern srs_flv_t srs_flv_open_read(const char* file);
/**
 * Open FlV file in mux mode.
 * @return A FLV muxer, NULL if failed.
 */
extern srs_flv_t srs_flv_open_write(const char* file);
/**
 * Close the FLV demuxer or muxer.
 */
extern void srs_flv_close(srs_flv_t flv);
/**
 * read the flv header. 9bytes header.
 * @param header, @see E.2 The FLV header, flv_v10_1.pdf in SRS doc.
 *   3bytes, signature, "FLV",
 *   1bytes, version, 0x01,
 *   1bytes, flags, UB[5] 0, UB[1] audio present, UB[1] 0, UB[1] video present.
 *   4bytes, dataoffset, 0x09, The length of this header in bytes
 *
 * @return 0, success; otherswise, failed.
 * @remark, drop the 4bytes zero previous tag size.
 */
extern int srs_flv_read_header(srs_flv_t flv, char header[9]);
/**
 * read the flv tag header, 1bytes tag, 3bytes data_size,
 * 4bytes time, 3bytes stream id.
 * @param ptype, output the type of tag, macros:
 *            SRS_RTMP_TYPE_AUDIO, FlvTagAudio
 *            SRS_RTMP_TYPE_VIDEO, FlvTagVideo
 *            SRS_RTMP_TYPE_SCRIPT, FlvTagScript
 * @param pdata_size, output the size of tag data.
 * @param ptime, output the time of tag, the dts in ms.
 *
 * @return 0, success; otherswise, failed.
 * @remark, user must ensure the next is a tag, srs never check it.
 */
extern int srs_flv_read_tag_header(srs_flv_t flv, char* ptype, int32_t* pdata_size, uint32_t* ptime);
/**
 * read the tag data. drop the 4bytes previous tag size
 * @param data, the data to read, user alloc and free it.
 * @param size, the size of data to read, get by srs_flv_read_tag_header().
 * @remark, srs will ignore and drop the 4bytes previous tag size.
 */
extern int srs_flv_read_tag_data(srs_flv_t flv, char* data, int32_t size);
/**
 * write the flv header. 9bytes header.
 * @param header, @see E.2 The FLV header, flv_v10_1.pdf in SRS doc.
 *   3bytes, signature, "FLV",
 *   1bytes, version, 0x01,
 *   1bytes, flags, UB[5] 0, UB[1] audio present, UB[1] 0, UB[1] video present.
 *   4bytes, dataoffset, 0x09, The length of this header in bytes
 *
 * @return 0, success; otherswise, failed.
 * @remark, auto write the 4bytes zero previous tag size.
 */
extern int srs_flv_write_header(srs_flv_t flv, char header[9]);
/**
 * write the flv tag to file.
 *
 * @return 0, success; otherswise, failed.
 * @remark, auto write the 4bytes zero previous tag size.
 */
/* write flv tag to file, auto write the 4bytes previous tag size */
extern int srs_flv_write_tag(srs_flv_t flv, char type, int32_t time, char* data, int size);
/**
 * get the tag size, for flv injecter to adjust offset,
 *       size = tag_header(11B) + data_size + previous_tag(4B)
 * @return the size of tag.
 */
extern int srs_flv_size_tag(int data_size);
/* file stream */
/* file stream tellg to get offset */
extern int64_t srs_flv_tellg(srs_flv_t flv);
/* seek file stream, offset is form the start of file */
extern void srs_flv_lseek(srs_flv_t flv, int64_t offset);
/* error code */
/* whether the error code indicates EOF */
extern srs_bool srs_flv_is_eof(int error_code);
/* media codec */
/**
 * whether the video body is sequence header
 * @param data, the data of tag, read by srs_flv_read_tag_data().
 * @param size, the size of tag, read by srs_flv_read_tag_data().
 */
extern srs_bool srs_flv_is_sequence_header(char* data, int32_t size);
/**
 * whether the video body is keyframe
 * @param data, the data of tag, read by srs_flv_read_tag_data().
 * @param size, the size of tag, read by srs_flv_read_tag_data().
 */
extern srs_bool srs_flv_is_keyframe(char* data, int32_t size);

/*************************************************************
 **************************************************************
 * amf0 codec
 * @example /trunk/research/librtmp/srs_ingest_flv.c
 * @example /trunk/research/librtmp/srs_ingest_rtmp.c
 **************************************************************
 *************************************************************/
/* the output handler. */
typedef double srs_amf0_number;
/**
 * parse amf0 from data.
 * @param nparsed, the parsed size, NULL to ignore.
 * @return the parsed amf0 object. NULL for error.
 * @remark user must free the parsed or created object by srs_amf0_free.
 */
extern srs_amf0_t srs_amf0_parse(char* data, int size, int* nparsed);
extern srs_amf0_t srs_amf0_create_string(const char* value);
extern srs_amf0_t srs_amf0_create_number(srs_amf0_number value);
extern srs_amf0_t srs_amf0_create_ecma_array();
extern srs_amf0_t srs_amf0_create_strict_array();
extern srs_amf0_t srs_amf0_create_object();
extern srs_amf0_t srs_amf0_ecma_array_to_object(srs_amf0_t ecma_arr);
extern void srs_amf0_free(srs_amf0_t amf0);
/* size and to bytes */
extern int srs_amf0_size(srs_amf0_t amf0);
extern int srs_amf0_serialize(srs_amf0_t amf0, char* data, int size);
/* type detecter */
extern srs_bool srs_amf0_is_string(srs_amf0_t amf0);
extern srs_bool srs_amf0_is_boolean(srs_amf0_t amf0);
extern srs_bool srs_amf0_is_number(srs_amf0_t amf0);
extern srs_bool srs_amf0_is_null(srs_amf0_t amf0);
extern srs_bool srs_amf0_is_object(srs_amf0_t amf0);
extern srs_bool srs_amf0_is_ecma_array(srs_amf0_t amf0);
extern srs_bool srs_amf0_is_strict_array(srs_amf0_t amf0);
/* value converter */
extern const char* srs_amf0_to_string(srs_amf0_t amf0);
extern srs_bool srs_amf0_to_boolean(srs_amf0_t amf0);
extern srs_amf0_number srs_amf0_to_number(srs_amf0_t amf0);
/* value setter */
extern void srs_amf0_set_number(srs_amf0_t amf0, srs_amf0_number value);
/* object value converter */
extern int srs_amf0_object_property_count(srs_amf0_t amf0);
extern const char* srs_amf0_object_property_name_at(srs_amf0_t amf0, int index);
extern srs_amf0_t srs_amf0_object_property_value_at(srs_amf0_t amf0, int index);
extern srs_amf0_t srs_amf0_object_property(srs_amf0_t amf0, const char* name);
extern void srs_amf0_object_property_set(srs_amf0_t amf0, const char* name, srs_amf0_t value);
extern void srs_amf0_object_clear(srs_amf0_t amf0);
/* ecma array value converter */
extern int srs_amf0_ecma_array_property_count(srs_amf0_t amf0);
extern const char* srs_amf0_ecma_array_property_name_at(srs_amf0_t amf0, int index);
extern srs_amf0_t srs_amf0_ecma_array_property_value_at(srs_amf0_t amf0, int index);
extern srs_amf0_t srs_amf0_ecma_array_property(srs_amf0_t amf0, const char* name);
extern void srs_amf0_ecma_array_property_set(srs_amf0_t amf0, const char* name, srs_amf0_t value);
/* strict array value converter */
extern int srs_amf0_strict_array_property_count(srs_amf0_t amf0);
extern srs_amf0_t srs_amf0_strict_array_property_at(srs_amf0_t amf0, int index);
extern void srs_amf0_strict_array_append(srs_amf0_t amf0, srs_amf0_t value);

/*************************************************************
 **************************************************************
 * utilities
 **************************************************************
 *************************************************************/
/**
 * get the current system time in ms.
 * use gettimeofday() to get system time.
 */
extern int64_t srs_utils_time_ms();

/**
 * get the send bytes.
 */
extern int64_t srs_utils_send_bytes(srs_rtmp_t rtmp);

/**
 * get the recv bytes.
 */
extern int64_t srs_utils_recv_bytes(srs_rtmp_t rtmp);

/**
 * parse the dts and pts by time in header and data in tag,
 * or to parse the RTMP packet by srs_rtmp_read_packet().
 *
 * @param time, the timestamp of tag, read by srs_flv_read_tag_header().
 * @param type, the type of tag, read by srs_flv_read_tag_header().
 * @param data, the data of tag, read by srs_flv_read_tag_data().
 * @param size, the size of tag, read by srs_flv_read_tag_header().
 * @param ppts, output the pts in ms,
 *
 * @return 0, success; otherswise, failed.
 * @remark, the dts always equals to @param time.
 * @remark, the pts=dts for audio or data.
 * @remark, video only support h.264.
 */
extern int srs_utils_parse_timestamp(uint32_t time, char type, char* data, int size, uint32_t* ppts);

/**
 * whether the flv tag specified by param type is ok.
 * @return true when tag is video/audio/script-data; otherwise, false.
 */
extern srs_bool srs_utils_flv_tag_is_ok(char type);
extern srs_bool srs_utils_flv_tag_is_audio(char type);
extern srs_bool srs_utils_flv_tag_is_video(char type);
extern srs_bool srs_utils_flv_tag_is_av(char type);

/**
 * get the CodecID of video tag.
 * Codec Identifier. The following values are defined:
 *           2 = Sorenson H.263
 *           3 = Screen video
 *           4 = On2 VP6
 *           5 = On2 VP6 with alpha channel
 *           6 = Screen video version 2
 *           7 = AVC
 * @return the code id. 0 for error.
 */
extern char srs_utils_flv_video_codec_id(char* data, int size);

/**
 * get the AVCPacketType of video tag.
 * The following values are defined:
 *           0 = AVC sequence header
 *           1 = AVC NALU
 *           2 = AVC end of sequence (lower level NALU sequence ender is
 *               not required or supported)
 * @return the avc packet type. -1(0xff) for error.
 */
extern char srs_utils_flv_video_avc_packet_type(char* data, int size);

/**
 * get the FrameType of video tag.
 * Type of video frame. The following values are defined:
 *           1 = key frame (for AVC, a seekable frame)
 *           2 = inter frame (for AVC, a non-seekable frame)
 *           3 = disposable inter frame (H.263 only)
 *           4 = generated key frame (reserved for server use only)
 *           5 = video info/command frame
 * @return the frame type. 0 for error.
 */
extern char srs_utils_flv_video_frame_type(char* data, int size);

/**
 * get the SoundFormat of audio tag.
 * Format of SoundData. The following values are defined:
 *               0 = Linear PCM, platform endian
 *               1 = ADPCM
 *               2 = MP3
 *               3 = Linear PCM, little endian
 *               4 = Nellymoser 16 kHz mono
 *               5 = Nellymoser 8 kHz mono
 *               6 = Nellymoser
 *               7 = G.711 A-law logarithmic PCM
 *               8 = G.711 mu-law logarithmic PCM
 *               9 = reserved
 *               10 = AAC
 *               11 = Speex
 *               14 = MP3 8 kHz
 *               15 = Device-specific sound
 *               Formats 7, 8, 14, and 15 are reserved.
 *               AAC is supported in Flash Player 9,0,115,0 and higher.
 *               Speex is supported in Flash Player 10 and higher.
 * @return the sound format. -1(0xff) for error.
 */
extern char srs_utils_flv_audio_sound_format(char* data, int size);

/**
 * get the SoundRate of audio tag.
 * Sampling rate. The following values are defined:
 *               0 = 5.5 kHz
 *               1 = 11 kHz
 *               2 = 22 kHz
 *               3 = 44 kHz
 * @return the sound rate. -1(0xff) for error.
 */
extern char srs_utils_flv_audio_sound_rate(char* data, int size);

/**
 * get the SoundSize of audio tag.
 * Size of each audio sample. This parameter only pertains to
 * uncompressed formats. Compressed formats always decode
 * to 16 bits internally.
 *               0 = 8-bit samples
 *               1 = 16-bit samples
 * @return the sound size. -1(0xff) for error.
 */
extern char srs_utils_flv_audio_sound_size(char* data, int size);

/**
 * get the SoundType of audio tag.
 * Mono or stereo sound
 *               0 = Mono sound
 *               1 = Stereo sound
 * @return the sound type. -1(0xff) for error.
 */
extern char srs_utils_flv_audio_sound_type(char* data, int size);

/**
 * get the AACPacketType of audio tag.
 * The following values are defined:
 *               0 = AAC sequence header
 *               1 = AAC raw
 * @return the aac packet type. -1(0xff) for error.
 */
extern char srs_utils_flv_audio_aac_packet_type(char* data, int size);

/*************************************************************
 **************************************************************
 * human readable print.
 **************************************************************
 *************************************************************/
/**
 * human readable print
 * @param pdata, output the heap data, NULL to ignore.
 *       user must use srs_amf0_free_bytes to free it.
 * @return return the *pdata for print. NULL to ignore.
 */
extern char* srs_human_amf0_print(srs_amf0_t amf0, char** pdata, int* psize);
/**
 * convert the flv tag type to string.
 *     SRS_RTMP_TYPE_AUDIO to "Audio"
 *     SRS_RTMP_TYPE_VIDEO to "Video"
 *     SRS_RTMP_TYPE_SCRIPT to "Data"
 *     otherwise, "Unknown"
 * @remark user never free the return char*,
 *   it's static shared const string.
 */
extern const char* srs_human_flv_tag_type2string(char type);

/**
 * get the codec id string.
 *           H.263 = Sorenson H.263
 *           Screen = Screen video
 *           VP6 = On2 VP6
 *           VP6Alpha = On2 VP6 with alpha channel
 *           Screen2 = Screen video version 2
 *           H.264 = AVC
 *           otherwise, "Unknown"
 * @remark user never free the return char*,
 *   it's static shared const string.
 */
extern const char* srs_human_flv_video_codec_id2string(char codec_id);

/**
 * get the avc packet type string.
 *           SH = AVC sequence header
 *           Nalu = AVC NALU
 *           SpsPpsEnd = AVC end of sequence
 *           otherwise, "Unknown"
 * @remark user never free the return char*,
 *   it's static shared const string.
 */
extern const char* srs_human_flv_video_avc_packet_type2string(char avc_packet_type);

/**
 * get the frame type string.
 *           I = key frame (for AVC, a seekable frame)
 *           P/B = inter frame (for AVC, a non-seekable frame)
 *           DI = disposable inter frame (H.263 only)
 *           GI = generated key frame (reserved for server use only)
 *           VI = video info/command frame
 *           otherwise, "Unknown"
 * @remark user never free the return char*,
 *   it's static shared const string.
 */
extern const char* srs_human_flv_video_frame_type2string(char frame_type);

/**
 * get the SoundFormat string.
 * Format of SoundData. The following values are defined:
 *               LinearPCM = Linear PCM, platform endian
 *               ADPCM = ADPCM
 *               MP3 = MP3
 *               LinearPCMLe = Linear PCM, little endian
 *               NellymoserKHz16 = Nellymoser 16 kHz mono
 *               NellymoserKHz8 = Nellymoser 8 kHz mono
 *               Nellymoser = Nellymoser
 *               G711APCM = G.711 A-law logarithmic PCM
 *               G711MuPCM = G.711 mu-law logarithmic PCM
 *               Reserved = reserved
 *               AAC = AAC
 *               Speex = Speex
 *               MP3KHz8 = MP3 8 kHz
 *               DeviceSpecific = Device-specific sound
 *               otherwise, "Unknown"
 * @remark user never free the return char*,
 *   it's static shared const string.
 */
extern const char* srs_human_flv_audio_sound_format2string(char sound_format);

/**
 * get the SoundRate of audio tag.
 * Sampling rate. The following values are defined:
 *               5.5KHz = 5.5 kHz
 *               11KHz = 11 kHz
 *               22KHz = 22 kHz
 *               44KHz = 44 kHz
 *               otherwise, "Unknown"
 * @remark user never free the return char*,
 *   it's static shared const string.
 */
extern const char* srs_human_flv_audio_sound_rate2string(char sound_rate);

/**
 * get the SoundSize of audio tag.
 * Size of each audio sample. This parameter only pertains to
 * uncompressed formats. Compressed formats always decode
 * to 16 bits internally.
 *               8bit = 8-bit samples
 *               16bit = 16-bit samples
 *               otherwise, "Unknown"
 * @remark user never free the return char*,
 *   it's static shared const string.
 */
extern const char* srs_human_flv_audio_sound_size2string(char sound_size);

/**
 * get the SoundType of audio tag.
 * Mono or stereo sound
 *               Mono = Mono sound
 *               Stereo = Stereo sound
 *               otherwise, "Unknown"
 * @remark user never free the return char*,
 *   it's static shared const string.
 */
extern const char* srs_human_flv_audio_sound_type2string(char sound_type);

/**
 * get the AACPacketType of audio tag.
 * The following values are defined:
 *               SH = AAC sequence header
 *               Raw = AAC raw
 *               otherwise, "Unknown"
 * @remark user never free the return char*,
 *   it's static shared const string.
 */
extern const char* srs_human_flv_audio_aac_packet_type2string(char aac_packet_type);

/**
 * Format the RTMP packet to human readable buffer.
 * @return Whether parse RTMP packet ok. 0, success; otherwise, failed.
 */
extern int srs_human_format_rtmp_packet(char* buffer, int nb_buffer, char type, uint32_t timestamp, char* data, int size);
extern int srs_human_format_rtmp_packet2(char* buffer, int nb_buffer, char type, uint32_t timestamp, char* data, int size,
    uint32_t pre_timestamp, int64_t pre_now, int64_t starttime, int64_t nb_packets);

/**
 * Format current time to human readable string.
 * @return A NULL terminated string.
 */
extern const char* srs_human_format_time();

#ifndef _WIN32
// for getpid.
#include <unistd.h>
#endif
// The log function for librtmp.
// User can disable it by define macro SRS_DISABLE_LOG.
// Or user can directly use them, or define the alias by:
//      #define trace(msg, ...) srs_human_trace(msg, ##__VA_ARGS__)
//      #define warn(msg, ...) srs_human_warn(msg, ##__VA_ARGS__)
//      #define error(msg, ...) srs_human_error(msg, ##__VA_ARGS__)
#ifdef SRS_DISABLE_LOG
#define srs_human_trace(msg, ...) (void)0
#define srs_human_warn(msg, ...) (void)0
#define srs_human_error(msg, ...) (void)0
#define srs_human_verbose(msg, ...) (void)0
#define srs_human_raw(msg, ...) (void)0
#else
#include <string.h>
#include <errno.h>
#define srs_human_trace(msg, ...) \
fprintf(stdout, "[T][%d][%s] ", getpid(), srs_human_format_time());\
fprintf(stdout, msg, ##__VA_ARGS__); fprintf(stdout, "\n")
#define srs_human_warn(msg, ...) \
fprintf(stdout, "[W][%d][%s][%d] ", getpid(), srs_human_format_time(), errno); \
fprintf(stdout, msg, ##__VA_ARGS__); \
fprintf(stdout, "\n")
#define srs_human_error(msg, ...) \
fprintf(stderr, "[E][%d][%s][%d] ", getpid(), srs_human_format_time(), errno);\
fprintf(stderr, msg, ##__VA_ARGS__); \
fprintf(stderr, " (%s)\n", strerror(errno))
#define srs_human_verbose(msg, ...) (void)0
#define srs_human_raw(msg, ...) printf(msg, ##__VA_ARGS__)
#endif

/*************************************************************
 **************************************************************
 * IO hijack, use your specified io functions.
 **************************************************************
 *************************************************************/
// the void* will convert to your handler for io hijack.
typedef void* srs_hijack_io_t;
#ifdef SRS_HIJACK_IO
#ifndef _WIN32
// for iovec.
#include <sys/uio.h>
#endif
/**
 * get the hijack io object in rtmp protocol sdk.
 * @remark, user should never provides this method, srs-librtmp provides it.
 */
extern srs_hijack_io_t srs_hijack_io_get(srs_rtmp_t rtmp);
#endif
// define the following macro and functions in your module to hijack the io.
// the example @see https://github.com/ossrs/srs-bench
// which use librtmp but use its own io(use st also).
#ifdef SRS_HIJACK_IO
/**
 * create hijack.
 * @return NULL for error; otherwise, ok.
 */
extern srs_hijack_io_t srs_hijack_io_create();
/**
 * destroy the context, user must close the socket.
 */
extern void srs_hijack_io_destroy(srs_hijack_io_t ctx);
/**
 * create socket, not connect yet.
 * @param owner, the rtmp context which create this socket.
 * @return 0, success; otherswise, failed.
 */
extern int srs_hijack_io_create_socket(srs_hijack_io_t ctx, srs_rtmp_t owner);
/**
 * connect socket at server_ip:port.
 * @return 0, success; otherswise, failed.
 */
extern int srs_hijack_io_connect(srs_hijack_io_t ctx, const char* server_ip, int port);
/**
 * read from socket.
 * @return 0, success; otherswise, failed.
 */
extern int srs_hijack_io_read(srs_hijack_io_t ctx, void* buf, size_t size, ssize_t* nread);
/**
 * set the socket recv timeout in ms.
 * @return 0, success; otherswise, failed.
 */
extern int srs_hijack_io_set_recv_timeout(srs_hijack_io_t ctx, int64_t tm);
/**
 * get the socket recv timeout.
 * @return 0, success; otherswise, failed.
 */
extern int64_t srs_hijack_io_get_recv_timeout(srs_hijack_io_t ctx);
/**
 * get the socket recv bytes.
 * @return 0, success; otherswise, failed.
 */
extern int64_t srs_hijack_io_get_recv_bytes(srs_hijack_io_t ctx);
/**
 * set the socket send timeout in ms.
 * @return 0, success; otherswise, failed.
 */
extern int srs_hijack_io_set_send_timeout(srs_hijack_io_t ctx, int64_t tm);
/**
 * get the socket send timeout.
 * @return 0, success; otherswise, failed.
 */
extern int64_t srs_hijack_io_get_send_timeout(srs_hijack_io_t ctx);
/**
 * get the socket send bytes.
 * @return 0, success; otherswise, failed.
 */
extern int64_t srs_hijack_io_get_send_bytes(srs_hijack_io_t ctx);
/**
 * writev of socket.
 * @return 0, success; otherswise, failed.
 * @remark We assume that the writev always write all data to peer, like what ST or block-socket done.
 */
extern int srs_hijack_io_writev(srs_hijack_io_t ctx, const iovec *iov, int iov_size, ssize_t* nwrite);
/**
 * whether the timeout is never timeout in ms.
 * @return 0, with timeout specified; otherwise, never timeout.
 */
extern int srs_hijack_io_is_never_timeout(srs_hijack_io_t ctx, int64_t tm);
/**
 * read fully, fill the buf exactly size bytes.
 * @return 0, success; otherswise, failed.
 */
extern int srs_hijack_io_read_fully(srs_hijack_io_t ctx, void* buf, size_t size, ssize_t* nread);
/**
 * write bytes to socket.
 * @return 0, success; otherswise, failed.
 * @remark We assume that the write always write all data to peer, like what ST or block-socket done.
 */
extern int srs_hijack_io_write(srs_hijack_io_t ctx, void* buf, size_t size, ssize_t* nwrite);
#endif

/*************************************************************
 **************************************************************
 * Windows SRS-LIBRTMP solution
 **************************************************************
 *************************************************************/
// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifdef _WIN32
// for time.
#define _CRT_SECURE_NO_WARNINGS
#include <time.h>
int gettimeofday(struct timeval* tv, struct timezone* tz);
#define PRId64 "lld"

// for inet helpers.
typedef int socklen_t;
const char *inet_ntop(int af, const void *src, char *dst, socklen_t size);

// for mkdir().
#include<direct.h>

// for open().
typedef int mode_t;
#define S_IRUSR 0
#define S_IWUSR 0
#define S_IXUSR 0
#define S_IRGRP 0
#define S_IWGRP 0
#define S_IXGRP 0
#define S_IROTH 0
#define S_IXOTH 0

// for file seek.
#include <io.h>
#include <fcntl.h>
#define open _open
#define close _close
#define lseek _lseek
#define write _write
#define read _read

// for socket.
ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
typedef int64_t useconds_t;
int usleep(useconds_t usec);
int socket_setup();
int socket_cleanup();

// others.
#define snprintf _snprintf
#endif

/*************************************************************
 *************************************************************
 * Deprecated APIs, maybe removed in future versions.
 *************************************************************
 *************************************************************/
/**
 * Deprecated, for bandwidth test check only.
 */
extern srs_rtmp_t srs_rtmp_create2(const char* url);

/**
 * Deprecated, use seperate function to retrieve information from rtmp,
 *      for example, use srs_rtmp_get_server_ip to get server ip.
 */
extern int srs_rtmp_connect_app2(srs_rtmp_t rtmp,
    char srs_server_ip[128], char srs_server[128],
    char srs_primary[128], char srs_authors[128],
    char srs_version[32], int* srs_id, int* srs_pid);

/**
 * Deprecated, use srs_human_format_rtmp_packet instead.
 */
extern int srs_human_print_rtmp_packet(char type, uint32_t timestamp, char* data, int size);
extern int srs_human_print_rtmp_packet2(char type, uint32_t timestamp, char* data, int size, uint32_t pre_timestamp);
extern int srs_human_print_rtmp_packet3(char type, uint32_t timestamp, char* data, int size, uint32_t pre_timestamp, int64_t pre_now);
extern int srs_human_print_rtmp_packet4(char type, uint32_t timestamp, char* data, int size, uint32_t pre_timestamp, int64_t pre_now,
    int64_t starttime, int64_t nb_packets);
    
#ifdef __cplusplus
}
#endif

#endif

// following is generated by src/libs/srs_lib_simple_socket.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_LIB_SIMPLE_SOCKET_HPP
#define SRS_LIB_SIMPLE_SOCKET_HPP

//#include <srs_core.hpp>

//#include <srs_protocol_io.hpp>
//#include <srs_librtmp.hpp>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#define SOCKET int
#endif

/**
 * simple socket stream,
 * use tcp socket, sync block mode, for client like srs-librtmp.
 */
class SimpleSocketStream : public ISrsProtocolReaderWriter
{
private:
    srs_hijack_io_t io;
public:
    SimpleSocketStream();
    virtual ~SimpleSocketStream();
public:
    virtual srs_hijack_io_t hijack_io();
    virtual int create_socket(srs_rtmp_t owner);
    virtual int connect(const char* server, int port);
// ISrsReader
public:
    virtual srs_error_t read(void* buf, size_t size, ssize_t* nread);
// ISrsProtocolReader
public:
    virtual void set_recv_timeout(int64_t tm);
    virtual int64_t get_recv_timeout();
    virtual int64_t get_recv_bytes();
// ISrsProtocolWriter
public:
    virtual void set_send_timeout(int64_t tm);
    virtual int64_t get_send_timeout();
    virtual int64_t get_send_bytes();
    virtual srs_error_t writev(const iovec *iov, int iov_size, ssize_t* nwrite);
// ISrsProtocolReaderWriter
public:
    virtual bool is_never_timeout(int64_t tm);
    virtual srs_error_t read_fully(void* buf, size_t size, ssize_t* nread);
    virtual srs_error_t write(void* buf, size_t size, ssize_t* nwrite);
};

#endif

// following is generated by src/libs/srs_lib_bandwidth.hpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

#ifndef SRS_LIB_BANDWIDTH_HPP
#define SRS_LIB_BANDWIDTH_HPP

//#include <srs_core.hpp>

class SrsRtmpClient;
class SrsBandwidthPacket;

/**
 * bandwith client library for srs-librtmp.
 */
class SrsBandwidthClient
{
private:
    SrsRtmpClient* _rtmp;
public:
    SrsBandwidthClient();
    virtual ~SrsBandwidthClient();
public:
    /**
     * initialize the bandwidth check client.
     */
    virtual int initialize(SrsRtmpClient* rtmp);
    /**
     * do bandwidth check.
     *
     * bandwidth info:
     * @param start_time, output the start time, in ms.
     * @param end_time, output the end time, in ms.
     * @param play_kbps, output the play/download kbps.
     * @param publish_kbps, output the publish/upload kbps.
     * @param play_bytes, output the play/download bytes.
     * @param publish_bytes, output the publish/upload bytes.
     * @param play_duration, output the play/download test duration, in ms.
     * @param publish_duration, output the publish/upload test duration, in ms.
     */
    virtual int bandwidth_check(
        int64_t* start_time, int64_t* end_time,
        int* play_kbps, int* publish_kbps,
        int* play_bytes, int* publish_bytes,
        int* play_duration, int* publish_duration);
private:
    /**
     * play check/test, downloading bandwidth kbps.
     */
    virtual int play_start();
    virtual int play_checking();
    virtual int play_stop();
    /**
     * publish check/test, publishing bandwidth kbps.
     */
    virtual int publish_start(int& duration_ms, int& play_kbps);
    virtual int publish_checking(int duration_ms, int play_kbps);
    virtual int publish_stop();
    /**
     * report and final packet
     */
    virtual int do_final(SrsBandwidthPacket** ppkt);
};

#endif

// following is generated by src/core/srs_core.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_core.hpp>


// following is generated by src/core/srs_core_autofree.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_core_autofree.hpp>

// following is generated by src/core/srs_core_performance.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_core_performance.hpp>

// following is generated by src/core/srs_core_mem_watch.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_core_mem_watch.hpp>

#ifdef SRS_AUTO_MEM_WATCH

#include <map>
#include <stdio.h>
using namespace std;

struct SrsMemoryObject
{
    void* ptr;
    std::string category;
    int size;
};

std::map<void*, SrsMemoryObject*> _srs_ptrs;

void srs_memory_watch(void* ptr, string category, int size)
{
    SrsMemoryObject* obj = NULL;
    
    std::map<void*, SrsMemoryObject*>::iterator it;
    if ((it = _srs_ptrs.find(ptr)) != _srs_ptrs.end()) {
        obj = it->second;
    } else {
        obj = new SrsMemoryObject();
        _srs_ptrs[ptr] = obj;
    }
    
    obj->ptr = ptr;
    obj->category = category;
    obj->size = size;
}

void srs_memory_unwatch(void* ptr)
{
    std::map<void*, SrsMemoryObject*>::iterator it;
    if ((it = _srs_ptrs.find(ptr)) != _srs_ptrs.end()) {
        SrsMemoryObject* obj = it->second;
        srs_freep(obj);
        
        _srs_ptrs.erase(it);
    }
}

void srs_memory_report()
{
    printf("srs memory watch leak report:\n");
    
    int total = 0;
    std::map<void*, SrsMemoryObject*>::iterator it;
    for (it = _srs_ptrs.begin(); it != _srs_ptrs.end(); ++it) {
        SrsMemoryObject* obj = it->second;
        printf("    %s: %#"PRIx64", %dB\n", obj->category.c_str(), (int64_t)obj->ptr, obj->size);
        total += obj->size;
    }
    
    printf("%d objects leak %dKB.\n", (int)_srs_ptrs.size(), total / 1024);
    printf("@remark use script to cleanup for memory watch: ./etc/init.d/srs stop\n");
}

#endif

// following is generated by src/kernel/srs_kernel_error.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kernel_error.hpp>

//#include <srs_kernel_log.hpp>

#include <errno.h>
#include <sstream>
#include <stdarg.h>
using namespace std;

bool srs_is_system_control_error(int error_code)
{
    return error_code == ERROR_CONTROL_RTMP_CLOSE
        || error_code == ERROR_CONTROL_REPUBLISH
        || error_code == ERROR_CONTROL_REDIRECT;
}

bool srs_is_system_control_error(srs_error_t err)
{
    int error_code = srs_error_code(err);
    return srs_is_system_control_error(error_code);
}

bool srs_is_client_gracefully_close(int error_code)
{
    return error_code == ERROR_SOCKET_READ
        || error_code == ERROR_SOCKET_READ_FULLY
        || error_code == ERROR_SOCKET_WRITE;
}

bool srs_is_client_gracefully_close(srs_error_t err)
{
    int error_code = srs_error_code(err);
    return srs_is_client_gracefully_close(error_code);
}

SrsCplxError::SrsCplxError()
{
    code = ERROR_SUCCESS;
    wrapped = NULL;
    cid = rerrno = line = 0;
}

SrsCplxError::~SrsCplxError()
{
}

std::string SrsCplxError::description() {
    if (desc.empty()) {
        stringstream ss;
        ss << "code=" << code;
        
        SrsCplxError* next = this;
        while (next) {
            ss << " : " << next->msg;
            next = next->wrapped;
        }
        ss << endl;
        
        next = this;
        while (next) {
            ss << "thread #" << next->cid << ": "
            << next->func << "() [" << next->file << ":" << next->line << "]"
            << "[errno=" << next->rerrno << "]"
            << endl;
            next = next->wrapped;
        }
        
        desc = ss.str();
    }
    
    return desc;
}

SrsCplxError* SrsCplxError::create(const char* func, const char* file, int line, int code, const char* fmt, ...) {
    int rerrno = (int)errno;

    va_list ap;
    va_start(ap, fmt);
    static char buffer[4096];
    vsnprintf(buffer, sizeof(buffer), fmt, ap);
    va_end(ap);
    
    SrsCplxError* err = new SrsCplxError();
    
    err->func = func;
    err->file = file;
    err->line = line;
    err->code = code;
    err->rerrno = rerrno;
    err->msg = buffer;
    err->wrapped = NULL;
    if (_srs_context) {
        err->cid = _srs_context->get_id();
    }
    
    return err;
}

SrsCplxError* SrsCplxError::wrap(const char* func, const char* file, int line, SrsCplxError* v, const char* fmt, ...) {
    int rerrno = (int)errno;
    
    va_list ap;
    va_start(ap, fmt);
    static char buffer[4096];
    vsnprintf(buffer, sizeof(buffer), fmt, ap);
    va_end(ap);
    
    SrsCplxError* err = new SrsCplxError();
    
    err->func = func;
    err->file = file;
    err->line = line;
    if (v) {
        err->code = v->code;
    }
    err->rerrno = rerrno;
    err->msg = buffer;
    err->wrapped = v;
    if (_srs_context) {
        err->cid = _srs_context->get_id();
    }
    
    return err;
}

SrsCplxError* SrsCplxError::success() {
    return NULL;
}

SrsCplxError* SrsCplxError::copy(SrsCplxError* from)
{
    if (from == srs_success) {
        return srs_success;
    }
    
    SrsCplxError* err = new SrsCplxError();
    
    err->code = from->code;
    err->wrapped = srs_error_copy(from->wrapped);
    err->msg = from->msg;
    err->func = from->func;
    err->file = from->file;
    err->line = from->line;
    err->cid = from->cid;
    err->rerrno = from->rerrno;
    err->desc = from->desc;
    
    return err;
}

string SrsCplxError::description(SrsCplxError* err)
{
    return err? err->description() : "Success";
}

int SrsCplxError::error_code(SrsCplxError* err)
{
    return err? err->code : ERROR_SUCCESS;
}

// following is generated by src/kernel/srs_kernel_log.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kernel_log.hpp>

//#include <srs_kernel_error.hpp>

ISrsLog::ISrsLog()
{
}

ISrsLog::~ISrsLog()
{
}

srs_error_t ISrsLog::initialize()
{
    return srs_success;
}

void ISrsLog::reopen()
{
}

void ISrsLog::verbose(const char* /*tag*/, int /*context_id*/, const char* /*fmt*/, ...)
{
}

void ISrsLog::info(const char* /*tag*/, int /*context_id*/, const char* /*fmt*/, ...)
{
}

void ISrsLog::trace(const char* /*tag*/, int /*context_id*/, const char* /*fmt*/, ...)
{
}

void ISrsLog::warn(const char* /*tag*/, int /*context_id*/, const char* /*fmt*/, ...)
{
}

void ISrsLog::error(const char* /*tag*/, int /*context_id*/, const char* /*fmt*/, ...)
{
}

ISrsThreadContext::ISrsThreadContext()
{
}

ISrsThreadContext::~ISrsThreadContext()
{
}

int ISrsThreadContext::generate_id()
{
    return 0;
}

int ISrsThreadContext::get_id()
{
    return 0;
}

int ISrsThreadContext::set_id(int /*v*/)
{
    return 0;
}


// following is generated by src/kernel/srs_kernel_buffer.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kernel_buffer.hpp>

using namespace std;

//#include <srs_kernel_log.hpp>
//#include <srs_kernel_error.hpp>
//#include <srs_kernel_utility.hpp>

ISrsCodec::ISrsCodec()
{
}

ISrsCodec::~ISrsCodec()
{
}

SrsBuffer::SrsBuffer()
{
    p = bytes = NULL;
    nb_bytes = 0;
    
    // TODO: support both little and big endian.
    srs_assert(srs_is_little_endian());
}

SrsBuffer::SrsBuffer(char* b, int nb_b)
{
    p = bytes = b;
    nb_bytes = nb_b;
    
    // TODO: support both little and big endian.
    srs_assert(srs_is_little_endian());
}

SrsBuffer::~SrsBuffer()
{
}

char* SrsBuffer::data()
{
    return bytes;
}

int SrsBuffer::size()
{
    return nb_bytes;
}

int SrsBuffer::pos()
{
    return (int)(p - bytes);
}

int SrsBuffer::left()
{
    return nb_bytes - (int)(p - bytes);
}

bool SrsBuffer::empty()
{
    return !bytes || (p >= bytes + nb_bytes);
}

bool SrsBuffer::require(int required_size)
{
    srs_assert(required_size >= 0);
    
    return required_size <= nb_bytes - (p - bytes);
}

void SrsBuffer::skip(int size)
{
    srs_assert(p);
    
    p += size;
}

int8_t SrsBuffer::read_1bytes()
{
    srs_assert(require(1));
    
    return (int8_t)*p++;
}

int16_t SrsBuffer::read_2bytes()
{
    srs_assert(require(2));
    
    int16_t value;
    char* pp = (char*)&value;
    pp[1] = *p++;
    pp[0] = *p++;
    
    return value;
}

int32_t SrsBuffer::read_3bytes()
{
    srs_assert(require(3));
    
    int32_t value = 0x00;
    char* pp = (char*)&value;
    pp[2] = *p++;
    pp[1] = *p++;
    pp[0] = *p++;
    
    return value;
}

int32_t SrsBuffer::read_4bytes()
{
    srs_assert(require(4));
    
    int32_t value;
    char* pp = (char*)&value;
    pp[3] = *p++;
    pp[2] = *p++;
    pp[1] = *p++;
    pp[0] = *p++;
    
    return value;
}

int64_t SrsBuffer::read_8bytes()
{
    srs_assert(require(8));
    
    int64_t value;
    char* pp = (char*)&value;
    pp[7] = *p++;
    pp[6] = *p++;
    pp[5] = *p++;
    pp[4] = *p++;
    pp[3] = *p++;
    pp[2] = *p++;
    pp[1] = *p++;
    pp[0] = *p++;
    
    return value;
}

string SrsBuffer::read_string(int len)
{
    srs_assert(require(len));
    
    std::string value;
    value.append(p, len);
    
    p += len;
    
    return value;
}

void SrsBuffer::read_bytes(char* data, int size)
{
    srs_assert(require(size));
    
    memcpy(data, p, size);
    
    p += size;
}

void SrsBuffer::write_1bytes(int8_t value)
{
    srs_assert(require(1));
    
    *p++ = value;
}

void SrsBuffer::write_2bytes(int16_t value)
{
    srs_assert(require(2));
    
    char* pp = (char*)&value;
    *p++ = pp[1];
    *p++ = pp[0];
}

void SrsBuffer::write_4bytes(int32_t value)
{
    srs_assert(require(4));
    
    char* pp = (char*)&value;
    *p++ = pp[3];
    *p++ = pp[2];
    *p++ = pp[1];
    *p++ = pp[0];
}

void SrsBuffer::write_3bytes(int32_t value)
{
    srs_assert(require(3));
    
    char* pp = (char*)&value;
    *p++ = pp[2];
    *p++ = pp[1];
    *p++ = pp[0];
}

void SrsBuffer::write_8bytes(int64_t value)
{
    srs_assert(require(8));
    
    char* pp = (char*)&value;
    *p++ = pp[7];
    *p++ = pp[6];
    *p++ = pp[5];
    *p++ = pp[4];
    *p++ = pp[3];
    *p++ = pp[2];
    *p++ = pp[1];
    *p++ = pp[0];
}

void SrsBuffer::write_string(string value)
{
    srs_assert(require((int)value.length()));
    
    memcpy(p, value.data(), value.length());
    p += value.length();
}

void SrsBuffer::write_bytes(char* data, int size)
{
    srs_assert(require(size));
    
    memcpy(p, data, size);
    p += size;
}

SrsBitBuffer::SrsBitBuffer()
{
    cb = 0;
    cb_left = 0;
    stream = NULL;
}

SrsBitBuffer::~SrsBitBuffer()
{
}

srs_error_t SrsBitBuffer::initialize(SrsBuffer* s) {
    stream = s;
    cb = 0;
    cb_left = 0;
    return srs_success;
}

bool SrsBitBuffer::empty() {
    if (cb_left) {
        return false;
    }
    return stream->empty();
}

int8_t SrsBitBuffer::read_bit() {
    if (!cb_left) {
        srs_assert(!stream->empty());
        cb = stream->read_1bytes();
        cb_left = 8;
    }
    
    int8_t v = (cb >> (cb_left - 1)) & 0x01;
    cb_left--;
    return v;
}

// following is generated by src/kernel/srs_kernel_utility.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kernel_utility.hpp>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <unistd.h>
#include <netdb.h>
#include <arpa/inet.h>
#include <sys/time.h>
#endif

#include <string.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>

#include <vector>
using namespace std;

//#include <srs_core_autofree.hpp>
//#include <srs_kernel_log.hpp>
//#include <srs_kernel_error.hpp>
//#include <srs_kernel_buffer.hpp>
//#include <srs_kernel_flv.hpp>

// this value must:
// equals to (SRS_SYS_CYCLE_INTERVAL*SRS_SYS_TIME_RESOLUTION_MS_TIMES)*1000
// @see SRS_SYS_TIME_RESOLUTION_MS_TIMES
#define SYS_TIME_RESOLUTION_US 300*1000

srs_error_t srs_avc_nalu_read_uev(SrsBitBuffer* stream, int32_t& v)
{
    srs_error_t err = srs_success;
    
    if (stream->empty()) {
        return srs_error_new(ERROR_AVC_NALU_UEV, "empty stream");
    }
    
    // ue(v) in 9.1 Parsing process for Exp-Golomb codes
    // ISO_IEC_14496-10-AVC-2012.pdf, page 227.
    // Syntax elements coded as ue(v), me(v), or se(v) are Exp-Golomb-coded.
    //      leadingZeroBits = -1;
    //      for( b = 0; !b; leadingZeroBits++ )
    //          b = read_bits( 1 )
    // The variable codeNum is then assigned as follows:
    //      codeNum = (2<<leadingZeroBits) - 1 + read_bits( leadingZeroBits )
    int leadingZeroBits = -1;
    for (int8_t b = 0; !b && !stream->empty(); leadingZeroBits++) {
        b = stream->read_bit();
    }
    
    if (leadingZeroBits >= 31) {
        return srs_error_new(ERROR_AVC_NALU_UEV, "%dbits overflow 31bits", leadingZeroBits);
    }
    
    v = (1 << leadingZeroBits) - 1;
    for (int i = 0; i < leadingZeroBits; i++) {
        int32_t b = stream->read_bit();
        v += b << (leadingZeroBits - 1 - i);
    }
    
    return err;
}

srs_error_t srs_avc_nalu_read_bit(SrsBitBuffer* stream, int8_t& v)
{
    srs_error_t err = srs_success;
    
    if (stream->empty()) {
        return srs_error_new(ERROR_AVC_NALU_UEV, "empty stream");
    }
    
    v = stream->read_bit();
    
    return err;
}

static int64_t _srs_system_time_us_cache = 0;
static int64_t _srs_system_time_startup_time = 0;

int64_t srs_get_system_time_ms()
{
    if (_srs_system_time_us_cache <= 0) {
        srs_update_system_time_ms();
    }
    
    return _srs_system_time_us_cache / 1000;
}

int64_t srs_get_system_startup_time_ms()
{
    if (_srs_system_time_startup_time <= 0) {
        srs_update_system_time_ms();
    }
    
    return _srs_system_time_startup_time / 1000;
}

int64_t srs_update_system_time_ms()
{
    timeval now;
    
    if (gettimeofday(&now, NULL) < 0) {
        srs_warn("gettimeofday failed, ignore");
        return -1;
    }
    
    // @see: https://github.com/ossrs/srs/issues/35
    // we must convert the tv_sec/tv_usec to int64_t.
    int64_t now_us = ((int64_t)now.tv_sec) * 1000 * 1000 + (int64_t)now.tv_usec;
    
    // for some ARM os, the starttime maybe invalid,
    // for example, on the cubieboard2, the srs_startup_time is 1262304014640,
    // while now is 1403842979210 in ms, diff is 141538964570 ms, 1638 days
    // it's impossible, and maybe the problem of startup time is invalid.
    // use date +%s to get system time is 1403844851.
    // so we use relative time.
    if (_srs_system_time_us_cache <= 0) {
        _srs_system_time_startup_time = _srs_system_time_us_cache = now_us;
        return _srs_system_time_us_cache / 1000;
    }
    
    // use relative time.
    int64_t diff = now_us - _srs_system_time_us_cache;
    diff = srs_max(0, diff);
    if (diff < 0 || diff > 1000 * SYS_TIME_RESOLUTION_US) {
        srs_warn("clock jump, history=%" PRId64 "us, now=%" PRId64 "us, diff=%" PRId64 "us", _srs_system_time_us_cache, now_us, diff);
        // @see: https://github.com/ossrs/srs/issues/109
        _srs_system_time_startup_time += diff;
    }
    
    _srs_system_time_us_cache = now_us;
    srs_info("clock updated, startup=%" PRId64 "us, now=%" PRId64 "us", _srs_system_time_startup_time, _srs_system_time_us_cache);
    
    return _srs_system_time_us_cache / 1000;
}

string srs_dns_resolve(string host, int& family)
{
    addrinfo hints;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family  = family;
    
    addrinfo* r = NULL;
    SrsAutoFree(addrinfo, r);
    
    if(getaddrinfo(host.c_str(), NULL, NULL, &r)) {
        return "";
    }
    
    char saddr[64];
    char* h = (char*)saddr;
    socklen_t nbh = sizeof(saddr);
    const int r0 = getnameinfo(r->ai_addr, r->ai_addrlen, h, nbh, NULL, 0, NI_NUMERICHOST);

    if(!r0) {
       family = r->ai_family;
       return string(saddr);
    }
    return "";
}

void srs_parse_hostport(const string& hostport, string& host, int& port)
{
    const size_t pos = hostport.rfind(":");   // Look for ":" from the end, to work with IPv6.
    if (pos != std::string::npos) {
        const string p = hostport.substr(pos + 1);
        if ((pos >= 1) &&
            (hostport[0]       == '[') &&
            (hostport[pos - 1] == ']')) {
            // Handle IPv6 in RFC 2732 format, e.g. [3ffe:dead:beef::1]:1935
            host = hostport.substr(1, pos - 2);
        } else {
            // Handle IP address
            host = hostport.substr(0, pos);
        }
        port = ::atoi(p.c_str());
    } else {
        host = hostport;
    }
}

string srs_any_address4listener()
{
    int fd = socket(AF_INET6, SOCK_DGRAM, 0);
    
    // socket()
    // A -1 is returned if an error occurs, otherwise the return value is a
    // descriptor referencing the socket.
    if(fd != -1) {
        close(fd);
        return "::";
    }
    
    return "0.0.0.0";
}

void srs_parse_endpoint(string hostport, string& ip, int& port)
{
    const size_t pos = hostport.rfind(":");   // Look for ":" from the end, to work with IPv6.
    if (pos != std::string::npos) {
        if ((pos >= 1) && (hostport[0] == '[') && (hostport[pos - 1] == ']')) {
            // Handle IPv6 in RFC 2732 format, e.g. [3ffe:dead:beef::1]:1935
            ip = hostport.substr(1, pos - 2);
        } else {
            // Handle IP address
            ip = hostport.substr(0, pos);
        }
        
        const string sport = hostport.substr(pos + 1);
        port = ::atoi(sport.c_str());
    } else {
        ip   = srs_any_address4listener();
        port = ::atoi(hostport.c_str());
    }
}

string srs_int2str(int64_t value)
{
    // len(max int64_t) is 20, plus one "+-."
    char tmp[22];
    snprintf(tmp, 22, "%" PRId64, value);
    return tmp;
}

string srs_float2str(double value)
{
    // len(max int64_t) is 20, plus one "+-."
    char tmp[22];
    snprintf(tmp, 22, "%.2f", value);
    return tmp;
}

string srs_bool2switch(bool v) {
    return v? "on" : "off";
}

bool srs_is_little_endian()
{
    // convert to network(big-endian) order, if not equals,
    // the system is little-endian, so need to convert the int64
    static int little_endian_check = -1;
    
    if(little_endian_check == -1) {
        union {
            int32_t i;
            int8_t c;
        } little_check_union;
        
        little_check_union.i = 0x01;
        little_endian_check = little_check_union.c;
    }
    
    return (little_endian_check == 1);
}

string srs_string_replace(string str, string old_str, string new_str)
{
    std::string ret = str;
    
    if (old_str == new_str) {
        return ret;
    }
    
    size_t pos = 0;
    while ((pos = ret.find(old_str, pos)) != std::string::npos) {
        ret = ret.replace(pos, old_str.length(), new_str);
    }
    
    return ret;
}

string srs_string_trim_end(string str, string trim_chars)
{
    std::string ret = str;
    
    for (int i = 0; i < (int)trim_chars.length(); i++) {
        char ch = trim_chars.at(i);
        
        while (!ret.empty() && ret.at(ret.length() - 1) == ch) {
            ret.erase(ret.end() - 1);
            
            // ok, matched, should reset the search
            i = 0;
        }
    }
    
    return ret;
}

string srs_string_trim_start(string str, string trim_chars)
{
    std::string ret = str;
    
    for (int i = 0; i < (int)trim_chars.length(); i++) {
        char ch = trim_chars.at(i);
        
        while (!ret.empty() && ret.at(0) == ch) {
            ret.erase(ret.begin());
            
            // ok, matched, should reset the search
            i = 0;
        }
    }
    
    return ret;
}

string srs_string_remove(string str, string remove_chars)
{
    std::string ret = str;
    
    for (int i = 0; i < (int)remove_chars.length(); i++) {
        char ch = remove_chars.at(i);
        
        for (std::string::iterator it = ret.begin(); it != ret.end();) {
            if (ch == *it) {
                it = ret.erase(it);
                
                // ok, matched, should reset the search
                i = 0;
            } else {
                ++it;
            }
        }
    }
    
    return ret;
}

bool srs_string_ends_with(string str, string flag)
{
    const size_t pos = str.rfind(flag);
    return (pos != string::npos) && (pos == str.length() - flag.length());
}

bool srs_string_ends_with(string str, string flag0, string flag1)
{
    return srs_string_ends_with(str, flag0) || srs_string_ends_with(str, flag1);
}

bool srs_string_ends_with(string str, string flag0, string flag1, string flag2)
{
    return srs_string_ends_with(str, flag0) || srs_string_ends_with(str, flag1) || srs_string_ends_with(str, flag2);
}

bool srs_string_ends_with(string str, string flag0, string flag1, string flag2, string flag3)
{
    return srs_string_ends_with(str, flag0) || srs_string_ends_with(str, flag1) || srs_string_ends_with(str, flag2) || srs_string_ends_with(str, flag3);
}

bool srs_string_starts_with(string str, string flag)
{
    return str.find(flag) == 0;
}

bool srs_string_starts_with(string str, string flag0, string flag1)
{
    return srs_string_starts_with(str, flag0) || srs_string_starts_with(str, flag1);
}

bool srs_string_starts_with(string str, string flag0, string flag1, string flag2)
{
    return srs_string_starts_with(str, flag0, flag1) || srs_string_starts_with(str, flag2);
}

bool srs_string_starts_with(string str, string flag0, string flag1, string flag2, string flag3)
{
    return srs_string_starts_with(str, flag0, flag1, flag2) || srs_string_starts_with(str, flag3);
}

bool srs_string_contains(string str, string flag)
{
    return str.find(flag) != string::npos;
}

bool srs_string_contains(string str, string flag0, string flag1)
{
    return str.find(flag0) != string::npos || str.find(flag1) != string::npos;
}

bool srs_string_contains(string str, string flag0, string flag1, string flag2)
{
    return str.find(flag0) != string::npos || str.find(flag1) != string::npos || str.find(flag2) != string::npos;
}

vector<string> srs_string_split(string str, string flag)
{
    vector<string> arr;
    
    size_t pos;
    string s = str;
    
    while ((pos = s.find(flag)) != string::npos) {
        if (pos != 0) {
            arr.push_back(s.substr(0, pos));
        }
        s = s.substr(pos + flag.length());
    }
    
    if (!s.empty()) {
        arr.push_back(s);
    }
    
    return arr;
}

string srs_string_min_match(string str, vector<string> flags)
{
    string match;
    
    size_t min_pos = string::npos;
    for (vector<string>::iterator it = flags.begin(); it != flags.end(); ++it) {
        string flag = *it;
        
        size_t pos = str.find(flag);
        if (pos == string::npos) {
            continue;
        }
        
        if (min_pos == string::npos || pos < min_pos) {
            min_pos = pos;
            match = flag;
        }
    }
    
    return match;
}

vector<string> srs_string_split(string str, vector<string> flags)
{
    vector<string> arr;
    
    size_t pos = string::npos;
    string s = str;
    
    while (true) {
        string flag = srs_string_min_match(s, flags);
        if (flag.empty()) {
            break;
        }
        
        if ((pos = s.find(flag)) == string::npos) {
            break;
        }
        
        if (pos != 0) {
            arr.push_back(s.substr(0, pos));
        }
        s = s.substr(pos + flag.length());
    }
    
    if (!s.empty()) {
        arr.push_back(s);
    }
    
    return arr;
}

int srs_do_create_dir_recursively(string dir)
{
    int ret = ERROR_SUCCESS;
    
    // stat current dir, if exists, return error.
    if (srs_path_exists(dir)) {
        return ERROR_SYSTEM_DIR_EXISTS;
    }
    
    // create parent first.
    size_t pos;
    if ((pos = dir.rfind("/")) != std::string::npos) {
        std::string parent = dir.substr(0, pos);
        ret = srs_do_create_dir_recursively(parent);
        // return for error.
        if (ret != ERROR_SUCCESS && ret != ERROR_SYSTEM_DIR_EXISTS) {
            return ret;
        }
        // parent exists, set to ok.
        ret = ERROR_SUCCESS;
    }
    
    // create curren dir.
    // for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
    mode_t mode = S_IRUSR|S_IWUSR|S_IXUSR|S_IRGRP|S_IWGRP|S_IXGRP|S_IROTH|S_IXOTH;
    if (::mkdir(dir.c_str(), mode) < 0) {
#else
    if (::mkdir(dir.c_str()) < 0) {
#endif
        if (errno == EEXIST) {
            return ERROR_SYSTEM_DIR_EXISTS;
        }
        
        ret = ERROR_SYSTEM_CREATE_DIR;
        srs_error("create dir %s failed. ret=%d", dir.c_str(), ret);
        return ret;
    }
    
    srs_info("create dir %s success.", dir.c_str());
    
    return ret;
}
    
bool srs_bytes_equals(void* pa, void* pb, int size)
{
    uint8_t* a = (uint8_t*)pa;
    uint8_t* b = (uint8_t*)pb;
    
    if (!a && !b) {
        return true;
    }
    
    if (!a || !b) {
        return false;
    }
    
    for(int i = 0; i < size; i++){
        if(a[i] != b[i]){
            return false;
        }
    }
    
    return true;
}

srs_error_t srs_create_dir_recursively(string dir)
{
    int ret = srs_do_create_dir_recursively(dir);
    
    if (ret == ERROR_SYSTEM_DIR_EXISTS || ret == ERROR_SUCCESS) {
        return srs_success;
    }
    
    return srs_error_new(ret, "create dir %s", dir.c_str());
}

bool srs_path_exists(std::string path)
{
    struct stat st;
    
    // stat current dir, if exists, return error.
    if (stat(path.c_str(), &st) == 0) {
        return true;
    }
    
    return false;
}

string srs_path_dirname(string path)
{
    std::string dirname = path;
    size_t pos = string::npos;
    
    if ((pos = dirname.rfind("/")) != string::npos) {
        if (pos == 0) {
            return "/";
        }
        dirname = dirname.substr(0, pos);
    }
    
    return dirname;
}

string srs_path_basename(string path)
{
    std::string dirname = path;
    size_t pos = string::npos;
    
    if ((pos = dirname.rfind("/")) != string::npos) {
        // the basename("/") is "/"
        if (dirname.length() == 1) {
            return dirname;
        }
        dirname = dirname.substr(pos + 1);
    }
    
    return dirname;
}

string srs_path_filename(string path)
{
    std::string filename = path;
    size_t pos = string::npos;
    
    if ((pos = filename.rfind(".")) != string::npos) {
        return filename.substr(0, pos);
    }
    
    return filename;
}

string srs_path_filext(string path)
{
    size_t pos = string::npos;
    
    if ((pos = path.rfind(".")) != string::npos) {
        return path.substr(pos);
    }
    
    return "";
}

bool srs_avc_startswith_annexb(SrsBuffer* stream, int* pnb_start_code)
{
    char* bytes = stream->data() + stream->pos();
    char* p = bytes;
    
    for (;;) {
        if (!stream->require((int)(p - bytes + 3))) {
            return false;
        }
        
        // not match
        if (p[0] != (char)0x00 || p[1] != (char)0x00) {
            return false;
        }
        
        // match N[00] 00 00 01, where N>=0
        if (p[2] == (char)0x01) {
            if (pnb_start_code) {
                *pnb_start_code = (int)(p - bytes) + 3;
            }
            return true;
        }
        
        p++;
    }
    
    return false;
}

bool srs_aac_startswith_adts(SrsBuffer* stream)
{
    char* bytes = stream->data() + stream->pos();
    char* p = bytes;
    
    if (!stream->require((int)(p - bytes) + 2)) {
        return false;
    }
    
    // matched 12bits 0xFFF,
    // @remark, we must cast the 0xff to char to compare.
    if (p[0] != (char)0xff || (char)(p[1] & 0xf0) != (char)0xf0) {
        return false;
    }
    
    return true;
}
    
// @see pycrc reflect at https://github.com/winlinvip/pycrc/blob/master/pycrc/algorithms.py#L107
uint64_t __crc32_reflect(uint64_t data, int width)
{
    uint64_t res = data & 0x01;
    
    for (int i = 0; i < width - 1; i++) {
        data >>= 1;
        res = (res << 1) | (data & 0x01);
    }
    
    return res;
}
    
// @see pycrc gen_table at https://github.com/winlinvip/pycrc/blob/master/pycrc/algorithms.py#L178
void __crc32_make_table(uint32_t t[256], uint32_t poly, bool reflect_in)
{
    int width = 32; // 32bits checksum.
    uint64_t msb_mask = (uint32_t)(0x01 << (width - 1));
    uint64_t mask = (uint32_t)(((msb_mask - 1) << 1) | 1);
    
    int tbl_idx_width = 8; // table index size.
    int tbl_width = 0x01 << tbl_idx_width; // table size: 256
    
    for (int i = 0; i < tbl_width; i++) {
        uint64_t reg = uint64_t(i);
        
        if (reflect_in) {
            reg = __crc32_reflect(reg, tbl_idx_width);
        }
        
        reg = reg << (width - tbl_idx_width);
        for (int j = 0; j < tbl_idx_width; j++) {
            if ((reg&msb_mask) != 0) {
                reg = (reg << 1) ^ poly;
            } else {
                reg = reg << 1;
            }
        }
        
        if (reflect_in) {
            reg = __crc32_reflect(reg, width);
        }
        
        t[i] = (uint32_t)(reg & mask);
    }
}
 
// @see pycrc table_driven at https://github.com/winlinvip/pycrc/blob/master/pycrc/algorithms.py#L207
uint32_t __crc32_table_driven(uint32_t* t, const void* buf, int size, uint32_t previous, bool reflect_in, uint32_t xor_in, bool reflect_out, uint32_t xor_out)
{
    int width = 32; // 32bits checksum.
    uint64_t msb_mask = (uint32_t)(0x01 << (width - 1));
    uint64_t mask = (uint32_t)(((msb_mask - 1) << 1) | 1);
    
    int tbl_idx_width = 8; // table index size.
    
    uint8_t* p = (uint8_t*)buf;
    uint64_t reg = 0;
    
    if (!reflect_in) {
        reg = xor_in;
        
        for (int i = 0; i < size; i++) {
            uint8_t tblidx = (uint8_t)((reg >> (width - tbl_idx_width)) ^ p[i]);
            reg = t[tblidx] ^ (reg << tbl_idx_width);
        }
    } else {
        reg = previous ^ __crc32_reflect(xor_in, width);
        
        for (int i = 0; i < size; i++) {
            uint8_t tblidx = (uint8_t)(reg ^ p[i]);
            reg = t[tblidx] ^ (reg >> tbl_idx_width);
        }
        
        reg = __crc32_reflect(reg, width);
    }
    
    if (reflect_out) {
        reg = __crc32_reflect(reg, width);
    }
    
    reg ^= xor_out;
    return (uint32_t)(reg & mask);
}
    
// @see pycrc https://github.com/winlinvip/pycrc/blob/master/pycrc/algorithms.py#L207
// IEEETable is the table for the IEEE polynomial.
static uint32_t __crc32_IEEE_table[256];
static bool __crc32_IEEE_table_initialized = false;

// @see pycrc https://github.com/winlinvip/pycrc/blob/master/pycrc/models.py#L220
//      crc32('123456789') = 0xcbf43926
// where it's defined as model:
//      'name':         'crc-32',
//      'width':         32,
//      'poly':          0x4c11db7,
//      'reflect_in':    True,
//      'xor_in':        0xffffffff,
//      'reflect_out':   True,
//      'xor_out':       0xffffffff,
//      'check':         0xcbf43926,
uint32_t srs_crc32_ieee(const void* buf, int size, uint32_t previous)
{
    // @see golang IEEE of hash/crc32/crc32.go
    // IEEE is by far and away the most common CRC-32 polynomial.
    // Used by ethernet (IEEE 802.3), v.42, fddi, gzip, zip, png, ...
    // @remark The poly of CRC32 IEEE is 0x04C11DB7, its reverse is 0xEDB88320,
    //      please read https://en.wikipedia.org/wiki/Cyclic_redundancy_check
    uint32_t poly = 0x04C11DB7;
    
    bool reflect_in = true;
    uint32_t xor_in = 0xffffffff;
    bool reflect_out = true;
    uint32_t xor_out = 0xffffffff;
    
    if (!__crc32_IEEE_table_initialized) {
        __crc32_make_table(__crc32_IEEE_table, poly, reflect_in);
        __crc32_IEEE_table_initialized = true;
    }
    
    return __crc32_table_driven(__crc32_IEEE_table, buf, size, previous, reflect_in, xor_in, reflect_out, xor_out);
}
    
// @see pycrc https://github.com/winlinvip/pycrc/blob/master/pycrc/algorithms.py#L238
// IEEETable is the table for the MPEG polynomial.
static uint32_t __crc32_MPEG_table[256];
static bool __crc32_MPEG_table_initialized = false;

// @see pycrc https://github.com/winlinvip/pycrc/blob/master/pycrc/models.py#L238
//      crc32('123456789') = 0x0376e6e7
// where it's defined as model:
//      'name':         'crc-32',
//      'width':         32,
//      'poly':          0x4c11db7,
//      'reflect_in':    False,
//      'xor_in':        0xffffffff,
//      'reflect_out':   False,
//      'xor_out':       0x0,
//      'check':         0x0376e6e7,
uint32_t srs_crc32_mpegts(const void* buf, int size)
{
    // @see golang IEEE of hash/crc32/crc32.go
    // IEEE is by far and away the most common CRC-32 polynomial.
    // Used by ethernet (IEEE 802.3), v.42, fddi, gzip, zip, png, ...
    // @remark The poly of CRC32 IEEE is 0x04C11DB7, its reverse is 0xEDB88320,
    //      please read https://en.wikipedia.org/wiki/Cyclic_redundancy_check
    uint32_t poly = 0x04C11DB7;
    
    bool reflect_in = false;
    uint32_t xor_in = 0xffffffff;
    bool reflect_out = false;
    uint32_t xor_out = 0x0;
    
    if (!__crc32_MPEG_table_initialized) {
        __crc32_make_table(__crc32_MPEG_table, poly, reflect_in);
        __crc32_MPEG_table_initialized = true;
    }
    
    return __crc32_table_driven(__crc32_MPEG_table, buf, size, 0x00, reflect_in, xor_in, reflect_out, xor_out);
}

// @see golang encoding/base64/base64.go
srs_error_t srs_av_base64_decode(string cipher, string& plaintext)
{
    srs_error_t err = srs_success;
    
    // We use the standard encoding:
    //      var StdEncoding = NewEncoding(encodeStd)
    // StdEncoding is the standard base64 encoding, as defined in RFC 4648.
    char padding = '=';
    string encoder = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    
    uint8_t decodeMap[256];
    memset(decodeMap, 0xff, sizeof(decodeMap));
    
    for (int i = 0; i < encoder.length(); i++) {
        decodeMap[(uint8_t)encoder.at(i)] = uint8_t(i);
    }
    
    // decode is like Decode but returns an additional 'end' value, which
    // indicates if end-of-message padding or a partial quantum was encountered
    // and thus any additional data is an error.
    int si = 0;
    
    // skip over newlines
    for (; si < cipher.length() && (cipher.at(si) == '\n' || cipher.at(si) == '\r'); si++) {
    }
    
    for (bool end = false; si < cipher.length() && !end;) {
        // Decode quantum using the base64 alphabet
        uint8_t dbuf[4];
        memset(dbuf, 0x00, sizeof(dbuf));
        
        int dinc = 3;
        int dlen = 4;
        
        for (int j = 0; j < sizeof(dbuf); j++) {
            if (si == cipher.length()) {
                if (padding != -1 || j < 2) {
                    return srs_error_new(ERROR_BASE64_DECODE, "corrupt input at %d", si);
                }
                
                dinc = j - 1;
                dlen = j;
                end = true;
                break;
            }
            
            char in = cipher.at(si);
            
            si++;
            // skip over newlines
            for (; si < cipher.length() && (cipher.at(si) == '\n' || cipher.at(si) == '\r'); si++) {
            }
            
            if (in == padding) {
                // We've reached the end and there's padding
                switch (j) {
                    case 0:
                    case 1:
                        // incorrect padding
                        return srs_error_new(ERROR_BASE64_DECODE, "corrupt input at %d", si);
                    case 2:
                        // "==" is expected, the first "=" is already consumed.
                        if (si == cipher.length()) {
                            return srs_error_new(ERROR_BASE64_DECODE, "corrupt input at %d", si);
                        }
                        if (cipher.at(si) != padding) {
                            // incorrect padding
                            return srs_error_new(ERROR_BASE64_DECODE, "corrupt input at %d", si);
                        }
                        
                        si++;
                        // skip over newlines
                        for (; si < cipher.length() && (cipher.at(si) == '\n' || cipher.at(si) == '\r'); si++) {
                        }
                }
                
                if (si < cipher.length()) {
                    // trailing garbage
                    err = srs_error_new(ERROR_BASE64_DECODE, "corrupt input at %d", si);
                }
                dinc = 3;
                dlen = j;
                end = true;
                break;
            }
            
            dbuf[j] = decodeMap[(uint8_t)in];
            if (dbuf[j] == 0xff) {
                return srs_error_new(ERROR_BASE64_DECODE, "corrupt input at %d", si);
            }
        }
        
        // Convert 4x 6bit source bytes into 3 bytes
        uint32_t val = uint32_t(dbuf[0])<<18 | uint32_t(dbuf[1])<<12 | uint32_t(dbuf[2])<<6 | uint32_t(dbuf[3]);
        if (dlen >= 2) {
            plaintext.append(1, char(val >> 16));
        }
        if (dlen >= 3) {
            plaintext.append(1, char(val >> 8));
        }
        if (dlen >= 4) {
            plaintext.append(1, char(val));
        }
    }
    
    return err;
}

#define SPACE_CHARS " \t\r\n"

int av_toupper(int c)
{
    if (c >= 'a' && c <= 'z') {
        c ^= 0x20;
    }
    return c;
}
    
// fromHexChar converts a hex character into its value and a success flag.
uint8_t srs_from_hex_char(uint8_t c)
{
    if ('0' <= c && c <= '9') {
        return c - '0';
    }
    if ('a' <= c && c <= 'f') {
        return c - 'a' + 10;
    }
    if ('A' <= c && c <= 'F') {
        return c - 'A' + 10;
    }
    
    return -1;
}

int srs_hex_to_data(uint8_t* data, const char* p, int size)
{
    if (size <= 0 || (size%2) == 1) {
        return -1;
    }
    
    for (int i = 0; i < size / 2; i++) {
        uint8_t a = srs_from_hex_char(p[i*2]);
        if (a == (uint8_t)-1) {
            return -1;
        }
        
        uint8_t b = srs_from_hex_char(p[i*2 + 1]);
        if (b == (uint8_t)-1) {
            return -1;
        }
        
        data[i] = (a << 4) | b;
    }
    
    return size / 2;
}

int srs_chunk_header_c0(int perfer_cid, uint32_t timestamp, int32_t payload_length, int8_t message_type, int32_t stream_id, char* cache, int nb_cache)
{
    // to directly set the field.
    char* pp = NULL;
    
    // generate the header.
    char* p = cache;
    
    // no header.
    if (nb_cache < SRS_CONSTS_RTMP_MAX_FMT0_HEADER_SIZE) {
        return 0;
    }
    
    // write new chunk stream header, fmt is 0
    *p++ = 0x00 | (perfer_cid & 0x3F);
    
    // chunk message header, 11 bytes
    // timestamp, 3bytes, big-endian
    if (timestamp < RTMP_EXTENDED_TIMESTAMP) {
        pp = (char*)&timestamp;
        *p++ = pp[2];
        *p++ = pp[1];
        *p++ = pp[0];
    } else {
        *p++ = 0xFF;
        *p++ = 0xFF;
        *p++ = 0xFF;
    }
    
    // message_length, 3bytes, big-endian
    pp = (char*)&payload_length;
    *p++ = pp[2];
    *p++ = pp[1];
    *p++ = pp[0];
    
    // message_type, 1bytes
    *p++ = message_type;
    
    // stream_id, 4bytes, little-endian
    pp = (char*)&stream_id;
    *p++ = pp[0];
    *p++ = pp[1];
    *p++ = pp[2];
    *p++ = pp[3];
    
    // for c0
    // chunk extended timestamp header, 0 or 4 bytes, big-endian
    //
    // for c3:
    // chunk extended timestamp header, 0 or 4 bytes, big-endian
    // 6.1.3. Extended Timestamp
    // This field is transmitted only when the normal time stamp in the
    // chunk message header is set to 0x00ffffff. If normal time stamp is
    // set to any value less than 0x00ffffff, this field MUST NOT be
    // present. This field MUST NOT be present if the timestamp field is not
    // present. Type 3 chunks MUST NOT have this field.
    // adobe changed for Type3 chunk:
    //        FMLE always sendout the extended-timestamp,
    //        must send the extended-timestamp to FMS,
    //        must send the extended-timestamp to flash-player.
    // @see: ngx_rtmp_prepare_message
    // @see: http://blog.csdn.net/win_lin/article/details/13363699
    // TODO: FIXME: extract to outer.
    if (timestamp >= RTMP_EXTENDED_TIMESTAMP) {
        pp = (char*)&timestamp;
        *p++ = pp[3];
        *p++ = pp[2];
        *p++ = pp[1];
        *p++ = pp[0];
    }
    
    // always has header
    return (int)(p - cache);
}

int srs_chunk_header_c3(int perfer_cid, uint32_t timestamp, char* cache, int nb_cache)
{
    // to directly set the field.
    char* pp = NULL;
    
    // generate the header.
    char* p = cache;
    
    // no header.
    if (nb_cache < SRS_CONSTS_RTMP_MAX_FMT3_HEADER_SIZE) {
        return 0;
    }
    
    // write no message header chunk stream, fmt is 3
    // @remark, if perfer_cid > 0x3F, that is, use 2B/3B chunk header,
    // SRS will rollback to 1B chunk header.
    *p++ = 0xC0 | (perfer_cid & 0x3F);
    
    // for c0
    // chunk extended timestamp header, 0 or 4 bytes, big-endian
    //
    // for c3:
    // chunk extended timestamp header, 0 or 4 bytes, big-endian
    // 6.1.3. Extended Timestamp
    // This field is transmitted only when the normal time stamp in the
    // chunk message header is set to 0x00ffffff. If normal time stamp is
    // set to any value less than 0x00ffffff, this field MUST NOT be
    // present. This field MUST NOT be present if the timestamp field is not
    // present. Type 3 chunks MUST NOT have this field.
    // adobe changed for Type3 chunk:
    //        FMLE always sendout the extended-timestamp,
    //        must send the extended-timestamp to FMS,
    //        must send the extended-timestamp to flash-player.
    // @see: ngx_rtmp_prepare_message
    // @see: http://blog.csdn.net/win_lin/article/details/13363699
    // TODO: FIXME: extract to outer.
    if (timestamp >= RTMP_EXTENDED_TIMESTAMP) {
        pp = (char*)&timestamp;
        *p++ = pp[3];
        *p++ = pp[2];
        *p++ = pp[1];
        *p++ = pp[0];
    }
    
    // always has header
    return (int)(p - cache);
}

// following is generated by src/kernel/srs_kernel_flv.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kernel_flv.hpp>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <unistd.h>
#endif

#include <fcntl.h>
#include <sstream>
using namespace std;

//#include <srs_kernel_log.hpp>
//#include <srs_kernel_error.hpp>
//#include <srs_kernel_buffer.hpp>
//#include <srs_kernel_file.hpp>
//#include <srs_kernel_codec.hpp>
//#include <srs_kernel_utility.hpp>
//#include <srs_core_mem_watch.hpp>
//#include <srs_core_autofree.hpp>

SrsMessageHeader::SrsMessageHeader()
{
    message_type = 0;
    payload_length = 0;
    timestamp_delta = 0;
    stream_id = 0;
    
    timestamp = 0;
    // we always use the connection chunk-id
    perfer_cid = RTMP_CID_OverConnection;
}

SrsMessageHeader::~SrsMessageHeader()
{
}

bool SrsMessageHeader::is_audio()
{
    return message_type == RTMP_MSG_AudioMessage;
}

bool SrsMessageHeader::is_video()
{
    return message_type == RTMP_MSG_VideoMessage;
}

bool SrsMessageHeader::is_amf0_command()
{
    return message_type == RTMP_MSG_AMF0CommandMessage;
}

bool SrsMessageHeader::is_amf0_data()
{
    return message_type == RTMP_MSG_AMF0DataMessage;
}

bool SrsMessageHeader::is_amf3_command()
{
    return message_type == RTMP_MSG_AMF3CommandMessage;
}

bool SrsMessageHeader::is_amf3_data()
{
    return message_type == RTMP_MSG_AMF3DataMessage;
}

bool SrsMessageHeader::is_window_ackledgement_size()
{
    return message_type == RTMP_MSG_WindowAcknowledgementSize;
}

bool SrsMessageHeader::is_ackledgement()
{
    return message_type == RTMP_MSG_Acknowledgement;
}

bool SrsMessageHeader::is_set_chunk_size()
{
    return message_type == RTMP_MSG_SetChunkSize;
}

bool SrsMessageHeader::is_user_control_message()
{
    return message_type == RTMP_MSG_UserControlMessage;
}

bool SrsMessageHeader::is_set_peer_bandwidth()
{
    return message_type == RTMP_MSG_SetPeerBandwidth;
}

bool SrsMessageHeader::is_aggregate()
{
    return message_type == RTMP_MSG_AggregateMessage;
}

void SrsMessageHeader::initialize_amf0_script(int size, int stream)
{
    message_type = RTMP_MSG_AMF0DataMessage;
    payload_length = (int32_t)size;
    timestamp_delta = (int32_t)0;
    timestamp = (int64_t)0;
    stream_id = (int32_t)stream;
    
    // amf0 script use connection2 chunk-id
    perfer_cid = RTMP_CID_OverConnection2;
}

void SrsMessageHeader::initialize_audio(int size, uint32_t time, int stream)
{
    message_type = RTMP_MSG_AudioMessage;
    payload_length = (int32_t)size;
    timestamp_delta = (int32_t)time;
    timestamp = (int64_t)time;
    stream_id = (int32_t)stream;
    
    // audio chunk-id
    perfer_cid = RTMP_CID_Audio;
}

void SrsMessageHeader::initialize_video(int size, uint32_t time, int stream)
{
    message_type = RTMP_MSG_VideoMessage;
    payload_length = (int32_t)size;
    timestamp_delta = (int32_t)time;
    timestamp = (int64_t)time;
    stream_id = (int32_t)stream;
    
    // video chunk-id
    perfer_cid = RTMP_CID_Video;
}

SrsCommonMessage::SrsCommonMessage()
{
    payload = NULL;
    size = 0;
}

SrsCommonMessage::~SrsCommonMessage()
{
#ifdef SRS_AUTO_MEM_WATCH
    srs_memory_unwatch(payload);
#endif
    srs_freepa(payload);
}

void SrsCommonMessage::create_payload(int size)
{
    srs_freepa(payload);
    
    payload = new char[size];
    srs_verbose("create payload for RTMP message. size=%d", size);
    
#ifdef SRS_AUTO_MEM_WATCH
    srs_memory_watch(payload, "RTMP.msg.payload", size);
#endif
}

srs_error_t SrsCommonMessage::create(SrsMessageHeader* pheader, char* body, int size)
{
    // drop previous payload.
    srs_freepa(payload);
    
    this->header = *pheader;
    this->payload = body;
    this->size = size;
    
    return srs_success;
}

SrsSharedMessageHeader::SrsSharedMessageHeader() : payload_length(0), message_type(0), perfer_cid(0)
{
}

SrsSharedMessageHeader::~SrsSharedMessageHeader()
{
}

SrsSharedPtrMessage::SrsSharedPtrPayload::SrsSharedPtrPayload()
{
    payload = NULL;
    size = 0;
    shared_count = 0;
}

SrsSharedPtrMessage::SrsSharedPtrPayload::~SrsSharedPtrPayload()
{
#ifdef SRS_AUTO_MEM_WATCH
    srs_memory_unwatch(payload);
#endif
    srs_freepa(payload);
}

SrsSharedPtrMessage::SrsSharedPtrMessage() : timestamp(0), stream_id(0), size(0), payload(NULL)
{
    ptr = NULL;
}

SrsSharedPtrMessage::~SrsSharedPtrMessage()
{
    if (ptr) {
        if (ptr->shared_count == 0) {
            srs_freep(ptr);
        } else {
            ptr->shared_count--;
        }
    }
}

srs_error_t SrsSharedPtrMessage::create(SrsCommonMessage* msg)
{
    srs_error_t err = srs_success;
    
    if ((err = create(&msg->header, msg->payload, msg->size)) != srs_success) {
        return srs_error_wrap(err, "create message");
    }
    
    // to prevent double free of payload:
    // initialize already attach the payload of msg,
    // detach the payload to transfer the owner to shared ptr.
    msg->payload = NULL;
    msg->size = 0;
    
    return err;
}

srs_error_t SrsSharedPtrMessage::create(SrsMessageHeader* pheader, char* payload, int size)
{
    srs_error_t err = srs_success;
    
    if (ptr) {
        srs_assert(false);
        return srs_error_new(ERROR_SYSTEM_ASSERT_FAILED, "should not set the payload twice");
    }
    
    ptr = new SrsSharedPtrPayload();
    
    // direct attach the data.
    if (pheader) {
        ptr->header.message_type = pheader->message_type;
        ptr->header.payload_length = size;
        ptr->header.perfer_cid = pheader->perfer_cid;
        this->timestamp = pheader->timestamp;
        this->stream_id = pheader->stream_id;
    }
    ptr->payload = payload;
    ptr->size = size;
    
    // message can access it.
    this->payload = ptr->payload;
    this->size = ptr->size;
    
    return err;
}

int SrsSharedPtrMessage::count()
{
    srs_assert(ptr);
    return ptr->shared_count;
}

bool SrsSharedPtrMessage::check(int stream_id)
{
    // we donot use the complex basic header,
    // ensure the basic header is 1bytes.
    if (ptr->header.perfer_cid < 2) {
        srs_info("change the chunk_id=%d to default=%d", ptr->header.perfer_cid, RTMP_CID_ProtocolControl);
        ptr->header.perfer_cid = RTMP_CID_ProtocolControl;
    }
    
    // we assume that the stream_id in a group must be the same.
    if (this->stream_id == stream_id) {
        return true;
    }
    this->stream_id = stream_id;
    
    return false;
}

bool SrsSharedPtrMessage::is_av()
{
    return ptr->header.message_type == RTMP_MSG_AudioMessage
    || ptr->header.message_type == RTMP_MSG_VideoMessage;
}

bool SrsSharedPtrMessage::is_audio()
{
    return ptr->header.message_type == RTMP_MSG_AudioMessage;
}

bool SrsSharedPtrMessage::is_video()
{
    return ptr->header.message_type == RTMP_MSG_VideoMessage;
}

int SrsSharedPtrMessage::chunk_header(char* cache, int nb_cache, bool c0)
{
    if (c0) {
        return srs_chunk_header_c0(ptr->header.perfer_cid, (uint32_t)timestamp,
            ptr->header.payload_length, ptr->header.message_type, stream_id, cache, nb_cache);
    } else {
        return srs_chunk_header_c3(ptr->header.perfer_cid, (uint32_t)timestamp,
            cache, nb_cache);
    }
}

SrsSharedPtrMessage* SrsSharedPtrMessage::copy()
{
    srs_assert(ptr);
    
    SrsSharedPtrMessage* copy = new SrsSharedPtrMessage();
    
    copy->ptr = ptr;
    ptr->shared_count++;
    
    copy->timestamp = timestamp;
    copy->stream_id = stream_id;
    copy->payload = ptr->payload;
    copy->size = ptr->size;
    
    return copy;
}

SrsFlvTransmuxer::SrsFlvTransmuxer()
{
    writer = NULL;
    
#ifdef SRS_PERF_FAST_FLV_ENCODER
    nb_tag_headers = 0;
    tag_headers = NULL;
    nb_iovss_cache = 0;
    iovss_cache = NULL;
    nb_ppts = 0;
    ppts = NULL;
#endif
}

SrsFlvTransmuxer::~SrsFlvTransmuxer()
{
#ifdef SRS_PERF_FAST_FLV_ENCODER
    srs_freepa(tag_headers);
    srs_freepa(iovss_cache);
    srs_freepa(ppts);
#endif
}

srs_error_t SrsFlvTransmuxer::initialize(ISrsWriter* fw)
{
    srs_assert(fw);
    writer = fw;
    return srs_success;
}

srs_error_t SrsFlvTransmuxer::write_header()
{
    srs_error_t err = srs_success;
    
    // 9bytes header and 4bytes first previous-tag-size
    char flv_header[] = {
        'F', 'L', 'V', // Signatures "FLV"
        (char)0x01, // File version (for example, 0x01 for FLV version 1)
        (char)0x05, // 4, audio; 1, video; 5 audio+video.
        (char)0x00, (char)0x00, (char)0x00, (char)0x09 // DataOffset UI32 The length of this header in bytes
    };
    
    // flv specification should set the audio and video flag,
    // actually in practise, application generally ignore this flag,
    // so we generally set the audio/video to 0.
    
    // write 9bytes header.
    if ((err = write_header(flv_header)) != srs_success) {
        return srs_error_wrap(err, "write header");
    }
    
    return err;
}

srs_error_t SrsFlvTransmuxer::write_header(char flv_header[9])
{
    srs_error_t err = srs_success;
    
    // write data.
    if ((err = writer->write(flv_header, 9, NULL)) != srs_success) {
        return srs_error_wrap(err, "write flv header failed");
    }
    
    // previous tag size.
    char pts[] = { (char)0x00, (char)0x00, (char)0x00, (char)0x00 };
    if ((err = writer->write(pts, 4, NULL)) != srs_success) {
        return srs_error_wrap(err, "write pts");
    }
    
    return err;
}

srs_error_t SrsFlvTransmuxer::write_metadata(char type, char* data, int size)
{
    srs_error_t err = srs_success;
    
    srs_assert(data);
    
    if ((err = write_metadata_to_cache(type, data, size, tag_header)) != srs_success) {
        return srs_error_wrap(err, "cache metadata");
    }
    
    if ((err = write_tag(tag_header, sizeof(tag_header), data, size)) != srs_success) {
        return srs_error_wrap(err, "write tag");
    }
    
    return err;
}

srs_error_t SrsFlvTransmuxer::write_audio(int64_t timestamp, char* data, int size)
{
    srs_error_t err = srs_success;
    
    srs_assert(data);
    
    if ((err = write_audio_to_cache(timestamp, data, size, tag_header)) != srs_success) {
        return srs_error_wrap(err, "cache audio");
    }
    
    if ((err = write_tag(tag_header, sizeof(tag_header), data, size)) != srs_success) {
        return srs_error_wrap(err, "write tag");
    }
    
    return err;
}

srs_error_t SrsFlvTransmuxer::write_video(int64_t timestamp, char* data, int size)
{
    srs_error_t err = srs_success;
    
    srs_assert(data);
    
    if ((err = write_video_to_cache(timestamp, data, size, tag_header)) != srs_success) {
        return srs_error_wrap(err, "cache video");
    }
    
    if ((err = write_tag(tag_header, sizeof(tag_header), data, size)) != srs_success) {
        return srs_error_wrap(err, "write flv video tag failed");
    }
    
    return err;
}

int SrsFlvTransmuxer::size_tag(int data_size)
{
    srs_assert(data_size >= 0);
    return SRS_FLV_TAG_HEADER_SIZE + data_size + SRS_FLV_PREVIOUS_TAG_SIZE;
}

#ifdef SRS_PERF_FAST_FLV_ENCODER
srs_error_t SrsFlvTransmuxer::write_tags(SrsSharedPtrMessage** msgs, int count)
{
    srs_error_t err = srs_success;
    
    // realloc the iovss.
    int nb_iovss = 3 * count;
    iovec* iovss = iovss_cache;
    if (nb_iovss_cache < nb_iovss) {
        srs_freepa(iovss_cache);
        
        nb_iovss_cache = nb_iovss;
        iovss = iovss_cache = new iovec[nb_iovss];
    }
    
    // realloc the tag headers.
    char* cache = tag_headers;
    if (nb_tag_headers < count) {
        srs_freepa(tag_headers);
        
        nb_tag_headers = count;
        cache = tag_headers = new char[SRS_FLV_TAG_HEADER_SIZE * count];
    }
    
    // realloc the pts.
    char* pts = ppts;
    if (nb_ppts < count) {
        srs_freepa(ppts);
        
        nb_ppts = count;
        pts = ppts = new char[SRS_FLV_PREVIOUS_TAG_SIZE * count];
    }
    
    // the cache is ok, write each messages.
    iovec* iovs = iovss;
    for (int i = 0; i < count; i++) {
        SrsSharedPtrMessage* msg = msgs[i];
        
        // cache all flv header.
        if (msg->is_audio()) {
            if ((err = write_audio_to_cache(msg->timestamp, msg->payload, msg->size, cache)) != srs_success) {
                return srs_error_wrap(err, "cache audio");
            }
        } else if (msg->is_video()) {
            if ((err = write_video_to_cache(msg->timestamp, msg->payload, msg->size, cache)) != srs_success) {
                return srs_error_wrap(err, "cache video");
            }
        } else {
            if ((err = write_metadata_to_cache(SrsFrameTypeScript, msg->payload, msg->size, cache)) != srs_success) {
                return srs_error_wrap(err, "cache metadata");
            }
        }
        
        // cache all pts.
        if ((err = write_pts_to_cache(SRS_FLV_TAG_HEADER_SIZE + msg->size, pts)) != srs_success) {
            return srs_error_wrap(err, "cache pts");
        }
        
        // all ioves.
        iovs[0].iov_base = cache;
        iovs[0].iov_len = SRS_FLV_TAG_HEADER_SIZE;
        iovs[1].iov_base = msg->payload;
        iovs[1].iov_len = msg->size;
        iovs[2].iov_base = pts;
        iovs[2].iov_len = SRS_FLV_PREVIOUS_TAG_SIZE;
        
        // move next.
        cache += SRS_FLV_TAG_HEADER_SIZE;
        pts += SRS_FLV_PREVIOUS_TAG_SIZE;
        iovs += 3;
    }
    
    if ((err = writer->writev(iovss, nb_iovss, NULL)) != srs_success) {
        return srs_error_wrap(err, "write flv tags failed");
    }
    
    return err;
}
#endif

srs_error_t SrsFlvTransmuxer::write_metadata_to_cache(char type, char* data, int size, char* cache)
{
    srs_error_t err = srs_success;
    
    srs_assert(data);
    
    // 11 bytes tag header
    /*char tag_header[] = {
     (char)type, // TagType UB [5], 18 = script data
     (char)0x00, (char)0x00, (char)0x00, // DataSize UI24 Length of the message.
     (char)0x00, (char)0x00, (char)0x00, // Timestamp UI24 Time in milliseconds at which the data in this tag applies.
     (char)0x00, // TimestampExtended UI8
     (char)0x00, (char)0x00, (char)0x00, // StreamID UI24 Always 0.
     };*/
    
    SrsBuffer* tag_stream = new SrsBuffer(cache, 11);
    SrsAutoFree(SrsBuffer, tag_stream);
    
    // write data size.
    tag_stream->write_1bytes(type);
    tag_stream->write_3bytes(size);
    tag_stream->write_3bytes(0x00);
    tag_stream->write_1bytes(0x00);
    tag_stream->write_3bytes(0x00);
    
    return err;
}

srs_error_t SrsFlvTransmuxer::write_audio_to_cache(int64_t timestamp, char* data, int size, char* cache)
{
    srs_error_t err = srs_success;
    
    srs_assert(data);
    
    timestamp &= 0x7fffffff;
    
    // 11bytes tag header
    /*char tag_header[] = {
     (char)SrsFrameTypeAudio, // TagType UB [5], 8 = audio
     (char)0x00, (char)0x00, (char)0x00, // DataSize UI24 Length of the message.
     (char)0x00, (char)0x00, (char)0x00, // Timestamp UI24 Time in milliseconds at which the data in this tag applies.
     (char)0x00, // TimestampExtended UI8
     (char)0x00, (char)0x00, (char)0x00, // StreamID UI24 Always 0.
     };*/
    
    SrsBuffer* tag_stream = new SrsBuffer(cache, 11);
    SrsAutoFree(SrsBuffer, tag_stream);
    
    // write data size.
    tag_stream->write_1bytes(SrsFrameTypeAudio);
    tag_stream->write_3bytes(size);
    tag_stream->write_3bytes((int32_t)timestamp);
    // default to little-endian
    tag_stream->write_1bytes((timestamp >> 24) & 0xFF);
    tag_stream->write_3bytes(0x00);
    
    return err;
}

srs_error_t SrsFlvTransmuxer::write_video_to_cache(int64_t timestamp, char* data, int size, char* cache)
{
    srs_error_t err = srs_success;
    
    srs_assert(data);
    
    timestamp &= 0x7fffffff;
    
    // 11bytes tag header
    /*char tag_header[] = {
     (char)SrsFrameTypeVideo, // TagType UB [5], 9 = video
     (char)0x00, (char)0x00, (char)0x00, // DataSize UI24 Length of the message.
     (char)0x00, (char)0x00, (char)0x00, // Timestamp UI24 Time in milliseconds at which the data in this tag applies.
     (char)0x00, // TimestampExtended UI8
     (char)0x00, (char)0x00, (char)0x00, // StreamID UI24 Always 0.
     };*/
    
    SrsBuffer* tag_stream = new SrsBuffer(cache, 11);
    SrsAutoFree(SrsBuffer, tag_stream);
    
    // write data size.
    tag_stream->write_1bytes(SrsFrameTypeVideo);
    tag_stream->write_3bytes(size);
    tag_stream->write_3bytes((int32_t)timestamp);
    // default to little-endian
    tag_stream->write_1bytes((timestamp >> 24) & 0xFF);
    tag_stream->write_3bytes(0x00);
    
    return err;
}

srs_error_t SrsFlvTransmuxer::write_pts_to_cache(int size, char* cache)
{
    srs_error_t err = srs_success;
    
    SrsBuffer* tag_stream = new SrsBuffer(cache, 11);
    SrsAutoFree(SrsBuffer, tag_stream);
    
    tag_stream->write_4bytes(size);
    
    return err;
}

srs_error_t SrsFlvTransmuxer::write_tag(char* header, int header_size, char* tag, int tag_size)
{
    srs_error_t err = srs_success;
    
    // PreviousTagSizeN UI32 Size of last tag, including its header, in bytes.
    char pre_size[SRS_FLV_PREVIOUS_TAG_SIZE];
    if ((err = write_pts_to_cache(tag_size + header_size, pre_size)) != srs_success) {
        return srs_error_wrap(err, "cache pts");
    }
    
    iovec iovs[3];
    iovs[0].iov_base = header;
    iovs[0].iov_len = header_size;
    iovs[1].iov_base = tag;
    iovs[1].iov_len = tag_size;
    iovs[2].iov_base = pre_size;
    iovs[2].iov_len = SRS_FLV_PREVIOUS_TAG_SIZE;
    
    if ((err = writer->writev(iovs, 3, NULL)) != srs_success) {
        return srs_error_wrap(err, "write flv tag failed");
    }
    
    return err;
}

SrsFlvDecoder::SrsFlvDecoder()
{
    reader = NULL;
}

SrsFlvDecoder::~SrsFlvDecoder()
{
}

srs_error_t SrsFlvDecoder::initialize(ISrsReader* fr)
{
    srs_assert(fr);
    reader = fr;
    return srs_success;
}

srs_error_t SrsFlvDecoder::read_header(char header[9])
{
    srs_error_t err = srs_success;
    
    srs_assert(header);
    
    // TODO: FIXME: Should use readfully.
    if ((err = reader->read(header, 9, NULL)) != srs_success) {
        return srs_error_wrap(err, "read header");
    }
    
    char* h = header;
    if (h[0] != 'F' || h[1] != 'L' || h[2] != 'V') {
        return srs_error_new(ERROR_KERNEL_FLV_HEADER, "flv header must start with FLV");
    }
    
    return err;
}

srs_error_t SrsFlvDecoder::read_tag_header(char* ptype, int32_t* pdata_size, uint32_t* ptime)
{
    srs_error_t err = srs_success;
    
    srs_assert(ptype);
    srs_assert(pdata_size);
    srs_assert(ptime);
    
    char th[11]; // tag header
    
    // read tag header
    // TODO: FIXME: Should use readfully.
    if ((err = reader->read(th, 11, NULL)) != srs_success) {
        return srs_error_wrap(err, "read flv tag header failed");
    }
    
    // Reserved UB [2]
    // Filter UB [1]
    // TagType UB [5]
    *ptype = (th[0] & 0x1F);
    
    // DataSize UI24
    char* pp = (char*)pdata_size;
    pp[3] = 0;
    pp[2] = th[1];
    pp[1] = th[2];
    pp[0] = th[3];
    
    // Timestamp UI24
    pp = (char*)ptime;
    pp[2] = th[4];
    pp[1] = th[5];
    pp[0] = th[6];
    
    // TimestampExtended UI8
    pp[3] = th[7];
    
    return err;
}

srs_error_t SrsFlvDecoder::read_tag_data(char* data, int32_t size)
{
    srs_error_t err = srs_success;
    
    srs_assert(data);
    
    // TODO: FIXME: Should use readfully.
    if ((err = reader->read(data, size, NULL)) != srs_success) {
        return srs_error_wrap(err, "read flv tag header failed");
    }
    
    return err;
    
}

srs_error_t SrsFlvDecoder::read_previous_tag_size(char previous_tag_size[4])
{
    srs_error_t err = srs_success;
    
    srs_assert(previous_tag_size);
    
    // ignore 4bytes tag size.
    // TODO: FIXME: Should use readfully.
    if ((err = reader->read(previous_tag_size, 4, NULL)) != srs_success) {
        return srs_error_wrap(err, "read flv previous tag size failed");
    }
    
    return err;
}

SrsFlvVodStreamDecoder::SrsFlvVodStreamDecoder()
{
    reader = NULL;
}

SrsFlvVodStreamDecoder::~SrsFlvVodStreamDecoder()
{
}

srs_error_t SrsFlvVodStreamDecoder::initialize(ISrsReader* fr)
{
    srs_error_t err = srs_success;
    
    srs_assert(fr);
    reader = dynamic_cast<SrsFileReader*>(fr);
    if (!reader) {
        return srs_error_new(ERROR_EXPECT_FILE_IO, "stream is not file io");
    }
    
    if (!reader->is_open()) {
        return srs_error_new(ERROR_KERNEL_FLV_STREAM_CLOSED, "stream is not open for decoder");
    }
    
    return err;
}

srs_error_t SrsFlvVodStreamDecoder::read_header_ext(char header[13])
{
    srs_error_t err = srs_success;
    
    srs_assert(header);
    
    // @remark, always false, for sizeof(char[13]) equals to sizeof(char*)
    //srs_assert(13 == sizeof(header));
    
    // 9bytes header and 4bytes first previous-tag-size
    int size = 13;
    
    if ((err = reader->read(header, size, NULL)) != srs_success) {
        return srs_error_wrap(err, "read header");
    }
    
    return err;
}

srs_error_t SrsFlvVodStreamDecoder::read_sequence_header_summary(int64_t* pstart, int* psize)
{
    srs_error_t err = srs_success;
    
    srs_assert(pstart);
    srs_assert(psize);
    
    // simply, the first video/audio must be the sequence header.
    // and must be a sequence video and audio.
    
    // 11bytes tag header
    char tag_header[] = {
        (char)0x00, // TagType UB [5], 9 = video, 8 = audio, 18 = script data
        (char)0x00, (char)0x00, (char)0x00, // DataSize UI24 Length of the message.
        (char)0x00, (char)0x00, (char)0x00, // Timestamp UI24 Time in milliseconds at which the data in this tag applies.
        (char)0x00, // TimestampExtended UI8
        (char)0x00, (char)0x00, (char)0x00, // StreamID UI24 Always 0.
    };
    
    // discovery the sequence header video and audio.
    // @remark, maybe no video or no audio.
    bool got_video = false;
    bool got_audio = false;
    // audio/video sequence and data offset.
    int64_t av_sequence_offset_start = -1;
    int64_t av_sequence_offset_end = -1;
    for (;;) {
        if ((err = reader->read(tag_header, SRS_FLV_TAG_HEADER_SIZE, NULL)) != srs_success) {
            return srs_error_wrap(err, "read tag header");
        }
        
        SrsBuffer* tag_stream = new SrsBuffer(tag_header, SRS_FLV_TAG_HEADER_SIZE);
        SrsAutoFree(SrsBuffer, tag_stream);
        
        int8_t tag_type = tag_stream->read_1bytes();
        int32_t data_size = tag_stream->read_3bytes();
        
        bool is_video = tag_type == 0x09;
        bool is_audio = tag_type == 0x08;
        bool is_not_av = !is_video && !is_audio;
        if (is_not_av) {
            // skip body and tag size.
            reader->skip(data_size + SRS_FLV_PREVIOUS_TAG_SIZE);
            continue;
        }
        
        // if video duplicated, no audio
        if (is_video && got_video) {
            break;
        }
        // if audio duplicated, no video
        if (is_audio && got_audio) {
            break;
        }
        
        // video
        if (is_video) {
            srs_assert(!got_video);
            got_video = true;
            
            if (av_sequence_offset_start < 0) {
                av_sequence_offset_start = reader->tellg() - SRS_FLV_TAG_HEADER_SIZE;
            }
            av_sequence_offset_end = reader->tellg() + data_size + SRS_FLV_PREVIOUS_TAG_SIZE;
            reader->skip(data_size + SRS_FLV_PREVIOUS_TAG_SIZE);
        }
        
        // audio
        if (is_audio) {
            srs_assert(!got_audio);
            got_audio = true;
            
            if (av_sequence_offset_start < 0) {
                av_sequence_offset_start = reader->tellg() - SRS_FLV_TAG_HEADER_SIZE;
            }
            av_sequence_offset_end = reader->tellg() + data_size + SRS_FLV_PREVIOUS_TAG_SIZE;
            reader->skip(data_size + SRS_FLV_PREVIOUS_TAG_SIZE);
        }
    }
    
    // seek to the sequence header start offset.
    if (av_sequence_offset_start > 0) {
        reader->seek2(av_sequence_offset_start);
        *pstart = av_sequence_offset_start;
        *psize = (int)(av_sequence_offset_end - av_sequence_offset_start);
    }
    
    return err;
}

srs_error_t SrsFlvVodStreamDecoder::seek2(int64_t offset)
{
    srs_error_t err = srs_success;
    
    if (offset >= reader->filesize()) {
        return srs_error_new(ERROR_SYSTEM_FILE_EOF, "flv fast decoder seek overflow file, size=%d, offset=%d", (int)reader->filesize(), (int)offset);
    }
    
    if (reader->seek2(offset) < 0) {
        return srs_error_new(ERROR_SYSTEM_FILE_SEEK, "flv fast decoder seek error, size=%d, offset=%d", (int)reader->filesize(), (int)offset);
    }
    
    return err;
}


// following is generated by src/kernel/srs_kernel_codec.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kernel_codec.hpp>

#include <string.h>
#include <stdlib.h>
using namespace std;

//#include <srs_kernel_error.hpp>
//#include <srs_kernel_log.hpp>
//#include <srs_kernel_buffer.hpp>
//#include <srs_kernel_utility.hpp>
//#include <srs_core_autofree.hpp>

string srs_video_codec_id2str(SrsVideoCodecId codec)
{
    switch (codec) {
        case SrsVideoCodecIdAVC:
            return "H264";
        case SrsVideoCodecIdOn2VP6:
        case SrsVideoCodecIdOn2VP6WithAlphaChannel:
            return "VP6";
        case SrsVideoCodecIdReserved:
        case SrsVideoCodecIdReserved1:
        case SrsVideoCodecIdReserved2:
        case SrsVideoCodecIdDisabled:
        case SrsVideoCodecIdSorensonH263:
        case SrsVideoCodecIdScreenVideo:
        case SrsVideoCodecIdScreenVideoVersion2:
        default:
            return "Other";
    }
}

string srs_audio_codec_id2str(SrsAudioCodecId codec)
{
    switch (codec) {
        case SrsAudioCodecIdAAC:
            return "AAC";
        case SrsAudioCodecIdMP3:
            return "MP3";
        case SrsAudioCodecIdReserved1:
        case SrsAudioCodecIdLinearPCMPlatformEndian:
        case SrsAudioCodecIdADPCM:
        case SrsAudioCodecIdLinearPCMLittleEndian:
        case SrsAudioCodecIdNellymoser16kHzMono:
        case SrsAudioCodecIdNellymoser8kHzMono:
        case SrsAudioCodecIdNellymoser:
        case SrsAudioCodecIdReservedG711AlawLogarithmicPCM:
        case SrsAudioCodecIdReservedG711MuLawLogarithmicPCM:
        case SrsAudioCodecIdReserved:
        case SrsAudioCodecIdSpeex:
        case SrsAudioCodecIdReservedMP3_8kHz:
        case SrsAudioCodecIdReservedDeviceSpecificSound:
        default:
            return "Other";
    }
}

string srs_audio_sample_rate2str(SrsAudioSampleRate v)
{
    switch (v) {
        case SrsAudioSampleRate5512: return "5512";
        case SrsAudioSampleRate11025: return "11025";
        case SrsAudioSampleRate22050: return "22050";
        case SrsAudioSampleRate44100: return "44100";
        default: return "Other";
    }
}

SrsFlvVideo::SrsFlvVideo()
{
}

SrsFlvVideo::~SrsFlvVideo()
{
}

bool SrsFlvVideo::keyframe(char* data, int size)
{
    // 2bytes required.
    if (size < 1) {
        return false;
    }
    
    char frame_type = data[0];
    frame_type = (frame_type >> 4) & 0x0F;
    
    return frame_type == SrsVideoAvcFrameTypeKeyFrame;
}

bool SrsFlvVideo::sh(char* data, int size)
{
    // sequence header only for h264
    if (!h264(data, size)) {
        return false;
    }
    
    // 2bytes required.
    if (size < 2) {
        return false;
    }
    
    char frame_type = data[0];
    frame_type = (frame_type >> 4) & 0x0F;
    
    char avc_packet_type = data[1];
    
    return frame_type == SrsVideoAvcFrameTypeKeyFrame
    && avc_packet_type == SrsVideoAvcFrameTraitSequenceHeader;
}

bool SrsFlvVideo::h264(char* data, int size)
{
    // 1bytes required.
    if (size < 1) {
        return false;
    }
    
    char codec_id = data[0];
    codec_id = codec_id & 0x0F;
    
    return codec_id == SrsVideoCodecIdAVC;
}

bool SrsFlvVideo::acceptable(char* data, int size)
{
    // 1bytes required.
    if (size < 1) {
        return false;
    }
    
    char frame_type = data[0];
    char codec_id = frame_type & 0x0f;
    frame_type = (frame_type >> 4) & 0x0f;
    
    if (frame_type < 1 || frame_type > 5) {
        return false;
    }
    
    if (codec_id < 2 || codec_id > 7) {
        return false;
    }
    
    return true;
}

bool SrsFlvAudio::sh(char* data, int size)
{
    // sequence header only for aac
    if (!aac(data, size)) {
        return false;
    }
    
    // 2bytes required.
    if (size < 2) {
        return false;
    }
    
    char aac_packet_type = data[1];
    
    return aac_packet_type == SrsAudioAacFrameTraitSequenceHeader;
}

bool SrsFlvAudio::aac(char* data, int size)
{
    // 1bytes required.
    if (size < 1) {
        return false;
    }
    
    char sound_format = data[0];
    sound_format = (sound_format >> 4) & 0x0F;
    
    return sound_format == SrsAudioCodecIdAAC;
}

/**
 * the public data, event HLS disable, others can use it.
 */
// 0 = 5.5 kHz = 5512 Hz
// 1 = 11 kHz = 11025 Hz
// 2 = 22 kHz = 22050 Hz
// 3 = 44 kHz = 44100 Hz
int srs_flv_srates[] = {5512, 11025, 22050, 44100, 0};

// the sample rates in the codec,
// in the sequence header.
int srs_aac_srates[] =
{
    96000, 88200, 64000, 48000,
    44100, 32000, 24000, 22050,
    16000, 12000, 11025,  8000,
    7350,     0,     0,    0
};

string srs_audio_sample_bits2str(SrsAudioSampleBits v)
{
    switch (v) {
        case SrsAudioSampleBits16bit: return "16bits";
        case SrsAudioSampleBits8bit: return "8bits";
        default: return "Other";
    }
}

string srs_audio_channels2str(SrsAudioChannels v)
{
    switch (v) {
        case SrsAudioChannelsStereo: return "Stereo";
        case SrsAudioChannelsMono: return "Mono";
        default: return "Other";
    }
}

string srs_avc_nalu2str(SrsAvcNaluType nalu_type)
{
    switch (nalu_type) {
        case SrsAvcNaluTypeNonIDR: return "NonIDR";
        case SrsAvcNaluTypeDataPartitionA: return "DataPartitionA";
        case SrsAvcNaluTypeDataPartitionB: return "DataPartitionB";
        case SrsAvcNaluTypeDataPartitionC: return "DataPartitionC";
        case SrsAvcNaluTypeIDR: return "IDR";
        case SrsAvcNaluTypeSEI: return "SEI";
        case SrsAvcNaluTypeSPS: return "SPS";
        case SrsAvcNaluTypePPS: return "PPS";
        case SrsAvcNaluTypeAccessUnitDelimiter: return "AccessUnitDelimiter";
        case SrsAvcNaluTypeEOSequence: return "EOSequence";
        case SrsAvcNaluTypeEOStream: return "EOStream";
        case SrsAvcNaluTypeFilterData: return "FilterData";
        case SrsAvcNaluTypeSPSExt: return "SPSExt";
        case SrsAvcNaluTypePrefixNALU: return "PrefixNALU";
        case SrsAvcNaluTypeSubsetSPS: return "SubsetSPS";
        case SrsAvcNaluTypeLayerWithoutPartition: return "LayerWithoutPartition";
        case SrsAvcNaluTypeCodedSliceExt: return "CodedSliceExt";
        case SrsAvcNaluTypeReserved: default: return "Other";
    }
}

string srs_aac_profile2str(SrsAacProfile aac_profile)
{
    switch (aac_profile) {
        case SrsAacProfileMain: return "Main";
        case SrsAacProfileLC: return "LC";
        case SrsAacProfileSSR: return "SSR";
        default: return "Other";
    }
}

string srs_aac_object2str(SrsAacObjectType aac_object)
{
    switch (aac_object) {
        case SrsAacObjectTypeAacMain: return "Main";
        case SrsAacObjectTypeAacHE: return "HE";
        case SrsAacObjectTypeAacHEV2: return "HEv2";
        case SrsAacObjectTypeAacLC: return "LC";
        case SrsAacObjectTypeAacSSR: return "SSR";
        default: return "Other";
    }
}

SrsAacObjectType srs_aac_ts2rtmp(SrsAacProfile profile)
{
    switch (profile) {
        case SrsAacProfileMain: return SrsAacObjectTypeAacMain;
        case SrsAacProfileLC: return SrsAacObjectTypeAacLC;
        case SrsAacProfileSSR: return SrsAacObjectTypeAacSSR;
        default: return SrsAacObjectTypeReserved;
    }
}

SrsAacProfile srs_aac_rtmp2ts(SrsAacObjectType object_type)
{
    switch (object_type) {
        case SrsAacObjectTypeAacMain: return SrsAacProfileMain;
        case SrsAacObjectTypeAacHE:
        case SrsAacObjectTypeAacHEV2:
        case SrsAacObjectTypeAacLC: return SrsAacProfileLC;
        case SrsAacObjectTypeAacSSR: return SrsAacProfileSSR;
        default: return SrsAacProfileReserved;
    }
}

string srs_avc_profile2str(SrsAvcProfile profile)
{
    switch (profile) {
        case SrsAvcProfileBaseline: return "Baseline";
        case SrsAvcProfileConstrainedBaseline: return "Baseline(Constrained)";
        case SrsAvcProfileMain: return "Main";
        case SrsAvcProfileExtended: return "Extended";
        case SrsAvcProfileHigh: return "High";
        case SrsAvcProfileHigh10: return "High(10)";
        case SrsAvcProfileHigh10Intra: return "High(10+Intra)";
        case SrsAvcProfileHigh422: return "High(422)";
        case SrsAvcProfileHigh422Intra: return "High(422+Intra)";
        case SrsAvcProfileHigh444: return "High(444)";
        case SrsAvcProfileHigh444Predictive: return "High(444+Predictive)";
        case SrsAvcProfileHigh444Intra: return "High(444+Intra)";
        default: return "Other";
    }
}

string srs_avc_level2str(SrsAvcLevel level)
{
    switch (level) {
        case SrsAvcLevel_1: return "1";
        case SrsAvcLevel_11: return "1.1";
        case SrsAvcLevel_12: return "1.2";
        case SrsAvcLevel_13: return "1.3";
        case SrsAvcLevel_2: return "2";
        case SrsAvcLevel_21: return "2.1";
        case SrsAvcLevel_22: return "2.2";
        case SrsAvcLevel_3: return "3";
        case SrsAvcLevel_31: return "3.1";
        case SrsAvcLevel_32: return "3.2";
        case SrsAvcLevel_4: return "4";
        case SrsAvcLevel_41: return "4.1";
        case SrsAvcLevel_5: return "5";
        case SrsAvcLevel_51: return "5.1";
        default: return "Other";
    }
}

SrsSample::SrsSample()
{
    size = 0;
    bytes = NULL;
}

SrsSample::~SrsSample()
{
}

SrsCodecConfig::SrsCodecConfig()
{
}

SrsCodecConfig::~SrsCodecConfig()
{
}

SrsAudioCodecConfig::SrsAudioCodecConfig()
{
    id = SrsAudioCodecIdForbidden;
    sound_rate = SrsAudioSampleRateForbidden;
    sound_size = SrsAudioSampleBitsForbidden;
    sound_type = SrsAudioChannelsForbidden;
    
    audio_data_rate = 0;
    
    aac_object = SrsAacObjectTypeForbidden;
    aac_sample_rate = SrsAacSampleRateUnset; // sample rate ignored
    aac_channels = 0;
}

SrsAudioCodecConfig::~SrsAudioCodecConfig()
{
}

bool SrsAudioCodecConfig::is_aac_codec_ok()
{
    return !aac_extra_data.empty();
}

SrsVideoCodecConfig::SrsVideoCodecConfig()
{
    id = SrsVideoCodecIdForbidden;
    video_data_rate = 0;
    frame_rate = duration = 0;
    
    width = 0;
    height = 0;
    
    NAL_unit_length = 0;
    avc_profile = SrsAvcProfileReserved;
    avc_level = SrsAvcLevelReserved;
    
    payload_format = SrsAvcPayloadFormatGuess;
}

SrsVideoCodecConfig::~SrsVideoCodecConfig()
{
}

bool SrsVideoCodecConfig::is_avc_codec_ok()
{
    return !avc_extra_data.empty();
}

SrsFrame::SrsFrame()
{
    codec = NULL;
    nb_samples = 0;
    dts = 0;
    cts = 0;
}

SrsFrame::~SrsFrame()
{
    srs_freep(codec);
}

srs_error_t SrsFrame::initialize(SrsCodecConfig* c)
{
    codec = c;
    nb_samples = 0;
    dts = 0;
    cts = 0;
    return srs_success;
}

srs_error_t SrsFrame::add_sample(char* bytes, int size)
{
    srs_error_t err = srs_success;
    
    if (nb_samples >= SrsMaxNbSamples) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "Frame samples overflow");
    }
    
    SrsSample* sample = &samples[nb_samples++];
    sample->bytes = bytes;
    sample->size = size;
    
    return err;
}

SrsAudioFrame::SrsAudioFrame()
{
    aac_packet_type = SrsAudioAacFrameTraitForbidden;
}

SrsAudioFrame::~SrsAudioFrame()
{
}

SrsAudioCodecConfig* SrsAudioFrame::acodec()
{
    return (SrsAudioCodecConfig*)codec;
}

SrsVideoFrame::SrsVideoFrame()
{
    frame_type = SrsVideoAvcFrameTypeForbidden;
    avc_packet_type = SrsVideoAvcFrameTraitForbidden;
    has_idr = has_aud = has_sps_pps = false;
    first_nalu_type = SrsAvcNaluTypeForbidden;
}

SrsVideoFrame::~SrsVideoFrame()
{
}

srs_error_t SrsVideoFrame::add_sample(char* bytes, int size)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsFrame::add_sample(bytes, size)) != srs_success) {
        return srs_error_wrap(err, "add frame");
    }
    
    // for video, parse the nalu type, set the IDR flag.
    SrsAvcNaluType nal_unit_type = (SrsAvcNaluType)(bytes[0] & 0x1f);
    
    if (nal_unit_type == SrsAvcNaluTypeIDR) {
        has_idr = true;
    } else if (nal_unit_type == SrsAvcNaluTypeSPS || nal_unit_type == SrsAvcNaluTypePPS) {
        has_sps_pps = true;
    } else if (nal_unit_type == SrsAvcNaluTypeAccessUnitDelimiter) {
        has_aud = true;
    }
    
    if (first_nalu_type == SrsAvcNaluTypeReserved) {
        first_nalu_type = nal_unit_type;
    }
    
    return err;
}

SrsVideoCodecConfig* SrsVideoFrame::vcodec()
{
    return (SrsVideoCodecConfig*)codec;
}

SrsFormat::SrsFormat()
{
    acodec = NULL;
    vcodec = NULL;
    audio = NULL;
    video = NULL;
    avc_parse_sps = true;
    raw = NULL;
    nb_raw = 0;
}

SrsFormat::~SrsFormat()
{
    srs_freep(audio);
    srs_freep(video);
    srs_freep(acodec);
    srs_freep(vcodec);
}

srs_error_t SrsFormat::initialize()
{
    return srs_success;
}

srs_error_t SrsFormat::on_audio(int64_t timestamp, char* data, int size)
{
    srs_error_t err = srs_success;
    
    if (!data || size <= 0) {
        srs_trace("no audio present, ignore it.");
        return err;
    }
    
    SrsBuffer* buffer = new SrsBuffer(data, size);
    SrsAutoFree(SrsBuffer, buffer);
    
    // audio decode
    if (!buffer->require(1)) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "aac decode sound_format");
    }
    
    // @see: E.4.2 Audio Tags, video_file_format_spec_v10_1.pdf, page 76
    uint8_t v = buffer->read_1bytes();
    SrsAudioCodecId codec = (SrsAudioCodecId)((v >> 4) & 0x0f);
    
    if (codec != SrsAudioCodecIdMP3 && codec != SrsAudioCodecIdAAC) {
        return err;
    }
    
    if (!acodec) {
        acodec = new SrsAudioCodecConfig();
    }
    if (!audio) {
        audio = new SrsAudioFrame();
    }
    
    if ((err = audio->initialize(acodec)) != srs_success) {
        return srs_error_wrap(err, "init audio");
    }
    
    // Parse by specified codec.
    buffer->skip(-1 * buffer->pos());
    
    if (codec == SrsAudioCodecIdMP3) {
        return audio_mp3_demux(buffer, timestamp);
    }
    
    return audio_aac_demux(buffer, timestamp);
}

srs_error_t SrsFormat::on_video(int64_t timestamp, char* data, int size)
{
    srs_error_t err = srs_success;
    
    if (!data || size <= 0) {
        srs_trace("no video present, ignore it.");
        return err;
    }
    
    SrsBuffer* buffer = new SrsBuffer(data, size);
    SrsAutoFree(SrsBuffer, buffer);
    
    // video decode
    if (!buffer->require(1)) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "decode frame_type");
    }
    
    // @see: E.4.3 Video Tags, video_file_format_spec_v10_1.pdf, page 78
    int8_t frame_type = buffer->read_1bytes();
    SrsVideoCodecId codec_id = (SrsVideoCodecId)(frame_type & 0x0f);
    
    // TODO: Support other codecs.
    if (codec_id != SrsVideoCodecIdAVC) {
        return err;
    }
    
    if (!vcodec) {
        vcodec = new SrsVideoCodecConfig();
    }
    if (!video) {
        video = new SrsVideoFrame();
    }
    
    if ((err = video->initialize(vcodec)) != srs_success) {
        return srs_error_wrap(err, "init video");
    }
    
    buffer->skip(-1 * buffer->pos());
    return video_avc_demux(buffer, timestamp);
}

srs_error_t SrsFormat::on_aac_sequence_header(char* data, int size)
{
    srs_error_t err = srs_success;
    
    if (!acodec) {
        acodec = new SrsAudioCodecConfig();
    }
    if (!audio) {
        audio = new SrsAudioFrame();
    }
    
    if ((err = audio->initialize(acodec)) != srs_success) {
        return srs_error_wrap(err, "init audio");
    }
    
    return audio_aac_sequence_header_demux(data, size);
}

bool SrsFormat::is_aac_sequence_header()
{
    return acodec && acodec->id == SrsAudioCodecIdAAC
        && audio && audio->aac_packet_type == SrsAudioAacFrameTraitSequenceHeader;
}

bool SrsFormat::is_avc_sequence_header()
{
    return vcodec && vcodec->id == SrsVideoCodecIdAVC
        && video && video->avc_packet_type == SrsVideoAvcFrameTraitSequenceHeader;
}

srs_error_t SrsFormat::video_avc_demux(SrsBuffer* stream, int64_t timestamp)
{
    srs_error_t err = srs_success;
    
    // @see: E.4.3 Video Tags, video_file_format_spec_v10_1.pdf, page 78
    int8_t frame_type = stream->read_1bytes();
    SrsVideoCodecId codec_id = (SrsVideoCodecId)(frame_type & 0x0f);
    frame_type = (frame_type >> 4) & 0x0f;
    
    video->frame_type = (SrsVideoAvcFrameType)frame_type;
    
    // ignore info frame without error,
    // @see https://github.com/ossrs/srs/issues/288#issuecomment-69863909
    if (video->frame_type == SrsVideoAvcFrameTypeVideoInfoFrame) {
        srs_warn("avc igone the info frame");
        return err;
    }
    
    // only support h.264/avc
    if (codec_id != SrsVideoCodecIdAVC) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "avc only support video h.264/avc, actual=%d", codec_id);
    }
    vcodec->id = codec_id;
    
    if (!stream->require(4)) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "avc decode avc_packet_type");
    }
    int8_t avc_packet_type = stream->read_1bytes();
    int32_t composition_time = stream->read_3bytes();
    
    // pts = dts + cts.
    video->dts = timestamp;
    video->cts = composition_time;
    video->avc_packet_type = (SrsVideoAvcFrameTrait)avc_packet_type;
    
    // Update the RAW AVC data.
    raw = stream->data() + stream->pos();
    nb_raw = stream->size() - stream->pos();
    
    if (avc_packet_type == SrsVideoAvcFrameTraitSequenceHeader) {
        if ((err = avc_demux_sps_pps(stream)) != srs_success) {
            return srs_error_wrap(err, "demux SPS/PPS");
        }
    } else if (avc_packet_type == SrsVideoAvcFrameTraitNALU){
        if ((err = video_nalu_demux(stream)) != srs_success) {
            return srs_error_wrap(err, "demux NALU");
        }
    } else {
        // ignored.
    }
    
    return err;
}

srs_error_t SrsFormat::avc_demux_sps_pps(SrsBuffer* stream)
{
    // AVCDecoderConfigurationRecord
    // 5.2.4.1.1 Syntax, ISO_IEC_14496-15-AVC-format-2012.pdf, page 16
    int avc_extra_size = stream->size() - stream->pos();
    if (avc_extra_size > 0) {
        char *copy_stream_from = stream->data() + stream->pos();
        vcodec->avc_extra_data = std::vector<char>(copy_stream_from, copy_stream_from + avc_extra_size);
    }
    
    if (!stream->require(6)) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "avc decode sequence header");
    }
    //int8_t configurationVersion = stream->read_1bytes();
    stream->read_1bytes();
    //int8_t AVCProfileIndication = stream->read_1bytes();
    vcodec->avc_profile = (SrsAvcProfile)stream->read_1bytes();
    //int8_t profile_compatibility = stream->read_1bytes();
    stream->read_1bytes();
    //int8_t AVCLevelIndication = stream->read_1bytes();
    vcodec->avc_level = (SrsAvcLevel)stream->read_1bytes();
    
    // parse the NALU size.
    int8_t lengthSizeMinusOne = stream->read_1bytes();
    lengthSizeMinusOne &= 0x03;
    vcodec->NAL_unit_length = lengthSizeMinusOne;
    
    // 5.3.4.2.1 Syntax, ISO_IEC_14496-15-AVC-format-2012.pdf, page 16
    // 5.2.4.1 AVC decoder configuration record
    // 5.2.4.1.2 Semantics
    // The value of this field shall be one of 0, 1, or 3 corresponding to a
    // length encoded with 1, 2, or 4 bytes, respectively.
    if (vcodec->NAL_unit_length == 2) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "sps lengthSizeMinusOne should never be 2");
    }
    
    // 1 sps, 7.3.2.1 Sequence parameter set RBSP syntax
    // ISO_IEC_14496-10-AVC-2003.pdf, page 45.
    if (!stream->require(1)) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "decode SPS");
    }
    int8_t numOfSequenceParameterSets = stream->read_1bytes();
    numOfSequenceParameterSets &= 0x1f;
    if (numOfSequenceParameterSets != 1) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "decode SPS");
    }
    if (!stream->require(2)) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "decode SPS size");
    }
    uint16_t sequenceParameterSetLength = stream->read_2bytes();
    if (!stream->require(sequenceParameterSetLength)) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "decode SPS data");
    }
    if (sequenceParameterSetLength > 0) {
        vcodec->sequenceParameterSetNALUnit.resize(sequenceParameterSetLength);
        stream->read_bytes(&vcodec->sequenceParameterSetNALUnit[0], sequenceParameterSetLength);
    }
    // 1 pps
    if (!stream->require(1)) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "decode PPS");
    }
    int8_t numOfPictureParameterSets = stream->read_1bytes();
    numOfPictureParameterSets &= 0x1f;
    if (numOfPictureParameterSets != 1) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "decode PPS");
    }
    if (!stream->require(2)) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "decode PPS size");
    }
    uint16_t pictureParameterSetLength = stream->read_2bytes();
    if (!stream->require(pictureParameterSetLength)) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "decode PPS data");
    }
    if (pictureParameterSetLength > 0) {
        vcodec->pictureParameterSetNALUnit.resize(pictureParameterSetLength);
        stream->read_bytes(&vcodec->pictureParameterSetNALUnit[0], pictureParameterSetLength);
    }
    
    return avc_demux_sps();
}

srs_error_t SrsFormat::avc_demux_sps()
{
    srs_error_t err = srs_success;
    
    if (vcodec->sequenceParameterSetNALUnit.empty()) {
        return err;
    }
    
    char* sps = &vcodec->sequenceParameterSetNALUnit[0];
    int nbsps = (int)vcodec->sequenceParameterSetNALUnit.size();
    
    SrsBuffer stream(sps, nbsps);
    
    // for NALU, 7.3.1 NAL unit syntax
    // ISO_IEC_14496-10-AVC-2012.pdf, page 61.
    if (!stream.require(1)) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "decode SPS");
    }
    int8_t nutv = stream.read_1bytes();
    
    // forbidden_zero_bit shall be equal to 0.
    int8_t forbidden_zero_bit = (nutv >> 7) & 0x01;
    if (forbidden_zero_bit) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "forbidden_zero_bit shall be equal to 0");
    }
    
    // nal_ref_idc not equal to 0 specifies that the content of the NAL unit contains a sequence parameter set or a picture
    // parameter set or a slice of a reference picture or a slice data partition of a reference picture.
    int8_t nal_ref_idc = (nutv >> 5) & 0x03;
    if (!nal_ref_idc) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "for sps, nal_ref_idc shall be not be equal to 0");
    }
    
    // 7.4.1 NAL unit semantics
    // ISO_IEC_14496-10-AVC-2012.pdf, page 61.
    // nal_unit_type specifies the type of RBSP data structure contained in the NAL unit as specified in Table 7-1.
    SrsAvcNaluType nal_unit_type = (SrsAvcNaluType)(nutv & 0x1f);
    if (nal_unit_type != 7) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "for sps, nal_unit_type shall be equal to 7");
    }
    
    // decode the rbsp from sps.
    // rbsp[ i ] a raw byte sequence payload is specified as an ordered sequence of bytes.
    std::vector<int8_t> rbsp(vcodec->sequenceParameterSetNALUnit.size());
    
    int nb_rbsp = 0;
    while (!stream.empty()) {
        rbsp[nb_rbsp] = stream.read_1bytes();
        
        // XX 00 00 03 XX, the 03 byte should be drop.
        if (nb_rbsp > 2 && rbsp[nb_rbsp - 2] == 0 && rbsp[nb_rbsp - 1] == 0 && rbsp[nb_rbsp] == 3) {
            // read 1byte more.
            if (stream.empty()) {
                break;
            }
            rbsp[nb_rbsp] = stream.read_1bytes();
            nb_rbsp++;
            
            continue;
        }
        
        nb_rbsp++;
    }
    
    return avc_demux_sps_rbsp((char*)&rbsp[0], nb_rbsp);
}


srs_error_t SrsFormat::avc_demux_sps_rbsp(char* rbsp, int nb_rbsp)
{
    srs_error_t err = srs_success;
    
    // we donot parse the detail of sps.
    // @see https://github.com/ossrs/srs/issues/474
    if (!avc_parse_sps) {
        return err;
    }
    
    // reparse the rbsp.
    SrsBuffer stream(rbsp, nb_rbsp);
    
    // for SPS, 7.3.2.1.1 Sequence parameter set data syntax
    // ISO_IEC_14496-10-AVC-2012.pdf, page 62.
    if (!stream.require(3)) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "sps shall atleast 3bytes");
    }
    uint8_t profile_idc = stream.read_1bytes();
    if (!profile_idc) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "sps the profile_idc invalid");
    }
    
    int8_t flags = stream.read_1bytes();
    if (flags & 0x03) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "sps the flags invalid");
    }
    
    uint8_t level_idc = stream.read_1bytes();
    if (!level_idc) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "sps the level_idc invalid");
    }
    
    SrsBitBuffer bs;
    if ((err = bs.initialize(&stream)) != srs_success) {
        return srs_error_wrap(err, "init bit buffer");
    }
    
    int32_t seq_parameter_set_id = -1;
    if ((err = srs_avc_nalu_read_uev(&bs, seq_parameter_set_id)) != srs_success) {
        return srs_error_wrap(err, "read seq_parameter_set_id");
    }
    if (seq_parameter_set_id < 0) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "sps the seq_parameter_set_id invalid");
    }
    
    int32_t chroma_format_idc = -1;
    if (profile_idc == 100 || profile_idc == 110 || profile_idc == 122 || profile_idc == 244
        || profile_idc == 44 || profile_idc == 83 || profile_idc == 86 || profile_idc == 118
        || profile_idc == 128) {
        if ((err = srs_avc_nalu_read_uev(&bs, chroma_format_idc)) != srs_success) {
            return srs_error_wrap(err, "read chroma_format_idc");
        }
        if (chroma_format_idc == 3) {
            int8_t separate_colour_plane_flag = -1;
            if ((err = srs_avc_nalu_read_bit(&bs, separate_colour_plane_flag)) != srs_success) {
                return srs_error_wrap(err, "read separate_colour_plane_flag");
            }
        }
        
        int32_t bit_depth_luma_minus8 = -1;
        if ((err = srs_avc_nalu_read_uev(&bs, bit_depth_luma_minus8)) != srs_success) {
            return srs_error_wrap(err, "read bit_depth_luma_minus8");;
        }
        
        int32_t bit_depth_chroma_minus8 = -1;
        if ((err = srs_avc_nalu_read_uev(&bs, bit_depth_chroma_minus8)) != srs_success) {
            return srs_error_wrap(err, "read bit_depth_chroma_minus8");;
        }
        
        int8_t qpprime_y_zero_transform_bypass_flag = -1;
        if ((err = srs_avc_nalu_read_bit(&bs, qpprime_y_zero_transform_bypass_flag)) != srs_success) {
            return srs_error_wrap(err, "read qpprime_y_zero_transform_bypass_flag");;
        }
        
        int8_t seq_scaling_matrix_present_flag = -1;
        if ((err = srs_avc_nalu_read_bit(&bs, seq_scaling_matrix_present_flag)) != srs_success) {
            return srs_error_wrap(err, "read seq_scaling_matrix_present_flag");;
        }
        if (seq_scaling_matrix_present_flag) {
            int nb_scmpfs = ((chroma_format_idc != 3)? 8:12);
            for (int i = 0; i < nb_scmpfs; i++) {
                int8_t seq_scaling_matrix_present_flag_i = -1;
                if ((err = srs_avc_nalu_read_bit(&bs, seq_scaling_matrix_present_flag_i)) != srs_success) {
                    return srs_error_wrap(err, "read seq_scaling_matrix_present_flag_i");;
                }
            }
        }
    }
    
    int32_t log2_max_frame_num_minus4 = -1;
    if ((err = srs_avc_nalu_read_uev(&bs, log2_max_frame_num_minus4)) != srs_success) {
        return srs_error_wrap(err, "read log2_max_frame_num_minus4");;
    }
    
    int32_t pic_order_cnt_type = -1;
    if ((err = srs_avc_nalu_read_uev(&bs, pic_order_cnt_type)) != srs_success) {
        return srs_error_wrap(err, "read pic_order_cnt_type");;
    }
    
    if (pic_order_cnt_type == 0) {
        int32_t log2_max_pic_order_cnt_lsb_minus4 = -1;
        if ((err = srs_avc_nalu_read_uev(&bs, log2_max_pic_order_cnt_lsb_minus4)) != srs_success) {
            return srs_error_wrap(err, "read log2_max_pic_order_cnt_lsb_minus4");;
        }
    } else if (pic_order_cnt_type == 1) {
        int8_t delta_pic_order_always_zero_flag = -1;
        if ((err = srs_avc_nalu_read_bit(&bs, delta_pic_order_always_zero_flag)) != srs_success) {
            return srs_error_wrap(err, "read delta_pic_order_always_zero_flag");;
        }
        
        int32_t offset_for_non_ref_pic = -1;
        if ((err = srs_avc_nalu_read_uev(&bs, offset_for_non_ref_pic)) != srs_success) {
            return srs_error_wrap(err, "read offset_for_non_ref_pic");;
        }
        
        int32_t offset_for_top_to_bottom_field = -1;
        if ((err = srs_avc_nalu_read_uev(&bs, offset_for_top_to_bottom_field)) != srs_success) {
            return srs_error_wrap(err, "read offset_for_top_to_bottom_field");;
        }
        
        int32_t num_ref_frames_in_pic_order_cnt_cycle = -1;
        if ((err = srs_avc_nalu_read_uev(&bs, num_ref_frames_in_pic_order_cnt_cycle)) != srs_success) {
            return srs_error_wrap(err, "read num_ref_frames_in_pic_order_cnt_cycle");;
        }
        if (num_ref_frames_in_pic_order_cnt_cycle < 0) {
            return srs_error_new(ERROR_HLS_DECODE_ERROR, "sps the num_ref_frames_in_pic_order_cnt_cycle");
        }
        for (int i = 0; i < num_ref_frames_in_pic_order_cnt_cycle; i++) {
            int32_t offset_for_ref_frame_i = -1;
            if ((err = srs_avc_nalu_read_uev(&bs, offset_for_ref_frame_i)) != srs_success) {
                return srs_error_wrap(err, "read offset_for_ref_frame_i");;
            }
        }
    }
    
    int32_t max_num_ref_frames = -1;
    if ((err = srs_avc_nalu_read_uev(&bs, max_num_ref_frames)) != srs_success) {
        return srs_error_wrap(err, "read max_num_ref_frames");;
    }
    
    int8_t gaps_in_frame_num_value_allowed_flag = -1;
    if ((err = srs_avc_nalu_read_bit(&bs, gaps_in_frame_num_value_allowed_flag)) != srs_success) {
        return srs_error_wrap(err, "read gaps_in_frame_num_value_allowed_flag");;
    }
    
    int32_t pic_width_in_mbs_minus1 = -1;
    if ((err = srs_avc_nalu_read_uev(&bs, pic_width_in_mbs_minus1)) != srs_success) {
        return srs_error_wrap(err, "read pic_width_in_mbs_minus1");;
    }
    
    int32_t pic_height_in_map_units_minus1 = -1;
    if ((err = srs_avc_nalu_read_uev(&bs, pic_height_in_map_units_minus1)) != srs_success) {
        return srs_error_wrap(err, "read pic_height_in_map_units_minus1");;
    }
    
    vcodec->width = (int)(pic_width_in_mbs_minus1 + 1) * 16;
    vcodec->height = (int)(pic_height_in_map_units_minus1 + 1) * 16;
    
    return err;
}

srs_error_t SrsFormat::video_nalu_demux(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // ensure the sequence header demuxed
    if (!vcodec->is_avc_codec_ok()) {
        srs_warn("avc ignore type=%d for no sequence header", SrsVideoAvcFrameTraitNALU);
        return err;
    }
    
    // guess for the first time.
    if (vcodec->payload_format == SrsAvcPayloadFormatGuess) {
        // One or more NALUs (Full frames are required)
        // try  "AnnexB" from ISO_IEC_14496-10-AVC-2003.pdf, page 211.
        if ((err = avc_demux_annexb_format(stream)) != srs_success) {
            // stop try when system error.
            if (srs_error_code(err) != ERROR_HLS_AVC_TRY_OTHERS) {
                return srs_error_wrap(err, "avc demux for annexb");
            }
            srs_freep(err);
            
            // try "ISO Base Media File Format" from ISO_IEC_14496-15-AVC-format-2012.pdf, page 20
            if ((err = avc_demux_ibmf_format(stream)) != srs_success) {
                return srs_error_wrap(err, "avc demux ibmf");
            } else {
                vcodec->payload_format = SrsAvcPayloadFormatIbmf;
            }
        } else {
            vcodec->payload_format = SrsAvcPayloadFormatAnnexb;
        }
    } else if (vcodec->payload_format == SrsAvcPayloadFormatIbmf) {
        // try "ISO Base Media File Format" from ISO_IEC_14496-15-AVC-format-2012.pdf, page 20
        if ((err = avc_demux_ibmf_format(stream)) != srs_success) {
            return srs_error_wrap(err, "avc demux ibmf");
        }
    } else {
        // One or more NALUs (Full frames are required)
        // try  "AnnexB" from ISO_IEC_14496-10-AVC-2003.pdf, page 211.
        if ((err = avc_demux_annexb_format(stream)) != srs_success) {
            // ok, we guess out the payload is annexb, but maybe changed to ibmf.
            if (srs_error_code(err) != ERROR_HLS_AVC_TRY_OTHERS) {
                return srs_error_wrap(err, "avc demux annexb");
            }
            srs_freep(err);
            
            // try "ISO Base Media File Format" from ISO_IEC_14496-15-AVC-format-2012.pdf, page 20
            if ((err = avc_demux_ibmf_format(stream)) != srs_success) {
                return srs_error_wrap(err, "avc demux ibmf");
            } else {
                vcodec->payload_format = SrsAvcPayloadFormatIbmf;
            }
        }
    }
    
    return err;
}

srs_error_t SrsFormat::avc_demux_annexb_format(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // not annexb, try others
    if (!srs_avc_startswith_annexb(stream, NULL)) {
        return srs_error_new(ERROR_HLS_AVC_TRY_OTHERS, "try others");
    }
    
    // AnnexB
    // B.1.1 Byte stream NAL unit syntax,
    // ISO_IEC_14496-10-AVC-2003.pdf, page 211.
    while (!stream->empty()) {
        // find start code
        int nb_start_code = 0;
        if (!srs_avc_startswith_annexb(stream, &nb_start_code)) {
            return err;
        }
        
        // skip the start code.
        if (nb_start_code > 0) {
            stream->skip(nb_start_code);
        }
        
        // the NALU start bytes.
        char* p = stream->data() + stream->pos();
        
        // get the last matched NALU
        while (!stream->empty()) {
            if (srs_avc_startswith_annexb(stream, NULL)) {
                break;
            }
            
            stream->skip(1);
        }
        
        char* pp = stream->data() + stream->pos();
        
        // skip the empty.
        if (pp - p <= 0) {
            continue;
        }
        
        // got the NALU.
        if ((err = video->add_sample(p, (int)(pp - p))) != srs_success) {
            return srs_error_wrap(err, "add video frame");
        }
    }
    
    return err;
}

srs_error_t SrsFormat::avc_demux_ibmf_format(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    int PictureLength = stream->size() - stream->pos();
    
    // 5.3.4.2.1 Syntax, ISO_IEC_14496-15-AVC-format-2012.pdf, page 16
    // 5.2.4.1 AVC decoder configuration record
    // 5.2.4.1.2 Semantics
    // The value of this field shall be one of 0, 1, or 3 corresponding to a
    // length encoded with 1, 2, or 4 bytes, respectively.
    srs_assert(vcodec->NAL_unit_length != 2);
    
    // 5.3.4.2.1 Syntax, ISO_IEC_14496-15-AVC-format-2012.pdf, page 20
    for (int i = 0; i < PictureLength;) {
        // unsigned int((NAL_unit_length+1)*8) NALUnitLength;
        if (!stream->require(vcodec->NAL_unit_length + 1)) {
            return srs_error_new(ERROR_HLS_DECODE_ERROR, "avc decode NALU size");
        }
        int32_t NALUnitLength = 0;
        if (vcodec->NAL_unit_length == 3) {
            NALUnitLength = stream->read_4bytes();
        } else if (vcodec->NAL_unit_length == 1) {
            NALUnitLength = stream->read_2bytes();
        } else {
            NALUnitLength = stream->read_1bytes();
        }
        
        // maybe stream is invalid format.
        // see: https://github.com/ossrs/srs/issues/183
        if (NALUnitLength < 0) {
            return srs_error_new(ERROR_HLS_DECODE_ERROR, "maybe stream is AnnexB format");
        }
        
        // NALUnit
        if (!stream->require(NALUnitLength)) {
            return srs_error_new(ERROR_HLS_DECODE_ERROR, "avc decode NALU data");
        }
        // 7.3.1 NAL unit syntax, ISO_IEC_14496-10-AVC-2003.pdf, page 44.
        if ((err = video->add_sample(stream->data() + stream->pos(), NALUnitLength)) != srs_success) {
            return srs_error_wrap(err, "avc add video frame");
        }
        stream->skip(NALUnitLength);
        
        i += vcodec->NAL_unit_length + 1 + NALUnitLength;
    }
    
    return err;
}

srs_error_t SrsFormat::audio_aac_demux(SrsBuffer* stream, int64_t timestamp)
{
    srs_error_t err = srs_success;
    
    audio->cts = 0;
    audio->dts = timestamp;
    
    // @see: E.4.2 Audio Tags, video_file_format_spec_v10_1.pdf, page 76
    int8_t sound_format = stream->read_1bytes();
    
    int8_t sound_type = sound_format & 0x01;
    int8_t sound_size = (sound_format >> 1) & 0x01;
    int8_t sound_rate = (sound_format >> 2) & 0x03;
    sound_format = (sound_format >> 4) & 0x0f;
    
    SrsAudioCodecId codec_id = (SrsAudioCodecId)sound_format;
    acodec->id = codec_id;
    
    acodec->sound_type = (SrsAudioChannels)sound_type;
    acodec->sound_rate = (SrsAudioSampleRate)sound_rate;
    acodec->sound_size = (SrsAudioSampleBits)sound_size;
    
    // we support h.264+mp3 for hls.
    if (codec_id == SrsAudioCodecIdMP3) {
        return srs_error_new(ERROR_HLS_TRY_MP3, "try mp3");
    }
    
    // only support aac
    if (codec_id != SrsAudioCodecIdAAC) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "not supported codec %d", codec_id);
    }
    
    if (!stream->require(1)) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "aac decode aac_packet_type");
    }
    
    SrsAudioAacFrameTrait aac_packet_type = (SrsAudioAacFrameTrait)stream->read_1bytes();
    audio->aac_packet_type = (SrsAudioAacFrameTrait)aac_packet_type;
    
    // Update the RAW AAC data.
    raw = stream->data() + stream->pos();
    nb_raw = stream->size() - stream->pos();
    
    if (aac_packet_type == SrsAudioAacFrameTraitSequenceHeader) {
        // AudioSpecificConfig
        // 1.6.2.1 AudioSpecificConfig, in ISO_IEC_14496-3-AAC-2001.pdf, page 33.
        int aac_extra_size = stream->size() - stream->pos();
        if (aac_extra_size > 0) {
            char *copy_stream_from = stream->data() + stream->pos();
            acodec->aac_extra_data = std::vector<char>(copy_stream_from, copy_stream_from + aac_extra_size);
            
            if ((err = audio_aac_sequence_header_demux(&acodec->aac_extra_data[0], aac_extra_size)) != srs_success) {
                return srs_error_wrap(err, "demux aac sh");
            }
        }
    } else if (aac_packet_type == SrsAudioAacFrameTraitRawData) {
        // ensure the sequence header demuxed
        if (!acodec->is_aac_codec_ok()) {
            srs_warn("aac ignore type=%d for no sequence header", aac_packet_type);
            return err;
        }
        
        // Raw AAC frame data in UI8 []
        // 6.3 Raw Data, ISO_IEC_13818-7-AAC-2004.pdf, page 28
        if ((err = audio->add_sample(stream->data() + stream->pos(), stream->size() - stream->pos())) != srs_success) {
            return srs_error_wrap(err, "add audio frame");
        }
    } else {
        // ignored.
    }
    
    // reset the sample rate by sequence header
    if (acodec->aac_sample_rate != SrsAacSampleRateUnset) {
        static int srs_aac_srates[] = {
            96000, 88200, 64000, 48000,
            44100, 32000, 24000, 22050,
            16000, 12000, 11025,  8000,
            7350,     0,     0,    0
        };
        switch (srs_aac_srates[acodec->aac_sample_rate]) {
            case 11025:
                acodec->sound_rate = SrsAudioSampleRate11025;
                break;
            case 22050:
                acodec->sound_rate = SrsAudioSampleRate22050;
                break;
            case 44100:
                acodec->sound_rate = SrsAudioSampleRate44100;
                break;
            default:
                break;
        };
    }
    
    return err;
}

srs_error_t SrsFormat::audio_mp3_demux(SrsBuffer* stream, int64_t timestamp)
{
    srs_error_t err = srs_success;
    
    audio->cts = 0;
    audio->dts = timestamp;
    
    // @see: E.4.2 Audio Tags, video_file_format_spec_v10_1.pdf, page 76
    int8_t sound_format = stream->read_1bytes();
    
    int8_t sound_type = sound_format & 0x01;
    int8_t sound_size = (sound_format >> 1) & 0x01;
    int8_t sound_rate = (sound_format >> 2) & 0x03;
    sound_format = (sound_format >> 4) & 0x0f;
    
    SrsAudioCodecId codec_id = (SrsAudioCodecId)sound_format;
    acodec->id = codec_id;
    
    acodec->sound_type = (SrsAudioChannels)sound_type;
    acodec->sound_rate = (SrsAudioSampleRate)sound_rate;
    acodec->sound_size = (SrsAudioSampleBits)sound_size;
    
    // we always decode aac then mp3.
    srs_assert(acodec->id == SrsAudioCodecIdMP3);
    
    // Update the RAW MP3 data.
    raw = stream->data() + stream->pos();
    nb_raw = stream->size() - stream->pos();
    
    stream->skip(1);
    if (stream->empty()) {
        return err;
    }
    
    char* data = stream->data() + stream->pos();
    int size = stream->size() - stream->pos();
    
    // mp3 payload.
    if ((err = audio->add_sample(data, size)) != srs_success) {
        return srs_error_wrap(err, "add audio frame");
    }
    
    return err;
}

srs_error_t SrsFormat::audio_aac_sequence_header_demux(char* data, int size)
{
    srs_error_t err = srs_success;
    
    SrsBuffer* buffer = new SrsBuffer(data, size);
    SrsAutoFree(SrsBuffer, buffer);
    
    // only need to decode the first 2bytes:
    //      audioObjectType, aac_profile, 5bits.
    //      samplingFrequencyIndex, aac_sample_rate, 4bits.
    //      channelConfiguration, aac_channels, 4bits
    if (!buffer->require(2)) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "audio codec decode aac sh");
    }
    uint8_t profile_ObjectType = buffer->read_1bytes();
    uint8_t samplingFrequencyIndex = buffer->read_1bytes();
    
    acodec->aac_channels = (samplingFrequencyIndex >> 3) & 0x0f;
    samplingFrequencyIndex = ((profile_ObjectType << 1) & 0x0e) | ((samplingFrequencyIndex >> 7) & 0x01);
    profile_ObjectType = (profile_ObjectType >> 3) & 0x1f;
    
    // set the aac sample rate.
    acodec->aac_sample_rate = samplingFrequencyIndex;
    
    // convert the object type in sequence header to aac profile of ADTS.
    acodec->aac_object = (SrsAacObjectType)profile_ObjectType;
    if (acodec->aac_object == SrsAacObjectTypeReserved) {
        return srs_error_new(ERROR_HLS_DECODE_ERROR, "aac decode sh object %d", profile_ObjectType);
    }
    
    // TODO: FIXME: to support aac he/he-v2, see: ngx_rtmp_codec_parse_aac_header
    // @see: https://github.com/winlinvip/nginx-rtmp-module/commit/3a5f9eea78fc8d11e8be922aea9ac349b9dcbfc2
    //
    // donot force to LC, @see: https://github.com/ossrs/srs/issues/81
    // the source will print the sequence header info.
    //if (aac_profile > 3) {
    // Mark all extended profiles as LC
    // to make Android as happy as possible.
    // @see: ngx_rtmp_hls_parse_aac_header
    //aac_profile = 1;
    //}
    
    return err;
}

// following is generated by src/kernel/srs_kernel_io.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kernel_io.hpp>

ISrsReader::ISrsReader()
{
}

ISrsReader::~ISrsReader()
{
}

ISrsSeeker::ISrsSeeker()
{
}

ISrsSeeker::~ISrsSeeker()
{
}

ISrsReadSeeker::ISrsReadSeeker()
{
}

ISrsReadSeeker::~ISrsReadSeeker()
{
}

ISrsStreamWriter::ISrsStreamWriter()
{
}

ISrsStreamWriter::~ISrsStreamWriter()
{
}

ISrsVectorWriter::ISrsVectorWriter()
{
}

ISrsVectorWriter::~ISrsVectorWriter()
{
}

ISrsWriter::ISrsWriter()
{
}

ISrsWriter::~ISrsWriter()
{
}

ISrsWriteSeeker::ISrsWriteSeeker()
{
}

ISrsWriteSeeker::~ISrsWriteSeeker()
{
}

// following is generated by src/kernel/srs_kernel_consts.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kernel_consts.hpp>


// following is generated by src/kernel/srs_kernel_aac.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kernel_aac.hpp>

#if !defined(SRS_EXPORT_LIBRTMP)

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <unistd.h>
#endif

#include <fcntl.h>
#include <sstream>
using namespace std;

//#include <srs_kernel_log.hpp>
//#include <srs_kernel_error.hpp>
//#include <srs_kernel_buffer.hpp>
//#include <srs_kernel_file.hpp>
//#include <srs_kernel_codec.hpp>
//#include <srs_core_autofree.hpp>

SrsAacTransmuxer::SrsAacTransmuxer()
{
    _fs = NULL;
    got_sequence_header = false;
    aac_object = SrsAacObjectTypeReserved;
}

SrsAacTransmuxer::~SrsAacTransmuxer()
{
}

srs_error_t SrsAacTransmuxer::initialize(SrsFileWriter* fs)
{
    srs_error_t err = srs_success;
    
    srs_assert(fs);
    
    if (!fs->is_open()) {
        return srs_error_new(ERROR_KERNEL_AAC_STREAM_CLOSED, "stream is not open");
    }
    
    _fs = fs;
    
    return err;
}

srs_error_t SrsAacTransmuxer::write_audio(int64_t timestamp, char* data, int size)
{
    srs_error_t err = srs_success;
    
    srs_assert(data);
    
    timestamp &= 0x7fffffff;
    
    SrsBuffer* stream = new SrsBuffer(data, size);
    SrsAutoFree(SrsBuffer, stream);
    
    // audio decode
    if (!stream->require(1)) {
        return srs_error_new(ERROR_AAC_DECODE_ERROR, "aac decode audio sound_format failed");
    }
    
    // @see: E.4.2 Audio Tags, video_file_format_spec_v10_1.pdf, page 76
    int8_t sound_format = stream->read_1bytes();
    
    //int8_t sound_type = sound_format & 0x01;
    //int8_t sound_size = (sound_format >> 1) & 0x01;
    //int8_t sound_rate = (sound_format >> 2) & 0x03;
    sound_format = (sound_format >> 4) & 0x0f;
    
    if ((SrsAudioCodecId)sound_format != SrsAudioCodecIdAAC) {
        return srs_error_new(ERROR_AAC_DECODE_ERROR, "aac required, format=%d", sound_format);
    }
    
    if (!stream->require(1)) {
        return srs_error_new(ERROR_AAC_DECODE_ERROR, "aac decode aac_packet_type failed");
    }
    
    SrsAudioAacFrameTrait aac_packet_type = (SrsAudioAacFrameTrait)stream->read_1bytes();
    if (aac_packet_type == SrsAudioAacFrameTraitSequenceHeader) {
        // AudioSpecificConfig
        // 1.6.2.1 AudioSpecificConfig, in ISO_IEC_14496-3-AAC-2001.pdf, page 33.
        //
        // only need to decode the first 2bytes:
        // audioObjectType, 5bits.
        // samplingFrequencyIndex, aac_sample_rate, 4bits.
        // channelConfiguration, aac_channels, 4bits
        if (!stream->require(2)) {
            return srs_error_new(ERROR_AAC_DECODE_ERROR, "aac decode sequence header failed");
        }
        
        int8_t audioObjectType = stream->read_1bytes();
        aac_sample_rate = stream->read_1bytes();
        
        aac_channels = (aac_sample_rate >> 3) & 0x0f;
        aac_sample_rate = ((audioObjectType << 1) & 0x0e) | ((aac_sample_rate >> 7) & 0x01);
        
        audioObjectType = (audioObjectType >> 3) & 0x1f;
        aac_object = (SrsAacObjectType)audioObjectType;
        
        got_sequence_header = true;
        
        return err;
    }
    
    if (!got_sequence_header) {
        return srs_error_new(ERROR_AAC_DECODE_ERROR, "aac no sequence header");
    }
    
    // the left is the aac raw frame data.
    int16_t aac_raw_length = stream->size() - stream->pos();
    
    // write the ADTS header.
    // @see ISO_IEC_14496-3-AAC-2001.pdf, page 75,
    //      1.A.2.2 Audio_Data_Transport_Stream frame, ADTS
    // @see https://github.com/ossrs/srs/issues/212#issuecomment-64145885
    // byte_alignment()
    
    // adts_fixed_header:
    //      12bits syncword,
    //      16bits left.
    // adts_variable_header:
    //      28bits
    //      12+16+28=56bits
    // adts_error_check:
    //      16bits if protection_absent
    //      56+16=72bits
    // if protection_absent:
    //      require(7bytes)=56bits
    // else
    //      require(9bytes)=72bits
    char aac_fixed_header[7];
    if(true) {
        char* pp = aac_fixed_header;
        int16_t aac_frame_length = aac_raw_length + 7;
        
        // Syncword 12 bslbf
        *pp++ = 0xff;
        // 4bits left.
        // adts_fixed_header(), 1.A.2.2.1 Fixed Header of ADTS
        // ID 1 bslbf
        // Layer 2 uimsbf
        // protection_absent 1 bslbf
        *pp++ = 0xf1;
        
        // profile 2 uimsbf
        // sampling_frequency_index 4 uimsbf
        // private_bit 1 bslbf
        // channel_configuration 3 uimsbf
        // original/copy 1 bslbf
        // home 1 bslbf
        SrsAacProfile aac_profile = srs_aac_rtmp2ts(aac_object);
        *pp++ = ((aac_profile << 6) & 0xc0) | ((aac_sample_rate << 2) & 0x3c) | ((aac_channels >> 2) & 0x01);
        // 4bits left.
        // adts_variable_header(), 1.A.2.2.2 Variable Header of ADTS
        // copyright_identification_bit 1 bslbf
        // copyright_identification_start 1 bslbf
        *pp++ = ((aac_channels << 6) & 0xc0) | ((aac_frame_length >> 11) & 0x03);
        
        // aac_frame_length 13 bslbf: Length of the frame including headers and error_check in bytes.
        // use the left 2bits as the 13 and 12 bit,
        // the aac_frame_length is 13bits, so we move 13-2=11.
        *pp++ = aac_frame_length >> 3;
        // adts_buffer_fullness 11 bslbf
        *pp++ = (aac_frame_length << 5) & 0xe0;
        
        // no_raw_data_blocks_in_frame 2 uimsbf
        *pp++ = 0xfc;
    }
    
    // write 7bytes fixed header.
    if ((err = _fs->write(aac_fixed_header, 7, NULL)) != srs_success) {
        return srs_error_wrap(err, "write aac header");
    }
    
    // write aac frame body.
    if ((err = _fs->write(data + stream->pos(), aac_raw_length, NULL)) != srs_success) {
        return srs_error_wrap(err, "write aac frame");
    }
    
    return err;
}

#endif

// following is generated by src/kernel/srs_kernel_mp3.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kernel_mp3.hpp>

#if !defined(SRS_EXPORT_LIBRTMP)

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <unistd.h>
#endif

#include <fcntl.h>
#include <sstream>
using namespace std;

//#include <srs_kernel_log.hpp>
//#include <srs_kernel_error.hpp>
//#include <srs_kernel_buffer.hpp>
//#include <srs_kernel_file.hpp>
//#include <srs_kernel_codec.hpp>
//#include <srs_core_autofree.hpp>

SrsMp3Transmuxer::SrsMp3Transmuxer()
{
    writer = NULL;
}

SrsMp3Transmuxer::~SrsMp3Transmuxer()
{
}

srs_error_t SrsMp3Transmuxer::initialize(SrsFileWriter* fw)
{
    srs_error_t err = srs_success;
    
    srs_assert(fw);
    
    if (!fw->is_open()) {
        return srs_error_new(ERROR_KERNEL_MP3_STREAM_CLOSED, "stream is not open");
    }
    
    writer = fw;
    
    return err;
}

srs_error_t SrsMp3Transmuxer::write_header()
{
    srs_error_t err = srs_success;
    
    char id3[] = {
        (char)0x49, (char)0x44, (char)0x33, // ID3
        (char)0x03, (char)0x00, // version
        (char)0x00, // flags
        (char)0x00, (char)0x00, (char)0x00, (char)0x0a, // size
        
        (char)0x00, (char)0x00, (char)0x00, (char)0x00, // FrameID
        (char)0x00, (char)0x00, (char)0x00, (char)0x00, // FrameSize
        (char)0x00, (char)0x00 // Flags
    };
    
    if ((err = writer->write(id3, sizeof(id3), NULL)) != srs_success) {
        return srs_error_wrap(err, "write id3");
    }
    
    return err;
}

srs_error_t SrsMp3Transmuxer::write_audio(int64_t timestamp, char* data, int size)
{
    srs_error_t err = srs_success;
    
    srs_assert(data);
    
    timestamp &= 0x7fffffff;
    
    SrsBuffer* stream = new SrsBuffer(data, size);
    SrsAutoFree(SrsBuffer, stream);
    
    // audio decode
    if (!stream->require(1)) {
        return srs_error_new(ERROR_MP3_DECODE_ERROR, "decode sound_format");
    }
    
    // @see: E.4.2 Audio Tags, video_file_format_spec_v10_1.pdf, page 76
    int8_t sound_format = stream->read_1bytes();
    
    //int8_t sound_type = sound_format & 0x01;
    //int8_t sound_size = (sound_format >> 1) & 0x01;
    //int8_t sound_rate = (sound_format >> 2) & 0x03;
    sound_format = (sound_format >> 4) & 0x0f;
    
    if ((SrsAudioCodecId)sound_format != SrsAudioCodecIdMP3) {
        return srs_error_new(ERROR_MP3_DECODE_ERROR, "mp3 required, format=%d", sound_format);
    }
    
    if (!stream->require(1)) {
        return srs_error_new(ERROR_MP3_DECODE_ERROR, "mp3 decode aac_packet_type failed");
    }
    
    if ((err = writer->write(data + stream->pos(), size - stream->pos(), NULL)) != srs_success) {
        return srs_error_wrap(err, "write audio");
    }
    
    return err;
}

#endif

// following is generated by src/kernel/srs_kernel_ts.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kernel_ts.hpp>

#if !defined(SRS_EXPORT_LIBRTMP)

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <unistd.h>
#endif

#include <fcntl.h>
#include <sstream>
using namespace std;

//#include <srs_kernel_log.hpp>
//#include <srs_kernel_error.hpp>
//#include <srs_kernel_file.hpp>
//#include <srs_kernel_codec.hpp>
//#include <srs_kernel_stream.hpp>
//#include <srs_kernel_utility.hpp>
//#include <srs_kernel_buffer.hpp>
//#include <srs_core_autofree.hpp>

// in ms, for HLS aac sync time.
#define SRS_CONF_DEFAULT_AAC_SYNC 100

// @see: ngx_rtmp_hls_audio
/* We assume here AAC frame size is 1024
 * Need to handle AAC frames with frame size of 960 */
#define _SRS_AAC_SAMPLE_SIZE 1024

// the mpegts header specifed the video/audio pid.
#define TS_PMT_NUMBER 1
#define TS_PMT_PID 0x1001
#define TS_VIDEO_AVC_PID 0x100
#define TS_AUDIO_AAC_PID 0x101
#define TS_AUDIO_MP3_PID 0x102

string srs_ts_stream2string(SrsTsStream stream)
{
    switch (stream) {
        case SrsTsStreamReserved: return "Reserved";
        case SrsTsStreamAudioMp3: return "MP3";
        case SrsTsStreamAudioAAC: return "AAC";
        case SrsTsStreamAudioAC3: return "AC3";
        case SrsTsStreamAudioDTS: return "AudioDTS";
        case SrsTsStreamVideoH264: return "H.264";
        case SrsTsStreamVideoMpeg4: return "MP4";
        case SrsTsStreamAudioMpeg4: return "MP4A";
        default: return "Other";
    }
}

SrsTsChannel::SrsTsChannel()
{
    pid = 0;
    apply = SrsTsPidApplyReserved;
    stream = SrsTsStreamReserved;
    msg = NULL;
    continuity_counter = 0;
    context = NULL;
}

SrsTsChannel::~SrsTsChannel()
{
    srs_freep(msg);
}

SrsTsMessage::SrsTsMessage(SrsTsChannel* c, SrsTsPacket* p)
{
    channel = c;
    packet = p;
    
    dts = pts = 0;
    sid = (SrsTsPESStreamId)0x00;
    continuity_counter = 0;
    PES_packet_length = 0;
    payload = new SrsSimpleStream();
    is_discontinuity = false;
    
    start_pts = 0;
    write_pcr = false;
}

SrsTsMessage::~SrsTsMessage()
{
    srs_freep(payload);
}

srs_error_t SrsTsMessage::dump(SrsBuffer* stream, int* pnb_bytes)
{
    srs_error_t err = srs_success;
    
    if (stream->empty()) {
        return err;
    }
    
    // xB
    int nb_bytes = stream->size() - stream->pos();
    if (PES_packet_length > 0) {
        nb_bytes = srs_min(nb_bytes, PES_packet_length - payload->length());
    }
    
    if (nb_bytes > 0) {
        if (!stream->require(nb_bytes)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: dump PSE bytes failed, requires=%dB", nb_bytes);
        }
        
        payload->append(stream->data() + stream->pos(), nb_bytes);
        stream->skip(nb_bytes);
    }
    
    *pnb_bytes = nb_bytes;
    
    return err;
}

bool SrsTsMessage::completed(int8_t payload_unit_start_indicator)
{
    if (PES_packet_length == 0) {
        return payload_unit_start_indicator;
    }
    return payload->length() >= PES_packet_length;
}

bool SrsTsMessage::fresh()
{
    return payload->length() == 0;
}

bool SrsTsMessage::is_audio()
{
    return ((sid >> 5) & 0x07) == SrsTsPESStreamIdAudioChecker;
}

bool SrsTsMessage::is_video()
{
    return ((sid >> 4) & 0x0f) == SrsTsPESStreamIdVideoChecker;
}

int SrsTsMessage::stream_number()
{
    if (is_audio()) {
        return sid & 0x1f;
    } else if (is_video()) {
        return sid & 0x0f;
    }
    return -1;
}

SrsTsMessage* SrsTsMessage::detach()
{
    // @remark the packet cannot be used, but channel is ok.
    SrsTsMessage* cp = new SrsTsMessage(channel, NULL);
    cp->start_pts = start_pts;
    cp->write_pcr = write_pcr;
    cp->is_discontinuity = is_discontinuity;
    cp->dts = dts;
    cp->pts = pts;
    cp->sid = sid;
    cp->PES_packet_length = PES_packet_length;
    cp->continuity_counter = continuity_counter;
    
    srs_freep(cp->payload);
    cp->payload = payload;
    payload = NULL;
    
    return cp;
}

ISrsTsHandler::ISrsTsHandler()
{
}

ISrsTsHandler::~ISrsTsHandler()
{
}

SrsTsContext::SrsTsContext()
{
    ready = false;
    pure_audio = false;
    sync_byte = 0x47; // ts default sync byte.
    vcodec = SrsVideoCodecIdReserved;
    acodec = SrsAudioCodecIdReserved1;
}

SrsTsContext::~SrsTsContext()
{
    std::map<int, SrsTsChannel*>::iterator it;
    for (it = pids.begin(); it != pids.end(); ++it) {
        SrsTsChannel* channel = it->second;
        srs_freep(channel);
    }
    pids.clear();
}

bool SrsTsContext::is_pure_audio()
{
    return pure_audio;
}

void SrsTsContext::on_pmt_parsed()
{
    pure_audio = true;
    
    std::map<int, SrsTsChannel*>::iterator it;
    for (it = pids.begin(); it != pids.end(); ++it) {
        SrsTsChannel* channel = it->second;
        if (channel->apply == SrsTsPidApplyVideo) {
            pure_audio = false;
        }
    }
}

void SrsTsContext::reset()
{
    ready = false;
    vcodec = SrsVideoCodecIdReserved;
    acodec = SrsAudioCodecIdReserved1;
}

SrsTsChannel* SrsTsContext::get(int pid)
{
    if (pids.find(pid) == pids.end()) {
        return NULL;
    }
    return pids[pid];
}

void SrsTsContext::set(int pid, SrsTsPidApply apply_pid, SrsTsStream stream)
{
    SrsTsChannel* channel = NULL;
    
    if (pids.find(pid) == pids.end()) {
        channel = new SrsTsChannel();
        channel->context = this;
        pids[pid] = channel;
    } else {
        channel = pids[pid];
    }
    
    channel->pid = pid;
    channel->apply = apply_pid;
    channel->stream = stream;
}

srs_error_t SrsTsContext::decode(SrsBuffer* stream, ISrsTsHandler* handler)
{
    srs_error_t err = srs_success;
    
    // parse util EOF of stream.
    // for example, parse multiple times for the PES_packet_length(0) packet.
    while (!stream->empty()) {
        SrsTsPacket* packet = new SrsTsPacket(this);
        SrsAutoFree(SrsTsPacket, packet);
        
        SrsTsMessage* msg = NULL;
        if ((err = packet->decode(stream, &msg)) != srs_success) {
            return srs_error_wrap(err, "ts: ts packet decode");
        }
        
        if (!msg) {
            continue;
        }
        SrsAutoFree(SrsTsMessage, msg);
        
        if ((err = handler->on_ts_message(msg)) != srs_success) {
            return srs_error_wrap(err, "ts: handle ts message");
        }
    }
    
    return err;
}

srs_error_t SrsTsContext::encode(SrsFileWriter* writer, SrsTsMessage* msg, SrsVideoCodecId vc, SrsAudioCodecId ac)
{
    srs_error_t err = srs_success;
    
    SrsTsStream vs, as;
    int16_t video_pid = 0, audio_pid = 0;
    switch (vc) {
        case SrsVideoCodecIdAVC:
            vs = SrsTsStreamVideoH264;
            video_pid = TS_VIDEO_AVC_PID;
            break;
        case SrsVideoCodecIdDisabled:
            vs = SrsTsStreamReserved;
            break;
        case SrsVideoCodecIdReserved:
        case SrsVideoCodecIdReserved1:
        case SrsVideoCodecIdReserved2:
        case SrsVideoCodecIdSorensonH263:
        case SrsVideoCodecIdScreenVideo:
        case SrsVideoCodecIdOn2VP6:
        case SrsVideoCodecIdOn2VP6WithAlphaChannel:
        case SrsVideoCodecIdScreenVideoVersion2:
            vs = SrsTsStreamReserved;
            break;
    }
    switch (ac) {
        case SrsAudioCodecIdAAC:
            as = SrsTsStreamAudioAAC;
            audio_pid = TS_AUDIO_AAC_PID;
            break;
        case SrsAudioCodecIdMP3:
            as = SrsTsStreamAudioMp3;
            audio_pid = TS_AUDIO_MP3_PID;
            break;
        case SrsAudioCodecIdDisabled:
            as = SrsTsStreamReserved;
            break;
        case SrsAudioCodecIdReserved1:
        case SrsAudioCodecIdLinearPCMPlatformEndian:
        case SrsAudioCodecIdADPCM:
        case SrsAudioCodecIdLinearPCMLittleEndian:
        case SrsAudioCodecIdNellymoser16kHzMono:
        case SrsAudioCodecIdNellymoser8kHzMono:
        case SrsAudioCodecIdNellymoser:
        case SrsAudioCodecIdReservedG711AlawLogarithmicPCM:
        case SrsAudioCodecIdReservedG711MuLawLogarithmicPCM:
        case SrsAudioCodecIdReserved:
        case SrsAudioCodecIdSpeex:
        case SrsAudioCodecIdReservedMP3_8kHz:
        case SrsAudioCodecIdReservedDeviceSpecificSound:
            as = SrsTsStreamReserved;
            break;
    }
    
    if (as == SrsTsStreamReserved && vs == SrsTsStreamReserved) {
        return srs_error_new(ERROR_HLS_NO_STREAM, "ts: no a/v stream, vcodec=%d, acodec=%d", vc, ac);
    }
    
    // when any codec changed, write PAT/PMT table.
    if (vcodec != vc || acodec != ac) {
        vcodec = vc;
        acodec = ac;
        if ((err = encode_pat_pmt(writer, video_pid, vs, audio_pid, as)) != srs_success) {
            return srs_error_wrap(err, "ts: encode PAT/PMT");
        }
    }
    
    // encode the media frame to PES packets over TS.
    if (msg->is_audio()) {
        return encode_pes(writer, msg, audio_pid, as, vs == SrsTsStreamReserved);
    } else {
        return encode_pes(writer, msg, video_pid, vs, vs == SrsTsStreamReserved);
    }
}

void SrsTsContext::set_sync_byte(int8_t sb)
{
    sync_byte = sb;
}

srs_error_t SrsTsContext::encode_pat_pmt(SrsFileWriter* writer, int16_t vpid, SrsTsStream vs, int16_t apid, SrsTsStream as)
{
    srs_error_t err = srs_success;
    
    if (vs != SrsTsStreamVideoH264 && as != SrsTsStreamAudioAAC && as != SrsTsStreamAudioMp3) {
        return srs_error_new(ERROR_HLS_NO_STREAM, "ts: no PID, vs=%d, as=%d", vs, as);
    }
    
    int16_t pmt_number = TS_PMT_NUMBER;
    int16_t pmt_pid = TS_PMT_PID;
    if (true) {
        SrsTsPacket* pkt = SrsTsPacket::create_pat(this, pmt_number, pmt_pid);
        SrsAutoFree(SrsTsPacket, pkt);
        
        pkt->sync_byte = sync_byte;
        
        char* buf = new char[SRS_TS_PACKET_SIZE];
        SrsAutoFreeA(char, buf);
        
        // set the left bytes with 0xFF.
        int nb_buf = pkt->size();
        srs_assert(nb_buf < SRS_TS_PACKET_SIZE);
        memset(buf + nb_buf, 0xFF, SRS_TS_PACKET_SIZE - nb_buf);
        
        SrsBuffer stream(buf, nb_buf);
        if ((err = pkt->encode(&stream)) != srs_success) {
            return srs_error_wrap(err, "ts: encode packet");
        }
        if ((err = writer->write(buf, SRS_TS_PACKET_SIZE, NULL)) != srs_success) {
            return srs_error_wrap(err, "ts: write packet");
        }
    }
    if (true) {
        SrsTsPacket* pkt = SrsTsPacket::create_pmt(this, pmt_number, pmt_pid, vpid, vs, apid, as);
        SrsAutoFree(SrsTsPacket, pkt);
        
        pkt->sync_byte = sync_byte;
        
        char* buf = new char[SRS_TS_PACKET_SIZE];
        SrsAutoFreeA(char, buf);
        
        // set the left bytes with 0xFF.
        int nb_buf = pkt->size();
        srs_assert(nb_buf < SRS_TS_PACKET_SIZE);
        memset(buf + nb_buf, 0xFF, SRS_TS_PACKET_SIZE - nb_buf);
        
        SrsBuffer stream(buf, nb_buf);
        if ((err = pkt->encode(&stream)) != srs_success) {
            return srs_error_wrap(err, "ts: encode packet");
        }
        if ((err = writer->write(buf, SRS_TS_PACKET_SIZE, NULL)) != srs_success) {
            return srs_error_wrap(err, "ts: write packet");
        }
    }
    
    // When PAT and PMT are writen, the context is ready now.
    ready = true;

    return err;
}

srs_error_t SrsTsContext::encode_pes(SrsFileWriter* writer, SrsTsMessage* msg, int16_t pid, SrsTsStream sid, bool pure_audio)
{
    srs_error_t err = srs_success;
    
    // Sometimes, the context is not ready(PAT/PMT write failed), error in this situation.
    if (!ready) {
        return srs_error_new(ERROR_TS_CONTEXT_NOT_READY, "ts: not ready");
    }

    if (msg->payload->length() == 0) {
        return err;
    }
    
    if (sid != SrsTsStreamVideoH264 && sid != SrsTsStreamAudioMp3 && sid != SrsTsStreamAudioAAC) {
        srs_info("ts: ignore the unknown stream, sid=%d", sid);
        return err;
    }
    
    SrsTsChannel* channel = get(pid);
    srs_assert(channel);
    
    char* start = msg->payload->bytes();
    char* end = start + msg->payload->length();
    char* p = start;
    
    while (p < end) {
        SrsTsPacket* pkt = NULL;
        if (p == start) {
            // write pcr according to message.
            bool write_pcr = msg->write_pcr;
            
            // for pure audio, always write pcr.
            // TODO: FIXME: maybe only need to write at begin and end of ts.
            if (pure_audio && msg->is_audio()) {
                write_pcr = true;
            }
            
            // it's ok to set pcr equals to dts,
            // @see https://github.com/ossrs/srs/issues/311
            // Fig. 3.18. Program Clock Reference of Digital-Video-and-Audio-Broadcasting-Technology, page 65
            // In MPEG-2, these are the "Program Clock Refer- ence" (PCR) values which are
            // nothing else than an up-to-date copy of the STC counter fed into the transport
            // stream at a certain time. The data stream thus carries an accurate internal
            // "clock time". All coding and de- coding processes are controlled by this clock
            // time. To do this, the receiver, i.e. the MPEG decoder, must read out the
            // "clock time", namely the PCR values, and compare them with its own internal
            // system clock, that is to say its own 42 bit counter.
            int64_t pcr = write_pcr? msg->dts : -1;
            
            // TODO: FIXME: finger it why use discontinuity of msg.
            pkt = SrsTsPacket::create_pes_first(this,
                pid, msg->sid, channel->continuity_counter++, msg->is_discontinuity,
                pcr, msg->dts, msg->pts, msg->payload->length()
            );
        } else {
            pkt = SrsTsPacket::create_pes_continue(this, pid, msg->sid, channel->continuity_counter++);
        }
        SrsAutoFree(SrsTsPacket, pkt);
        
        pkt->sync_byte = sync_byte;
        
        char* buf = new char[SRS_TS_PACKET_SIZE];
        SrsAutoFreeA(char, buf);
        
        // set the left bytes with 0xFF.
        int nb_buf = pkt->size();
        srs_assert(nb_buf < SRS_TS_PACKET_SIZE);
        
        int left = (int)srs_min(end - p, SRS_TS_PACKET_SIZE - nb_buf);
        int nb_stuffings = SRS_TS_PACKET_SIZE - nb_buf - left;
        if (nb_stuffings > 0) {
            // set all bytes to stuffings.
            memset(buf, 0xFF, SRS_TS_PACKET_SIZE);
            
            // padding with stuffings.
            pkt->padding(nb_stuffings);
            
            // size changed, recalc it.
            nb_buf = pkt->size();
            srs_assert(nb_buf < SRS_TS_PACKET_SIZE);
            
            left = (int)srs_min(end - p, SRS_TS_PACKET_SIZE - nb_buf);
            nb_stuffings = SRS_TS_PACKET_SIZE - nb_buf - left;
            srs_assert(nb_stuffings == 0);
        }
        memcpy(buf + nb_buf, p, left);
        p += left;
        
        SrsBuffer stream(buf, nb_buf);
        if ((err = pkt->encode(&stream)) != srs_success) {
            return srs_error_wrap(err, "ts: encode packet");
        }
        if ((err = writer->write(buf, SRS_TS_PACKET_SIZE, NULL)) != srs_success) {
            return srs_error_wrap(err, "ts: write packet");
        }
    }
    
    return err;
}

SrsTsPacket::SrsTsPacket(SrsTsContext* c)
{
    context = c;
    
    sync_byte = 0;
    transport_error_indicator = 0;
    payload_unit_start_indicator = 0;
    transport_priority = 0;
    pid = SrsTsPidPAT;
    transport_scrambling_control = SrsTsScrambledDisabled;
    adaption_field_control = SrsTsAdaptationFieldTypeReserved;
    continuity_counter = 0;
    adaptation_field = NULL;
    payload = NULL;
}

SrsTsPacket::~SrsTsPacket()
{
    srs_freep(adaptation_field);
    srs_freep(payload);
}

srs_error_t SrsTsPacket::decode(SrsBuffer* stream, SrsTsMessage** ppmsg)
{
    srs_error_t err = srs_success;
    
    int pos = stream->pos();
    
    // 4B ts packet header.
    if (!stream->require(4)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_HEADER, "ts: decode packet");
    }
    
    sync_byte = stream->read_1bytes();
    if (sync_byte != 0x47) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_SYNC_BYTE, "ts: sync_bytes must be 0x47, actual=%#x", sync_byte);
    }
    
    int16_t pidv = stream->read_2bytes();
    transport_error_indicator = (pidv >> 15) & 0x01;
    payload_unit_start_indicator = (pidv >> 14) & 0x01;
    transport_priority = (pidv >> 13) & 0x01;
    pid = (SrsTsPid)(pidv & 0x1FFF);
    
    int8_t ccv = stream->read_1bytes();
    transport_scrambling_control = (SrsTsScrambled)((ccv >> 6) & 0x03);
    adaption_field_control = (SrsTsAdaptationFieldType)((ccv >> 4) & 0x03);
    continuity_counter = ccv & 0x0F;
    
    // TODO: FIXME: create pids map when got new pid.
    
    srs_info("ts: header sync=%#x error=%d unit_start=%d priotiry=%d pid=%d scrambling=%d adaption=%d counter=%d",
             sync_byte, transport_error_indicator, payload_unit_start_indicator, transport_priority, pid,
             transport_scrambling_control, adaption_field_control, continuity_counter);
    
    // optional: adaptation field
    if (adaption_field_control == SrsTsAdaptationFieldTypeAdaptionOnly || adaption_field_control == SrsTsAdaptationFieldTypeBoth) {
        srs_freep(adaptation_field);
        adaptation_field = new SrsTsAdaptationField(this);
        
        if ((err = adaptation_field->decode(stream)) != srs_success) {
            return srs_error_wrap(err, "ts: demux af field");
        }
        srs_verbose("ts: demux af ok.");
    }
    
    // calc the user defined data size for payload.
    int nb_payload = SRS_TS_PACKET_SIZE - (stream->pos() - pos);
    
    // optional: payload.
    if (adaption_field_control == SrsTsAdaptationFieldTypePayloadOnly || adaption_field_control == SrsTsAdaptationFieldTypeBoth) {
        if (pid == SrsTsPidPAT) {
            // 2.4.4.3 Program association Table
            srs_freep(payload);
            payload = new SrsTsPayloadPAT(this);
        } else {
            SrsTsChannel* channel = context->get(pid);
            if (channel && channel->apply == SrsTsPidApplyPMT) {
                // 2.4.4.8 Program Map Table
                srs_freep(payload);
                payload = new SrsTsPayloadPMT(this);
            } else if (channel && (channel->apply == SrsTsPidApplyVideo || channel->apply == SrsTsPidApplyAudio)) {
                // 2.4.3.6 PES packet
                srs_freep(payload);
                payload = new SrsTsPayloadPES(this);
            } else {
                // left bytes as reserved.
                stream->skip(nb_payload);
            }
        }
        
        if (payload && (err = payload->decode(stream, ppmsg)) != srs_success) {
            return srs_error_wrap(err, "ts: demux payload");
        }
    }
    
    return err;
}

int SrsTsPacket::size()
{
    int sz = 4;
    
    sz += adaptation_field? adaptation_field->size() : 0;
    sz += payload? payload->size() : 0;
    
    return sz;
}

srs_error_t SrsTsPacket::encode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // 4B ts packet header.
    if (!stream->require(4)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_HEADER, "ts: requires 4+ bytes");
    }
    
    stream->write_1bytes(sync_byte);
    
    int16_t pidv = pid & 0x1FFF;
    pidv |= (transport_priority << 13) & 0x2000;
    pidv |= (transport_error_indicator << 15) & 0x8000;
    pidv |= (payload_unit_start_indicator << 14) & 0x4000;
    stream->write_2bytes(pidv);
    
    int8_t ccv = continuity_counter & 0x0F;
    ccv |= (transport_scrambling_control << 6) & 0xC0;
    ccv |= (adaption_field_control << 4) & 0x30;
    stream->write_1bytes(ccv);
    
    srs_info("ts: header sync=%#x error=%d unit_start=%d priotiry=%d pid=%d scrambling=%d adaption=%d counter=%d",
             sync_byte, transport_error_indicator, payload_unit_start_indicator, transport_priority, pid,
             transport_scrambling_control, adaption_field_control, continuity_counter);
    
    // optional: adaptation field
    if (adaptation_field) {
        if ((err = adaptation_field->encode(stream)) != srs_success) {
            return srs_error_wrap(err, "ts: mux af field");
        }
        srs_verbose("ts: mux af ok.");
    }
    
    // optional: payload.
    if (payload) {
        if ((err = payload->encode(stream)) != srs_success) {
            return srs_error_wrap(err, "ts: mux payload");
        }
        srs_verbose("ts: mux payload ok.");
    }
    
    return err;
}

void SrsTsPacket::padding(int nb_stuffings)
{
    if (!adaptation_field) {
        SrsTsAdaptationField* af = new SrsTsAdaptationField(this);
        adaptation_field = af;
        
        af->adaption_field_length = 0; // calc in size.
        af->discontinuity_indicator = 0;
        af->random_access_indicator = 0;
        af->elementary_stream_priority_indicator = 0;
        af->PCR_flag = 0;
        af->OPCR_flag = 0;
        af->splicing_point_flag = 0;
        af->transport_private_data_flag = 0;
        af->adaptation_field_extension_flag = 0;
        
        // consume the af size if possible.
        nb_stuffings = srs_max(0, nb_stuffings - af->size());
    }
    
    adaptation_field->nb_af_reserved = nb_stuffings;
    
    // set payload with af.
    if (adaption_field_control == SrsTsAdaptationFieldTypePayloadOnly) {
        adaption_field_control = SrsTsAdaptationFieldTypeBoth;
    }
}

SrsTsPacket* SrsTsPacket::create_pat(SrsTsContext* context, int16_t pmt_number, int16_t pmt_pid)
{
    SrsTsPacket* pkt = new SrsTsPacket(context);
    pkt->sync_byte = 0x47;
    pkt->transport_error_indicator = 0;
    pkt->payload_unit_start_indicator = 1;
    pkt->transport_priority = 0;
    pkt->pid = SrsTsPidPAT;
    pkt->transport_scrambling_control = SrsTsScrambledDisabled;
    pkt->adaption_field_control = SrsTsAdaptationFieldTypePayloadOnly;
    pkt->continuity_counter = 0;
    pkt->adaptation_field = NULL;
    SrsTsPayloadPAT* pat = new SrsTsPayloadPAT(pkt);
    pkt->payload = pat;
    
    pat->pointer_field = 0;
    pat->table_id = SrsTsPsiIdPas;
    pat->section_syntax_indicator = 1;
    pat->section_length = 0; // calc in size.
    pat->transport_stream_id = 1;
    pat->version_number = 0;
    pat->current_next_indicator = 1;
    pat->section_number = 0;
    pat->last_section_number = 0;
    pat->programs.push_back(new SrsTsPayloadPATProgram(pmt_number, pmt_pid));
    pat->CRC_32 = 0; // calc in encode.
    return pkt;
}

SrsTsPacket* SrsTsPacket::create_pmt(SrsTsContext* context, int16_t pmt_number, int16_t pmt_pid, int16_t vpid, SrsTsStream vs, int16_t apid, SrsTsStream as)
{
    SrsTsPacket* pkt = new SrsTsPacket(context);
    pkt->sync_byte = 0x47;
    pkt->transport_error_indicator = 0;
    pkt->payload_unit_start_indicator = 1;
    pkt->transport_priority = 0;
    pkt->pid = (SrsTsPid)pmt_pid;
    pkt->transport_scrambling_control = SrsTsScrambledDisabled;
    pkt->adaption_field_control = SrsTsAdaptationFieldTypePayloadOnly;
    // TODO: FIXME: maybe should continuous in channel.
    pkt->continuity_counter = 0;
    pkt->adaptation_field = NULL;
    SrsTsPayloadPMT* pmt = new SrsTsPayloadPMT(pkt);
    pkt->payload = pmt;
    
    pmt->pointer_field = 0;
    pmt->table_id = SrsTsPsiIdPms;
    pmt->section_syntax_indicator = 1;
    pmt->section_length = 0; // calc in size.
    pmt->program_number = pmt_number;
    pmt->version_number = 0;
    pmt->current_next_indicator = 1;
    pmt->section_number = 0;
    pmt->last_section_number = 0;
    
    // must got one valid codec.
    srs_assert(vs == SrsTsStreamVideoH264 || as == SrsTsStreamAudioAAC || as == SrsTsStreamAudioMp3);
    
    // if mp3 or aac specified, use audio to carry pcr.
    if (as == SrsTsStreamAudioAAC || as == SrsTsStreamAudioMp3) {
        // use audio to carray pcr by default.
        // for hls, there must be atleast one audio channel.
        pmt->PCR_PID = apid;
        pmt->infos.push_back(new SrsTsPayloadPMTESInfo(as, apid));
    }
    
    // if h.264 specified, use video to carry pcr.
    if (vs == SrsTsStreamVideoH264) {
        pmt->PCR_PID = vpid;
        pmt->infos.push_back(new SrsTsPayloadPMTESInfo(vs, vpid));
    }
    
    pmt->CRC_32 = 0; // calc in encode.
    return pkt;
}

SrsTsPacket* SrsTsPacket::create_pes_first(SrsTsContext* context,
                                           int16_t pid, SrsTsPESStreamId sid, uint8_t continuity_counter, bool discontinuity,
                                           int64_t pcr, int64_t dts, int64_t pts, int size
                                           ) {
    SrsTsPacket* pkt = new SrsTsPacket(context);
    pkt->sync_byte = 0x47;
    pkt->transport_error_indicator = 0;
    pkt->payload_unit_start_indicator = 1;
    pkt->transport_priority = 0;
    pkt->pid = (SrsTsPid)pid;
    pkt->transport_scrambling_control = SrsTsScrambledDisabled;
    pkt->adaption_field_control = SrsTsAdaptationFieldTypePayloadOnly;
    pkt->continuity_counter = continuity_counter;
    pkt->adaptation_field = NULL;
    SrsTsPayloadPES* pes = new SrsTsPayloadPES(pkt);
    pkt->payload = pes;
    
    if (pcr >= 0) {
        SrsTsAdaptationField* af = new SrsTsAdaptationField(pkt);
        pkt->adaptation_field = af;
        pkt->adaption_field_control = SrsTsAdaptationFieldTypeBoth;
        
        af->adaption_field_length = 0; // calc in size.
        af->discontinuity_indicator = discontinuity;
        af->random_access_indicator = 0;
        af->elementary_stream_priority_indicator = 0;
        af->PCR_flag = 1;
        af->OPCR_flag = 0;
        af->splicing_point_flag = 0;
        af->transport_private_data_flag = 0;
        af->adaptation_field_extension_flag = 0;
        af->program_clock_reference_base = pcr;
        af->program_clock_reference_extension = 0;
    }
    
    pes->packet_start_code_prefix = 0x01;
    pes->stream_id = (uint8_t)sid;
    pes->PES_packet_length = (size > 0xFFFF)? 0:size;
    pes->PES_scrambling_control = 0;
    pes->PES_priority = 0;
    pes->data_alignment_indicator = 0;
    pes->copyright = 0;
    pes->original_or_copy = 0;
    pes->PTS_DTS_flags = (dts == pts)? 0x02:0x03;
    pes->ESCR_flag = 0;
    pes->ES_rate_flag = 0;
    pes->DSM_trick_mode_flag = 0;
    pes->additional_copy_info_flag = 0;
    pes->PES_CRC_flag = 0;
    pes->PES_extension_flag = 0;
    pes->PES_header_data_length = 0; // calc in size.
    pes->pts = pts;
    pes->dts = dts;
    return pkt;
}

SrsTsPacket* SrsTsPacket::create_pes_continue(SrsTsContext* context, int16_t pid, SrsTsPESStreamId sid, uint8_t continuity_counter)
{
    SrsTsPacket* pkt = new SrsTsPacket(context);
    pkt->sync_byte = 0x47;
    pkt->transport_error_indicator = 0;
    pkt->payload_unit_start_indicator = 0;
    pkt->transport_priority = 0;
    pkt->pid = (SrsTsPid)pid;
    pkt->transport_scrambling_control = SrsTsScrambledDisabled;
    pkt->adaption_field_control = SrsTsAdaptationFieldTypePayloadOnly;
    pkt->continuity_counter = continuity_counter;
    pkt->adaptation_field = NULL;
    pkt->payload = NULL;
    
    return pkt;
}

SrsTsAdaptationField::SrsTsAdaptationField(SrsTsPacket* pkt)
{
    packet = pkt;
    
    adaption_field_length = 0;
    discontinuity_indicator = 0;
    random_access_indicator = 0;
    elementary_stream_priority_indicator = 0;
    PCR_flag = 0;
    OPCR_flag = 0;
    splicing_point_flag = 0;
    transport_private_data_flag = 0;
    adaptation_field_extension_flag = 0;
    program_clock_reference_base = 0;
    program_clock_reference_extension = 0;
    original_program_clock_reference_base = 0;
    original_program_clock_reference_extension = 0;
    splice_countdown = 0;
    adaptation_field_extension_length = 0;
    ltw_flag = 0;
    piecewise_rate_flag = 0;
    seamless_splice_flag = 0;
    ltw_valid_flag = 0;
    ltw_offset = 0;
    piecewise_rate = 0;
    splice_type = 0;
    DTS_next_AU0 = 0;
    marker_bit0 = 0;
    DTS_next_AU1 = 0;
    marker_bit1 = 0;
    DTS_next_AU2 = 0;
    marker_bit2 = 0;
    nb_af_ext_reserved = 0;
    nb_af_reserved = 0;
    
    const1_value0 = 0x3F;
    const1_value1 = 0x1F;
    const1_value2 = 0x3F;
}

SrsTsAdaptationField::~SrsTsAdaptationField()
{
}

srs_error_t SrsTsAdaptationField::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if (!stream->require(2)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: decode af");
    }
    adaption_field_length = stream->read_1bytes();
    
    // When the adaptation_field_control value is '11', the value of the adaptation_field_length shall
    // be in the range 0 to 182.
    if (packet->adaption_field_control == SrsTsAdaptationFieldTypeBoth && adaption_field_length > 182) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: demux af length failed, must in [0, 182], actual=%d", adaption_field_length);
    }
    // When the adaptation_field_control value is '10', the value of the adaptation_field_length shall
    // be 183.
    if (packet->adaption_field_control == SrsTsAdaptationFieldTypeAdaptionOnly && adaption_field_length != 183) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: demux af length failed, must be 183, actual=%d", adaption_field_length);
    }
    
    // no adaptation field.
    if (adaption_field_length == 0) {
        srs_info("ts: demux af empty.");
        return err;
    }
    
    // the adaptation field start at here.
    int pos_af = stream->pos();
    int8_t tmpv = stream->read_1bytes();
    
    discontinuity_indicator = (tmpv >> 7) & 0x01;
    random_access_indicator = (tmpv >> 6) & 0x01;
    elementary_stream_priority_indicator = (tmpv >> 5) & 0x01;
    PCR_flag = (tmpv >> 4) & 0x01;
    OPCR_flag = (tmpv >> 3) & 0x01;
    splicing_point_flag = (tmpv >> 2) & 0x01;
    transport_private_data_flag = (tmpv >> 1) & 0x01;
    adaptation_field_extension_flag = tmpv & 0x01;
    
    if (PCR_flag) {
        if (!stream->require(6)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: demux af PCR_flag");
        }
        
        char* pp = NULL;
        char* p = stream->data() + stream->pos();
        stream->skip(6);
        
        int64_t pcrv = 0;
        pp = (char*)&pcrv;
        pp[5] = *p++;
        pp[4] = *p++;
        pp[3] = *p++;
        pp[2] = *p++;
        pp[1] = *p++;
        pp[0] = *p++;
        
        // @remark, use pcr base and ignore the extension
        // @see https://github.com/ossrs/srs/issues/250#issuecomment-71349370
        program_clock_reference_extension = pcrv & 0x1ff;
        const1_value0 = (pcrv >> 9) & 0x3F;
        program_clock_reference_base = (pcrv >> 15) & 0x1ffffffffLL;
    }
    
    if (OPCR_flag) {
        if (!stream->require(6)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: demux af OPCR_flag");
        }
        
        char* pp = NULL;
        char* p = stream->data() + stream->pos();
        stream->skip(6);
        
        int64_t opcrv = 0;
        pp = (char*)&opcrv;
        pp[5] = *p++;
        pp[4] = *p++;
        pp[3] = *p++;
        pp[2] = *p++;
        pp[1] = *p++;
        pp[0] = *p++;
        
        // @remark, use pcr base and ignore the extension
        // @see https://github.com/ossrs/srs/issues/250#issuecomment-71349370
        original_program_clock_reference_extension = opcrv & 0x1ff;
        const1_value2 = (opcrv >> 9) & 0x3F;
        original_program_clock_reference_base = (opcrv >> 15) & 0x1ffffffffLL;
    }
    
    if (splicing_point_flag) {
        if (!stream->require(1)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: demux af splicing_point_flag");
        }
        splice_countdown = stream->read_1bytes();
    }
    
    if (transport_private_data_flag) {
        if (!stream->require(1)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: demux af transport_private_data_flag");
        }
        /**
         * The transport_private_data_length is an 8-bit field specifying the number of
         * private_data bytes immediately following the transport private_data_length field. The number of private_data bytes shall
         * not be such that private data extends beyond the adaptation field.
         */
        uint8_t transport_private_data_length = (uint8_t)stream->read_1bytes();
        
        if (transport_private_data_length > 0) {
            if (!stream->require(transport_private_data_length)) {
                return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: demux af transport_private_data");
            }
            transport_private_data.resize(transport_private_data_length);
            stream->read_bytes(&transport_private_data[0], transport_private_data_length);
        }
    }
    
    if (adaptation_field_extension_flag) {
        int pos_af_ext = stream->pos();
        
        if (!stream->require(2)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: demux af adaptation_field_extension_flag");
        }
        adaptation_field_extension_length = (uint8_t)stream->read_1bytes();
        int8_t ltwfv = stream->read_1bytes();
        
        piecewise_rate_flag = (ltwfv >> 6) & 0x01;
        seamless_splice_flag = (ltwfv >> 5) & 0x01;
        ltw_flag = (ltwfv >> 7) & 0x01;
        const1_value1 = ltwfv & 0x1F;
        
        if (ltw_flag) {
            if (!stream->require(2)) {
                return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: demux af ltw_flag");
            }
            ltw_offset = stream->read_2bytes();
            
            ltw_valid_flag = (ltw_offset >> 15) &0x01;
            ltw_offset &= 0x7FFF;
        }
        
        if (piecewise_rate_flag) {
            if (!stream->require(3)) {
                return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: demux af piecewise_rate_flag");
            }
            piecewise_rate = stream->read_3bytes();
            
            piecewise_rate &= 0x3FFFFF;
        }
        
        if (seamless_splice_flag) {
            if (!stream->require(5)) {
                return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: demux af seamless_splice_flag");
            }
            marker_bit0 = stream->read_1bytes();
            DTS_next_AU1 = stream->read_2bytes();
            DTS_next_AU2 = stream->read_2bytes();
            
            splice_type = (marker_bit0 >> 4) & 0x0F;
            DTS_next_AU0 = (marker_bit0 >> 1) & 0x07;
            marker_bit0 &= 0x01;
            
            marker_bit1 = DTS_next_AU1 & 0x01;
            DTS_next_AU1 = (DTS_next_AU1 >> 1) & 0x7FFF;
            
            marker_bit2 = DTS_next_AU2 & 0x01;
            DTS_next_AU2 = (DTS_next_AU2 >> 1) & 0x7FFF;
        }
        
        nb_af_ext_reserved = adaptation_field_extension_length - (stream->pos() - pos_af_ext);
        stream->skip(nb_af_ext_reserved);
    }
    
    nb_af_reserved = adaption_field_length - (stream->pos() - pos_af);
    stream->skip(nb_af_reserved);
    
    srs_info("ts: af parsed, discontinuity=%d random=%d priority=%d PCR=%d OPCR=%d slicing=%d private=%d extension=%d/%d pcr=%" PRId64 "/%d opcr=%" PRId64 "/%d",
             discontinuity_indicator, random_access_indicator, elementary_stream_priority_indicator, PCR_flag, OPCR_flag, splicing_point_flag,
             transport_private_data_flag, adaptation_field_extension_flag, adaptation_field_extension_length, program_clock_reference_base,
             program_clock_reference_extension, original_program_clock_reference_base, original_program_clock_reference_extension);
    
    return err;
}

int SrsTsAdaptationField::size()
{
    int sz = 2;
    
    sz += PCR_flag? 6 : 0;
    sz += OPCR_flag? 6 : 0;
    sz += splicing_point_flag? 1 : 0;
    sz += transport_private_data_flag ? 1 + transport_private_data.size() : 0;
    sz += adaptation_field_extension_flag? 2 + adaptation_field_extension_length : 0;
    sz += nb_af_ext_reserved;
    sz += nb_af_reserved;
    
    adaption_field_length = sz - 1;
    
    return sz;
}

srs_error_t SrsTsAdaptationField::encode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if (!stream->require(2)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: mux af");
    }
    stream->write_1bytes(adaption_field_length);
    
    // When the adaptation_field_control value is '11', the value of the adaptation_field_length shall
    // be in the range 0 to 182.
    if (packet->adaption_field_control == SrsTsAdaptationFieldTypeBoth && adaption_field_length > 182) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: mux af length failed, must in [0, 182], actual=%d", adaption_field_length);
    }
    // When the adaptation_field_control value is '10', the value of the adaptation_field_length shall
    // be 183.
    if (packet->adaption_field_control == SrsTsAdaptationFieldTypeAdaptionOnly && adaption_field_length != 183) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: mux af length failed, must be 183, actual=%d", adaption_field_length);
    }
    
    // no adaptation field.
    if (adaption_field_length == 0) {
        srs_info("ts: mux af empty.");
        return err;
    }
    int8_t tmpv = adaptation_field_extension_flag & 0x01;
    tmpv |= (discontinuity_indicator << 7) & 0x80;
    tmpv |= (random_access_indicator << 6) & 0x40;
    tmpv |= (elementary_stream_priority_indicator << 5) & 0x20;
    tmpv |= (PCR_flag << 4) & 0x10;
    tmpv |= (OPCR_flag << 3) & 0x08;
    tmpv |= (splicing_point_flag << 2) & 0x04;
    tmpv |= (transport_private_data_flag << 1) & 0x02;
    stream->write_1bytes(tmpv);
    
    if (PCR_flag) {
        if (!stream->require(6)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: mux af PCR_flag");
        }
        
        char* pp = NULL;
        char* p = stream->data() + stream->pos();
        stream->skip(6);
        
        // @remark, use pcr base and ignore the extension
        // @see https://github.com/ossrs/srs/issues/250#issuecomment-71349370
        int64_t pcrv = program_clock_reference_extension & 0x1ff;
        pcrv |= (const1_value0 << 9) & 0x7E00;
        pcrv |= (program_clock_reference_base << 15) & 0xFFFFFFFF8000LL;
        
        pp = (char*)&pcrv;
        *p++ = pp[5];
        *p++ = pp[4];
        *p++ = pp[3];
        *p++ = pp[2];
        *p++ = pp[1];
        *p++ = pp[0];
    }
    
    if (OPCR_flag) {
        if (!stream->require(6)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: mux af OPCR_flag");
        }
        stream->skip(6);
        srs_warn("ts: mux af ignore OPCR");
    }
    
    if (splicing_point_flag) {
        if (!stream->require(1)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: mux af splicing_point_flag");
        }
        stream->write_1bytes(splice_countdown);
    }
    
    if (transport_private_data_flag) {
        if (!stream->require(1)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: mux af transport_private_data_flag");
        }
        stream->write_1bytes(transport_private_data.size());
        
        if (!transport_private_data.empty()) {
            if (!stream->require((int)transport_private_data.size())) {
                return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: mux af transport_private_data");
            }
            stream->write_bytes(&transport_private_data[0], (int)transport_private_data.size());
        }
    }
    
    if (adaptation_field_extension_flag) {
        if (!stream->require(2)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: mux af adaptation_field_extension_flag");
        }
        stream->write_1bytes(adaptation_field_extension_length);
        int8_t ltwfv = const1_value1 & 0x1F;
        ltwfv |= (ltw_flag << 7) & 0x80;
        ltwfv |= (piecewise_rate_flag << 6) & 0x40;
        ltwfv |= (seamless_splice_flag << 5) & 0x20;
        stream->write_1bytes(ltwfv);
        
        if (ltw_flag) {
            if (!stream->require(2)) {
                return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: mux af ltw_flag");
            }
            stream->skip(2);
            srs_warn("ts: mux af ignore ltw");
        }
        
        if (piecewise_rate_flag) {
            if (!stream->require(3)) {
                return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: mux af piecewise_rate_flag");
            }
            stream->skip(3);
            srs_warn("ts: mux af ignore piecewise_rate");
        }
        
        if (seamless_splice_flag) {
            if (!stream->require(5)) {
                return srs_error_new(ERROR_STREAM_CASTER_TS_AF, "ts: mux af seamless_splice_flag");
            }
            stream->skip(5);
            srs_warn("ts: mux af ignore seamless_splice");
        }
        
        if (nb_af_ext_reserved) {
            stream->skip(nb_af_ext_reserved);
        }
    }
    
    if (nb_af_reserved) {
        stream->skip(nb_af_reserved);
    }
    
    srs_info("ts: af parsed, discontinuity=%d random=%d priority=%d PCR=%d OPCR=%d slicing=%d private=%d extension=%d/%d pcr=%" PRId64 "/%d opcr=%" PRId64 "/%d",
             discontinuity_indicator, random_access_indicator, elementary_stream_priority_indicator, PCR_flag, OPCR_flag, splicing_point_flag,
             transport_private_data_flag, adaptation_field_extension_flag, adaptation_field_extension_length, program_clock_reference_base,
             program_clock_reference_extension, original_program_clock_reference_base, original_program_clock_reference_extension);
    
    return err;
}

SrsTsPayload::SrsTsPayload(SrsTsPacket* p)
{
    packet = p;
}

SrsTsPayload::~SrsTsPayload()
{
}

SrsTsPayloadPES::SrsTsPayloadPES(SrsTsPacket* p) : SrsTsPayload(p)
{
    nb_stuffings = 0;
    nb_bytes = 0;
    nb_paddings = 0;
    const2bits = 0x02;
    const1_value0 = 0x07;
}

SrsTsPayloadPES::~SrsTsPayloadPES()
{
}

srs_error_t SrsTsPayloadPES::decode(SrsBuffer* stream, SrsTsMessage** ppmsg)
{
    srs_error_t err = srs_success;
    
    // find the channel from chunk.
    SrsTsChannel* channel = packet->context->get(packet->pid);
    if (!channel) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: demux PES no channel for pid=%#x", packet->pid);
    }
    
    // init msg.
    SrsTsMessage* msg = channel->msg;
    if (!msg) {
        msg = new SrsTsMessage(channel, packet);
        channel->msg = msg;
    }
    
    // we must cache the fresh state of msg,
    // for the PES_packet_length is 0, the first payload_unit_start_indicator always 1,
    // so should check for the fresh and not completed it.
    bool is_fresh_msg = msg->fresh();
    
    // check when fresh, the payload_unit_start_indicator
    // should be 1 for the fresh msg.
    if (is_fresh_msg && !packet->payload_unit_start_indicator) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: PES fresh packet length=%d, us=%d, cc=%d",
            msg->PES_packet_length, packet->payload_unit_start_indicator, packet->continuity_counter);
    }
    
    // check when not fresh and PES_packet_length>0,
    // the payload_unit_start_indicator should never be 1 when not completed.
    if (!is_fresh_msg && msg->PES_packet_length > 0 && !msg->completed(packet->payload_unit_start_indicator) && packet->payload_unit_start_indicator) {
        srs_warn("ts: ignore PES packet length=%d, payload=%d, us=%d, cc=%d",
            msg->PES_packet_length, msg->payload->length(), packet->payload_unit_start_indicator, packet->continuity_counter);
        
        // reparse current msg.
        stream->skip(stream->pos() * -1);
        srs_freep(msg);
        channel->msg = NULL;
        return err;
    }
    
    // check the continuity counter
    if (!is_fresh_msg) {
        // late-incoming or duplicated continuity, drop message.
        // @remark check overflow, the counter plus 1 should greater when invalid.
        if (msg->continuity_counter >= packet->continuity_counter && ((msg->continuity_counter + 1) & 0x0f) > packet->continuity_counter) {
            srs_warn("ts: drop PES %dB for duplicated cc=%#x", msg->continuity_counter);
            stream->skip(stream->size() - stream->pos());
            return err;
        }
        
        // when got partially message, the continous count must be continuous, or drop it.
        if (((msg->continuity_counter + 1) & 0x0f) != packet->continuity_counter) {
            srs_warn("ts: ignore continuity must be continous, msg=%#x, packet=%#x", msg->continuity_counter, packet->continuity_counter);
            
            // reparse current msg.
            stream->skip(stream->pos() * -1);
            srs_freep(msg);
            channel->msg = NULL;
            return err;
        }
    }
    msg->continuity_counter = packet->continuity_counter;
    
    // for the PES_packet_length(0), reap when completed.
    if (!is_fresh_msg && msg->completed(packet->payload_unit_start_indicator)) {
        // reap previous PES packet.
        *ppmsg = msg;
        channel->msg = NULL;
        
        // reparse current msg.
        stream->skip(stream->pos() * -1);
        return err;
    }
    
    // contious packet, append bytes for unit start is 0
    if (!packet->payload_unit_start_indicator) {
        if ((err = msg->dump(stream, &nb_bytes)) != srs_success) {
            return srs_error_wrap(err, "ts: pes dump");
        }
    }
    
    // when unit start, parse the fresh msg.
    if (packet->payload_unit_start_indicator) {
        // 6B fixed header.
        if (!stream->require(6)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: demux PSE");
        }
        // 3B
        packet_start_code_prefix = stream->read_3bytes();
        // 1B
        stream_id = stream->read_1bytes();
        // 2B
        PES_packet_length = stream->read_2bytes();
        
        // check the packet start prefix.
        packet_start_code_prefix &= 0xFFFFFF;
        if (packet_start_code_prefix != 0x01) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: demux PES start code failed, expect=0x01, actual=%#x", packet_start_code_prefix);
        }
        int pos_packet = stream->pos();
        
        // @remark the sid indicates the elementary stream format.
        //      the SrsTsPESStreamIdAudio and SrsTsPESStreamIdVideo is start by 0b110 or 0b1110
        SrsTsPESStreamId sid = (SrsTsPESStreamId)stream_id;
        msg->sid = sid;
        
        if (sid != SrsTsPESStreamIdProgramStreamMap
            && sid != SrsTsPESStreamIdPaddingStream
            && sid != SrsTsPESStreamIdPrivateStream2
            && sid != SrsTsPESStreamIdEcmStream
            && sid != SrsTsPESStreamIdEmmStream
            && sid != SrsTsPESStreamIdProgramStreamDirectory
            && sid != SrsTsPESStreamIdDsmccStream
            && sid != SrsTsPESStreamIdH2221TypeE
            ) {
            // 3B flags.
            if (!stream->require(3)) {
                return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: demux PSE flags");
            }
            // 1B
            int8_t oocv = stream->read_1bytes();
            // 1B
            int8_t pefv = stream->read_1bytes();
            // 1B
            PES_header_data_length = stream->read_1bytes();
            // position of header start.
            int pos_header = stream->pos();
            
            const2bits = (oocv >> 6) & 0x03;
            PES_scrambling_control = (oocv >> 4) & 0x03;
            PES_priority = (oocv >> 3) & 0x01;
            data_alignment_indicator = (oocv >> 2) & 0x01;
            copyright = (oocv >> 1) & 0x01;
            original_or_copy = oocv & 0x01;
            
            PTS_DTS_flags = (pefv >> 6) & 0x03;
            ESCR_flag = (pefv >> 5) & 0x01;
            ES_rate_flag = (pefv >> 4) & 0x01;
            DSM_trick_mode_flag = (pefv >> 3) & 0x01;
            additional_copy_info_flag = (pefv >> 2) & 0x01;
            PES_CRC_flag = (pefv >> 1) & 0x01;
            PES_extension_flag = pefv & 0x01;
            
            // check required together.
            int nb_required = 0;
            nb_required += (PTS_DTS_flags == 0x2)? 5:0;
            nb_required += (PTS_DTS_flags == 0x3)? 10:0;
            nb_required += ESCR_flag? 6:0;
            nb_required += ES_rate_flag? 3:0;
            nb_required += DSM_trick_mode_flag? 1:0;
            nb_required += additional_copy_info_flag? 1:0;
            nb_required += PES_CRC_flag? 2:0;
            nb_required += PES_extension_flag? 1:0;
            if (!stream->require(nb_required)) {
                return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: demux PSE payload");
            }
            
            // 5B
            if (PTS_DTS_flags == 0x2) {
                if ((err = decode_33bits_dts_pts(stream, &pts)) != srs_success) {
                    return srs_error_wrap(err, "dts/pts");
                }
                dts = pts;
                
                // update the dts and pts of message.
                msg->dts = dts;
                msg->pts = pts;
            }
            
            // 10B
            if (PTS_DTS_flags == 0x3) {
                if ((err = decode_33bits_dts_pts(stream, &pts)) != srs_success) {
                    return srs_error_wrap(err, "dts/pts");
                }
                if ((err = decode_33bits_dts_pts(stream, &dts)) != srs_success) {
                    return srs_error_wrap(err, "dts/pts");
                }
                
                // check sync, the diff of dts and pts should never greater than 1s.
                if (dts - pts > 90000 || pts - dts > 90000) {
                    srs_warn("ts: sync dts=%" PRId64 ", pts=%" PRId64, dts, pts);
                }
                
                // update the dts and pts of message.
                msg->dts = dts;
                msg->pts = pts;
            }
            
            // 6B
            if (ESCR_flag) {
                ESCR_extension = 0;
                ESCR_base = 0;
                
                stream->skip(6);
                srs_warn("ts: demux PES, ignore the escr.");
            }
            
            // 3B
            if (ES_rate_flag) {
                ES_rate = stream->read_3bytes();
                
                ES_rate = ES_rate >> 1;
                ES_rate &= 0x3FFFFF;
            }
            
            // 1B
            if (DSM_trick_mode_flag) {
                trick_mode_control = stream->read_1bytes();
                
                trick_mode_value = trick_mode_control & 0x1f;
                trick_mode_control = (trick_mode_control >> 5) & 0x03;
            }
            
            // 1B
            if (additional_copy_info_flag) {
                additional_copy_info = stream->read_1bytes();
                
                additional_copy_info &= 0x7f;
            }
            
            // 2B
            if (PES_CRC_flag) {
                previous_PES_packet_CRC = stream->read_2bytes();
            }
            
            // 1B
            if (PES_extension_flag) {
                int8_t efv = stream->read_1bytes();
                
                PES_private_data_flag = (efv >> 7) & 0x01;
                pack_header_field_flag = (efv >> 6) & 0x01;
                program_packet_sequence_counter_flag = (efv >> 5) & 0x01;
                P_STD_buffer_flag = (efv >> 4) & 0x01;
                const1_value0 = (efv >> 1) & 0x07;
                PES_extension_flag_2 = efv & 0x01;
                
                nb_required = 0;
                nb_required += PES_private_data_flag? 16:0;
                nb_required += pack_header_field_flag? 1:0; // 1+x bytes.
                nb_required += program_packet_sequence_counter_flag? 2:0;
                nb_required += P_STD_buffer_flag? 2:0;
                nb_required += PES_extension_flag_2? 1:0; // 1+x bytes.
                if (!stream->require(nb_required)) {
                    return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: demux PSE ext payload");
                }
                
                // 16B
                if (PES_private_data_flag) {
                    PES_private_data.resize(16);
                    stream->read_bytes(&PES_private_data[0], 16);
                }
                
                // (1+x)B
                if (pack_header_field_flag) {
                    // This is an 8-bit field which indicates the length, in bytes, of the pack_header_field()
                    uint8_t pack_field_length = stream->read_1bytes();
                    if (pack_field_length > 0) {
                        // the adjust required bytes.
                        nb_required = nb_required - 16 - 1 + pack_field_length;
                        if (!stream->require(nb_required)) {
                            return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: demux PSE ext pack");
                        }
                        pack_field.resize(pack_field_length);
                        stream->read_bytes(&pack_field[0], pack_field_length);
                    }
                }
                
                // 2B
                if (program_packet_sequence_counter_flag) {
                    program_packet_sequence_counter = stream->read_1bytes();
                    program_packet_sequence_counter &= 0x7f;
                    
                    original_stuff_length = stream->read_1bytes();
                    MPEG1_MPEG2_identifier = (original_stuff_length >> 6) & 0x01;
                    original_stuff_length &= 0x3f;
                }
                
                // 2B
                if (P_STD_buffer_flag) {
                    P_STD_buffer_size = stream->read_2bytes();
                    
                    // '01'
                    //int8_t const2bits = (P_STD_buffer_scale >>14) & 0x03;
                    
                    P_STD_buffer_scale = (P_STD_buffer_scale >>13) & 0x01;
                    P_STD_buffer_size &= 0x1FFF;
                }
                
                // (1+x)B
                if (PES_extension_flag_2) {
                    /**
                     * This is a 7-bit field which specifies the length, in bytes, of the data following this field in
                     * the PES extension field up to and including any reserved bytes.
                     */
                    uint8_t PES_extension_field_length = stream->read_1bytes();
                    PES_extension_field_length &= 0x7F;
                    
                    if (PES_extension_field_length > 0) {
                        if (!stream->require(PES_extension_field_length)) {
                            return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: demux PSE ext field");
                        }
                        PES_extension_field.resize(PES_extension_field_length);
                        stream->read_bytes(&PES_extension_field[0], PES_extension_field_length);
                    }
                }
            }
            
            // stuffing_byte
            nb_stuffings = PES_header_data_length - (stream->pos() - pos_header);
            if (nb_stuffings > 0) {
                if (!stream->require(nb_stuffings)) {
                    return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: demux PSE stuffings");
                }
                stream->skip(nb_stuffings);
            }
            
            // PES_packet_data_byte, page58.
            // the packet size contains the header size.
            // The number of PES_packet_data_bytes, N, is specified by the
            // PES_packet_length field. N shall be equal to the value
            // indicated in the PES_packet_length minus the number of bytes
            // between the last byte of the PES_packet_length field and the
            // first PES_packet_data_byte.
            /**
             * when actual packet length > 0xffff(65535),
             * which exceed the max uint16_t packet length,
             * use 0 packet length, the next unit start indicates the end of packet.
             */
            if (PES_packet_length > 0) {
                int nb_packet = PES_packet_length - (stream->pos() - pos_packet);
                msg->PES_packet_length = srs_max(0, nb_packet);
            }
            
            // xB
            if ((err = msg->dump(stream, &nb_bytes)) != srs_success) {
                return srs_error_wrap(err, "dump pes");
            }
        } else if (sid == SrsTsPESStreamIdProgramStreamMap
                   || sid == SrsTsPESStreamIdPrivateStream2
                   || sid == SrsTsPESStreamIdEcmStream
                   || sid == SrsTsPESStreamIdEmmStream
                   || sid == SrsTsPESStreamIdProgramStreamDirectory
                   || sid == SrsTsPESStreamIdDsmccStream
                   || sid == SrsTsPESStreamIdH2221TypeE
                   ) {
            // for (i = 0; i < PES_packet_length; i++) {
            //         PES_packet_data_byte
            // }
            
            // xB
            if ((err = msg->dump(stream, &nb_bytes)) != srs_success) {
                return srs_error_wrap(err, "dump packet");
            }
        } else if (sid == SrsTsPESStreamIdPaddingStream) {
            // for (i = 0; i < PES_packet_length; i++) {
            //         padding_byte
            // }
            nb_paddings = stream->size() - stream->pos();
            stream->skip(nb_paddings);
            srs_info("ts: drop %dB padding bytes", nb_paddings);
        } else {
            int nb_drop = stream->size() - stream->pos();
            stream->skip(nb_drop);
            srs_warn("ts: drop the pes packet %dB for stream_id=%#x", nb_drop, stream_id);
        }
    }
    
    // when fresh and the PES_packet_length is 0,
    // the payload_unit_start_indicator always be 1,
    // the message should never EOF for the first packet.
    if (is_fresh_msg && msg->PES_packet_length == 0) {
        return err;
    }
    
    // check msg, reap when completed.
    if (msg->completed(packet->payload_unit_start_indicator)) {
        *ppmsg = msg;
        channel->msg = NULL;
        srs_info("ts: reap msg for completed.");
    }
    
    return err;
}

int SrsTsPayloadPES::size()
{
    int sz = 0;
    
    PES_header_data_length = 0;
    SrsTsPESStreamId sid = (SrsTsPESStreamId)stream_id;
    
    if (sid != SrsTsPESStreamIdProgramStreamMap
        && sid != SrsTsPESStreamIdPaddingStream
        && sid != SrsTsPESStreamIdPrivateStream2
        && sid != SrsTsPESStreamIdEcmStream
        && sid != SrsTsPESStreamIdEmmStream
        && sid != SrsTsPESStreamIdProgramStreamDirectory
        && sid != SrsTsPESStreamIdDsmccStream
        && sid != SrsTsPESStreamIdH2221TypeE
        ) {
        sz += 6;
        sz += 3;
        PES_header_data_length = sz;
        
        sz += (PTS_DTS_flags == 0x2)? 5:0;
        sz += (PTS_DTS_flags == 0x3)? 10:0;
        sz += ESCR_flag? 6:0;
        sz += ES_rate_flag? 3:0;
        sz += DSM_trick_mode_flag? 1:0;
        sz += additional_copy_info_flag? 1:0;
        sz += PES_CRC_flag? 2:0;
        sz += PES_extension_flag? 1:0;
        
        if (PES_extension_flag) {
            sz += PES_private_data_flag? 16:0;
            sz += pack_header_field_flag ? 1 + pack_field.size() : 0; // 1+x bytes.
            sz += program_packet_sequence_counter_flag? 2:0;
            sz += P_STD_buffer_flag? 2:0;
            sz += PES_extension_flag_2 ? 1 + PES_extension_field.size() : 0; // 1+x bytes.
        }
        PES_header_data_length = sz - PES_header_data_length;
        
        sz += nb_stuffings;
        
        // packet bytes
    } else if (sid == SrsTsPESStreamIdProgramStreamMap
               || sid == SrsTsPESStreamIdPrivateStream2
               || sid == SrsTsPESStreamIdEcmStream
               || sid == SrsTsPESStreamIdEmmStream
               || sid == SrsTsPESStreamIdProgramStreamDirectory
               || sid == SrsTsPESStreamIdDsmccStream
               || sid == SrsTsPESStreamIdH2221TypeE
               ) {
        // packet bytes
    } else {
        // nb_drop
    }
    
    return sz;
}

srs_error_t SrsTsPayloadPES::encode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // 6B fixed header.
    if (!stream->require(6)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: mux PSE");
    }
    
    // 3B
    stream->write_3bytes(packet_start_code_prefix);
    // 1B
    stream->write_1bytes(stream_id);
    // 2B
    // the PES_packet_length is the actual bytes size, the pplv write to ts
    // is the actual bytes plus the header size.
    int32_t pplv = 0;
    if (PES_packet_length > 0) {
        pplv = PES_packet_length + 3 + PES_header_data_length;
        pplv = (pplv > 0xFFFF)? 0 : pplv;
    }
    stream->write_2bytes(pplv);
    
    // check the packet start prefix.
    packet_start_code_prefix &= 0xFFFFFF;
    if (packet_start_code_prefix != 0x01) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: mux PSE start code failed, expect=0x01, actual=%#x", packet_start_code_prefix);
    }
    
    // 3B flags.
    if (!stream->require(3)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: mux PSE flags");
    }
    // 1B
    int8_t oocv = original_or_copy & 0x01;
    oocv |= (const2bits << 6) & 0xC0;
    oocv |= (PES_scrambling_control << 4) & 0x30;
    oocv |= (PES_priority << 3) & 0x08;
    oocv |= (data_alignment_indicator << 2) & 0x04;
    oocv |= (copyright << 1) & 0x02;
    stream->write_1bytes(oocv);
    // 1B
    int8_t pefv = PES_extension_flag & 0x01;
    pefv |= (PTS_DTS_flags << 6) & 0xC0;
    pefv |= (ESCR_flag << 5) & 0x20;
    pefv |= (ES_rate_flag << 4) & 0x10;
    pefv |= (DSM_trick_mode_flag << 3) & 0x08;
    pefv |= (additional_copy_info_flag << 2) & 0x04;
    pefv |= (PES_CRC_flag << 1) & 0x02;
    stream->write_1bytes(pefv);
    // 1B
    stream->write_1bytes(PES_header_data_length);
    
    // check required together.
    int nb_required = 0;
    nb_required += (PTS_DTS_flags == 0x2)? 5:0;
    nb_required += (PTS_DTS_flags == 0x3)? 10:0;
    nb_required += ESCR_flag? 6:0;
    nb_required += ES_rate_flag? 3:0;
    nb_required += DSM_trick_mode_flag? 1:0;
    nb_required += additional_copy_info_flag? 1:0;
    nb_required += PES_CRC_flag? 2:0;
    nb_required += PES_extension_flag? 1:0;
    if (!stream->require(nb_required)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: mux PSE payload");
    }
    
    // 5B
    if (PTS_DTS_flags == 0x2) {
        if ((err = encode_33bits_dts_pts(stream, 0x02, pts)) != srs_success) {
            return srs_error_wrap(err, "dts/pts");
        }
    }
    
    // 10B
    if (PTS_DTS_flags == 0x3) {
        if ((err = encode_33bits_dts_pts(stream, 0x03, pts)) != srs_success) {
            return srs_error_wrap(err, "dts/pts");
        }
        if ((err = encode_33bits_dts_pts(stream, 0x01, dts)) != srs_success) {
            return srs_error_wrap(err, "dts/pts");
        }
        
        // check sync, the diff of dts and pts should never greater than 1s.
        if (dts - pts > 90000 || pts - dts > 90000) {
            srs_warn("ts: sync dts=%" PRId64 ", pts=%" PRId64, dts, pts);
        }
    }
    
    // 6B
    if (ESCR_flag) {
        stream->skip(6);
        srs_warn("ts: demux PES, ignore the escr.");
    }
    
    // 3B
    if (ES_rate_flag) {
        stream->skip(3);
        srs_warn("ts: demux PES, ignore the ES_rate.");
    }
    
    // 1B
    if (DSM_trick_mode_flag) {
        stream->skip(1);
        srs_warn("ts: demux PES, ignore the DSM_trick_mode.");
    }
    
    // 1B
    if (additional_copy_info_flag) {
        stream->skip(1);
        srs_warn("ts: demux PES, ignore the additional_copy_info.");
    }
    
    // 2B
    if (PES_CRC_flag) {
        stream->skip(2);
        srs_warn("ts: demux PES, ignore the PES_CRC.");
    }
    
    // 1B
    if (PES_extension_flag) {
        int8_t efv = PES_extension_flag_2 & 0x01;
        efv |= (PES_private_data_flag << 7) & 0x80;
        efv |= (pack_header_field_flag << 6) & 0x40;
        efv |= (program_packet_sequence_counter_flag << 5) & 0x20;
        efv |= (P_STD_buffer_flag << 4) & 0x10;
        efv |= (const1_value0 << 1) & 0xE0;
        stream->write_1bytes(efv);
        
        nb_required = 0;
        nb_required += PES_private_data_flag? 16:0;
        nb_required += pack_header_field_flag ? 1 + pack_field.size() : 0; // 1+x bytes.
        nb_required += program_packet_sequence_counter_flag? 2:0;
        nb_required += P_STD_buffer_flag? 2:0;
        nb_required += PES_extension_flag_2 ? 1 + PES_extension_field.size() : 0; // 1+x bytes.
        if (!stream->require(nb_required)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: mux PSE ext payload");
        }
        stream->skip(nb_required);
        srs_warn("ts: demux PES, ignore the PES_extension.");
    }
    
    // stuffing_byte
    if (nb_stuffings) {
        stream->skip(nb_stuffings);
        srs_warn("ts: demux PES, ignore the stuffings.");
    }
    
    return err;
}

srs_error_t SrsTsPayloadPES::decode_33bits_dts_pts(SrsBuffer* stream, int64_t* pv)
{
    srs_error_t err = srs_success;
    
    if (!stream->require(5)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: demux PSE dts/pts");
    }
    
    // decode the 33bits schema.
    // ===========1B
    // 4bits const maybe '0001', '0010' or '0011'.
    // 3bits DTS/PTS [32..30]
    // 1bit const '1'
    int64_t dts_pts_30_32 = stream->read_1bytes();
    if ((dts_pts_30_32 & 0x01) != 0x01) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: demux PSE dts/pts 30-32");
    }
    // @remark, we donot check the high 4bits, maybe '0001', '0010' or '0011'.
    //      so we just ensure the high 4bits is not 0x00.
    if (((dts_pts_30_32 >> 4) & 0x0f) == 0x00) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: demux PSE dts/pts 30-32");
    }
    dts_pts_30_32 = (dts_pts_30_32 >> 1) & 0x07;
    
    // ===========2B
    // 15bits DTS/PTS [29..15]
    // 1bit const '1'
    int64_t dts_pts_15_29 = stream->read_2bytes();
    if ((dts_pts_15_29 & 0x01) != 0x01) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: demux PSE dts/pts 15-29");
    }
    dts_pts_15_29 = (dts_pts_15_29 >> 1) & 0x7fff;
    
    // ===========2B
    // 15bits DTS/PTS [14..0]
    // 1bit const '1'
    int64_t dts_pts_0_14 = stream->read_2bytes();
    if ((dts_pts_0_14 & 0x01) != 0x01) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: demux PSE dts/pts 0-14");
    }
    dts_pts_0_14 = (dts_pts_0_14 >> 1) & 0x7fff;
    
    int64_t v = 0x00;
    v |= (dts_pts_30_32 << 30) & 0x1c0000000LL;
    v |= (dts_pts_15_29 << 15) & 0x3fff8000LL;
    v |= dts_pts_0_14 & 0x7fff;
    *pv = v;
    
    return err;
}

srs_error_t SrsTsPayloadPES::encode_33bits_dts_pts(SrsBuffer* stream, uint8_t fb, int64_t v)
{
    srs_error_t err = srs_success;
    
    if (!stream->require(5)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSE, "ts: mux PSE dts/pts");
    }
    
    char* p = stream->data() + stream->pos();
    stream->skip(5);
    
    int32_t val = 0;
    
    val = int32_t(fb << 4 | (((v >> 30) & 0x07) << 1) | 1);
    *p++ = val;
    
    val = int32_t((((v >> 15) & 0x7fff) << 1) | 1);
    *p++ = (val >> 8);
    *p++ = val;
    
    val = int32_t((((v) & 0x7fff) << 1) | 1);
    *p++ = (val >> 8);
    *p++ = val;
    
    return err;
}

SrsTsPayloadPSI::SrsTsPayloadPSI(SrsTsPacket* p) : SrsTsPayload(p)
{
    pointer_field = 0;
    const0_value = 0;
    const1_value = 3;
    CRC_32 = 0;
}

SrsTsPayloadPSI::~SrsTsPayloadPSI()
{
}

srs_error_t SrsTsPayloadPSI::decode(SrsBuffer* stream, SrsTsMessage** /*ppmsg*/)
{
    srs_error_t err = srs_success;
    
    /**
     * When the payload of the Transport Stream packet contains PSI data, the payload_unit_start_indicator has the following
     * significance: if the Transport Stream packet carries the first byte of a PSI section, the payload_unit_start_indicator value
     * shall be '1', indicating that the first byte of the payload of this Transport Stream packet carries the pointer_field. If the
     * Transport Stream packet does not carry the first byte of a PSI section, the payload_unit_start_indicator value shall be '0',
     * indicating that there is no pointer_field in the payload. Refer to 2.4.4.1 and 2.4.4.2. This also applies to private streams of
     * stream_type 5 (refer to Table 2-29).
     */
    if (packet->payload_unit_start_indicator) {
        if (!stream->require(1)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_PSI, "ts: demux PSI");
        }
        pointer_field = stream->read_1bytes();
    }
    
    // to calc the crc32
    char* ppat = stream->data() + stream->pos();
    int pat_pos = stream->pos();
    
    // atleast 3B for all psi.
    if (!stream->require(3)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSI, "ts: demux PSI");
    }
    // 1B
    table_id = (SrsTsPsiId)stream->read_1bytes();
    
    // 2B
    int16_t slv = stream->read_2bytes();
    
    section_syntax_indicator = (slv >> 15) & 0x01;
    const0_value = (slv >> 14) & 0x01;
    const1_value = (slv >> 12) & 0x03;
    section_length = slv & 0x0FFF;
    
    // no section, ignore.
    if (section_length == 0) {
        srs_warn("ts: demux PAT ignore empty section");
        return err;
    }
    
    if (!stream->require(section_length)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSI, "ts: demux PSI section");
    }
    
    // call the virtual method of actual PSI.
    if ((err = psi_decode(stream)) != srs_success) {
        return srs_error_wrap(err, "demux PSI");
    }
    
    // 4B
    if (!stream->require(4)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSI, "ts: demux PSI crc32");
    }
    CRC_32 = stream->read_4bytes();
    
    // verify crc32.
    int32_t crc32 = srs_crc32_mpegts(ppat, stream->pos() - pat_pos - 4);
    if (crc32 != CRC_32) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSI, "ts: verify PSI crc32");
    }
    
    // consume left stuffings
    if (!stream->empty()) {
        int nb_stuffings = stream->size() - stream->pos();
        char* stuffing = stream->data() + stream->pos();
        
        // all stuffing must be 0xff.
        // TODO: FIXME: maybe need to remove the following.
        for (int i = 0; i < nb_stuffings; i++) {
            if ((uint8_t)stuffing[i] != 0xff) {
                srs_warn("ts: stuff is not 0xff, actual=%#x", stuffing[i]);
                break;
            }
        }
        
        stream->skip(nb_stuffings);
    }
    
    return err;
}

int SrsTsPayloadPSI::size()
{
    int sz = 0;
    
    // section size is the sl plus the crc32
    section_length = psi_size() + 4;
    
    sz += packet->payload_unit_start_indicator? 1:0;
    sz += 3;
    sz += section_length;
    
    return sz;
}

srs_error_t SrsTsPayloadPSI::encode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if (packet->payload_unit_start_indicator) {
        if (!stream->require(1)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_PSI, "ts: mux PSI");
        }
        stream->write_1bytes(pointer_field);
    }
    
    // to calc the crc32
    char* ppat = stream->data() + stream->pos();
    int pat_pos = stream->pos();
    
    // atleast 3B for all psi.
    if (!stream->require(3)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSI, "ts: mux PSI");
    }
    // 1B
    stream->write_1bytes(table_id);
    
    // 2B
    int16_t slv = section_length & 0x0FFF;
    slv |= (section_syntax_indicator << 15) & 0x8000;
    slv |= (const0_value << 14) & 0x4000;
    slv |= (const1_value << 12) & 0x3000;
    stream->write_2bytes(slv);
    
    // no section, ignore.
    if (section_length == 0) {
        srs_warn("ts: mux PAT ignore empty section");
        return err;
    }
    
    if (!stream->require(section_length)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSI, "ts: mux PSI section");
    }
    
    // call the virtual method of actual PSI.
    if ((err = psi_encode(stream)) != srs_success) {
        return srs_error_wrap(err, "mux PSI");
    }
    
    // 4B
    if (!stream->require(4)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PSI, "ts: mux PSI crc32");
    }
    CRC_32 = srs_crc32_mpegts(ppat, stream->pos() - pat_pos);
    stream->write_4bytes(CRC_32);
    
    return err;
}

SrsTsPayloadPATProgram::SrsTsPayloadPATProgram(int16_t n, int16_t p)
{
    number = n;
    pid = p;
    const1_value = 0x07;
}

SrsTsPayloadPATProgram::~SrsTsPayloadPATProgram()
{
}

srs_error_t SrsTsPayloadPATProgram::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // atleast 4B for PAT program specified
    if (!stream->require(4)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PAT, "ts: demux PAT");
    }
    
    int tmpv = stream->read_4bytes();
    number = (int16_t)((tmpv >> 16) & 0xFFFF);
    const1_value = (int16_t)((tmpv >> 13) & 0x07);
    pid = (int16_t)(tmpv & 0x1FFF);
    
    return err;
}

int SrsTsPayloadPATProgram::size()
{
    return 4;
}

srs_error_t SrsTsPayloadPATProgram::encode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // atleast 4B for PAT program specified
    if (!stream->require(4)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PAT, "ts: mux PAT");
    }
    
    int tmpv = pid & 0x1FFF;
    tmpv |= (number << 16) & 0xFFFF0000;
    tmpv |= (const1_value << 13) & 0xE000;
    stream->write_4bytes(tmpv);
    
    return err;
}

SrsTsPayloadPAT::SrsTsPayloadPAT(SrsTsPacket* p) : SrsTsPayloadPSI(p)
{
    const3_value = 3;
}

SrsTsPayloadPAT::~SrsTsPayloadPAT()
{
    std::vector<SrsTsPayloadPATProgram*>::iterator it;
    for (it = programs.begin(); it != programs.end(); ++it) {
        SrsTsPayloadPATProgram* program = *it;
        srs_freep(program);
    }
    programs.clear();
}

srs_error_t SrsTsPayloadPAT::psi_decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // atleast 5B for PAT specified
    if (!stream->require(5)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PAT, "ts: demux PAT");
    }
    
    int pos = stream->pos();
    
    // 2B
    transport_stream_id = stream->read_2bytes();
    
    // 1B
    int8_t cniv = stream->read_1bytes();
    
    const3_value = (cniv >> 6) & 0x03;
    version_number = (cniv >> 1) & 0x1F;
    current_next_indicator = cniv & 0x01;
    
    // TODO: FIXME: check the indicator.
    
    // 1B
    section_number = stream->read_1bytes();
    // 1B
    last_section_number = stream->read_1bytes();
    
    // multiple 4B program data.
    int program_bytes = section_length - 4 - (stream->pos() - pos);
    for (int i = 0; i < program_bytes; i += 4) {
        SrsTsPayloadPATProgram* program = new SrsTsPayloadPATProgram();
        
        if ((err = program->decode(stream)) != srs_success) {
            return srs_error_wrap(err, "demux PAT program");
        }
        
        // update the apply pid table.
        packet->context->set(program->pid, SrsTsPidApplyPMT);
        
        programs.push_back(program);
    }
    
    // update the apply pid table.
    packet->context->set(packet->pid, SrsTsPidApplyPAT);
    packet->context->on_pmt_parsed();
    
    return err;
}

int SrsTsPayloadPAT::psi_size()
{
    int sz = 5;
    for (int i = 0; i < (int)programs.size(); i ++) {
        SrsTsPayloadPATProgram* program = programs.at(i);
        sz += program->size();
    }
    return sz;
}

srs_error_t SrsTsPayloadPAT::psi_encode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // atleast 5B for PAT specified
    if (!stream->require(5)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PAT, "ts: mux PAT");
    }
    
    // 2B
    stream->write_2bytes(transport_stream_id);
    
    // 1B
    int8_t cniv = current_next_indicator & 0x01;
    cniv |= (version_number << 1) & 0x3E;
    cniv |= (const1_value << 6) & 0xC0;
    stream->write_1bytes(cniv);
    
    // 1B
    stream->write_1bytes(section_number);
    // 1B
    stream->write_1bytes(last_section_number);
    
    // multiple 4B program data.
    for (int i = 0; i < (int)programs.size(); i ++) {
        SrsTsPayloadPATProgram* program = programs.at(i);
        if ((err = program->encode(stream)) != srs_success) {
            return srs_error_wrap(err, "mux PAT program");
        }
        
        // update the apply pid table.
        packet->context->set(program->pid, SrsTsPidApplyPMT);
    }
    
    // update the apply pid table.
    packet->context->set(packet->pid, SrsTsPidApplyPAT);
    
    return err;
}

SrsTsPayloadPMTESInfo::SrsTsPayloadPMTESInfo(SrsTsStream st, int16_t epid)
{
    stream_type = st;
    elementary_PID = epid;
    
    const1_value0 = 7;
    const1_value1 = 0x0f;
}

SrsTsPayloadPMTESInfo::~SrsTsPayloadPMTESInfo()
{
}

srs_error_t SrsTsPayloadPMTESInfo::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // 5B
    if (!stream->require(5)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PMT, "ts: demux PMT");
    }
    
    stream_type = (SrsTsStream)stream->read_1bytes();
    
    int16_t epv = stream->read_2bytes();
    const1_value0 = (epv >> 13) & 0x07;
    elementary_PID = epv & 0x1FFF;
    
    int16_t eilv = stream->read_2bytes();
    const1_value1 = (eilv >> 12) & 0x0f;
    /**
     * This is a 12-bit field, the first two bits of which shall be '00'. The remaining 10 bits specify the number
     * of bytes of the descriptors of the associated program element immediately following the ES_info_length field.
     */
    int16_t ES_info_length = eilv & 0x0FFF;
    
    if (ES_info_length > 0) {
        if (!stream->require(ES_info_length)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_PMT, "ts: demux PMT ES_info");
        }
        ES_info.resize(ES_info_length);
        stream->read_bytes(&ES_info[0], ES_info_length);
    }
    
    return err;
}

int SrsTsPayloadPMTESInfo::size()
{
    return 5 + (int)ES_info.size();
}

srs_error_t SrsTsPayloadPMTESInfo::encode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // 5B
    if (!stream->require(5)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PMT, "ts: mux PMT");
    }
    
    stream->write_1bytes(stream_type);
    
    int16_t epv = elementary_PID & 0x1FFF;
    epv |= (const1_value0 << 13) & 0xE000;
    stream->write_2bytes(epv);
    
    int16_t eilv = ES_info.size() & 0x0FFF;
    eilv |= (const1_value1 << 12) & 0xF000;
    stream->write_2bytes(eilv);
    
    if (!ES_info.empty()) {
        if (!stream->require((int)ES_info.size())) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_PMT, "ts: mux PMT ES_info");
        }
        stream->write_bytes(&ES_info[0], (int)ES_info.size());
    }
    
    return err;
}

SrsTsPayloadPMT::SrsTsPayloadPMT(SrsTsPacket* p) : SrsTsPayloadPSI(p)
{
    const1_value0 = 3;
    const1_value1 = 7;
    const1_value2 = 0x0f;
}

SrsTsPayloadPMT::~SrsTsPayloadPMT()
{
    std::vector<SrsTsPayloadPMTESInfo*>::iterator it;
    for (it = infos.begin(); it != infos.end(); ++it) {
        SrsTsPayloadPMTESInfo* info = *it;
        srs_freep(info);
    }
    infos.clear();
}

srs_error_t SrsTsPayloadPMT::psi_decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // atleast 9B for PMT specified
    if (!stream->require(9)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PMT, "ts: demux PMT");
    }
    
    // 2B
    program_number = stream->read_2bytes();
    
    // 1B
    int8_t cniv = stream->read_1bytes();
    
    const1_value0 = (cniv >> 6) & 0x03;
    version_number = (cniv >> 1) & 0x1F;
    current_next_indicator = cniv & 0x01;
    
    // 1B
    section_number = stream->read_1bytes();
    
    // 1B
    last_section_number = stream->read_1bytes();
    
    // 2B
    int16_t ppv = stream->read_2bytes();
    const1_value1 = (ppv >> 13) & 0x07;
    PCR_PID = ppv & 0x1FFF;
    
    // 2B
    int16_t pilv = stream->read_2bytes();
    const1_value2 = (pilv >> 12) & 0x0F;
    /**
     * This is a 12-bit field, the first two bits of which shall be '00'. The remaining 10 bits specify the
     * number of bytes of the descriptors immediately following the program_info_length field.
     */
    uint16_t program_info_length = pilv & 0xFFF;
    
    if (program_info_length > 0) {
        if (!stream->require(program_info_length)) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_PMT, "ts: demux PMT program info");
        }
        
        program_info_desc.resize(program_info_length);
        stream->read_bytes(&program_info_desc[0], program_info_length);
    }
    
    // [section_length] - 4(CRC) - 9B - [program_info_length]
    int ES_EOF_pos = stream->pos() + section_length - 4 - 9 - program_info_length;
    while (stream->pos() < ES_EOF_pos) {
        SrsTsPayloadPMTESInfo* info = new SrsTsPayloadPMTESInfo();
        infos.push_back(info);
        
        if ((err = info->decode(stream)) != srs_success) {
            return srs_error_wrap(err, "demux PMT program info");
        }
        
        // update the apply pid table
        switch (info->stream_type) {
            case SrsTsStreamVideoH264:
            case SrsTsStreamVideoMpeg4:
                packet->context->set(info->elementary_PID, SrsTsPidApplyVideo, info->stream_type);
                break;
            case SrsTsStreamAudioAAC:
            case SrsTsStreamAudioAC3:
            case SrsTsStreamAudioDTS:
            case SrsTsStreamAudioMp3:
                packet->context->set(info->elementary_PID, SrsTsPidApplyAudio, info->stream_type);
                break;
            default:
                srs_warn("ts: drop pid=%#x, stream=%#x", info->elementary_PID, info->stream_type);
                break;
        }
    }
    
    // update the apply pid table.
    packet->context->set(packet->pid, SrsTsPidApplyPMT);
    
    return err;
}

int SrsTsPayloadPMT::psi_size()
{
    int sz = 9;
    sz += program_info_desc.size();
    for (int i = 0; i < (int)infos.size(); i ++) {
        SrsTsPayloadPMTESInfo* info = infos.at(i);
        sz += info->size();
    }
    return sz;
}

srs_error_t SrsTsPayloadPMT::psi_encode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // atleast 9B for PMT specified
    if (!stream->require(9)) {
        return srs_error_new(ERROR_STREAM_CASTER_TS_PMT, "ts: mux PMT");
    }
    
    // 2B
    stream->write_2bytes(program_number);
    
    // 1B
    int8_t cniv = current_next_indicator & 0x01;
    cniv |= (const1_value0 << 6) & 0xC0;
    cniv |= (version_number << 1) & 0xFE;
    stream->write_1bytes(cniv);
    
    // 1B
    stream->write_1bytes(section_number);
    
    // 1B
    stream->write_1bytes(last_section_number);
    
    // 2B
    int16_t ppv = PCR_PID & 0x1FFF;
    ppv |= (const1_value1 << 13) & 0xE000;
    stream->write_2bytes(ppv);
    
    // 2B
    int16_t pilv = program_info_desc.size() & 0xFFF;
    pilv |= (const1_value2 << 12) & 0xF000;
    stream->write_2bytes(pilv);
    
    if (!program_info_desc.empty()) {
        if (!stream->require((int)program_info_desc.size())) {
            return srs_error_new(ERROR_STREAM_CASTER_TS_PMT, "ts: mux PMT program info");
        }
        
        stream->write_bytes(&program_info_desc[0], (int)program_info_desc.size());
    }
    
    for (int i = 0; i < (int)infos.size(); i ++) {
        SrsTsPayloadPMTESInfo* info = infos.at(i);
        if ((err = info->encode(stream)) != srs_success) {
            return srs_error_wrap(err, "mux PMT program info");
        }
        
        // update the apply pid table
        switch (info->stream_type) {
            case SrsTsStreamVideoH264:
            case SrsTsStreamVideoMpeg4:
                packet->context->set(info->elementary_PID, SrsTsPidApplyVideo, info->stream_type);
                break;
            case SrsTsStreamAudioAAC:
            case SrsTsStreamAudioAC3:
            case SrsTsStreamAudioDTS:
            case SrsTsStreamAudioMp3:
                packet->context->set(info->elementary_PID, SrsTsPidApplyAudio, info->stream_type);
                break;
            default:
                srs_warn("ts: drop pid=%#x, stream=%#x", info->elementary_PID, info->stream_type);
                break;
        }
    }
    
    // update the apply pid table.
    packet->context->set(packet->pid, SrsTsPidApplyPMT);
    
    return err;
}

SrsTsContextWriter::SrsTsContextWriter(SrsFileWriter* w, SrsTsContext* c, SrsAudioCodecId ac, SrsVideoCodecId vc)
{
    writer = w;
    context = c;
    
    acodec = ac;
    vcodec = vc;
}

SrsTsContextWriter::~SrsTsContextWriter()
{
    close();
}

srs_error_t SrsTsContextWriter::open(string p)
{
    srs_error_t err = srs_success;
    
    path = p;
    
    close();
    
    // reset the context for a new ts start.
    context->reset();
    
    if ((err = writer->open(path)) != srs_success) {
        return srs_error_wrap(err, "ts: open writer");
    }
    
    return err;
}

srs_error_t SrsTsContextWriter::write_audio(SrsTsMessage* audio)
{
    srs_error_t err = srs_success;
    
    srs_info("hls: write audio pts=%" PRId64 ", dts=%" PRId64 ", size=%d",
        audio->pts, audio->dts, audio->PES_packet_length);
    
    if ((err = context->encode(writer, audio, vcodec, acodec)) != srs_success) {
        return srs_error_wrap(err, "ts: write audio");
    }
    srs_info("hls encode audio ok");
    
    return err;
}

srs_error_t SrsTsContextWriter::write_video(SrsTsMessage* video)
{
    srs_error_t err = srs_success;
    
    srs_info("hls: write video pts=%" PRId64 ", dts=%" PRId64 ", size=%d",
        video->pts, video->dts, video->PES_packet_length);
    
    if ((err = context->encode(writer, video, vcodec, acodec)) != srs_success) {
        return srs_error_wrap(err, "ts: write video");
    }
    srs_info("hls encode video ok");
    
    return err;
}

void SrsTsContextWriter::close()
{
    writer->close();
}

SrsVideoCodecId SrsTsContextWriter::video_codec()
{
    return vcodec;
}

SrsTsMessageCache::SrsTsMessageCache()
{
    audio = NULL;
    video = NULL;
}

SrsTsMessageCache::~SrsTsMessageCache()
{
    srs_freep(audio);
    srs_freep(video);
}

srs_error_t SrsTsMessageCache::cache_audio(SrsAudioFrame* frame, int64_t dts)
{
    srs_error_t err = srs_success;
    
    // create the ts audio message.
    if (!audio) {
        audio = new SrsTsMessage();
        audio->write_pcr = false;
        audio->dts = audio->pts = audio->start_pts = dts;
    }
    
    // TODO: FIXME: refine code.
    //audio->dts = dts;
    //audio->pts = audio->dts;
    audio->sid = SrsTsPESStreamIdAudioCommon;
    
    // must be aac or mp3
    SrsAudioCodecConfig* acodec = frame->acodec();
    srs_assert(acodec->id == SrsAudioCodecIdAAC || acodec->id == SrsAudioCodecIdMP3);
    
    // write video to cache.
    if (acodec->id == SrsAudioCodecIdAAC) {
        if ((err = do_cache_aac(frame)) != srs_success) {
            return srs_error_wrap(err, "ts: cache aac");
        }
    } else {
        if ((err = do_cache_mp3(frame)) != srs_success) {
            return srs_error_wrap(err, "ts: cache mp3");
        }
    }
    
    return err;
}

srs_error_t SrsTsMessageCache::cache_video(SrsVideoFrame* frame, int64_t dts)
{
    srs_error_t err = srs_success;
    
    // create the ts video message.
    if (!video) {
        video = new SrsTsMessage();
        video->write_pcr = (frame->frame_type == SrsVideoAvcFrameTypeKeyFrame);
        video->start_pts = dts;
    }
    
    video->dts = dts;
    video->pts = video->dts + frame->cts * 90;
    video->sid = SrsTsPESStreamIdVideoCommon;
    
    // write video to cache.
    if ((err = do_cache_avc(frame)) != srs_success) {
        return srs_error_wrap(err, "ts: cache avc");
    }
    
    return err;
}

srs_error_t SrsTsMessageCache::do_cache_mp3(SrsAudioFrame* frame)
{
    srs_error_t err = srs_success;
    
    // for mp3, directly write to cache.
    // TODO: FIXME: implements the ts jitter.
    for (int i = 0; i < frame->nb_samples; i++) {
        SrsSample* sample = &frame->samples[i];
        audio->payload->append(sample->bytes, sample->size);
    }
    
    return err;
}

srs_error_t SrsTsMessageCache::do_cache_aac(SrsAudioFrame* frame)
{
    srs_error_t err = srs_success;
    
    SrsAudioCodecConfig* codec = frame->acodec();
    srs_assert(codec);
    
    for (int i = 0; i < frame->nb_samples; i++) {
        SrsSample* sample = &frame->samples[i];
        int32_t size = sample->size;
        
        if (!sample->bytes || size <= 0 || size > 0x1fff) {
            return srs_error_new(ERROR_HLS_AAC_FRAME_LENGTH, "ts: invalid aac frame length=%d", size);
        }
        
        // the frame length is the AAC raw data plus the adts header size.
        int32_t frame_length = size + 7;
        
        // AAC-ADTS
        // 6.2 Audio Data Transport Stream, ADTS
        // in ISO_IEC_13818-7-AAC-2004.pdf, page 26.
        // fixed 7bytes header
        uint8_t adts_header[7] = {0xff, 0xf9, 0x00, 0x00, 0x00, 0x0f, 0xfc};
        /*
         // adts_fixed_header
         // 2B, 16bits
         int16_t syncword; //12bits, '1111 1111 1111'
         int8_t ID; //1bit, '1'
         int8_t layer; //2bits, '00'
         int8_t protection_absent; //1bit, can be '1'
         // 12bits
         int8_t profile; //2bit, 7.1 Profiles, page 40
         TSAacSampleFrequency sampling_frequency_index; //4bits, Table 35, page 46
         int8_t private_bit; //1bit, can be '0'
         int8_t channel_configuration; //3bits, Table 8
         int8_t original_or_copy; //1bit, can be '0'
         int8_t home; //1bit, can be '0'
         
         // adts_variable_header
         // 28bits
         int8_t copyright_identification_bit; //1bit, can be '0'
         int8_t copyright_identification_start; //1bit, can be '0'
         int16_t frame_length; //13bits
         int16_t adts_buffer_fullness; //11bits, 7FF signals that the bitstream is a variable rate bitstream.
         int8_t number_of_raw_data_blocks_in_frame; //2bits, 0 indicating 1 raw_data_block()
         */
        // profile, 2bits
        SrsAacProfile aac_profile = srs_aac_rtmp2ts(codec->aac_object);
        adts_header[2] = (aac_profile << 6) & 0xc0;
        // sampling_frequency_index 4bits
        adts_header[2] |= (codec->aac_sample_rate << 2) & 0x3c;
        // channel_configuration 3bits
        adts_header[2] |= (codec->aac_channels >> 2) & 0x01;
        adts_header[3] = (codec->aac_channels << 6) & 0xc0;
        // frame_length 13bits
        adts_header[3] |= (frame_length >> 11) & 0x03;
        adts_header[4] = (frame_length >> 3) & 0xff;
        adts_header[5] = ((frame_length << 5) & 0xe0);
        // adts_buffer_fullness; //11bits
        adts_header[5] |= 0x1f;
        
        // copy to audio buffer
        audio->payload->append((const char*)adts_header, sizeof(adts_header));
        audio->payload->append(sample->bytes, sample->size);
    }
    
    return err;
}

void srs_avc_insert_aud(SrsSimpleStream* payload, bool& aud_inserted)
{
    // mux the samples in annexb format,
    // ISO_IEC_14496-10-AVC-2012.pdf, page 324.
    /**
     * 00 00 00 01 // header
     *       xxxxxxx // data bytes
     * 00 00 01 // continue header
     *       xxxxxxx // data bytes.
     *
     * nal_unit_type specifies the type of RBSP data structure contained in the NAL unit as specified in Table 7-1.
     * Table 7-1 - NAL unit type codes, syntax element categories, and NAL unit type classes
     * ISO_IEC_14496-10-AVC-2012.pdf, page 83.
     *      1, Coded slice of a non-IDR picture slice_layer_without_partitioning_rbsp( )
     *      2, Coded slice data partition A slice_data_partition_a_layer_rbsp( )
     *      3, Coded slice data partition B slice_data_partition_b_layer_rbsp( )
     *      4, Coded slice data partition C slice_data_partition_c_layer_rbsp( )
     *      5, Coded slice of an IDR picture slice_layer_without_partitioning_rbsp( )
     *      6, Supplemental enhancement information (SEI) sei_rbsp( )
     *      7, Sequence parameter set seq_parameter_set_rbsp( )
     *      8, Picture parameter set pic_parameter_set_rbsp( )
     *      9, Access unit delimiter access_unit_delimiter_rbsp( )
     *      10, End of sequence end_of_seq_rbsp( )
     *      11, End of stream end_of_stream_rbsp( )
     *      12, Filler data filler_data_rbsp( )
     *      13, Sequence parameter set extension seq_parameter_set_extension_rbsp( )
     *      14, Prefix NAL unit prefix_nal_unit_rbsp( )
     *      15, Subset sequence parameter set subset_seq_parameter_set_rbsp( )
     *      19, Coded slice of an auxiliary coded picture without partitioning slice_layer_without_partitioning_rbsp( )
     *      20, Coded slice extension slice_layer_extension_rbsp( )
     * the first ts message of apple sample:
     *      annexb 4B header, 2B aud(nal_unit_type:6)(0x09 0xf0)(AUD)
     *      annexb 4B header, 19B sps(nal_unit_type:7)(SPS)
     *      annexb 3B header, 4B pps(nal_unit_type:8)(PPS)
     *      annexb 3B header, 12B nalu(nal_unit_type:6)(SEI)
     *      annexb 3B header, 21B nalu(nal_unit_type:6)(SEI)
     *      annexb 3B header, 2762B nalu(nal_unit_type:5)(IDR)
     *      annexb 3B header, 3535B nalu(nal_unit_type:5)(IDR)
     * the second ts message of apple ts sample:
     *      annexb 4B header, 2B aud(nal_unit_type:6)(0x09 0xf0)(AUD)
     *      annexb 3B header, 21B nalu(nal_unit_type:6)(SEI)
     *      annexb 3B header, 379B nalu(nal_unit_type:1)(non-IDR,P/B)
     *      annexb 3B header, 406B nalu(nal_unit_type:1)(non-IDR,P/B)
     * @remark we use the sequence of apple samples http://ossrs.net/apple-sample/bipbopall.m3u8
     */
    static uint8_t fresh_nalu_header[] = { 0x00, 0x00, 0x00, 0x01 };
    static uint8_t cont_nalu_header[] = { 0x00, 0x00, 0x01 };
    
    if (!aud_inserted) {
        aud_inserted = true;
        payload->append((const char*)fresh_nalu_header, 4);
    } else {
        payload->append((const char*)cont_nalu_header, 3);
    }
}

srs_error_t SrsTsMessageCache::do_cache_avc(SrsVideoFrame* frame)
{
    srs_error_t err = srs_success;
    
    // Whether aud inserted.
    bool aud_inserted = false;
    
    // Insert a default AUD NALU when no AUD in samples.
    if (!frame->has_aud) {
        // the aud(access unit delimiter) before each frame.
        // 7.3.2.4 Access unit delimiter RBSP syntax
        // ISO_IEC_14496-10-AVC-2012.pdf, page 66.
        //
        // primary_pic_type u(3), the first 3bits, primary_pic_type indicates that the slice_type values
        //      for all slices of the primary coded picture are members of the set listed in Table 7-5 for
        //      the given value of primary_pic_type.
        //      0, slice_type 2, 7
        //      1, slice_type 0, 2, 5, 7
        //      2, slice_type 0, 1, 2, 5, 6, 7
        //      3, slice_type 4, 9
        //      4, slice_type 3, 4, 8, 9
        //      5, slice_type 2, 4, 7, 9
        //      6, slice_type 0, 2, 3, 4, 5, 7, 8, 9
        //      7, slice_type 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
        // 7.4.2.4 Access unit delimiter RBSP semantics
        // ISO_IEC_14496-10-AVC-2012.pdf, page 102.
        //
        // slice_type specifies the coding type of the slice according to Table 7-6.
        //      0, P (P slice)
        //      1, B (B slice)
        //      2, I (I slice)
        //      3, SP (SP slice)
        //      4, SI (SI slice)
        //      5, P (P slice)
        //      6, B (B slice)
        //      7, I (I slice)
        //      8, SP (SP slice)
        //      9, SI (SI slice)
        // ISO_IEC_14496-10-AVC-2012.pdf, page 105.
        static uint8_t default_aud_nalu[] = { 0x09, 0xf0};
        srs_avc_insert_aud(video->payload, aud_inserted);
        video->payload->append((const char*)default_aud_nalu, 2);
    }
    
    SrsVideoCodecConfig* codec = frame->vcodec();
    srs_assert(codec);
    
    bool is_sps_pps_appended = false;
    
    // all sample use cont nalu header, except the sps-pps before IDR frame.
    for (int i = 0; i < frame->nb_samples; i++) {
        SrsSample* sample = &frame->samples[i];
        int32_t size = sample->size;
        
        if (!sample->bytes || size <= 0) {
            return srs_error_new(ERROR_HLS_AVC_SAMPLE_SIZE, "ts: invalid avc sample length=%d", size);
        }
        
        // 5bits, 7.3.1 NAL unit syntax,
        // ISO_IEC_14496-10-AVC-2012.pdf, page 83.
        SrsAvcNaluType nal_unit_type = (SrsAvcNaluType)(sample->bytes[0] & 0x1f);
        
        // Insert sps/pps before IDR when there is no sps/pps in samples.
        // The sps/pps is parsed from sequence header(generally the first flv packet).
        if (nal_unit_type == SrsAvcNaluTypeIDR && !frame->has_sps_pps && !is_sps_pps_appended) {
            if (!codec->sequenceParameterSetNALUnit.empty()) {
                srs_avc_insert_aud(video->payload, aud_inserted);
                video->payload->append(&codec->sequenceParameterSetNALUnit[0], (int)codec->sequenceParameterSetNALUnit.size());
            }
            if (!codec->pictureParameterSetNALUnit.empty()) {
                srs_avc_insert_aud(video->payload, aud_inserted);
                video->payload->append(&codec->pictureParameterSetNALUnit[0], (int)codec->pictureParameterSetNALUnit.size());
            }
            is_sps_pps_appended = true;
        }
        
        // Insert the NALU to video in annexb.
        srs_avc_insert_aud(video->payload, aud_inserted);
        video->payload->append(sample->bytes, sample->size);
    }
    
    return err;
}

SrsTsTransmuxer::SrsTsTransmuxer()
{
    writer = NULL;
    format = new SrsFormat();
    tsmc = new SrsTsMessageCache();
    context = new SrsTsContext();
    tscw = NULL;
}

SrsTsTransmuxer::~SrsTsTransmuxer()
{
    srs_freep(format);
    srs_freep(tsmc);
    srs_freep(tscw);
    srs_freep(context);
}

srs_error_t SrsTsTransmuxer::initialize(SrsFileWriter* fw)
{
    srs_error_t err = srs_success;
    
    if ((err = format->initialize()) != srs_success) {
        return srs_error_wrap(err, "ts: init format");
    }
    
    srs_assert(fw);
    
    if (!fw->is_open()) {
        return srs_error_new(ERROR_KERNEL_FLV_STREAM_CLOSED, "ts: stream is not open");
    }
    
    writer = fw;
    
    srs_freep(tscw);
    // TODO: FIXME: Support config the codec.
    tscw = new SrsTsContextWriter(fw, context, SrsAudioCodecIdAAC, SrsVideoCodecIdAVC);
    
    if ((err = tscw->open("")) != srs_success) {
        return srs_error_wrap(err, "ts: open writer");
    }
    
    return err;
}

srs_error_t SrsTsTransmuxer::write_audio(int64_t timestamp, char* data, int size)
{
    srs_error_t err = srs_success;
    
    if ((err = format->on_audio(timestamp, data, size)) != srs_success) {
        return srs_error_wrap(err, "ts: format on audio");
    }
    
    // ts support audio codec: aac/mp3
    srs_assert(format->acodec && format->audio);
    if (format->acodec->id != SrsAudioCodecIdAAC && format->acodec->id != SrsAudioCodecIdMP3) {
        return err;
    }
    
    // for aac: ignore sequence header
    if (format->acodec->id == SrsAudioCodecIdAAC && format->audio->aac_packet_type == SrsAudioAacFrameTraitSequenceHeader) {
        return err;
    }
    
    // the dts calc from rtmp/flv header.
    // @remark for http ts stream, the timestamp is always monotonically increase,
    //      for the packet is filtered by consumer.
    int64_t dts = timestamp * 90;
    
    // write audio to cache.
    if ((err = tsmc->cache_audio(format->audio, dts)) != srs_success) {
        return srs_error_wrap(err, "ts: cache audio");
    }
    
    // TODO: FIXME: for pure audio, aggregate some frame to one.
    
    // always flush audio frame by frame.
    // @see https://github.com/ossrs/srs/issues/512
    return flush_audio();
}

srs_error_t SrsTsTransmuxer::write_video(int64_t timestamp, char* data, int size)
{
    srs_error_t err = srs_success;
    
    if ((err = format->on_video(timestamp, data, size)) != srs_success) {
        return srs_error_wrap(err, "ts: on video");
    }
    
    // ignore info frame,
    // @see https://github.com/ossrs/srs/issues/288#issuecomment-69863909
    srs_assert(format->video && format->vcodec);
    if (format->video->frame_type == SrsVideoAvcFrameTypeVideoInfoFrame) {
        return err;
    }
    
    if (format->vcodec->id != SrsVideoCodecIdAVC) {
        return err;
    }
    
    // ignore sequence header
    if (format->video->frame_type == SrsVideoAvcFrameTypeKeyFrame && format->video->avc_packet_type == SrsVideoAvcFrameTraitSequenceHeader) {
        return err;
    }
    
    int64_t dts = timestamp * 90;
    
    // write video to cache.
    if ((err = tsmc->cache_video(format->video, dts)) != srs_success) {
        return srs_error_wrap(err, "ts: cache video");
    }
    
    return flush_video();
}

srs_error_t SrsTsTransmuxer::flush_audio()
{
    srs_error_t err = srs_success;
    
    if ((err = tscw->write_audio(tsmc->audio)) != srs_success) {
        return srs_error_wrap(err, "ts: write audio");
    }
    
    // write success, clear and free the ts message.
    srs_freep(tsmc->audio);
    
    return err;
}

srs_error_t SrsTsTransmuxer::flush_video()
{
    srs_error_t err = srs_success;
    
    if ((err = tscw->write_video(tsmc->video)) != srs_success) {
        return srs_error_wrap(err, "ts: write video");
    }
    
    // write success, clear and free the ts message.
    srs_freep(tsmc->video);
    
    return err;
}

#endif

// following is generated by src/kernel/srs_kernel_stream.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kernel_stream.hpp>

//#include <srs_kernel_error.hpp>
//#include <srs_kernel_log.hpp>
//#include <srs_kernel_utility.hpp>
//#include <srs_core_performance.hpp>

SrsSimpleStream::SrsSimpleStream()
{
}

SrsSimpleStream::~SrsSimpleStream()
{
}

int SrsSimpleStream::length()
{
    int len = (int)data.size();
    srs_assert(len >= 0);
    return len;
}

char* SrsSimpleStream::bytes()
{
    return (length() == 0)? NULL : &data.at(0);
}

void SrsSimpleStream::erase(int size)
{
    if (size <= 0) {
        return;
    }
    
    if (size >= length()) {
        data.clear();
        return;
    }
    
    data.erase(data.begin(), data.begin() + size);
}

void SrsSimpleStream::append(const char* bytes, int size)
{
    srs_assert(size > 0);
    
    data.insert(data.end(), bytes, bytes + size);
}
// following is generated by src/kernel/srs_kernel_balance.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kernel_balance.hpp>

using namespace std;

SrsLbRoundRobin::SrsLbRoundRobin()
{
    index = -1;
    count = 0;
}

SrsLbRoundRobin::~SrsLbRoundRobin()
{
}

uint32_t SrsLbRoundRobin::current()
{
    return index;
}

string SrsLbRoundRobin::selected()
{
    return elem;
}

string SrsLbRoundRobin::select(const vector<string>& servers)
{
    srs_assert(!servers.empty());
    
    index = (int)(count++ % servers.size());
    elem = servers.at(index);
    
    return elem;
}

// following is generated by src/kernel/srs_kernel_mp4.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kernel_mp4.hpp>

//#include <srs_kernel_log.hpp>
//#include <srs_kernel_error.hpp>
//#include <srs_kernel_stream.hpp>
//#include <srs_core_autofree.hpp>
//#include <srs_kernel_io.hpp>
//#include <srs_kernel_utility.hpp>
//#include <srs_kernel_buffer.hpp>

#include <string.h>
#include <sstream>
#include <iomanip>
using namespace std;

#define SRS_MP4_EOF_SIZE 0
#define SRS_MP4_USE_LARGE_SIZE 1

#define SRS_MP4_BUF_SIZE 4096

stringstream& srs_padding(stringstream& ss, SrsMp4DumpContext dc, int tab = 4)
{
    for (int i = 0; i < dc.level; i++) {
        for (int j = 0; j < tab; j++) {
            ss << " ";
        }
    }
    return ss;
}

stringstream& srs_print_mp4_type(stringstream& ss, uint32_t v)
{
    ss << char(v>>24) << char(v>>16) << char(v>>8) << char(v);
    return ss;
}

#define SrsSummaryCount 8

template<typename T>
stringstream& srs_dumps_array(std::vector<T>&arr, stringstream& ss, SrsMp4DumpContext dc,
    void (*pfn)(T&, stringstream&, SrsMp4DumpContext),
    void (*delimiter)(stringstream&,SrsMp4DumpContext))
{
    int limit = arr.size();
    if (dc.summary) {
        limit = srs_min(SrsSummaryCount, limit);
    }
    
    for (size_t i = 0; i < limit; i++) {
        T& elem = arr[i];
        
        pfn(elem, ss, dc);
        
        if (i < limit - 1) {
            delimiter(ss, dc);
        }
    }
    return ss;
}

template<typename T>
stringstream& srs_dumps_array(T* arr, int size, stringstream& ss, SrsMp4DumpContext dc,
    void (*pfn)(T&, stringstream&, SrsMp4DumpContext),
    void (*delimiter)(stringstream&, SrsMp4DumpContext))
{
    int limit = size;
    if (dc.summary) {
        limit = srs_min(SrsSummaryCount, limit);
    }
    
    for (size_t i = 0; i < limit; i++) {
        T& elem = arr[i];
        
        pfn(elem, ss, dc);
        
        if (i < limit - 1) {
            delimiter(ss, dc);
        }
    }
    return ss;
}

void srs_delimiter_inline(stringstream& ss, SrsMp4DumpContext dc)
{
    ss << ",";
}

void srs_delimiter_inlinespace(stringstream& ss, SrsMp4DumpContext dc)
{
    ss << ", ";
}

void srs_delimiter_newline(stringstream& ss, SrsMp4DumpContext dc)
{
    ss << endl;
    srs_padding(ss, dc);
}

template<typename T>
void srs_pfn_box(T& elem, stringstream& ss, SrsMp4DumpContext dc)
{
    elem.dumps(ss, dc);
}

template<typename T>
void srs_pfn_detail(T& elem, stringstream& ss, SrsMp4DumpContext dc)
{
    elem.dumps_detail(ss, dc);
}

template<typename T>
void srs_pfn_pbox(T*& elem, stringstream& ss, SrsMp4DumpContext dc)
{
    elem->dumps(ss, dc);
}

template<typename T>
void srs_pfn_pdetail(T*& elem, stringstream& ss, SrsMp4DumpContext dc)
{
    elem->dumps_detail(ss, dc);
}

template<typename T>
void srs_pfn_types(T& elem, stringstream& ss, SrsMp4DumpContext dc)
{
    srs_print_mp4_type(ss, (uint32_t)elem);
}

template<typename T>
void srs_pfn_hex(T& elem, stringstream& ss, SrsMp4DumpContext dc)
{
    ss << "0x" << std::setw(2) << std::setfill('0') << std::hex << (uint32_t)(uint8_t)elem << std::dec;
}

template<typename T>
void srs_pfn_elems(T& elem, stringstream& ss, SrsMp4DumpContext dc)
{
    ss << elem;
}

stringstream& srs_print_bytes(stringstream& ss, const char* p, int size, SrsMp4DumpContext dc, int line = SrsSummaryCount, int max = -1)
{
    if (max == -1) {
        max = size;
    }
    
    for (int i = 0; i < max; i++) {
        ss << "0x" << std::setw(2) << std::setfill('0') << std::hex << (uint32_t)(uint8_t)p[i] << std::dec;
         if (i < max -1) {
             ss << ", ";
             if (((i+1)%line) == 0) {
                 ss << endl;
                 srs_padding(ss, dc);
             }
        }
    }
    return ss;
}

int srs_mp4_string_length(const string& v)
{
    return (int)v.length()+1;
}

void srs_mp4_string_write(SrsBuffer* buf, const string& v)
{
    // Nothing for empty string.
    if (v.empty()) {
        return;
    }
    
    buf->write_bytes((char*)v.data(), (int)v.length());
    buf->write_1bytes(0x00);
}

srs_error_t srs_mp4_string_read(SrsBuffer* buf, string& v, int left)
{
    srs_error_t err = srs_success;
    
    if (left == 0) {
        return err;
    }
    
    char* start = buf->data() + buf->pos();
    size_t len = strnlen(start, left);
    
    if ((int)len == left) {
        return srs_error_new(ERROR_MP4_BOX_STRING, "string corrupt, left=%d", left);
    }
    
    v.append(start, len);
    buf->skip((int)len + 1);
    
    return err;
}

SrsMp4DumpContext SrsMp4DumpContext::indent()
{
    SrsMp4DumpContext ctx = *this;
    ctx.level++;
    return ctx;
}

SrsMp4Box::SrsMp4Box()
{
    smallsize = 0;
    largesize = 0;
    start_pos = 0;
    type = SrsMp4BoxTypeForbidden;
}

SrsMp4Box::~SrsMp4Box()
{
    vector<SrsMp4Box*>::iterator it;
    for (it = boxes.begin(); it != boxes.end(); ++it) {
        SrsMp4Box* box = *it;
        srs_freep(box);
    }
    boxes.clear();
    
}

uint64_t SrsMp4Box::sz()
{
    return smallsize == SRS_MP4_USE_LARGE_SIZE? largesize:smallsize;
}

int SrsMp4Box::sz_header()
{
    return nb_header();
}

int SrsMp4Box::left_space(SrsBuffer* buf)
{
    return (int)sz() - (buf->pos() - start_pos);
}

bool SrsMp4Box::is_ftyp()
{
    return type == SrsMp4BoxTypeFTYP;
}

bool SrsMp4Box::is_moov()
{
    return type == SrsMp4BoxTypeMOOV;
}

bool SrsMp4Box::is_mdat()
{
    return type == SrsMp4BoxTypeMDAT;
}

SrsMp4Box* SrsMp4Box::get(SrsMp4BoxType bt)
{
    vector<SrsMp4Box*>::iterator it;
    for (it = boxes.begin(); it != boxes.end(); ++it) {
        SrsMp4Box* box = *it;
        
        if (box->type == bt) {
            return box;
        }
    }
    
    return NULL;
}

int SrsMp4Box::remove(SrsMp4BoxType bt)
{
    int nb_removed = 0;
    
    vector<SrsMp4Box*>::iterator it;
    for (it = boxes.begin(); it != boxes.end();) {
        SrsMp4Box* box = *it;
        
        if (box->type == bt) {
            it = boxes.erase(it);
        } else {
            ++it;
        }
    }
    
    return nb_removed;
}

stringstream& SrsMp4Box::dumps(stringstream& ss, SrsMp4DumpContext dc)
{
    srs_padding(ss, dc);
    srs_print_mp4_type(ss, (uint32_t)type);
    
    ss << ", " << sz();
    if (smallsize == SRS_MP4_USE_LARGE_SIZE) {
        ss << "(large)";
    }
    ss << "B";
    
    dumps_detail(ss, dc);
    
    if (!boxes.empty()) {
        ss << ", " << boxes.size() << " boxes";
    }
    
    // If there contained boxes in header,
    // which means the last box has already output the endl.
    if (!boxes_in_header()) {
        ss << endl;
    }
    
    vector<SrsMp4Box*>::iterator it;
    for (it = boxes.begin(); it != boxes.end(); ++it) {
        SrsMp4Box* box = *it;
        box->dumps(ss, dc.indent());
    }
    
    return ss;
}

srs_error_t SrsMp4Box::discovery(SrsBuffer* buf, SrsMp4Box** ppbox)
{
    *ppbox = NULL;
    
    srs_error_t err = srs_success;
    
    if (!buf->require(8)) {
        return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "requires 8 only %d bytes", buf->left());
    }
    
    // Discovery the size and type.
    uint64_t largesize = 0;
    uint32_t smallsize = (uint32_t)buf->read_4bytes();
    SrsMp4BoxType type = (SrsMp4BoxType)buf->read_4bytes();
    if (smallsize == SRS_MP4_USE_LARGE_SIZE) {
        if (!buf->require(8)) {
            return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "requires 16 only %d bytes", buf->left());
        }
        largesize = (uint64_t)buf->read_8bytes();
        buf->skip(-8);
    }
    buf->skip(-8);
    
    // Only support 31bits size.
    if (largesize > 0x7fffffff) {
        return srs_error_new(ERROR_MP4_BOX_OVERFLOW, "overflow 31bits, largesize=%" PRId64, largesize);
    }
    
    SrsMp4Box* box = NULL;
    switch(type) {
        case SrsMp4BoxTypeFTYP: box = new SrsMp4FileTypeBox(); break;
        case SrsMp4BoxTypeMDAT: box = new SrsMp4MediaDataBox(); break;
        case SrsMp4BoxTypeMOOV: box = new SrsMp4MovieBox(); break;
        case SrsMp4BoxTypeMVHD: box = new SrsMp4MovieHeaderBox(); break;
        case SrsMp4BoxTypeTRAK: box = new SrsMp4TrackBox(); break;
        case SrsMp4BoxTypeTKHD: box = new SrsMp4TrackHeaderBox(); break;
        case SrsMp4BoxTypeEDTS: box = new SrsMp4EditBox(); break;
        case SrsMp4BoxTypeELST: box = new SrsMp4EditListBox(); break;
        case SrsMp4BoxTypeMDIA: box = new SrsMp4MediaBox(); break;
        case SrsMp4BoxTypeMDHD: box = new SrsMp4MediaHeaderBox(); break;
        case SrsMp4BoxTypeHDLR: box = new SrsMp4HandlerReferenceBox(); break;
        case SrsMp4BoxTypeMINF: box = new SrsMp4MediaInformationBox(); break;
        case SrsMp4BoxTypeVMHD: box = new SrsMp4VideoMeidaHeaderBox(); break;
        case SrsMp4BoxTypeSMHD: box = new SrsMp4SoundMeidaHeaderBox(); break;
        case SrsMp4BoxTypeDINF: box = new SrsMp4DataInformationBox(); break;
        case SrsMp4BoxTypeURL: box = new SrsMp4DataEntryUrlBox(); break;
        case SrsMp4BoxTypeURN: box = new SrsMp4DataEntryUrnBox(); break;
        case SrsMp4BoxTypeDREF: box = new SrsMp4DataReferenceBox(); break;
        case SrsMp4BoxTypeSTBL: box = new SrsMp4SampleTableBox(); break;
        case SrsMp4BoxTypeSTSD: box = new SrsMp4SampleDescriptionBox(); break;
        case SrsMp4BoxTypeSTTS: box = new SrsMp4DecodingTime2SampleBox(); break;
        case SrsMp4BoxTypeCTTS: box = new SrsMp4CompositionTime2SampleBox(); break;
        case SrsMp4BoxTypeSTSS: box = new SrsMp4SyncSampleBox(); break;
        case SrsMp4BoxTypeSTSC: box = new SrsMp4Sample2ChunkBox(); break;
        case SrsMp4BoxTypeSTCO: box = new SrsMp4ChunkOffsetBox(); break;
        case SrsMp4BoxTypeCO64: box = new SrsMp4ChunkLargeOffsetBox(); break;
        case SrsMp4BoxTypeSTSZ: box = new SrsMp4SampleSizeBox(); break;
        case SrsMp4BoxTypeAVC1: box = new SrsMp4VisualSampleEntry(); break;
        case SrsMp4BoxTypeAVCC: box = new SrsMp4AvccBox(); break;
        case SrsMp4BoxTypeMP4A: box = new SrsMp4AudioSampleEntry(); break;
        case SrsMp4BoxTypeESDS: box = new SrsMp4EsdsBox(); break;
        case SrsMp4BoxTypeUDTA: box = new SrsMp4UserDataBox(); break;
        case SrsMp4BoxTypeMVEX: box = new SrsMp4MovieExtendsBox(); break;
        case SrsMp4BoxTypeTREX: box = new SrsMp4TrackExtendsBox(); break;
        case SrsMp4BoxTypeSTYP: box = new SrsMp4SegmentTypeBox(); break;
        case SrsMp4BoxTypeMOOF: box = new SrsMp4MovieFragmentBox(); break;
        case SrsMp4BoxTypeMFHD: box = new SrsMp4MovieFragmentHeaderBox(); break;
        case SrsMp4BoxTypeTRAF: box = new SrsMp4TrackFragmentBox(); break;
        case SrsMp4BoxTypeTFHD: box = new SrsMp4TrackFragmentHeaderBox(); break;
        case SrsMp4BoxTypeTFDT: box = new SrsMp4TrackFragmentDecodeTimeBox(); break;
        case SrsMp4BoxTypeTRUN: box = new SrsMp4TrackFragmentRunBox(); break;
        // Skip some unknown boxes.
        case SrsMp4BoxTypeFREE: case SrsMp4BoxTypeSKIP: case SrsMp4BoxTypePASP:
            box = new SrsMp4FreeSpaceBox(type); break;
        default:
            err = srs_error_new(ERROR_MP4_BOX_ILLEGAL_TYPE, "illegal box type=%d", type);
            break;
    }
    
    if (box) {
        box->smallsize = smallsize;
        box->largesize = largesize;
        box->type = type;
        *ppbox = box;
    }
    
    return err;
}

int SrsMp4Box::nb_bytes()
{
    int sz = nb_header();
    
    vector<SrsMp4Box*>::iterator it;
    for (it = boxes.begin(); it != boxes.end(); ++it) {
        SrsMp4Box* box = *it;
        sz += box->nb_bytes();
    }
    
    return sz;
}

srs_error_t SrsMp4Box::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    uint64_t size = nb_bytes();
    if (size > 0xffffffff) {
        largesize = size;
    } else {
        smallsize = (uint32_t)size;
    }
    
    start_pos = buf->pos();
    
    if ((err = encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode box header");
    }
    
    if ((err = encode_boxes(buf)) != srs_success) {
        return srs_error_wrap(err, "encode contained boxes");
    }
    
    return err;
}

srs_error_t SrsMp4Box::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    start_pos = buf->pos();
    
    if ((err = decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode box header");
    }
    
    if ((err = decode_boxes(buf)) != srs_success) {
        return srs_error_wrap(err, "decode contained boxes");
    }
    
    return err;
}

srs_error_t SrsMp4Box::encode_boxes(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    vector<SrsMp4Box*>::iterator it;
    for (it = boxes.begin(); it != boxes.end(); ++it) {
        SrsMp4Box* box = *it;
        if ((err = box->encode(buf)) != srs_success) {
            return srs_error_wrap(err, "encode contained box");
        }
    }
    
    return err;
}

srs_error_t SrsMp4Box::decode_boxes(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    int left = left_space(buf);
    while (left > 0) {
        SrsMp4Box* box = NULL;
        if ((err = discovery(buf, &box)) != srs_success) {
            return srs_error_wrap(err, "discovery contained box");
        }
        
        srs_assert(box);
        if ((err = box->decode(buf)) != srs_success) {
            srs_freep(box);
            return srs_error_wrap(err, "decode contained box");
        }
        
        boxes.push_back(box);
        left -= box->sz();
    }
    
    return err;
}

int SrsMp4Box::nb_header()
{
    int size = 8;
    if (smallsize == SRS_MP4_USE_LARGE_SIZE) {
        size += 8;
    }
    
    if (type == SrsMp4BoxTypeUUID) {
        size += 16;
    }
    
    return size;
}

srs_error_t SrsMp4Box::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    // Only support 31bits size.
    if (sz() > 0x7fffffff) {
        return srs_error_new(ERROR_MP4_BOX_OVERFLOW, "box size overflow 31bits, size=%" PRId64, sz());
    }
    
    int size = SrsMp4Box::nb_header();
    if (!buf->require(size)) {
        return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "requires %d only %d bytes", size, buf->left());
    }
    
    buf->write_4bytes(smallsize);
    if (smallsize == SRS_MP4_USE_LARGE_SIZE) {
        buf->write_8bytes(largesize);
    }
    buf->write_4bytes(type);
    
    if (type == SrsMp4BoxTypeUUID) {
        buf->write_bytes(&usertype[0], 16);
    }
    
    int lrsz = nb_header() - SrsMp4Box::nb_header();
    if (!buf->require(lrsz)) {
        return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "box requires %v only %d bytes", lrsz, buf->left());
    }
    
    return err;
}

srs_error_t SrsMp4Box::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if (!buf->require(8)) {
        return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "requires 8 only %d bytes", buf->left());
    }
    smallsize = (uint32_t)buf->read_4bytes();
    type = (SrsMp4BoxType)buf->read_4bytes();
    
    if (smallsize == SRS_MP4_EOF_SIZE) {
        srs_trace("MP4 box EOF.");
        return err;
    }
    
    if (smallsize == SRS_MP4_USE_LARGE_SIZE) {
        if (!buf->require(8)) {
            return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "box requires 8 only %d bytes", buf->left());
        }
        largesize = (uint64_t)buf->read_8bytes();
    }
    
    // Only support 31bits size.
    if (sz() > 0x7fffffff) {
        return srs_error_new(ERROR_MP4_BOX_OVERFLOW, "box size overflow 31bits, size=%" PRId64, sz());
    }
    
    if (type == SrsMp4BoxTypeUUID) {
        if (!buf->require(16)) {
            return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "box requires 16 only %d bytes", buf->left());
        }
        usertype.resize(16);
        buf->read_bytes(&usertype[0], 16);
    }
    
    // The left required size, determined by the default version(0).
    int lrsz = nb_header() - SrsMp4Box::nb_header();
    if (!buf->require(lrsz)) {
        return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "box requires %d only %d bytes", lrsz, buf->left());
    }
    
    return err;
}

bool SrsMp4Box::boxes_in_header()
{
    return false;
}

stringstream& SrsMp4Box::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    return ss;
}

SrsMp4FullBox::SrsMp4FullBox()
{
    version = 0;
    flags = 0;
}

SrsMp4FullBox::~SrsMp4FullBox()
{
}

int SrsMp4FullBox::nb_header()
{
    return SrsMp4Box::nb_header() + 1 + 3;
}

srs_error_t SrsMp4FullBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    if (!buf->require(4)) {
        return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "full box requires 4 only %d bytes", buf->left());
    }
    
    buf->write_1bytes(version);
    buf->write_3bytes(flags);
    
    return err;
}

srs_error_t SrsMp4FullBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    if (!buf->require(4)) {
        return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "full box requires 4 only %d bytes", buf->left());
    }
    
    flags = (uint32_t)buf->read_4bytes();
    
    version = (uint8_t)((flags >> 24) & 0xff);
    flags &= 0x00ffffff;
    
    // The left required size, determined by the version.
    int lrsz = nb_header() - SrsMp4FullBox::nb_header();
    if (!buf->require(lrsz)) {
        return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "full box requires %d only %d bytes", lrsz, buf->left());
    }
    
    return err;
}

stringstream& SrsMp4FullBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4Box::dumps_detail(ss, dc);
    
    ss << ", FB(4B";
    
    if (version != 0 || flags != 0) {
        ss << ",V" << uint32_t(version)
            << ",0x" << std::setw(2) << std::setfill('0') << std::hex << flags << std::dec;
    }
    
    ss << ")";
    
    return ss;
}

SrsMp4FileTypeBox::SrsMp4FileTypeBox()
{
    type = SrsMp4BoxTypeFTYP;
    major_brand = SrsMp4BoxBrandForbidden;
    minor_version = 0;
}

SrsMp4FileTypeBox::~SrsMp4FileTypeBox()
{
}

void SrsMp4FileTypeBox::set_compatible_brands(SrsMp4BoxBrand b0, SrsMp4BoxBrand b1)
{
    compatible_brands.resize(2);
    compatible_brands[0] = b0;
    compatible_brands[1] = b1;
}

void SrsMp4FileTypeBox::set_compatible_brands(SrsMp4BoxBrand b0, SrsMp4BoxBrand b1, SrsMp4BoxBrand b2, SrsMp4BoxBrand b3)
{
    compatible_brands.resize(4);
    compatible_brands[0] = b0;
    compatible_brands[1] = b1;
    compatible_brands[2] = b2;
    compatible_brands[3] = b3;
}

int SrsMp4FileTypeBox::nb_header()
{
    return (int)(SrsMp4Box::nb_header() + 8 + compatible_brands.size() * 4);
}

srs_error_t SrsMp4FileTypeBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes(major_brand);
    buf->write_4bytes(minor_version);
    
    for (size_t i = 0; i < compatible_brands.size(); i++) {
        buf->write_4bytes(compatible_brands[i]);
    }
    
    return err;
}

srs_error_t SrsMp4FileTypeBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    major_brand = (SrsMp4BoxBrand)buf->read_4bytes();
    minor_version = buf->read_4bytes();
    
    // Compatible brands to the end of the box.
    int left = left_space(buf);
    
    if (left > 0) {
        compatible_brands.resize(left / 4);
    }
    
    for (int i = 0; left > 0; i++, left -= 4){
        compatible_brands[i] = (SrsMp4BoxBrand)buf->read_4bytes();
    }
    
    return err;
}

stringstream& SrsMp4FileTypeBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4Box::dumps_detail(ss, dc);
    
    ss << ", brands:";
    srs_print_mp4_type(ss, (uint32_t)major_brand);
    
    ss << "," << minor_version;
    
    if (!compatible_brands.empty()) {
        ss << "(";
        srs_dumps_array(compatible_brands, ss, dc, srs_pfn_types, srs_delimiter_inline);
        ss << ")";
    }
    return ss;
}

SrsMp4SegmentTypeBox::SrsMp4SegmentTypeBox()
{
    type = SrsMp4BoxTypeSTYP;
}

SrsMp4SegmentTypeBox::~SrsMp4SegmentTypeBox()
{
}

SrsMp4MovieFragmentBox::SrsMp4MovieFragmentBox()
{
    type = SrsMp4BoxTypeMOOF;
}

SrsMp4MovieFragmentBox::~SrsMp4MovieFragmentBox()
{
}

SrsMp4MovieFragmentHeaderBox* SrsMp4MovieFragmentBox::mfhd()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeMFHD);
    return dynamic_cast<SrsMp4MovieFragmentHeaderBox*>(box);
}

void SrsMp4MovieFragmentBox::set_mfhd(SrsMp4MovieFragmentHeaderBox* v)
{
    remove(SrsMp4BoxTypeMFHD);
    boxes.push_back(v);
}

SrsMp4TrackFragmentBox* SrsMp4MovieFragmentBox::traf()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeTRAF);
    return dynamic_cast<SrsMp4TrackFragmentBox*>(box);
}

void SrsMp4MovieFragmentBox::set_traf(SrsMp4TrackFragmentBox* v)
{
    remove(SrsMp4BoxTypeTRAF);
    boxes.push_back(v);
}

SrsMp4MovieFragmentHeaderBox::SrsMp4MovieFragmentHeaderBox()
{
    type = SrsMp4BoxTypeMFHD;
    
    sequence_number = 0;
}

SrsMp4MovieFragmentHeaderBox::~SrsMp4MovieFragmentHeaderBox()
{
}

int SrsMp4MovieFragmentHeaderBox::nb_header()
{
    return SrsMp4FullBox::nb_header() + 4;
}

srs_error_t SrsMp4MovieFragmentHeaderBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes(sequence_number);
    
    return err;
}

srs_error_t SrsMp4MovieFragmentHeaderBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    sequence_number = buf->read_4bytes();
    
    return err;
}

stringstream& SrsMp4MovieFragmentHeaderBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", sequence=" << sequence_number;
    return ss;
}

SrsMp4TrackFragmentBox::SrsMp4TrackFragmentBox()
{
    type = SrsMp4BoxTypeTRAF;
}

SrsMp4TrackFragmentBox::~SrsMp4TrackFragmentBox()
{
}

SrsMp4TrackFragmentHeaderBox* SrsMp4TrackFragmentBox::tfhd()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeTFHD);
    return dynamic_cast<SrsMp4TrackFragmentHeaderBox*>(box);
}

void SrsMp4TrackFragmentBox::set_tfhd(SrsMp4TrackFragmentHeaderBox* v)
{
    remove(SrsMp4BoxTypeTFHD);
    boxes.push_back(v);
}

SrsMp4TrackFragmentDecodeTimeBox* SrsMp4TrackFragmentBox::tfdt()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeTFDT);
    return dynamic_cast<SrsMp4TrackFragmentDecodeTimeBox*>(box);
}

void SrsMp4TrackFragmentBox::set_tfdt(SrsMp4TrackFragmentDecodeTimeBox* v)
{
    remove(SrsMp4BoxTypeTFDT);
    boxes.push_back(v);
}

SrsMp4TrackFragmentRunBox* SrsMp4TrackFragmentBox::trun()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeTRUN);
    return dynamic_cast<SrsMp4TrackFragmentRunBox*>(box);
}

void SrsMp4TrackFragmentBox::set_trun(SrsMp4TrackFragmentRunBox* v)
{
    remove(SrsMp4BoxTypeTRUN);
    boxes.push_back(v);
}

SrsMp4TrackFragmentHeaderBox::SrsMp4TrackFragmentHeaderBox()
{
    type = SrsMp4BoxTypeTFHD;
    
    flags = 0;
    base_data_offset = 0;
    track_id = sample_description_index = 0;
    default_sample_duration = default_sample_size = 0;
    default_sample_flags = 0;
}

SrsMp4TrackFragmentHeaderBox::~SrsMp4TrackFragmentHeaderBox()
{
}

int SrsMp4TrackFragmentHeaderBox::nb_header()
{
    int size = SrsMp4FullBox::nb_header() + 4;
    
    if ((flags&SrsMp4TfhdFlagsBaseDataOffset) == SrsMp4TfhdFlagsBaseDataOffset) {
        size += 8;
    }
    if ((flags&SrsMp4TfhdFlagsSampleDescriptionIndex) == SrsMp4TfhdFlagsSampleDescriptionIndex) {
        size += 4;
    }
    if ((flags&SrsMp4TfhdFlagsDefaultSampleDuration) == SrsMp4TfhdFlagsDefaultSampleDuration) {
        size += 4;
    }
    if ((flags&SrsMp4TfhdFlagsDefautlSampleSize) == SrsMp4TfhdFlagsDefautlSampleSize) {
        size += 4;
    }
    if ((flags&SrsMp4TfhdFlagsDefaultSampleFlags) == SrsMp4TfhdFlagsDefaultSampleFlags) {
        size += 4;
    }
    
    return size;
}

srs_error_t SrsMp4TrackFragmentHeaderBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes(track_id);
    
    if ((flags&SrsMp4TfhdFlagsBaseDataOffset) == SrsMp4TfhdFlagsBaseDataOffset) {
        buf->write_8bytes(base_data_offset);
    }
    if ((flags&SrsMp4TfhdFlagsSampleDescriptionIndex) == SrsMp4TfhdFlagsSampleDescriptionIndex) {
        buf->write_4bytes(sample_description_index);
    }
    if ((flags&SrsMp4TfhdFlagsDefaultSampleDuration) == SrsMp4TfhdFlagsDefaultSampleDuration) {
        buf->write_4bytes(default_sample_duration);
    }
    if ((flags&SrsMp4TfhdFlagsDefautlSampleSize) == SrsMp4TfhdFlagsDefautlSampleSize) {
        buf->write_4bytes(default_sample_size);
    }
    if ((flags&SrsMp4TfhdFlagsDefaultSampleFlags) == SrsMp4TfhdFlagsDefaultSampleFlags) {
        buf->write_4bytes(default_sample_flags);
    }
    
    return err;
}

srs_error_t SrsMp4TrackFragmentHeaderBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    track_id = buf->read_4bytes();
    
    if ((flags&SrsMp4TfhdFlagsBaseDataOffset) == SrsMp4TfhdFlagsBaseDataOffset) {
        base_data_offset = buf->read_8bytes();
    }
    if ((flags&SrsMp4TfhdFlagsSampleDescriptionIndex) == SrsMp4TfhdFlagsSampleDescriptionIndex) {
        sample_description_index = buf->read_4bytes();
    }
    if ((flags&SrsMp4TfhdFlagsDefaultSampleDuration) == SrsMp4TfhdFlagsDefaultSampleDuration) {
        default_sample_duration = buf->read_4bytes();
    }
    if ((flags&SrsMp4TfhdFlagsDefautlSampleSize) == SrsMp4TfhdFlagsDefautlSampleSize) {
        default_sample_size = buf->read_4bytes();
    }
    if ((flags&SrsMp4TfhdFlagsDefaultSampleFlags) == SrsMp4TfhdFlagsDefaultSampleFlags) {
        default_sample_flags = buf->read_4bytes();
    }
    
    return err;
}

stringstream& SrsMp4TrackFragmentHeaderBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", track=" << track_id;
    
    if ((flags&SrsMp4TfhdFlagsBaseDataOffset) == SrsMp4TfhdFlagsBaseDataOffset) {
        ss << ", bdo=" << base_data_offset;
    }
    if ((flags&SrsMp4TfhdFlagsSampleDescriptionIndex) == SrsMp4TfhdFlagsSampleDescriptionIndex) {
        ss << ", sdi=" << sample_description_index;
    }
    if ((flags&SrsMp4TfhdFlagsDefaultSampleDuration) == SrsMp4TfhdFlagsDefaultSampleDuration) {
        ss << ", dsu=" << default_sample_duration;
    }
    if ((flags&SrsMp4TfhdFlagsDefautlSampleSize) == SrsMp4TfhdFlagsDefautlSampleSize) {
        ss << ", dss=" << default_sample_size;
    }
    if ((flags&SrsMp4TfhdFlagsDefaultSampleFlags) == SrsMp4TfhdFlagsDefaultSampleFlags) {
        ss << ", dsf=" << default_sample_flags;
    }
    
    if ((flags&SrsMp4TfhdFlagsDurationIsEmpty) == SrsMp4TfhdFlagsDurationIsEmpty) {
        ss << ", empty-duration";
    }
    if ((flags&SrsMp4TfhdFlagsDefaultBaseIsMoof) == SrsMp4TfhdFlagsDefaultBaseIsMoof) {
        ss << ", moof-base";
    }
    
    return ss;
}

SrsMp4TrackFragmentDecodeTimeBox::SrsMp4TrackFragmentDecodeTimeBox()
{
    type = SrsMp4BoxTypeTFDT;
    base_media_decode_time = 0;
}

SrsMp4TrackFragmentDecodeTimeBox::~SrsMp4TrackFragmentDecodeTimeBox()
{
}

int SrsMp4TrackFragmentDecodeTimeBox::nb_header()
{
    return SrsMp4FullBox::nb_header() + (version? 8:4);
}

srs_error_t SrsMp4TrackFragmentDecodeTimeBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    if (version) {
        buf->write_8bytes(base_media_decode_time);
    } else {
        buf->write_4bytes((uint32_t)base_media_decode_time);
    }
    
    return err;
}

srs_error_t SrsMp4TrackFragmentDecodeTimeBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    if (version) {
        base_media_decode_time = buf->read_8bytes();
    } else {
        base_media_decode_time = buf->read_4bytes();
    }
    
    return err;
}

stringstream& SrsMp4TrackFragmentDecodeTimeBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", bmdt=" << base_media_decode_time;
    
    return ss;
}

SrsMp4TrunEntry::SrsMp4TrunEntry(SrsMp4FullBox* o)
{
    owner = o;
    sample_duration = sample_size = sample_flags = 0;
    sample_composition_time_offset = 0;
}

SrsMp4TrunEntry::~SrsMp4TrunEntry()
{
}

int SrsMp4TrunEntry::nb_header()
{
    int size = 0;
    
    if ((owner->flags&SrsMp4TrunFlagsSampleDuration) == SrsMp4TrunFlagsSampleDuration) {
        size += 4;
    }
    if ((owner->flags&SrsMp4TrunFlagsSampleSize) == SrsMp4TrunFlagsSampleSize) {
        size += 4;
    }
    if ((owner->flags&SrsMp4TrunFlagsSampleFlag) == SrsMp4TrunFlagsSampleFlag) {
        size += 4;
    }
    if ((owner->flags&SrsMp4TrunFlagsSampleCtsOffset) == SrsMp4TrunFlagsSampleCtsOffset) {
        size += 4;
    }
    
    return size;
}

srs_error_t SrsMp4TrunEntry::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((owner->flags&SrsMp4TrunFlagsSampleDuration) == SrsMp4TrunFlagsSampleDuration) {
        buf->write_4bytes(sample_duration);
    }
    if ((owner->flags&SrsMp4TrunFlagsSampleSize) == SrsMp4TrunFlagsSampleSize) {
        buf->write_4bytes(sample_size);
    }
    if ((owner->flags&SrsMp4TrunFlagsSampleFlag) == SrsMp4TrunFlagsSampleFlag) {
        buf->write_4bytes(sample_flags);
    }
    if ((owner->flags&SrsMp4TrunFlagsSampleCtsOffset) == SrsMp4TrunFlagsSampleCtsOffset) {
        if (!owner->version) {
            uint32_t v = (uint32_t)sample_composition_time_offset;
            buf->write_4bytes(v);
        } else {
            int32_t v = (int32_t)sample_composition_time_offset;
            buf->write_4bytes(v);
        }
    }
    
    return err;
}

srs_error_t SrsMp4TrunEntry::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((owner->flags&SrsMp4TrunFlagsSampleDuration) == SrsMp4TrunFlagsSampleDuration) {
        sample_duration = buf->read_4bytes();
    }
    if ((owner->flags&SrsMp4TrunFlagsSampleSize) == SrsMp4TrunFlagsSampleSize) {
        sample_size = buf->read_4bytes();
    }
    if ((owner->flags&SrsMp4TrunFlagsSampleFlag) == SrsMp4TrunFlagsSampleFlag) {
        sample_flags = buf->read_4bytes();
    }
    if ((owner->flags&SrsMp4TrunFlagsSampleCtsOffset) == SrsMp4TrunFlagsSampleCtsOffset) {
        if (!owner->version) {
            uint32_t v = buf->read_4bytes();
            sample_composition_time_offset = v;
        } else {
            int32_t v = buf->read_4bytes();
            sample_composition_time_offset = v;
        }
    }
    
    return err;
}

stringstream& SrsMp4TrunEntry::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    if ((owner->flags&SrsMp4TrunFlagsSampleDuration) == SrsMp4TrunFlagsSampleDuration) {
        ss << "duration=" << sample_duration;
    }
    if ((owner->flags&SrsMp4TrunFlagsSampleSize) == SrsMp4TrunFlagsSampleSize) {
        ss << ", size=" << sample_size;
    }
    if ((owner->flags&SrsMp4TrunFlagsSampleFlag) == SrsMp4TrunFlagsSampleFlag) {
        ss << ", flags=" << sample_flags;
    }
    if ((owner->flags&SrsMp4TrunFlagsSampleCtsOffset) == SrsMp4TrunFlagsSampleCtsOffset) {
        ss << ", cts=" << sample_composition_time_offset;
    }
    return ss;
}

SrsMp4TrackFragmentRunBox::SrsMp4TrackFragmentRunBox()
{
    type = SrsMp4BoxTypeTRUN;
    sample_count = first_sample_flags = 0;
    data_offset = 0;
}

SrsMp4TrackFragmentRunBox::~SrsMp4TrackFragmentRunBox()
{
    vector<SrsMp4TrunEntry*>::iterator it;
    for (it = entries.begin(); it != entries.end(); ++it) {
        SrsMp4TrunEntry* entry = *it;
        srs_freep(entry);
    }
}

int SrsMp4TrackFragmentRunBox::nb_header()
{
    int size = SrsMp4FullBox::nb_header() + 4;
    
    if ((flags&SrsMp4TrunFlagsDataOffset) == SrsMp4TrunFlagsDataOffset) {
        size += 4;
    }
    if ((flags&SrsMp4TrunFlagsFirstSample) == SrsMp4TrunFlagsFirstSample) {
        size += 4;
    }
    
    vector<SrsMp4TrunEntry*>::iterator it;
    for (it = entries.begin(); it != entries.end(); ++it) {
        SrsMp4TrunEntry* entry = *it;
        size += entry->nb_header();
    }
    
    return size;
}

srs_error_t SrsMp4TrackFragmentRunBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes(sample_count);
    
    if ((flags&SrsMp4TrunFlagsDataOffset) == SrsMp4TrunFlagsDataOffset) {
        buf->write_4bytes(data_offset);
    }
    if ((flags&SrsMp4TrunFlagsFirstSample) == SrsMp4TrunFlagsFirstSample) {
        buf->write_4bytes(first_sample_flags);
    }
    
    vector<SrsMp4TrunEntry*>::iterator it;
    for (it = entries.begin(); it != entries.end(); ++it) {
        SrsMp4TrunEntry* entry = *it;
        if ((err = entry->encode_header(buf)) != srs_success) {
            return srs_error_wrap(err, "encode entry");
        }
    }
    
    return err;
}

srs_error_t SrsMp4TrackFragmentRunBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    sample_count = buf->read_4bytes();
    
    if ((flags&SrsMp4TrunFlagsDataOffset) == SrsMp4TrunFlagsDataOffset) {
        data_offset = buf->read_4bytes();
    }
    if ((flags&SrsMp4TrunFlagsFirstSample) == SrsMp4TrunFlagsFirstSample) {
        first_sample_flags = buf->read_4bytes();
    }
    
    for (int i = 0; i < sample_count; i++) {
        SrsMp4TrunEntry* entry = new SrsMp4TrunEntry(this);
        entries.push_back(entry);
        
        if ((err = entry->decode_header(buf)) != srs_success) {
            return srs_error_wrap(err, "decode entry");
        }
    }
    
    return err;
}

stringstream& SrsMp4TrackFragmentRunBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", samples=" << sample_count;
    
    if ((flags&SrsMp4TrunFlagsDataOffset) == SrsMp4TrunFlagsDataOffset) {
        ss << ", data-offset=" << data_offset;
    }
    if ((flags&SrsMp4TrunFlagsFirstSample) == SrsMp4TrunFlagsFirstSample) {
        ss << ", first-sample=" << first_sample_flags;
    }
    
    if (sample_count > 0) {
        ss << endl;
        srs_padding(ss, dc.indent());
        srs_dumps_array(entries, ss, dc.indent(), srs_pfn_pdetail, srs_delimiter_newline);
    }
    
    return ss;
}

SrsMp4MediaDataBox::SrsMp4MediaDataBox()
{
    type = SrsMp4BoxTypeMDAT;
    nb_data = 0;
}

SrsMp4MediaDataBox::~SrsMp4MediaDataBox()
{
}

int SrsMp4MediaDataBox::nb_bytes()
{
    return SrsMp4Box::nb_header() + nb_data;
}

srs_error_t SrsMp4MediaDataBox::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::encode(buf)) != srs_success) {
        return srs_error_wrap(err, "encode box");
    }
    
    return err;
}

srs_error_t SrsMp4MediaDataBox::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::decode(buf)) != srs_success) {
        return srs_error_wrap(err, "decode box");
    }
    
    nb_data = (int)(sz() - nb_header());
    
    return err;
}

srs_error_t SrsMp4MediaDataBox::encode_boxes(SrsBuffer* buf)
{
    return srs_success;
}

srs_error_t SrsMp4MediaDataBox::decode_boxes(SrsBuffer* buf)
{
    return srs_success;
}

stringstream& SrsMp4MediaDataBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4Box::dumps_detail(ss, dc);
    
    ss << ", total " << nb_data << " bytes";
    
    return ss;
}

SrsMp4FreeSpaceBox::SrsMp4FreeSpaceBox(SrsMp4BoxType v)
{
    type = v; // 'free' or 'skip'
}

SrsMp4FreeSpaceBox::~SrsMp4FreeSpaceBox()
{
}

int SrsMp4FreeSpaceBox::nb_header()
{
    return SrsMp4Box::nb_header() + (int)data.size();
}

srs_error_t SrsMp4FreeSpaceBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    if (!data.empty()) {
        buf->write_bytes(&data[0], (int)data.size());
    }
    
    return err;
}

srs_error_t SrsMp4FreeSpaceBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    int left = left_space(buf);
    if (left) {
        data.resize(left);
        buf->read_bytes(&data[0], left);
    }
    
    return err;
}

stringstream& SrsMp4FreeSpaceBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4Box::dumps_detail(ss, dc);
    
    ss << ", free " << data.size() << "B";
    
    if (!data.empty()) {
        ss << endl;
        srs_padding(ss, dc.indent());
        srs_dumps_array(&data[0], (int)data.size(), ss, dc.indent(), srs_pfn_hex, srs_delimiter_inlinespace);
    }
    return ss;
}

SrsMp4MovieBox::SrsMp4MovieBox()
{
    type = SrsMp4BoxTypeMOOV;
}

SrsMp4MovieBox::~SrsMp4MovieBox()
{
}

SrsMp4MovieHeaderBox* SrsMp4MovieBox::mvhd()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeMVHD);
    return dynamic_cast<SrsMp4MovieHeaderBox*>(box);
}

void SrsMp4MovieBox::set_mvhd(SrsMp4MovieHeaderBox* v)
{
    remove(SrsMp4BoxTypeMVHD);
    boxes.push_back(v);
}

SrsMp4MovieExtendsBox* SrsMp4MovieBox::mvex()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeMVEX);
    return dynamic_cast<SrsMp4MovieExtendsBox*>(box);
}

void SrsMp4MovieBox::set_mvex(SrsMp4MovieExtendsBox* v)
{
    remove(SrsMp4BoxTypeMVEX);
    boxes.push_back(v);
}

SrsMp4TrackBox* SrsMp4MovieBox::video()
{
    for (int i = 0; i < (int)boxes.size(); i++) {
        SrsMp4Box* box = boxes.at(i);
        if (box->type == SrsMp4BoxTypeTRAK) {
            SrsMp4TrackBox* trak = dynamic_cast<SrsMp4TrackBox*>(box);
            if ((trak->track_type() & SrsMp4TrackTypeVideo) == SrsMp4TrackTypeVideo) {
                return trak;
            }
        }
    }
    return NULL;
}

SrsMp4TrackBox* SrsMp4MovieBox::audio()
{
    for (int i = 0; i < (int)boxes.size(); i++) {
        SrsMp4Box* box = boxes.at(i);
        if (box->type == SrsMp4BoxTypeTRAK) {
            SrsMp4TrackBox* trak = dynamic_cast<SrsMp4TrackBox*>(box);
            if ((trak->track_type() & SrsMp4TrackTypeAudio) == SrsMp4TrackTypeAudio) {
                return trak;
            }
        }
    }
    return NULL;
}

void SrsMp4MovieBox::add_trak(SrsMp4TrackBox* v)
{
    boxes.push_back(v);
}

int SrsMp4MovieBox::nb_vide_tracks()
{
    int nb_tracks = 0;
    
    for (int i = 0; i < (int)boxes.size(); i++) {
        SrsMp4Box* box = boxes.at(i);
        if (box->type == SrsMp4BoxTypeTRAK) {
            SrsMp4TrackBox* trak = dynamic_cast<SrsMp4TrackBox*>(box);
            if ((trak->track_type() & SrsMp4TrackTypeVideo) == SrsMp4TrackTypeVideo) {
                nb_tracks++;
            }
        }
    }
    
    return nb_tracks;
}

int SrsMp4MovieBox::nb_soun_tracks()
{
    int nb_tracks = 0;
    
    for (int i = 0; i < (int)boxes.size(); i++) {
        SrsMp4Box* box = boxes.at(i);
        if (box->type == SrsMp4BoxTypeTRAK) {
            SrsMp4TrackBox* trak = dynamic_cast<SrsMp4TrackBox*>(box);
            if ((trak->track_type() & SrsMp4TrackTypeAudio) == SrsMp4TrackTypeAudio) {
                nb_tracks++;
            }
        }
    }
    
    return nb_tracks;
}

int SrsMp4MovieBox::nb_header()
{
    return SrsMp4Box::nb_header();
}

srs_error_t SrsMp4MovieBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    return err;
}

srs_error_t SrsMp4MovieBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    return err;
}

SrsMp4MovieHeaderBox::SrsMp4MovieHeaderBox() : creation_time(0), modification_time(0), timescale(0), duration_in_tbn(0)
{
    type = SrsMp4BoxTypeMVHD;
    
    rate = 0x00010000; // typically 1.0
    volume = 0x0100; // typically, full volume
    reserved0 = 0;
    reserved1 = 0;
    
    int32_t v[] = {0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000};
    memcpy(matrix, v, 36);
    
    memset(pre_defined, 0, 24);
    
    next_track_ID = 0;
}

SrsMp4MovieHeaderBox::~SrsMp4MovieHeaderBox()
{
}

uint64_t SrsMp4MovieHeaderBox::duration()
{
    return duration_in_tbn * 1000 / timescale;
}

int SrsMp4MovieHeaderBox::nb_header()
{
    int size = SrsMp4FullBox::nb_header();
    
    if (version == 1) {
        size += 8+8+4+8;
    } else {
        size += 4+4+4+4;
    }
    
    size += 4+2+2+8+36+24+4;
    
    return size;
}

srs_error_t SrsMp4MovieHeaderBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    if (version == 1) {
        buf->write_8bytes(creation_time);
        buf->write_8bytes(modification_time);
        buf->write_4bytes(timescale);
        buf->write_8bytes(duration_in_tbn);
    } else {
        buf->write_4bytes((uint32_t)creation_time);
        buf->write_4bytes((uint32_t)modification_time);
        buf->write_4bytes(timescale);
        buf->write_4bytes((uint32_t)duration_in_tbn);
    }
    
    buf->write_4bytes(rate);
    buf->write_2bytes(volume);
    buf->write_2bytes(reserved0);
    buf->write_8bytes(reserved1);
    for (int i = 0; i < 9; i++) {
        buf->write_4bytes(matrix[i]);
    }
    for (int i = 0; i < 6; i++) {
        buf->write_4bytes(pre_defined[i]);
    }
    buf->write_4bytes(next_track_ID);
    
    return err;
}

srs_error_t SrsMp4MovieHeaderBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    if (version == 1) {
        creation_time = buf->read_8bytes();
        modification_time = buf->read_8bytes();
        timescale = buf->read_4bytes();
        duration_in_tbn = buf->read_8bytes();
    } else {
        creation_time = buf->read_4bytes();
        modification_time = buf->read_4bytes();
        timescale = buf->read_4bytes();
        duration_in_tbn = buf->read_4bytes();
    }
    
    rate = buf->read_4bytes();
    volume = buf->read_2bytes();
    buf->skip(2);
    buf->skip(8);
    for (int i = 0; i < 9; i++) {
        matrix[i] = buf->read_4bytes();
    }
    buf->skip(24);
    next_track_ID = buf->read_4bytes();
    
    return err;
}

stringstream& SrsMp4MovieHeaderBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", " << std::setprecision(2) << duration() << "ms, TBN=" << timescale << ", nTID=" << next_track_ID;
    return ss;
}

SrsMp4MovieExtendsBox::SrsMp4MovieExtendsBox()
{
    type = SrsMp4BoxTypeMVEX;
}

SrsMp4MovieExtendsBox::~SrsMp4MovieExtendsBox()
{
}

SrsMp4TrackExtendsBox* SrsMp4MovieExtendsBox::trex()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeTREX);
    return dynamic_cast<SrsMp4TrackExtendsBox*>(box);
}

void SrsMp4MovieExtendsBox::set_trex(SrsMp4TrackExtendsBox* v)
{
    remove(SrsMp4BoxTypeTREX);
    boxes.push_back(v);
}

SrsMp4TrackExtendsBox::SrsMp4TrackExtendsBox()
{
    type = SrsMp4BoxTypeTREX;
    track_ID = default_sample_size = default_sample_flags = 0;
    default_sample_size = default_sample_duration = default_sample_description_index = 0;
}

SrsMp4TrackExtendsBox::~SrsMp4TrackExtendsBox()
{
}

int SrsMp4TrackExtendsBox::nb_header()
{
    return SrsMp4FullBox::nb_header() + 4*5;
}

srs_error_t SrsMp4TrackExtendsBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes(track_ID);
    buf->write_4bytes(default_sample_description_index);
    buf->write_4bytes(default_sample_duration);
    buf->write_4bytes(default_sample_size);
    buf->write_4bytes(default_sample_flags);
    
    return err;
}

srs_error_t SrsMp4TrackExtendsBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    track_ID = buf->read_4bytes();
    default_sample_description_index = buf->read_4bytes();
    default_sample_duration = buf->read_4bytes();
    default_sample_size = buf->read_4bytes();
    default_sample_flags = buf->read_4bytes();
    
    return err;
}

stringstream& SrsMp4TrackExtendsBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", track=#" << track_ID << ", default-sample("
        << "index:" << default_sample_description_index << ", size:" << default_sample_size
        << ", duration:" << default_sample_duration << ", flags:" << default_sample_flags << ")";
    return ss;
}

SrsMp4TrackBox::SrsMp4TrackBox()
{
    type = SrsMp4BoxTypeTRAK;
}

SrsMp4TrackBox::~SrsMp4TrackBox()
{
}

SrsMp4TrackType SrsMp4TrackBox::track_type()
{
    // TODO: Maybe should discovery all mdia boxes.
    SrsMp4MediaBox* box = mdia();
    if (!box) {
        return SrsMp4TrackTypeForbidden;
    }
    return box->track_type();
}

SrsMp4TrackHeaderBox* SrsMp4TrackBox::tkhd()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeTKHD);
    return dynamic_cast<SrsMp4TrackHeaderBox*>(box);
}

void SrsMp4TrackBox::set_tkhd(SrsMp4TrackHeaderBox* v)
{
    remove(SrsMp4BoxTypeTKHD);
    boxes.insert(boxes.begin(), v);
}

SrsMp4ChunkOffsetBox* SrsMp4TrackBox::stco()
{
    SrsMp4SampleTableBox* box = stbl();
    return box? box->stco():NULL;
}

SrsMp4SampleSizeBox* SrsMp4TrackBox::stsz()
{
    SrsMp4SampleTableBox* box = stbl();
    return box? box->stsz():NULL;
}

SrsMp4Sample2ChunkBox* SrsMp4TrackBox::stsc()
{
    SrsMp4SampleTableBox* box = stbl();
    return box? box->stsc():NULL;
}

SrsMp4DecodingTime2SampleBox* SrsMp4TrackBox::stts()
{
    SrsMp4SampleTableBox* box = stbl();
    return box? box->stts():NULL;
}

SrsMp4CompositionTime2SampleBox* SrsMp4TrackBox::ctts()
{
    SrsMp4SampleTableBox* box = stbl();
    return box? box->ctts():NULL;
}

SrsMp4SyncSampleBox* SrsMp4TrackBox::stss()
{
    SrsMp4SampleTableBox* box = stbl();
    return box? box->stss():NULL;
}

SrsMp4MediaHeaderBox* SrsMp4TrackBox::mdhd()
{
    SrsMp4MediaBox* box = mdia();
    return box? box->mdhd():NULL;
}

SrsVideoCodecId SrsMp4TrackBox::vide_codec()
{
    SrsMp4SampleDescriptionBox* box = stsd();
    if (!box) {
        return SrsVideoCodecIdForbidden;
    }
    
    if (box->entry_count() == 0) {
        return SrsVideoCodecIdForbidden;
    }
    
    SrsMp4SampleEntry* entry = box->entrie_at(0);
    switch(entry->type) {
        case SrsMp4BoxTypeAVC1: return SrsVideoCodecIdAVC;
        default: return SrsVideoCodecIdForbidden;
    }
}

SrsAudioCodecId SrsMp4TrackBox::soun_codec()
{
    SrsMp4SampleDescriptionBox* box = stsd();
    if (!box) {
        return SrsAudioCodecIdForbidden;
    }
    
    if (box->entry_count() == 0) {
        return SrsAudioCodecIdForbidden;
    }
    
    SrsMp4SampleEntry* entry = box->entrie_at(0);
    switch(entry->type) {
        case SrsMp4BoxTypeMP4A: return SrsAudioCodecIdAAC;
        default: return SrsAudioCodecIdForbidden;
    }
}

SrsMp4AvccBox* SrsMp4TrackBox::avcc()
{
    SrsMp4VisualSampleEntry* box = avc1();
    return box? box->avcC():NULL;
}

SrsMp4DecoderSpecificInfo* SrsMp4TrackBox::asc()
{
    SrsMp4AudioSampleEntry* box = mp4a();
    return box? box->asc():NULL;
}

SrsMp4MediaBox* SrsMp4TrackBox::mdia()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeMDIA);
    return dynamic_cast<SrsMp4MediaBox*>(box);
}

void SrsMp4TrackBox::set_mdia(SrsMp4MediaBox* v)
{
    remove(SrsMp4BoxTypeMDIA);
    boxes.push_back(v);
}

SrsMp4MediaInformationBox* SrsMp4TrackBox::minf()
{
    SrsMp4MediaBox* box = mdia();
    return box? box->minf():NULL;
}

SrsMp4SampleTableBox* SrsMp4TrackBox::stbl()
{
    SrsMp4MediaInformationBox* box = minf();
    return box? box->stbl():NULL;
}

SrsMp4SampleDescriptionBox* SrsMp4TrackBox::stsd()
{
    SrsMp4SampleTableBox* box = stbl();
    return box? box->stsd():NULL;
}

SrsMp4VisualSampleEntry* SrsMp4TrackBox::avc1()
{
    SrsMp4SampleDescriptionBox* box = stsd();
    return box? box->avc1():NULL;
}

SrsMp4AudioSampleEntry* SrsMp4TrackBox::mp4a()
{
    SrsMp4SampleDescriptionBox* box = stsd();
    return box? box->mp4a():NULL;
}

SrsMp4TrackHeaderBox::SrsMp4TrackHeaderBox() : creation_time(0), modification_time(0), track_ID(0), duration(0)
{
    type = SrsMp4BoxTypeTKHD;
    
    reserved0 = 0;
    reserved1 = 0;
    reserved2 = 0;
    layer = alternate_group = 0;
    volume = 0; // if track_is_audio 0x0100 else 0
    
    int32_t v[] = {0x00010000, 0, 0, 0, 0x00010000, 0, 0, 0, 0x40000000};
    memcpy(matrix, v, 36);
    
    width = height = 0;
    flags = 0x03;
}

SrsMp4TrackHeaderBox::~SrsMp4TrackHeaderBox()
{
}

int SrsMp4TrackHeaderBox::nb_header()
{
    int size = SrsMp4FullBox::nb_header();
    
    if (version == 1) {
        size += 8+8+4+4+8;
    } else {
        size += 4+4+4+4+4;
    }
    
    size += 8+2+2+2+2+36+4+4;
    
    return size;
}

srs_error_t SrsMp4TrackHeaderBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    if (version == 1) {
        buf->write_8bytes(creation_time);
        buf->write_8bytes(modification_time);
        buf->write_4bytes(track_ID);
        buf->write_4bytes(reserved0);
        buf->write_8bytes(duration);
    } else {
        buf->write_4bytes((uint32_t)creation_time);
        buf->write_4bytes((uint32_t)modification_time);
        buf->write_4bytes(track_ID);
        buf->write_4bytes(reserved0);
        buf->write_4bytes((uint32_t)duration);
    }
    
    buf->write_8bytes(reserved1);
    buf->write_2bytes(layer);
    buf->write_2bytes(alternate_group);
    buf->write_2bytes(volume);
    buf->write_2bytes(reserved2);
    for (int i = 0; i < 9; i++) {
        buf->write_4bytes(matrix[i]);
    }
    buf->write_4bytes(width);
    buf->write_4bytes(height);
    
    return err;
}

srs_error_t SrsMp4TrackHeaderBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    if (version == 1) {
        creation_time = buf->read_8bytes();
        modification_time = buf->read_8bytes();
        track_ID = buf->read_4bytes();
        buf->skip(4);
        duration = buf->read_8bytes();
    } else {
        creation_time = buf->read_4bytes();
        modification_time = buf->read_4bytes();
        track_ID = buf->read_4bytes();
        buf->skip(4);
        duration = buf->read_4bytes();
    }
    
    buf->skip(8);
    layer = buf->read_2bytes();
    alternate_group = buf->read_2bytes();
    volume = buf->read_2bytes();
    buf->skip(2);
    for (int i = 0; i < 9; i++) {
        matrix[i] = buf->read_4bytes();
    }
    width = buf->read_4bytes();
    height = buf->read_4bytes();
    
    return err;
}

stringstream& SrsMp4TrackHeaderBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", track #" << track_ID << ", " << duration << "TBN";
    
    if (volume) {
        ss << ", volume=" << uint32_t(volume>>8) << "." << uint32_t(volume&0xFF);
    }
    
    if (width || height) {
        ss << ", size=" << uint16_t(width>>16) << "x" << uint16_t(height>>16);
    }
    
    return ss;
}

SrsMp4EditBox::SrsMp4EditBox()
{
    type = SrsMp4BoxTypeEDTS;
}

SrsMp4EditBox::~SrsMp4EditBox()
{
}

SrsMp4ElstEntry::SrsMp4ElstEntry() : segment_duration(0), media_time(0), media_rate_integer(0)
{
    media_rate_fraction = 0;
}

stringstream& SrsMp4ElstEntry::dumps(stringstream& ss, SrsMp4DumpContext dc)
{
    return dumps_detail(ss, dc);
}

stringstream& SrsMp4ElstEntry::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    ss << "Entry, " << segment_duration << "TBN, start=" << media_time << "TBN"
        << ", rate=" << media_rate_integer << "," << media_rate_fraction;
    return ss;
}

SrsMp4EditListBox::SrsMp4EditListBox()
{
    type = SrsMp4BoxTypeELST;
}

SrsMp4EditListBox::~SrsMp4EditListBox()
{
}

int SrsMp4EditListBox::nb_header()
{
    int size = SrsMp4FullBox::nb_header() + 4;
    
    if (version == 1) {
        size += entries.size() * (2+2+8+8);
    } else {
        size += entries.size() * (2+2+4+4);
    }
    
    return size;
}

srs_error_t SrsMp4EditListBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes((int)entries.size());
    for (size_t i = 0; i < entries.size(); i++) {
        SrsMp4ElstEntry& entry = entries[i];
        
        if (version == 1) {
            buf->write_8bytes(entry.segment_duration);
            buf->write_8bytes(entry.media_time);
        } else {
            buf->write_4bytes((uint32_t)entry.segment_duration);
            buf->write_4bytes((int32_t)entry.media_time);
        }
        
        buf->write_2bytes(entry.media_rate_integer);
        buf->write_2bytes(entry.media_rate_fraction);
    }
    
    return err;
}

srs_error_t SrsMp4EditListBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    uint32_t entry_count = buf->read_4bytes();
    if (entry_count > 0) {
        entries.resize(entry_count);
    }
    for (int i = 0; i < (int)entry_count; i++) {
        SrsMp4ElstEntry& entry = entries[i];
        
        if (version == 1) {
            entry.segment_duration = buf->read_8bytes();
            entry.media_time = buf->read_8bytes();
        } else {
            entry.segment_duration = buf->read_4bytes();
            entry.media_time = buf->read_4bytes();
        }
        
        entry.media_rate_integer = buf->read_2bytes();
        entry.media_rate_fraction = buf->read_2bytes();
    }
    
    return err;
}

stringstream& SrsMp4EditListBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", " << entries.size() << " childs";
    
    if (!entries.empty()) {
        ss << "(+)" << endl;
        srs_padding(ss, dc.indent());
        srs_dumps_array(entries, ss, dc.indent(), srs_pfn_detail, srs_delimiter_newline);
    }
    
    return ss;
}

SrsMp4MediaBox::SrsMp4MediaBox()
{
    type = SrsMp4BoxTypeMDIA;
}

SrsMp4MediaBox::~SrsMp4MediaBox()
{
}

SrsMp4TrackType SrsMp4MediaBox::track_type()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeHDLR);
    if (!box) {
        return SrsMp4TrackTypeForbidden;
    }
    
    SrsMp4HandlerReferenceBox* hdlr = dynamic_cast<SrsMp4HandlerReferenceBox*>(box);
    if (hdlr->handler_type == SrsMp4HandlerTypeSOUN) {
        return SrsMp4TrackTypeAudio;
    } else if (hdlr->handler_type == SrsMp4HandlerTypeVIDE) {
        return SrsMp4TrackTypeVideo;
    } else {
        return SrsMp4TrackTypeForbidden;
    }
}

SrsMp4MediaHeaderBox* SrsMp4MediaBox::mdhd()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeMDHD);
    return dynamic_cast<SrsMp4MediaHeaderBox*>(box);
}

void SrsMp4MediaBox::set_mdhd(SrsMp4MediaHeaderBox* v)
{
    remove(SrsMp4BoxTypeMDHD);
    boxes.insert(boxes.begin(), v);
}

SrsMp4HandlerReferenceBox* SrsMp4MediaBox::hdlr()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeHDLR);
    return dynamic_cast<SrsMp4HandlerReferenceBox*>(box);
}

void SrsMp4MediaBox::set_hdlr(SrsMp4HandlerReferenceBox* v)
{
    remove(SrsMp4BoxTypeHDLR);
    boxes.push_back(v);
}

SrsMp4MediaInformationBox* SrsMp4MediaBox::minf()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeMINF);
    return dynamic_cast<SrsMp4MediaInformationBox*>(box);
}

void SrsMp4MediaBox::set_minf(SrsMp4MediaInformationBox* v)
{
    remove(SrsMp4BoxTypeMINF);
    boxes.push_back(v);
}

SrsMp4MediaHeaderBox::SrsMp4MediaHeaderBox() : creation_time(0), modification_time(0), duration(0)
{
    type = SrsMp4BoxTypeMDHD;
    language = 0;
    pre_defined = 0;
}

SrsMp4MediaHeaderBox::~SrsMp4MediaHeaderBox()
{
}

char SrsMp4MediaHeaderBox::language0()
{
    return (char)(((language >> 10) & 0x1f) + 0x60);
}

void SrsMp4MediaHeaderBox::set_language0(char v)
{
    language |= uint16_t((uint8_t(v) - 0x60) & 0x1f) << 10;
}

char SrsMp4MediaHeaderBox::language1()
{
    return (char)(((language >> 5) & 0x1f) + 0x60);
}

void SrsMp4MediaHeaderBox::set_language1(char v)
{
    language |= uint16_t((uint8_t(v) - 0x60) & 0x1f) << 5;
}

char SrsMp4MediaHeaderBox::language2()
{
    return (char)((language & 0x1f) + 0x60);
}

void SrsMp4MediaHeaderBox::set_language2(char v)
{
    language |= uint16_t((uint8_t(v) - 0x60) & 0x1f);
}

int SrsMp4MediaHeaderBox::nb_header()
{
    int size = SrsMp4FullBox::nb_header();
    
    if (version == 1) {
        size += 8+8+4+8;
    } else {
        size += 4+4+4+4;
    }
    
    size += 2+2;
    
    return size;
}

srs_error_t SrsMp4MediaHeaderBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    if (version == 1) {
        buf->write_8bytes(creation_time);
        buf->write_8bytes(modification_time);
        buf->write_4bytes(timescale);
        buf->write_8bytes(duration);
    } else {
        buf->write_4bytes((uint32_t)creation_time);
        buf->write_4bytes((uint32_t)modification_time);
        buf->write_4bytes(timescale);
        buf->write_4bytes((uint32_t)duration);
    }
    
    buf->write_2bytes(language);
    buf->write_2bytes(pre_defined);
    
    return err;
}

srs_error_t SrsMp4MediaHeaderBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    if (version == 1) {
        creation_time = buf->read_8bytes();
        modification_time = buf->read_8bytes();
        timescale = buf->read_4bytes();
        duration = buf->read_8bytes();
    } else {
        creation_time = buf->read_4bytes();
        modification_time = buf->read_4bytes();
        timescale = buf->read_4bytes();
        duration = buf->read_4bytes();
    }
    
    language = buf->read_2bytes();
    buf->skip(2);
    
    return err;
}

stringstream& SrsMp4MediaHeaderBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", TBN=" << timescale << ", " << duration << "TBN";
    if (language) {
        ss << ", LANG=" << language0() << language1() << language2();
    }
    return ss;
}

SrsMp4HandlerReferenceBox::SrsMp4HandlerReferenceBox()
{
    type = SrsMp4BoxTypeHDLR;
    
    pre_defined = 0;
    memset(reserved, 0, 12);
    
    handler_type = SrsMp4HandlerTypeForbidden;
}

SrsMp4HandlerReferenceBox::~SrsMp4HandlerReferenceBox()
{
}

bool SrsMp4HandlerReferenceBox::is_video()
{
    return handler_type == SrsMp4HandlerTypeVIDE;
}

bool SrsMp4HandlerReferenceBox::is_audio()
{
    return handler_type == SrsMp4HandlerTypeSOUN;
}

int SrsMp4HandlerReferenceBox::nb_header()
{
    return SrsMp4FullBox::nb_header()+4+4+12+srs_mp4_string_length(name);
}

srs_error_t SrsMp4HandlerReferenceBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes(pre_defined);
    buf->write_4bytes(handler_type);
    buf->write_4bytes(reserved[0]);
    buf->write_4bytes(reserved[1]);
    buf->write_4bytes(reserved[2]);
    srs_mp4_string_write(buf, name);
    
    return err;
}

srs_error_t SrsMp4HandlerReferenceBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    buf->skip(4);
    handler_type = (SrsMp4HandlerType)buf->read_4bytes();
    buf->skip(12);
    
    if ((err = srs_mp4_string_read(buf, name, left_space(buf))) != srs_success) {
        return srs_error_wrap(err, "hdlr read string");
    }
    
    return err;
}

stringstream& SrsMp4HandlerReferenceBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", ";
    srs_print_mp4_type(ss, (uint32_t)handler_type);
    ss << ", " <<  name;
    
    return ss;
}

SrsMp4MediaInformationBox::SrsMp4MediaInformationBox()
{
    type = SrsMp4BoxTypeMINF;
}

SrsMp4MediaInformationBox::~SrsMp4MediaInformationBox()
{
}

SrsMp4VideoMeidaHeaderBox* SrsMp4MediaInformationBox::vmhd()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeVMHD);
    return dynamic_cast<SrsMp4VideoMeidaHeaderBox*>(box);
}

void SrsMp4MediaInformationBox::set_vmhd(SrsMp4VideoMeidaHeaderBox* v)
{
    remove(SrsMp4BoxTypeVMHD);
    boxes.push_back(v);
}

SrsMp4SoundMeidaHeaderBox* SrsMp4MediaInformationBox::smhd()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeSMHD);
    return dynamic_cast<SrsMp4SoundMeidaHeaderBox*>(box);
}

void SrsMp4MediaInformationBox::set_smhd(SrsMp4SoundMeidaHeaderBox* v)
{
    remove(SrsMp4BoxTypeSMHD);
    boxes.push_back(v);
}

SrsMp4DataInformationBox* SrsMp4MediaInformationBox::dinf()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeDINF);
    return dynamic_cast<SrsMp4DataInformationBox*>(box);
}

void SrsMp4MediaInformationBox::set_dinf(SrsMp4DataInformationBox* v)
{
    remove(SrsMp4BoxTypeDINF);
    boxes.push_back(v);
}

SrsMp4SampleTableBox* SrsMp4MediaInformationBox::stbl()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeSTBL);
    return dynamic_cast<SrsMp4SampleTableBox*>(box);
}

void SrsMp4MediaInformationBox::set_stbl(SrsMp4SampleTableBox* v)
{
    remove(SrsMp4BoxTypeSTBL);
    boxes.push_back(v);
}

SrsMp4VideoMeidaHeaderBox::SrsMp4VideoMeidaHeaderBox()
{
    type = SrsMp4BoxTypeVMHD;
    version = 0;
    flags = 1;
    
    graphicsmode = 0;
    memset(opcolor, 0, 6);
}

SrsMp4VideoMeidaHeaderBox::~SrsMp4VideoMeidaHeaderBox()
{
}

int SrsMp4VideoMeidaHeaderBox::nb_header()
{
    return SrsMp4FullBox::nb_header()+2+6;
}

srs_error_t SrsMp4VideoMeidaHeaderBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_2bytes(graphicsmode);
    buf->write_2bytes(opcolor[0]);
    buf->write_2bytes(opcolor[1]);
    buf->write_2bytes(opcolor[2]);
    
    return err;
}

srs_error_t SrsMp4VideoMeidaHeaderBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    graphicsmode = buf->read_2bytes();
    opcolor[0] = buf->read_2bytes();
    opcolor[1] = buf->read_2bytes();
    opcolor[2] = buf->read_2bytes();
    
    return err;
}

SrsMp4SoundMeidaHeaderBox::SrsMp4SoundMeidaHeaderBox()
{
    type = SrsMp4BoxTypeSMHD;
    
    reserved = balance = 0;
}

SrsMp4SoundMeidaHeaderBox::~SrsMp4SoundMeidaHeaderBox()
{
}

int SrsMp4SoundMeidaHeaderBox::nb_header()
{
    return SrsMp4FullBox::nb_header()+2+2;
}

srs_error_t SrsMp4SoundMeidaHeaderBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_2bytes(balance);
    buf->write_2bytes(reserved);
    
    return err;
}

srs_error_t SrsMp4SoundMeidaHeaderBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    balance = buf->read_2bytes();
    buf->skip(2);
    
    return err;
}

SrsMp4DataInformationBox::SrsMp4DataInformationBox()
{
    type = SrsMp4BoxTypeDINF;
}

SrsMp4DataInformationBox::~SrsMp4DataInformationBox()
{
}

SrsMp4DataReferenceBox* SrsMp4DataInformationBox::dref()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeDREF);
    return dynamic_cast<SrsMp4DataReferenceBox*>(box);
}

void SrsMp4DataInformationBox::set_dref(SrsMp4DataReferenceBox* v)
{
    remove(SrsMp4BoxTypeDREF);
    boxes.push_back(v);
}

SrsMp4DataEntryBox::SrsMp4DataEntryBox()
{
}

SrsMp4DataEntryBox::~SrsMp4DataEntryBox()
{
}

SrsMp4DataEntryUrlBox::SrsMp4DataEntryUrlBox()
{
    type = SrsMp4BoxTypeURL;
}

SrsMp4DataEntryUrlBox::~SrsMp4DataEntryUrlBox()
{
}

int SrsMp4DataEntryUrlBox::nb_header()
{
    // a 24-bit integer with flags; one flag is defined (x000001) which means that the media
    // data is in the same file as the Movie Box containing this data reference.
    if (location.empty()) {
        return SrsMp4FullBox::nb_header();
    }
    return SrsMp4FullBox::nb_header()+srs_mp4_string_length(location);
}

srs_error_t SrsMp4DataEntryUrlBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    // a 24-bit integer with flags; one flag is defined (x000001) which means that the media
    // data is in the same file as the Movie Box containing this data reference.
    if (location.empty()) {
        flags = 0x01;
    }
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    if (!location.empty()) {
        srs_mp4_string_write(buf, location);
    }
    
    return err;
}

srs_error_t SrsMp4DataEntryUrlBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    // a 24-bit integer with flags; one flag is defined (x000001) which means that the media
    // data is in the same file as the Movie Box containing this data reference.
    if (flags == 0x01) {
        return err;
    }
    
    if ((err = srs_mp4_string_read(buf, location, left_space(buf))) != srs_success) {
        return srs_error_wrap(err, "url read location");
    }
    
    return err;
}

stringstream& SrsMp4DataEntryUrlBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    ss << "URL: " << location;
    if (location.empty()) {
        ss << "Same file";
    }
    return ss;
}

SrsMp4DataEntryUrnBox::SrsMp4DataEntryUrnBox()
{
    type = SrsMp4BoxTypeURN;
}

SrsMp4DataEntryUrnBox::~SrsMp4DataEntryUrnBox()
{
}

int SrsMp4DataEntryUrnBox::nb_header()
{
    return SrsMp4FullBox::nb_header()+srs_mp4_string_length(location)+srs_mp4_string_length(name);
}

srs_error_t SrsMp4DataEntryUrnBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4DataEntryBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode entry");
    }
    
    srs_mp4_string_write(buf, location);
    srs_mp4_string_write(buf, name);
    
    return err;
}

srs_error_t SrsMp4DataEntryUrnBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4DataEntryBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode entry");
    }
    
    if ((err = srs_mp4_string_read(buf, location, left_space(buf))) != srs_success) {
        return srs_error_wrap(err, "urn read location");
    }
    
    if ((err = srs_mp4_string_read(buf, name, left_space(buf))) != srs_success) {
        return srs_error_wrap(err, "urn read name");
    }
    
    return err;
}

stringstream& SrsMp4DataEntryUrnBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    ss << "URN: " << name << ", " << location;
    return ss;
}

SrsMp4DataReferenceBox::SrsMp4DataReferenceBox()
{
    type = SrsMp4BoxTypeDREF;
}

SrsMp4DataReferenceBox::~SrsMp4DataReferenceBox()
{
    vector<SrsMp4DataEntryBox*>::iterator it;
    for (it = entries.begin(); it != entries.end(); ++it) {
        SrsMp4DataEntryBox* entry = *it;
        srs_freep(entry);
    }
    entries.clear();
}

uint32_t SrsMp4DataReferenceBox::entry_count()
{
    return (uint32_t)entries.size();
}

SrsMp4DataEntryBox* SrsMp4DataReferenceBox::entry_at(int index)
{
    return entries.at(index);
}

SrsMp4DataReferenceBox* SrsMp4DataReferenceBox::append(SrsMp4DataEntryBox* v)
{
    entries.push_back(v);
    return this;
}

int SrsMp4DataReferenceBox::nb_header()
{
    int size = SrsMp4FullBox::nb_header();
    
    size += 4;
    
    vector<SrsMp4DataEntryBox*>::iterator it;
    for (it = entries.begin(); it != entries.end(); ++it) {
        SrsMp4DataEntryBox* entry = *it;
        size += entry->nb_bytes();
    }
    
    return size;
}

srs_error_t SrsMp4DataReferenceBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes((int32_t)entries.size());
    
    vector<SrsMp4DataEntryBox*>::iterator it;
    for (it = entries.begin(); it != entries.end(); ++it) {
        SrsMp4DataEntryBox* entry = *it;
        if ((err = entry->encode(buf)) != srs_success) {
            return srs_error_wrap(err, "encode entry");
        }
    }
    
    return err;
}

srs_error_t SrsMp4DataReferenceBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    uint32_t nb_entries = buf->read_4bytes();
    for (uint32_t i = 0; i < nb_entries; i++) {
        SrsMp4Box* box = NULL;
        if ((err = SrsMp4Box::discovery(buf, &box)) != srs_success) {
            return srs_error_wrap(err, "discovery box");
        }
        
        if ((err = box->decode(buf)) != srs_success) {
            return srs_error_wrap(err, "decode box");
        }
        
        SrsMp4FullBox* fbox = dynamic_cast<SrsMp4FullBox*>(box);
        if (fbox) {
            fbox->version = version;
            fbox->flags = flags;
        }
        
        if (box->type == SrsMp4BoxTypeURL) {
            entries.push_back(dynamic_cast<SrsMp4DataEntryUrlBox*>(box));
        } else if (box->type == SrsMp4BoxTypeURN) {
            entries.push_back(dynamic_cast<SrsMp4DataEntryUrnBox*>(box));
        } else {
            srs_freep(box);
        }
    }
    
    return err;
}

stringstream& SrsMp4DataReferenceBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", " << entries.size() << " childs";
    if (!entries.empty()) {
        ss << "(+)" << endl;
        srs_padding(ss, dc.indent());
        srs_dumps_array(entries, ss, dc.indent(), srs_pfn_pdetail, srs_delimiter_newline);
    }
    return ss;
}

SrsMp4SampleTableBox::SrsMp4SampleTableBox()
{
    type = SrsMp4BoxTypeSTBL;
}

SrsMp4SampleTableBox::~SrsMp4SampleTableBox()
{
}

SrsMp4SampleDescriptionBox* SrsMp4SampleTableBox::stsd()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeSTSD);
    return dynamic_cast<SrsMp4SampleDescriptionBox*>(box);
}

void SrsMp4SampleTableBox::set_stsd(SrsMp4SampleDescriptionBox* v)
{
    remove(SrsMp4BoxTypeSTSD);
    boxes.push_back(v);
}

SrsMp4ChunkOffsetBox* SrsMp4SampleTableBox::stco()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeSTCO);
    return dynamic_cast<SrsMp4ChunkOffsetBox*>(box);
}

void SrsMp4SampleTableBox::set_stco(SrsMp4ChunkOffsetBox* v)
{
    remove(SrsMp4BoxTypeSTCO);
    boxes.push_back(v);
}

SrsMp4SampleSizeBox* SrsMp4SampleTableBox::stsz()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeSTSZ);
    return dynamic_cast<SrsMp4SampleSizeBox*>(box);
}

void SrsMp4SampleTableBox::set_stsz(SrsMp4SampleSizeBox* v)
{
    remove(SrsMp4BoxTypeSTSZ);
    boxes.push_back(v);
}

SrsMp4Sample2ChunkBox* SrsMp4SampleTableBox::stsc()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeSTSC);
    return dynamic_cast<SrsMp4Sample2ChunkBox*>(box);
}

void SrsMp4SampleTableBox::set_stsc(SrsMp4Sample2ChunkBox* v)
{
    remove(SrsMp4BoxTypeSTSC);
    boxes.push_back(v);
}

SrsMp4DecodingTime2SampleBox* SrsMp4SampleTableBox::stts()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeSTTS);
    return dynamic_cast<SrsMp4DecodingTime2SampleBox*>(box);
}

void SrsMp4SampleTableBox::set_stts(SrsMp4DecodingTime2SampleBox* v)
{
    remove(SrsMp4BoxTypeSTTS);
    boxes.push_back(v);
}

SrsMp4CompositionTime2SampleBox* SrsMp4SampleTableBox::ctts()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeCTTS);
    return dynamic_cast<SrsMp4CompositionTime2SampleBox*>(box);
}

void SrsMp4SampleTableBox::set_ctts(SrsMp4CompositionTime2SampleBox* v)
{
    remove(SrsMp4BoxTypeCTTS);
    boxes.push_back(v);
}

SrsMp4SyncSampleBox* SrsMp4SampleTableBox::stss()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeSTSS);
    return dynamic_cast<SrsMp4SyncSampleBox*>(box);
}

void SrsMp4SampleTableBox::set_stss(SrsMp4SyncSampleBox* v)
{
    remove(SrsMp4BoxTypeSTSS);
    boxes.push_back(v);
}

int SrsMp4SampleTableBox::nb_header()
{
    return SrsMp4Box::nb_header();
}

srs_error_t SrsMp4SampleTableBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    return err;
}

srs_error_t SrsMp4SampleTableBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    return err;
}

SrsMp4SampleEntry::SrsMp4SampleEntry() : data_reference_index(0)
{
    memset(reserved, 0, 6);
}

SrsMp4SampleEntry::~SrsMp4SampleEntry()
{
}

int SrsMp4SampleEntry::nb_header()
{
    return SrsMp4Box::nb_header()+6+2;
}

srs_error_t SrsMp4SampleEntry::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    for (int i = 0; i < 6; i++) {
        buf->write_1bytes(reserved[i]);
    }
    buf->write_2bytes(data_reference_index);
    
    return err;
}

srs_error_t SrsMp4SampleEntry::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    buf->skip(6);
    data_reference_index = buf->read_2bytes();
    
    return err;
}

stringstream& SrsMp4SampleEntry::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4Box::dumps_detail(ss, dc);
    
    ss << ", refs#" << data_reference_index;
    return ss;
}

SrsMp4VisualSampleEntry::SrsMp4VisualSampleEntry() : width(0), height(0)
{
    type = SrsMp4BoxTypeAVC1;
    
    pre_defined0 = 0;
    reserved0 = 0;
    reserved1 = 0;
    memset(pre_defined1, 0, 12);
    memset(compressorname, 0, 32);
    frame_count = 1;
    horizresolution = 0x00480000; // 72 dpi
    vertresolution = 0x00480000; // 72 dpi
    depth = 0x0018;
    pre_defined2 = -1;
}

SrsMp4VisualSampleEntry::~SrsMp4VisualSampleEntry()
{
}

SrsMp4AvccBox* SrsMp4VisualSampleEntry::avcC()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeAVCC);
    return dynamic_cast<SrsMp4AvccBox*>(box);
}

void SrsMp4VisualSampleEntry::set_avcC(SrsMp4AvccBox* v)
{
    remove(SrsMp4BoxTypeAVCC);
    boxes.push_back(v);
}

int SrsMp4VisualSampleEntry::nb_header()
{
    return SrsMp4SampleEntry::nb_header()+2+2+12+2+2+4+4+4+2+32+2+2;
}

srs_error_t SrsMp4VisualSampleEntry::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4SampleEntry::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode entry");
    }
    
    buf->write_2bytes(pre_defined0);
    buf->write_2bytes(reserved0);
    buf->write_4bytes(pre_defined1[0]);
    buf->write_4bytes(pre_defined1[1]);
    buf->write_4bytes(pre_defined1[2]);
    buf->write_2bytes(width);
    buf->write_2bytes(height);
    buf->write_4bytes(horizresolution);
    buf->write_4bytes(vertresolution);
    buf->write_4bytes(reserved1);
    buf->write_2bytes(frame_count);
    buf->write_bytes(compressorname, 32);
    buf->write_2bytes(depth);
    buf->write_2bytes(pre_defined2);
    
    return err;
}

srs_error_t SrsMp4VisualSampleEntry::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4SampleEntry::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode entry");
    }
    
    buf->skip(2);
    buf->skip(2);
    buf->skip(12);
    width = buf->read_2bytes();
    height = buf->read_2bytes();
    horizresolution = buf->read_4bytes();
    vertresolution = buf->read_4bytes();
    buf->skip(4);
    frame_count = buf->read_2bytes();
    buf->read_bytes(compressorname, 32);
    depth = buf->read_2bytes();
    buf->skip(2);
    
    return err;
}

stringstream& SrsMp4VisualSampleEntry::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4SampleEntry::dumps_detail(ss, dc);
    
    ss << ", size=" << width << "x" << height;
    return ss;
}

SrsMp4AvccBox::SrsMp4AvccBox()
{
    type = SrsMp4BoxTypeAVCC;
}

SrsMp4AvccBox::~SrsMp4AvccBox()
{
}

int SrsMp4AvccBox::nb_header()
{
    return SrsMp4Box::nb_header() + (int)avc_config.size();
}

srs_error_t SrsMp4AvccBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    if (!avc_config.empty()) {
        buf->write_bytes(&avc_config[0], (int)avc_config.size());
    }
    
    return err;
}

srs_error_t SrsMp4AvccBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    int nb_config = left_space(buf);
    if (nb_config) {
        avc_config.resize(nb_config);
        buf->read_bytes(&avc_config[0], nb_config);
    }
    
    return err;
}

stringstream& SrsMp4AvccBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4Box::dumps_detail(ss, dc);
    
    ss << ", AVC Config: " << (int)avc_config.size() << "B" << endl;
    srs_padding(ss, dc.indent());
    srs_print_bytes(ss, (const char*)&avc_config[0], (int)avc_config.size(), dc.indent());
    return ss;
}

SrsMp4AudioSampleEntry::SrsMp4AudioSampleEntry() : samplerate(0)
{
    type = SrsMp4BoxTypeMP4A;
    
    reserved0 = 0;
    pre_defined0 = 0;
    reserved1 = 0;
    channelcount = 2;
    samplesize = 16;
}

SrsMp4AudioSampleEntry::~SrsMp4AudioSampleEntry()
{
}

SrsMp4EsdsBox* SrsMp4AudioSampleEntry::esds()
{
    SrsMp4Box* box = get(SrsMp4BoxTypeESDS);
    return dynamic_cast<SrsMp4EsdsBox*>(box);
}

void SrsMp4AudioSampleEntry::set_esds(SrsMp4EsdsBox* v)
{
    remove(SrsMp4BoxTypeESDS);
    boxes.push_back(v);
}

SrsMp4DecoderSpecificInfo* SrsMp4AudioSampleEntry::asc()
{
    SrsMp4EsdsBox* box = esds();
    return box? box->asc():NULL;
}

int SrsMp4AudioSampleEntry::nb_header()
{
    return SrsMp4SampleEntry::nb_header()+8+2+2+2+2+4;
}

srs_error_t SrsMp4AudioSampleEntry::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4SampleEntry::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode entry");
    }
    
    buf->write_8bytes(reserved0);
    buf->write_2bytes(channelcount);
    buf->write_2bytes(samplesize);
    buf->write_2bytes(pre_defined0);
    buf->write_2bytes(reserved1);
    buf->write_4bytes(samplerate);
    
    return err;
}

srs_error_t SrsMp4AudioSampleEntry::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4SampleEntry::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode entry");
    }
    
    buf->skip(8);
    channelcount = buf->read_2bytes();
    samplesize = buf->read_2bytes();
    buf->skip(2);
    buf->skip(2);
    samplerate = buf->read_4bytes();
    
    return err;
}

stringstream& SrsMp4AudioSampleEntry::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4SampleEntry::dumps_detail(ss, dc);
    
    ss << ", " << channelcount << " channels, " << samplesize << " bits"
        << ", " << (samplerate>>16) << " Hz";
    return ss;
}

SrsMp4BaseDescriptor::SrsMp4BaseDescriptor()
{
    tag = SrsMp4ESTagESforbidden;
    vlen = -1;
    start_pos = 0;
}

SrsMp4BaseDescriptor::~SrsMp4BaseDescriptor()
{
}

int SrsMp4BaseDescriptor::left_space(SrsBuffer* buf)
{
    return vlen - (buf->pos() - start_pos);
}

int SrsMp4BaseDescriptor::nb_bytes()
{
    // 1 byte tag.
    int size = 1;
    
    // 1-3 bytes size.
    int32_t length = vlen = nb_payload(); // bit(8) to bit(32)
    if (length > 0x1fffff) {
        size += 4;
    } else if (length > 0x3fff) {
        size += 3;
    } else if (length > 0x7f) {
        size += 2;
    } else {
        size += 1;
    }
    
    // length bytes payload.
    size += length;
    
    return size;
}

srs_error_t SrsMp4BaseDescriptor::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    int size = nb_bytes();
    if (!buf->require(size)) {
        return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "ES requires %d only %d bytes", size, buf->left());
    }
    
    buf->write_1bytes((uint8_t)tag);
    
    // As an expandable class the size of each class instance in bytes is encoded and accessible
    // through the instance variable sizeOfInstance (see 8.3.3).
    int32_t length = vlen; // bit(8) to bit(32)
    srs_assert(vlen > 0);
    
    if (length > 0x1fffff) {
        buf->write_1bytes(uint8_t(length>>21)|0x80);
    }
    if (length > 0x3fff) {
        buf->write_1bytes(uint8_t(length>>14)|0x80);
    }
    if (length > 0x7f) {
        buf->write_1bytes(uint8_t(length>>7)|0x80);
    }
    buf->write_1bytes(length&0x7f);
    
    if ((err = encode_payload(buf)) != srs_success) {
        return srs_error_wrap(err, "encode payload");
    }
    
    return err;
}

srs_error_t SrsMp4BaseDescriptor::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    int size = nb_bytes();
    if (!buf->require(size)) {
        return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "requires %d only %d bytes", size, buf->left());
    }
    
    tag = (SrsMp4ESTagEs)buf->read_1bytes();
    
    uint8_t v = 0x80;
    int32_t length = 0x00;
    while ((v&0x80) == 0x80) {
        if (!buf->require(1)) {
            return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "ES requires 1 only %d bytes", buf->left());
        }
        v = buf->read_1bytes();
        
        length = (length<<7) | (v&0x7f);
    }
    vlen = length;
    
    if (!buf->require(vlen)) {
        return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "ES requires %d only %d bytes", vlen, buf->left());
    }
    
    start_pos = buf->pos();
    
    if ((err = decode_payload(buf)) != srs_success) {
        return srs_error_wrap(err, "decode payload");
    }
    
    return err;
}

stringstream& SrsMp4BaseDescriptor::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    ss << ", tag=" << "0x" << std::setw(2) << std::setfill('0') << std::hex << (uint32_t)(uint8_t)tag << std::dec;
    return ss;
}

SrsMp4DecoderSpecificInfo::SrsMp4DecoderSpecificInfo()
{
    tag = SrsMp4ESTagESDecSpecificInfoTag;
}

SrsMp4DecoderSpecificInfo::~SrsMp4DecoderSpecificInfo()
{
}

int32_t SrsMp4DecoderSpecificInfo::nb_payload()
{
    return (int)asc.size();
}

srs_error_t SrsMp4DecoderSpecificInfo::encode_payload(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if (!asc.empty()) {
        buf->write_bytes(&asc[0], (int)asc.size());
    }
    
    return err;
}

srs_error_t SrsMp4DecoderSpecificInfo::decode_payload(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    int nb_asc = vlen;
    if (nb_asc) {
        asc.resize(nb_asc);
        buf->read_bytes(&asc[0], nb_asc);
    }
    
    return err;
}

stringstream& SrsMp4DecoderSpecificInfo::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4BaseDescriptor::dumps_detail(ss, dc);
    
    ss << ", ASC " << asc.size() << "B";
    
    ss << endl;
    srs_padding(ss, dc.indent());
    return srs_print_bytes(ss, (const char*)&asc[0], (int)asc.size(), dc.indent());
}

SrsMp4DecoderConfigDescriptor::SrsMp4DecoderConfigDescriptor() : upStream(0), bufferSizeDB(0), maxBitrate(0), avgBitrate(0)
{
    tag = SrsMp4ESTagESDecoderConfigDescrTag;
    objectTypeIndication = SrsMp4ObjectTypeForbidden;
    streamType = SrsMp4StreamTypeForbidden;
    decSpecificInfo = NULL;
    reserved = 1;
}

SrsMp4DecoderConfigDescriptor::~SrsMp4DecoderConfigDescriptor()
{
    srs_freep(decSpecificInfo);
}

int32_t SrsMp4DecoderConfigDescriptor::nb_payload()
{
    return 13 + (decSpecificInfo? decSpecificInfo->nb_bytes():0);
}

srs_error_t SrsMp4DecoderConfigDescriptor::encode_payload(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    buf->write_1bytes(objectTypeIndication);
    
    uint8_t v = reserved;
    v |= (upStream&0x01)<<1;
    v |= uint8_t(streamType&0x3f)<<2;
    buf->write_1bytes(v);
    
    buf->write_3bytes(bufferSizeDB);
    buf->write_4bytes(maxBitrate);
    buf->write_4bytes(avgBitrate);
    
    if (decSpecificInfo && (err = decSpecificInfo->encode(buf)) != srs_success) {
        return srs_error_wrap(err, "encode des specific info");
    }
    
    return err;
}

srs_error_t SrsMp4DecoderConfigDescriptor::decode_payload(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    objectTypeIndication = (SrsMp4ObjectType)buf->read_1bytes();
    
    uint8_t v = buf->read_1bytes();
    upStream = (v>>1) & 0x01;
    streamType = (SrsMp4StreamType)((v>>2) & 0x3f);
    reserved = v&0x01;
    
    bufferSizeDB = buf->read_3bytes();
    maxBitrate = buf->read_4bytes();
    avgBitrate = buf->read_4bytes();
    
    int left = left_space(buf);
    if (left > 0) {
        decSpecificInfo = new SrsMp4DecoderSpecificInfo();
        if ((err = decSpecificInfo->decode(buf)) != srs_success) {
            return srs_error_wrap(err, "decode dec specific info");
        }
    }
    
    return err;
}

stringstream& SrsMp4DecoderConfigDescriptor::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4BaseDescriptor::dumps_detail(ss, dc);
    
    ss << ", type=" << objectTypeIndication << ", stream=" << streamType;
    
    ss << endl;
    srs_padding(ss, dc.indent());
    
    ss << "decoder specific";
    return decSpecificInfo->dumps_detail(ss, dc.indent());
}

SrsMp4SLConfigDescriptor::SrsMp4SLConfigDescriptor()
{
    tag = SrsMp4ESTagESSLConfigDescrTag;
    predefined = 2;
}

SrsMp4SLConfigDescriptor::~SrsMp4SLConfigDescriptor()
{
}

int32_t SrsMp4SLConfigDescriptor::nb_payload()
{
    return 1;
}

srs_error_t SrsMp4SLConfigDescriptor::encode_payload(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    buf->write_1bytes(predefined);
    
    return err;
}

srs_error_t SrsMp4SLConfigDescriptor::decode_payload(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    predefined = buf->read_1bytes();
    
    // TODO: FIXME: To support complete SL Config.
    if (predefined != 0x02) {
        return srs_error_new(ERROR_MP4_ESDS_SL_Config, "illegal ESDS SL Config, predefined=%d", predefined);
    }
    
    return err;
}

SrsMp4ES_Descriptor::SrsMp4ES_Descriptor() : ES_ID(0), dependsOn_ES_ID(0), OCR_ES_Id(0)
{
    tag = SrsMp4ESTagESDescrTag;
    streamPriority = streamDependenceFlag = URL_Flag = OCRstreamFlag = 0;
}

SrsMp4ES_Descriptor::~SrsMp4ES_Descriptor()
{
}

int32_t SrsMp4ES_Descriptor::nb_payload()
{
    int size = 2 +1;
    size += streamDependenceFlag? 2:0;
    if (URL_Flag) {
        size += 1 + URLstring.size();
    }
    size += OCRstreamFlag? 2:0;
    size += decConfigDescr.nb_bytes() +slConfigDescr.nb_bytes();
    return size;
}

srs_error_t SrsMp4ES_Descriptor::encode_payload(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    buf->write_2bytes(ES_ID);
    
    uint8_t v = streamPriority & 0x1f;
    v |= (streamDependenceFlag & 0x01) << 7;
    v |= (URL_Flag & 0x01) << 6;
    v |= (OCRstreamFlag & 0x01) << 5;
    buf->write_1bytes(v);
    
    if (streamDependenceFlag) {
        buf->write_2bytes(dependsOn_ES_ID);
    }
    
    if (URL_Flag && !URLstring.empty()) {
        buf->write_1bytes(URLstring.size());
        buf->write_bytes(&URLstring[0], (int)URLstring.size());
    }
    
    if (OCRstreamFlag) {
        buf->write_2bytes(OCR_ES_Id);
    }
    
    if ((err = decConfigDescr.encode(buf)) != srs_success) {
        return srs_error_wrap(err, "encode dec config");
    }
    
    if ((err = slConfigDescr.encode(buf)) != srs_success) {
        return srs_error_wrap(err, "encode sl config");
    }
    
    return err;
}

srs_error_t SrsMp4ES_Descriptor::decode_payload(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    ES_ID = buf->read_2bytes();
    
    uint8_t v = buf->read_1bytes();
    streamPriority = v & 0x1f;
    streamDependenceFlag = (v >> 7) & 0x01;
    URL_Flag = (v >> 6) & 0x01;
    OCRstreamFlag = (v >> 5) & 0x01;
    
    if (streamDependenceFlag) {
        if (!buf->require(2)) {
            return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "ES requires 2 only %v bytes", buf->left());
        }
        dependsOn_ES_ID = buf->read_2bytes();
    }
    
    if (URL_Flag) {
        if (!buf->require(1)) {
            return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "URLlength requires 1 only %v bytes", buf->left());
        }
        uint8_t URLlength = buf->read_1bytes();
        
        if (!buf->require(URLlength)) {
            return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "URL requires %d only %v bytes", URLlength, buf->left());
        }
        URLstring.resize(URLlength);
        buf->read_bytes(&URLstring[0], URLlength);
    }
    
    if (OCRstreamFlag) {
        if (!buf->require(2)) {
            return srs_error_new(ERROR_MP4_BOX_REQUIRE_SPACE, "OCR requires 2 only %v bytes", buf->left());
        }
        OCR_ES_Id = buf->read_2bytes();
    }
    
    if ((err = decConfigDescr.decode(buf)) != srs_success) {
        return srs_error_wrap(err, "decode dec config");
    }
    
    if ((err = slConfigDescr.decode(buf)) != srs_success) {
        return srs_error_wrap(err, "decode sl config");
    }
    
    return err;
}

stringstream& SrsMp4ES_Descriptor::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4BaseDescriptor::dumps_detail(ss, dc);
    
    ss << ", ID=" << ES_ID;
    
    ss << endl;
    srs_padding(ss, dc.indent());
    
    ss << "decoder config";
    decConfigDescr.dumps_detail(ss, dc.indent());
    return ss;
}

SrsMp4EsdsBox::SrsMp4EsdsBox()
{
    type = SrsMp4BoxTypeESDS;
    es = new SrsMp4ES_Descriptor();
}

SrsMp4EsdsBox::~SrsMp4EsdsBox()
{
    srs_freep(es);
}

SrsMp4DecoderSpecificInfo* SrsMp4EsdsBox::asc()
{
    return es->decConfigDescr.decSpecificInfo;
}

int SrsMp4EsdsBox::nb_header()
{
    return SrsMp4FullBox::nb_header() + es->nb_bytes();
}

srs_error_t SrsMp4EsdsBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    int left = left_space(buf);
    SrsBuffer buffer(buf->data() + buf->pos(), left);
    if ((err = es->encode(&buffer)) != srs_success) {
        return srs_error_wrap(err, "encode es");
    }
    
    buf->skip(buffer.pos());
    
    return err;
}

srs_error_t SrsMp4EsdsBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    int left = left_space(buf);
    SrsBuffer buffer(buf->data() + buf->pos(), left);
    if ((err = es->decode(&buffer)) != srs_success) {
        return srs_error_wrap(err, "decode es");
    }
    
    buf->skip(buffer.pos());
    
    return err;
}

stringstream& SrsMp4EsdsBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    return es->dumps_detail(ss, dc);
}

SrsMp4SampleDescriptionBox::SrsMp4SampleDescriptionBox()
{
    type = SrsMp4BoxTypeSTSD;
}

SrsMp4SampleDescriptionBox::~SrsMp4SampleDescriptionBox()
{
    vector<SrsMp4SampleEntry*>::iterator it;
    for (it = entries.begin(); it != entries.end(); ++it) {
        SrsMp4SampleEntry* entry = *it;
        srs_freep(entry);
    }
    entries.clear();
}

SrsMp4VisualSampleEntry* SrsMp4SampleDescriptionBox::avc1()
{
    vector<SrsMp4SampleEntry*>::iterator it;
    for (it = entries.begin(); it != entries.end(); ++it) {
        SrsMp4SampleEntry* entry = *it;
        if (entry->type == SrsMp4BoxTypeAVC1) {
            return dynamic_cast<SrsMp4VisualSampleEntry*>(entry);
        }
    }
    return NULL;
}

SrsMp4AudioSampleEntry* SrsMp4SampleDescriptionBox::mp4a()
{
    vector<SrsMp4SampleEntry*>::iterator it;
    for (it = entries.begin(); it != entries.end(); ++it) {
        SrsMp4SampleEntry* entry = *it;
        if (entry->type == SrsMp4BoxTypeMP4A) {
            return dynamic_cast<SrsMp4AudioSampleEntry*>(entry);
        }
    }
    return NULL;
}

uint32_t SrsMp4SampleDescriptionBox::entry_count()
{
    return (uint32_t)entries.size();
}

SrsMp4SampleEntry* SrsMp4SampleDescriptionBox::entrie_at(int index)
{
    return entries.at(index);
}

SrsMp4SampleDescriptionBox* SrsMp4SampleDescriptionBox::append(SrsMp4SampleEntry* v)
{
    entries.push_back(v);
    return this;
}

int SrsMp4SampleDescriptionBox::nb_header()
{
    int size = SrsMp4FullBox::nb_header();
    
    size += 4;
    
    vector<SrsMp4SampleEntry*>::iterator it;
    for (it = entries.begin(); it != entries.end(); ++it) {
        SrsMp4SampleEntry* entry = *it;
        size += entry->nb_bytes();
    }
    
    return size;
}

srs_error_t SrsMp4SampleDescriptionBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes(entry_count());
    
    vector<SrsMp4SampleEntry*>::iterator it;
    for (it = entries.begin(); it != entries.end(); ++it) {
        SrsMp4SampleEntry* entry = *it;
        if ((err = entry->encode(buf)) != srs_success) {
            return srs_error_wrap(err, "encode entry");
        }
    }
    
    return err;
}

srs_error_t SrsMp4SampleDescriptionBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    uint32_t nb_entries = buf->read_4bytes();
    for (uint32_t i = 0; i < nb_entries; i++) {
        SrsMp4Box* box = NULL;
        if ((err = SrsMp4Box::discovery(buf, &box)) != srs_success) {
            return srs_error_wrap(err, "discovery box");
        }
        
        if ((err = box->decode(buf)) != srs_success) {
            return srs_error_wrap(err, "decode box");
        }
        
        SrsMp4SampleEntry* entry = dynamic_cast<SrsMp4SampleEntry*>(box);
        if (entry) {
            entries.push_back(entry);
        } else {
            srs_freep(box);
        }
    }
    
    return err;
}

bool SrsMp4SampleDescriptionBox::boxes_in_header()
{
    return true;
}

stringstream& SrsMp4SampleDescriptionBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", " << entries.size() << " childs";
    if (!entries.empty()) {
        ss << "(+)" << endl;
        srs_dumps_array(entries, ss, dc.indent(), srs_pfn_pbox, srs_delimiter_newline);
    }
    return ss;
}

SrsMp4SttsEntry::SrsMp4SttsEntry()
{
    sample_count = 0;
    sample_delta = 0;
}

stringstream& SrsMp4SttsEntry::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    ss << "count=" << sample_count << ", delta=" << sample_delta;
    return ss;
}

SrsMp4DecodingTime2SampleBox::SrsMp4DecodingTime2SampleBox()
{
    type = SrsMp4BoxTypeSTTS;
    
    index = count = 0;
}

SrsMp4DecodingTime2SampleBox::~SrsMp4DecodingTime2SampleBox()
{
}

srs_error_t SrsMp4DecodingTime2SampleBox::initialize_counter()
{
    srs_error_t err = srs_success;
    
    index = 0;
    if (index >= entries.size()) {
        return srs_error_new(ERROR_MP4_ILLEGAL_TIMESTAMP, "illegal ts, empty stts");
    }
    
    count = entries[0].sample_count;
    
    return err;
}

srs_error_t SrsMp4DecodingTime2SampleBox::on_sample(uint32_t sample_index, SrsMp4SttsEntry** ppentry)
{
    srs_error_t err = srs_success;
    
    if (sample_index + 1 > count) {
        index++;
        
        if (index >= entries.size()) {
            return srs_error_new(ERROR_MP4_ILLEGAL_TIMESTAMP, "illegal ts, stts overflow, count=%d", entries.size());
        }
        
        count += entries[index].sample_count;
    }
    
    *ppentry = &entries[index];
    
    return err;
}

int SrsMp4DecodingTime2SampleBox::nb_header()
{
    return SrsMp4FullBox::nb_header() + 4 + 8 * (int)entries.size();
}

srs_error_t SrsMp4DecodingTime2SampleBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes((int)entries.size());
    for (size_t i = 0; i < entries.size(); i++) {
        SrsMp4SttsEntry& entry = entries[i];
        buf->write_4bytes(entry.sample_count);
        buf->write_4bytes(entry.sample_delta);
    }
    
    return err;
}

srs_error_t SrsMp4DecodingTime2SampleBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    uint32_t entry_count = buf->read_4bytes();
    if (entry_count) {
        entries.resize(entry_count);
    }
    for (size_t i = 0; i < entry_count; i++) {
        SrsMp4SttsEntry& entry = entries[i];
        entry.sample_count = buf->read_4bytes();
        entry.sample_delta = buf->read_4bytes();
    }
    
    return err;
}

stringstream& SrsMp4DecodingTime2SampleBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", " << entries.size() << " childs (+)";
    if (!entries.empty()) {
        ss << endl;
        srs_padding(ss, dc.indent());
        srs_dumps_array(entries, ss, dc.indent(), srs_pfn_detail, srs_delimiter_newline);
    }
    return ss;
}

SrsMp4CttsEntry::SrsMp4CttsEntry()
{
    sample_count = 0;
    sample_offset = 0;
}

stringstream& SrsMp4CttsEntry::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    ss << "count=" << sample_count << ", offset=" << sample_offset;
    return ss;
}

SrsMp4CompositionTime2SampleBox::SrsMp4CompositionTime2SampleBox()
{
    type = SrsMp4BoxTypeCTTS;
    
    index = count = 0;
}

SrsMp4CompositionTime2SampleBox::~SrsMp4CompositionTime2SampleBox()
{
}

srs_error_t SrsMp4CompositionTime2SampleBox::initialize_counter()
{
    srs_error_t err = srs_success;
    
    index = 0;
    if (index >= entries.size()) {
        return srs_error_new(ERROR_MP4_ILLEGAL_TIMESTAMP, "illegal ts, empty ctts");
    }
    
    count = entries[0].sample_count;
    
    return err;
}

srs_error_t SrsMp4CompositionTime2SampleBox::on_sample(uint32_t sample_index, SrsMp4CttsEntry** ppentry)
{
    srs_error_t err = srs_success;
    
    if (sample_index + 1 > count) {
        index++;
        
        if (index >= entries.size()) {
            return srs_error_new(ERROR_MP4_ILLEGAL_TIMESTAMP, "illegal ts, ctts overflow, count=%d", entries.size());
        }
        
        count += entries[index].sample_count;
    }
    
    *ppentry = &entries[index];
    
    return err;
}

int SrsMp4CompositionTime2SampleBox::nb_header()
{
    return SrsMp4FullBox::nb_header() + 4 + 8 * (int)entries.size();
}

srs_error_t SrsMp4CompositionTime2SampleBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes((int)entries.size());
    for (size_t i = 0; i < entries.size(); i++) {
        SrsMp4CttsEntry& entry = entries[i];
        buf->write_4bytes(entry.sample_count);
        if (version == 0) {
            buf->write_4bytes((uint32_t)entry.sample_offset);
        } else if (version == 1) {
            buf->write_4bytes((int32_t)entry.sample_offset);
        }
    }
    
    return err;
}

srs_error_t SrsMp4CompositionTime2SampleBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    uint32_t entry_count = buf->read_4bytes();
    if (entry_count) {
        entries.resize(entry_count);
    }
    for (size_t i = 0; i < entry_count; i++) {
        SrsMp4CttsEntry& entry = entries[i];
        entry.sample_count = buf->read_4bytes();
        if (version == 0) {
            entry.sample_offset = (uint32_t)buf->read_4bytes();
        } else if (version == 1) {
            entry.sample_offset = (int32_t)buf->read_4bytes();
        }
    }
    
    return err;
}

stringstream& SrsMp4CompositionTime2SampleBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", " << entries.size() << " childs (+)";
    if (!entries.empty()) {
        ss << endl;
        srs_padding(ss, dc.indent());
        srs_dumps_array(entries, ss, dc.indent(), srs_pfn_detail, srs_delimiter_newline);
    }
    return ss;
}

SrsMp4SyncSampleBox::SrsMp4SyncSampleBox()
{
    type = SrsMp4BoxTypeSTSS;
    
    entry_count = 0;
    sample_numbers = NULL;
}

SrsMp4SyncSampleBox::~SrsMp4SyncSampleBox()
{
    srs_freepa(sample_numbers);
}

bool SrsMp4SyncSampleBox::is_sync(uint32_t sample_index)
{
    for (uint32_t i = 0; i < entry_count; i++) {
        if (sample_index + 1 == sample_numbers[i]) {
            return true;
        }
    }
    return false;
}

int SrsMp4SyncSampleBox::nb_header()
{
    return SrsMp4FullBox::nb_header() +4 +4*entry_count;
}

srs_error_t SrsMp4SyncSampleBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes(entry_count);
    for (uint32_t i = 0; i < entry_count; i++) {
        uint32_t sample_number = sample_numbers[i];
        buf->write_4bytes(sample_number);
    }
    
    return err;
}

srs_error_t SrsMp4SyncSampleBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    entry_count = buf->read_4bytes();
    if (entry_count > 0) {
        sample_numbers = new uint32_t[entry_count];
    }
    for (uint32_t i = 0; i < entry_count; i++) {
        sample_numbers[i] = buf->read_4bytes();
    }
    
    return err;
}

stringstream& SrsMp4SyncSampleBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", count=" << entry_count;
    if (entry_count > 0) {
        ss << endl;
        srs_padding(ss, dc.indent());
        srs_dumps_array(sample_numbers, entry_count, ss, dc.indent(), srs_pfn_elems, srs_delimiter_inlinespace);
    }
    return ss;
}

SrsMp4StscEntry::SrsMp4StscEntry()
{
    first_chunk = 0;
    samples_per_chunk = 0;
    sample_description_index = 0;
}

stringstream& SrsMp4StscEntry::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    ss << "first=" << first_chunk << ", samples=" << samples_per_chunk << ", index=" << sample_description_index;
    return ss;
}

SrsMp4Sample2ChunkBox::SrsMp4Sample2ChunkBox()
{
    type = SrsMp4BoxTypeSTSC;
    
    entry_count = 0;
    entries = NULL;
    index = 0;
}

SrsMp4Sample2ChunkBox::~SrsMp4Sample2ChunkBox()
{
    srs_freepa(entries);
}

void SrsMp4Sample2ChunkBox::initialize_counter()
{
    index = 0;
}

SrsMp4StscEntry* SrsMp4Sample2ChunkBox::on_chunk(uint32_t chunk_index)
{
    // Last chunk?
    if (index >= entry_count - 1) {
        return &entries[index];
    }
    
    // Move next chunk?
    if (chunk_index + 1 >= entries[index + 1].first_chunk) {
        index++;
    }
    return &entries[index];
}

int SrsMp4Sample2ChunkBox::nb_header()
{
    return SrsMp4FullBox::nb_header() +4 + 12*entry_count;
}

srs_error_t SrsMp4Sample2ChunkBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes(entry_count);
    for (uint32_t i = 0; i < entry_count; i++) {
        SrsMp4StscEntry& entry = entries[i];
        buf->write_4bytes(entry.first_chunk);
        buf->write_4bytes(entry.samples_per_chunk);
        buf->write_4bytes(entry.sample_description_index);
    }
    
    return err;
}

srs_error_t SrsMp4Sample2ChunkBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    entry_count = buf->read_4bytes();
    if (entry_count) {
        entries = new SrsMp4StscEntry[entry_count];
    }
    for (uint32_t i = 0; i < entry_count; i++) {
        SrsMp4StscEntry& entry = entries[i];
        entry.first_chunk = buf->read_4bytes();
        entry.samples_per_chunk = buf->read_4bytes();
        entry.sample_description_index = buf->read_4bytes();
    }
    
    return err;
}

stringstream& SrsMp4Sample2ChunkBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", " << entry_count << " childs (+)";
    if (entry_count > 0) {
        ss << endl;
        srs_padding(ss, dc.indent());
        srs_dumps_array(entries, entry_count, ss, dc.indent(), srs_pfn_detail, srs_delimiter_newline);
    }
    return ss;
}

SrsMp4ChunkOffsetBox::SrsMp4ChunkOffsetBox()
{
    type = SrsMp4BoxTypeSTCO;
    
    entry_count = 0;
    entries = NULL;
}

SrsMp4ChunkOffsetBox::~SrsMp4ChunkOffsetBox()
{
    srs_freepa(entries);
}

int SrsMp4ChunkOffsetBox::nb_header()
{
    return SrsMp4FullBox::nb_header() +4 +4*entry_count;
}

srs_error_t SrsMp4ChunkOffsetBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes(entry_count);
    for (uint32_t i = 0; i < entry_count; i++) {
        buf->write_4bytes(entries[i]);
    }
    
    return err;
}

srs_error_t SrsMp4ChunkOffsetBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    entry_count = buf->read_4bytes();
    if (entry_count) {
        entries = new uint32_t[entry_count];
    }
    for (uint32_t i = 0; i < entry_count; i++) {
        entries[i] = buf->read_4bytes();
    }
    
    return err;
}

stringstream& SrsMp4ChunkOffsetBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", " << entry_count << " childs (+)";
    if (entry_count > 0) {
        ss << endl;
        srs_padding(ss, dc.indent());
        srs_dumps_array(entries, entry_count, ss, dc.indent(), srs_pfn_elems, srs_delimiter_inlinespace);
    }
    return ss;
}

SrsMp4ChunkLargeOffsetBox::SrsMp4ChunkLargeOffsetBox()
{
    type = SrsMp4BoxTypeCO64;
    
    entry_count = 0;
    entries = NULL;
}

SrsMp4ChunkLargeOffsetBox::~SrsMp4ChunkLargeOffsetBox()
{
    srs_freepa(entries);
}

int SrsMp4ChunkLargeOffsetBox::nb_header()
{
    return SrsMp4FullBox::nb_header() +4 +8*entry_count;
}

srs_error_t SrsMp4ChunkLargeOffsetBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes(entry_count);
    for (uint32_t i = 0; i < entry_count; i++) {
        buf->write_8bytes(entries[i]);
    }
    
    return err;
}

srs_error_t SrsMp4ChunkLargeOffsetBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    entry_count = buf->read_4bytes();
    if (entry_count) {
        entries = new uint64_t[entry_count];
    }
    for (uint32_t i = 0; i < entry_count; i++) {
        entries[i] = buf->read_8bytes();
    }
    
    return err;
}

stringstream& SrsMp4ChunkLargeOffsetBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", " << entry_count << " childs (+)";
    if (entry_count > 0) {
        ss << endl;
        srs_padding(ss, dc.indent());
        srs_dumps_array(entries, entry_count, ss, dc.indent(), srs_pfn_elems, srs_delimiter_inlinespace);
    }
    return ss;
}

SrsMp4SampleSizeBox::SrsMp4SampleSizeBox()
{
    type = SrsMp4BoxTypeSTSZ;
    
    sample_size = sample_count = 0;
    entry_sizes = NULL;
}

SrsMp4SampleSizeBox::~SrsMp4SampleSizeBox()
{
    srs_freepa(entry_sizes);
}

srs_error_t SrsMp4SampleSizeBox::get_sample_size(uint32_t sample_index, uint32_t* psample_size)
{
    srs_error_t err = srs_success;
    
    if (sample_size != 0) {
        *psample_size = sample_size;
        return err;
    }
    
    if (sample_index >= sample_count) {
        return srs_error_new(ERROR_MP4_MOOV_OVERFLOW, "stsz overflow, sample_count=%d", sample_count);
    }
    *psample_size = entry_sizes[sample_index];
    
    return err;
}

int SrsMp4SampleSizeBox::nb_header()
{
    int size = SrsMp4FullBox::nb_header() +4+4;
    if (sample_size == 0) {
        size += 4*sample_count;
    }
    return size;
}

srs_error_t SrsMp4SampleSizeBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    buf->write_4bytes(sample_size);
    buf->write_4bytes(sample_count);
    for (uint32_t i = 0; i < sample_count && sample_size == 0; i++) {
        buf->write_4bytes(entry_sizes[i]);
    }
    
    return err;
}

srs_error_t SrsMp4SampleSizeBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4FullBox::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    sample_size = buf->read_4bytes();
    sample_count = buf->read_4bytes();
    if (!sample_size && sample_count) {
        entry_sizes = new uint32_t[sample_count];
    }
    for (uint32_t i = 0; i < sample_count && sample_size == 0; i++) {
        entry_sizes[i] = buf->read_4bytes();
    }
    
    return err;
}

stringstream& SrsMp4SampleSizeBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4FullBox::dumps_detail(ss, dc);
    
    ss << ", size=" << sample_size << ", " << sample_count << " childs (+)";
    if (!sample_size  && sample_count> 0) {
        ss << endl;
        srs_padding(ss, dc.indent());
        srs_dumps_array(entry_sizes, sample_count, ss, dc.indent(), srs_pfn_elems, srs_delimiter_inlinespace);
    }
    return ss;
}

SrsMp4UserDataBox::SrsMp4UserDataBox()
{
    type = SrsMp4BoxTypeUDTA;
}

SrsMp4UserDataBox::~SrsMp4UserDataBox()
{
}

int SrsMp4UserDataBox::nb_header()
{
    return SrsMp4Box::nb_header() + (int)data.size();
}

srs_error_t SrsMp4UserDataBox::encode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::encode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    }
    
    if (!data.empty()) {
        buf->write_bytes(&data[0], (int)data.size());
    }
    
    return err;
}

srs_error_t SrsMp4UserDataBox::decode_header(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsMp4Box::decode_header(buf)) != srs_success) {
        return srs_error_wrap(err, "decode header");
    }
    
    int nb_data = left_space(buf);
    if (nb_data) {
        data.resize(nb_data);
        buf->read_bytes(&data[0], (int)data.size());
    }
    
    return err;
}

stringstream& SrsMp4UserDataBox::dumps_detail(stringstream& ss, SrsMp4DumpContext dc)
{
    SrsMp4Box::dumps_detail(ss, dc);
    
    ss << ", total " << data.size() << "B";
    
    if (!data.empty()) {
        ss << endl;
        srs_padding(ss, dc.indent());
        srs_dumps_array(&data[0], (int)data.size(), ss, dc.indent(), srs_pfn_hex, srs_delimiter_inlinespace);
    }
    return ss;
}

SrsMp4Sample::SrsMp4Sample()
{
    type = SrsFrameTypeForbidden;
    offset = 0;
    index = 0;
    dts = pts = 0;
    nb_data = 0;
    data = NULL;
    frame_type = SrsVideoAvcFrameTypeForbidden;
    tbn = 0;
    adjust = 0;
}

SrsMp4Sample::~SrsMp4Sample()
{
    srs_freepa(data);
}

uint32_t SrsMp4Sample::dts_ms()
{
    return (uint32_t)(dts * 1000 / tbn) + adjust;
}

uint32_t SrsMp4Sample::pts_ms()
{
    return (uint32_t)(pts * 1000 / tbn) + adjust;
}

SrsMp4SampleManager::SrsMp4SampleManager()
{
}

SrsMp4SampleManager::~SrsMp4SampleManager()
{
    vector<SrsMp4Sample*>::iterator it;
    for (it = samples.begin(); it != samples.end(); ++it) {
        SrsMp4Sample* sample = *it;
        srs_freep(sample);
    }
    samples.clear();
}

srs_error_t SrsMp4SampleManager::load(SrsMp4MovieBox* moov)
{
    srs_error_t err = srs_success;
    
    map<uint64_t, SrsMp4Sample*> tses;
    
    // Load samples from moov, merge to temp samples.
    if ((err = do_load(tses, moov)) != srs_success) {
        map<uint64_t, SrsMp4Sample*>::iterator it;
        for (it = tses.begin(); it != tses.end(); ++it) {
            SrsMp4Sample* sample = it->second;
            srs_freep(sample);
        }
        
        return srs_error_wrap(err, "load mp4");
    }
    
    // Dumps temp samples.
    // Adjust the sequence diff.
    int32_t maxp = 0;
    int32_t maxn = 0;
    if (true) {
        SrsMp4Sample* pvideo = NULL;
        map<uint64_t, SrsMp4Sample*>::iterator it;
        for (it = tses.begin(); it != tses.end(); ++it) {
            SrsMp4Sample* sample = it->second;
            samples.push_back(sample);
            
            if (sample->type == SrsFrameTypeVideo) {
                pvideo = sample;
            } else if (pvideo) {
                int32_t diff = sample->dts_ms() - pvideo->dts_ms();
                if (diff > 0) {
                    maxp = srs_max(maxp, diff);
                } else {
                    maxn = srs_min(maxn, diff);
                }
                pvideo = NULL;
            }
        }
    }
    
    // Adjust when one of maxp and maxn is zero,
    // that means we can adjust by add maxn or sub maxp,
    // notice that maxn is negative and maxp is positive.
    if (maxp * maxn == 0 && maxp + maxn != 0) {
        map<uint64_t, SrsMp4Sample*>::iterator it;
        for (it = tses.begin(); it != tses.end(); ++it) {
            SrsMp4Sample* sample = it->second;
            if (sample->type == SrsFrameTypeAudio) {
                sample->adjust = 0 - maxp - maxn;
            }
        }
    }
    
    return err;
}

SrsMp4Sample* SrsMp4SampleManager::at(uint32_t index)
{
    if (index >= samples.size() - 1) {
        return NULL;
    }
    return samples.at(index);
}

void SrsMp4SampleManager::append(SrsMp4Sample* sample)
{
    samples.push_back(sample);
}

srs_error_t SrsMp4SampleManager::write(SrsMp4MovieBox* moov)
{
    srs_error_t err = srs_success;
    
    SrsMp4TrackBox* vide = moov->video();
    if (vide) {
        bool has_cts = false;
        vector<SrsMp4Sample*>::iterator it;
        for (it = samples.begin(); it != samples.end(); ++it) {
            SrsMp4Sample* sample = *it;
            if (sample->dts != sample->pts) {
                has_cts = true;
                break;
            }
        }
        
        SrsMp4SampleTableBox* stbl = vide->stbl();
        
        SrsMp4DecodingTime2SampleBox* stts = new SrsMp4DecodingTime2SampleBox();
        stbl->set_stts(stts);
        
        SrsMp4SyncSampleBox* stss = new SrsMp4SyncSampleBox();
        stbl->set_stss(stss);
        
        SrsMp4CompositionTime2SampleBox* ctts = NULL;
        if (has_cts) {
            ctts = new SrsMp4CompositionTime2SampleBox();
            stbl->set_ctts(ctts);
        }
        
        SrsMp4Sample2ChunkBox* stsc = new SrsMp4Sample2ChunkBox();
        stbl->set_stsc(stsc);
        
        SrsMp4SampleSizeBox* stsz = new SrsMp4SampleSizeBox();
        stbl->set_stsz(stsz);
        
        SrsMp4ChunkOffsetBox* stco = new SrsMp4ChunkOffsetBox();
        stbl->set_stco(stco);
        
        if ((err = write_track(SrsFrameTypeVideo, stts, stss, ctts, stsc, stsz, stco)) != srs_success) {
            return srs_error_wrap(err, "write vide track");
        }
    }
    
    SrsMp4TrackBox* soun = moov->audio();
    if (soun) {
        SrsMp4SampleTableBox* stbl = soun->stbl();
        
        SrsMp4DecodingTime2SampleBox* stts = new SrsMp4DecodingTime2SampleBox();
        stbl->set_stts(stts);
        
        SrsMp4SyncSampleBox* stss = NULL;
        SrsMp4CompositionTime2SampleBox* ctts = NULL;
        
        SrsMp4Sample2ChunkBox* stsc = new SrsMp4Sample2ChunkBox();
        stbl->set_stsc(stsc);
        
        SrsMp4SampleSizeBox* stsz = new SrsMp4SampleSizeBox();
        stbl->set_stsz(stsz);
        
        SrsMp4ChunkOffsetBox* stco = new SrsMp4ChunkOffsetBox();
        stbl->set_stco(stco);
        
        if ((err = write_track(SrsFrameTypeAudio, stts, stss, ctts, stsc, stsz, stco)) != srs_success) {
            return srs_error_wrap(err, "write soun track");
        }
    }
    
    return err;
}

srs_error_t SrsMp4SampleManager::write(SrsMp4MovieFragmentBox* moof, uint64_t& dts)
{
    srs_error_t err = srs_success;
    
    SrsMp4TrackFragmentBox* traf = moof->traf();
    SrsMp4TrackFragmentRunBox* trun = traf->trun();
    
    trun->flags = SrsMp4TrunFlagsDataOffset | SrsMp4TrunFlagsSampleDuration
        | SrsMp4TrunFlagsSampleSize | SrsMp4TrunFlagsSampleFlag | SrsMp4TrunFlagsSampleCtsOffset;
    trun->sample_count = (uint32_t)samples.size();
    
    SrsMp4Sample* previous = NULL;
    
    vector<SrsMp4Sample*>::iterator it;
    for (it = samples.begin(); it != samples.end(); ++it) {
        SrsMp4Sample* sample = *it;
        SrsMp4TrunEntry* entry = new SrsMp4TrunEntry(trun);
        
        if (!previous) {
            previous = sample;
            entry->sample_flags = 0x02000000;
        } else {
            entry->sample_flags = 0x01000000;
        }
        
        entry->sample_duration = (uint32_t)srs_min(100, sample->dts - dts);
        if (entry->sample_duration == 0) {
            entry->sample_duration = 40;
        }
        dts = sample->dts;
        
        entry->sample_size = sample->nb_data;
        entry->sample_composition_time_offset = (int64_t)(sample->pts - sample->dts);
        if (entry->sample_composition_time_offset < 0) {
            trun->version = 1;
        }
        
        trun->entries.push_back(entry);
    }
    
    return err;
}

srs_error_t SrsMp4SampleManager::write_track(SrsFrameType track,
    SrsMp4DecodingTime2SampleBox* stts, SrsMp4SyncSampleBox* stss, SrsMp4CompositionTime2SampleBox* ctts,
    SrsMp4Sample2ChunkBox* stsc, SrsMp4SampleSizeBox* stsz, SrsMp4ChunkOffsetBox* stco)
{
    srs_error_t err = srs_success;
    
    SrsMp4SttsEntry stts_entry;
    vector<SrsMp4SttsEntry> stts_entries;
    
    SrsMp4CttsEntry ctts_entry;
    vector<SrsMp4CttsEntry> ctts_entries;
    
    vector<uint32_t> stsz_entries;
    vector<uint32_t> stco_entries;
    vector<uint32_t> stss_entries;
    
    SrsMp4Sample* previous = NULL;
    vector<SrsMp4Sample*>::iterator it;
    for (it = samples.begin(); it != samples.end(); ++it) {
        SrsMp4Sample* sample = *it;
        if (sample->type != track) {
            continue;
        }
        
        stsz_entries.push_back(sample->nb_data);
        stco_entries.push_back((uint32_t)sample->offset);
        
        if (sample->frame_type == SrsVideoAvcFrameTypeKeyFrame) {
            stss_entries.push_back(sample->index + 1);
        }
        
        if (stts) {
            if (previous) {
                uint32_t delta = (uint32_t)(sample->dts - previous->dts);
                if (stts_entry.sample_delta == 0 || stts_entry.sample_delta == delta) {
                    stts_entry.sample_delta = delta;
                    stts_entry.sample_count++;
                } else {
                    stts_entries.push_back(stts_entry);
                    stts_entry.sample_count = 1;
                    stts_entry.sample_delta = delta;
                }
            } else {
                // The first sample always in the STTS table.
                stts_entry.sample_count++;
            }
        }
        
        if (ctts) {
            int64_t offset = sample->pts - sample->dts;
            if (offset < 0) {
                ctts->version = 0x01;
            }
            if (ctts_entry.sample_count == 0 || ctts_entry.sample_offset == offset) {
                ctts_entry.sample_count++;
            } else {
                ctts_entries.push_back(ctts_entry);
                ctts_entry.sample_offset = offset;
                ctts_entry.sample_count = 1;
            }
        }
        
        previous = sample;
    }
    
    if (stts && stts_entry.sample_count) {
        stts_entries.push_back(stts_entry);
    }
    
    if (ctts && ctts_entry.sample_count) {
        ctts_entries.push_back(ctts_entry);
    }
    
    if (stts && !stts_entries.empty()) {
        stts->entries = stts_entries;
    }
    
    if (ctts && !ctts_entries.empty()) {
        ctts->entries = ctts_entries;
    }
    
    if (stsc) {
        stsc->entry_count = 1;
        stsc->entries = new SrsMp4StscEntry[1];
        
        SrsMp4StscEntry& v = stsc->entries[0];
        v.first_chunk = v.sample_description_index = v.samples_per_chunk = 1;
    }
    
    if (stsz && !stsz_entries.empty()) {
        stsz->sample_size = 0;
        stsz->sample_count = (uint32_t)stsz_entries.size();
        stsz->entry_sizes = new uint32_t[stsz->sample_count];
        for (int i = 0; i < (int)stsz->sample_count; i++) {
            stsz->entry_sizes[i] = stsz_entries.at(i);
        }
    }
    
    if (stco && !stco_entries.empty()) {
        stco->entry_count = (uint32_t)stco_entries.size();
        stco->entries = new uint32_t[stco->entry_count];
        for (int i = 0; i < (int)stco->entry_count; i++) {
            stco->entries[i] = stco_entries.at(i);
        }
    }
    
    if (stss && !stss_entries.empty()) {
        stss->entry_count = (uint32_t)stss_entries.size();
        stss->sample_numbers = new uint32_t[stss->entry_count];
        for (int i = 0; i < (int)stss->entry_count; i++) {
            stss->sample_numbers[i] = stss_entries.at(i);
        }
    }
    
    return err;
}

srs_error_t SrsMp4SampleManager::do_load(map<uint64_t, SrsMp4Sample*>& tses, SrsMp4MovieBox* moov)
{
    srs_error_t err = srs_success;
    
    SrsMp4TrackBox* vide = moov->video();
    if (vide) {
        SrsMp4MediaHeaderBox* mdhd = vide->mdhd();
        SrsMp4TrackType tt = vide->track_type();
        SrsMp4ChunkOffsetBox* stco = vide->stco();
        SrsMp4SampleSizeBox* stsz = vide->stsz();
        SrsMp4Sample2ChunkBox* stsc = vide->stsc();
        SrsMp4DecodingTime2SampleBox* stts = vide->stts();
        // The composition time to sample table is optional and must only be present if DT and CT differ for any samples.
        SrsMp4CompositionTime2SampleBox* ctts = vide->ctts();
        // If the sync sample box is not present, every sample is a sync sample.
        SrsMp4SyncSampleBox* stss = vide->stss();
        
        if (!mdhd || !stco || !stsz || !stsc || !stts) {
            return srs_error_new(ERROR_MP4_ILLEGAL_TRACK, "illegal track, empty mdhd/stco/stsz/stsc/stts, type=%d", tt);
        }
        
        if ((err = load_trak(tses, SrsFrameTypeVideo, mdhd, stco, stsz, stsc, stts, ctts, stss)) != srs_success) {
            return srs_error_wrap(err, "load vide track");
        }
    }
    
    SrsMp4TrackBox* soun = moov->audio();
    if (soun) {
        SrsMp4MediaHeaderBox* mdhd = soun->mdhd();
        SrsMp4TrackType tt = soun->track_type();
        SrsMp4ChunkOffsetBox* stco = soun->stco();
        SrsMp4SampleSizeBox* stsz = soun->stsz();
        SrsMp4Sample2ChunkBox* stsc = soun->stsc();
        SrsMp4DecodingTime2SampleBox* stts = soun->stts();
        
        if (!mdhd || !stco || !stsz || !stsc || !stts) {
            return srs_error_new(ERROR_MP4_ILLEGAL_TRACK, "illegal track, empty mdhd/stco/stsz/stsc/stts, type=%d", tt);
        }
        
        if ((err = load_trak(tses, SrsFrameTypeAudio, mdhd, stco, stsz, stsc, stts, NULL, NULL)) != srs_success) {
            return srs_error_wrap(err, "load soun track");
        }
    }
    
    return err;
}

srs_error_t SrsMp4SampleManager::load_trak(map<uint64_t, SrsMp4Sample*>& tses, SrsFrameType tt,
    SrsMp4MediaHeaderBox* mdhd, SrsMp4ChunkOffsetBox* stco, SrsMp4SampleSizeBox* stsz, SrsMp4Sample2ChunkBox* stsc,
    SrsMp4DecodingTime2SampleBox* stts, SrsMp4CompositionTime2SampleBox* ctts, SrsMp4SyncSampleBox* stss)
{
    srs_error_t err = srs_success;
    
    // Samples per chunk.
    stsc->initialize_counter();
    
    // DTS box.
    if ((err = stts->initialize_counter()) != srs_success) {
        return srs_error_wrap(err, "stts init counter");
    }
    
    // CTS/PTS box.
    if (ctts && (err = ctts->initialize_counter()) != srs_success) {
        return srs_error_wrap(err, "ctts init counter");
    }
    
    SrsMp4Sample* previous = NULL;
    
    // For each chunk offset.
    for (uint32_t ci = 0; ci < stco->entry_count; ci++) {
        // The sample offset relative in chunk.
        uint32_t sample_relative_offset = 0;
        
        // Find how many samples from stsc.
        SrsMp4StscEntry* stsc_entry = stsc->on_chunk(ci);
        for (uint32_t i = 0; i < stsc_entry->samples_per_chunk; i++) {
            SrsMp4Sample* sample = new SrsMp4Sample();
            sample->type = tt;
            sample->index = (previous? previous->index+1:0);
            sample->tbn = mdhd->timescale;
            sample->offset = stco->entries[ci] + sample_relative_offset;
            
            uint32_t sample_size = 0;
            if ((err = stsz->get_sample_size(sample->index, &sample_size)) != srs_success) {
                srs_freep(sample);
                return srs_error_wrap(err, "stsz get sample size");
            }
            sample_relative_offset += sample_size;
            
            SrsMp4SttsEntry* stts_entry = NULL;
            if ((err = stts->on_sample(sample->index, &stts_entry)) != srs_success) {
                srs_freep(sample);
                return srs_error_wrap(err, "stts on sample");
            }
            if (previous) {
                sample->pts = sample->dts = previous->dts + stts_entry->sample_delta;
            }
            
            SrsMp4CttsEntry* ctts_entry = NULL;
            if (ctts && (err = ctts->on_sample(sample->index, &ctts_entry)) != srs_success) {
                srs_freep(sample);
                return srs_error_wrap(err, "ctts on sample");
            }
            if (ctts_entry) {
                sample->pts = sample->dts + ctts_entry->sample_offset;
            }
            
            if (tt == SrsFrameTypeVideo) {
                if (!stss || stss->is_sync(sample->index)) {
                    sample->frame_type = SrsVideoAvcFrameTypeKeyFrame;
                } else {
                    sample->frame_type = SrsVideoAvcFrameTypeInterFrame;
                }
            }
            
            // Only set the sample size, read data from io when needed.
            sample->nb_data = sample_size;
            sample->data = NULL;
            
            previous = sample;
            tses[sample->offset] = sample;
        }
    }
    
    // Check total samples.
    if (previous && previous->index + 1 != stsz->sample_count) {
        return srs_error_new(ERROR_MP4_ILLEGAL_SAMPLES, "illegal samples count, expect=%d, actual=%d", stsz->sample_count, previous->index + 1);
    }
    
    return err;
}

SrsMp4BoxReader::SrsMp4BoxReader()
{
    rsio = NULL;
    buf = new char[SRS_MP4_BUF_SIZE];
}

SrsMp4BoxReader::~SrsMp4BoxReader()
{
    srs_freepa(buf);
}

srs_error_t SrsMp4BoxReader::initialize(ISrsReadSeeker* rs)
{
    rsio = rs;
    
    return srs_success;
}

srs_error_t SrsMp4BoxReader::read(SrsSimpleStream* stream, SrsMp4Box** ppbox)
{
    srs_error_t err = srs_success;
    
    SrsMp4Box* box = NULL;
    while (true) {
        // For the first time to read the box, maybe it's a basic box which is only 4bytes header.
        // When we disconvery the real box, we know the size of the whole box, then read again and decode it.
        uint64_t required = box? box->sz():4;
        
        // For mdat box, we only requires to decode the header.
        if (box && box->is_mdat()) {
            required = box->sz_header();
        }
        
        // Fill the stream util we can discovery box.
        while (stream->length() < (int)required) {
            ssize_t nread;
            if ((err = rsio->read(buf, SRS_MP4_BUF_SIZE, &nread)) != srs_success) {
                return srs_error_wrap(err, "load failed, nread=%d, required=%d", nread, required);
            }
            
            srs_assert(nread > 0);
            stream->append(buf, (int)nread);
        }
        
        SrsBuffer* buffer = new SrsBuffer(stream->bytes(), stream->length());
        SrsAutoFree(SrsBuffer, buffer);
        
        // Discovery the box with basic header.
        if (!box && (err = SrsMp4Box::discovery(buffer, &box)) != srs_success) {
            if (srs_error_code(err) == ERROR_MP4_BOX_REQUIRE_SPACE) {
                srs_freep(err);
                continue;
            }
            return srs_error_wrap(err, "load box failed");
        }
        
        // When box is discoveried, check whether we can demux the whole box.
        // For mdat, only the header is required.
        required = (box->is_mdat()? box->sz_header():box->sz());
        if (!buffer->require((int)required)) {
            continue;
        }
        
        if (err != srs_success) {
            srs_freep(box);
        } else {
            *ppbox = box;
        }
        
        break;
    }
    
    return err;
}

srs_error_t SrsMp4BoxReader::skip(SrsMp4Box* box, SrsSimpleStream* stream)
{
    srs_error_t err = srs_success;
    
    // For mdat, always skip the content.
    if (box->is_mdat()) {
        int offset = (int)(box->sz() - stream->length());
        if (offset < 0) {
            stream->erase(stream->length() + offset);
        } else {
            stream->erase(stream->length());
        }
        if (offset > 0 && (err = rsio->lseek(offset, SEEK_CUR, NULL)) != srs_success) {
            return srs_error_wrap(err, "io seek");
        }
    } else {
        // Remove the consumed bytes.
        stream->erase((int)box->sz());
    }
    
    return err;
}

SrsMp4Decoder::SrsMp4Decoder()
{
    rsio = NULL;
    brand = SrsMp4BoxBrandForbidden;
    stream = new SrsSimpleStream();
    vcodec = SrsVideoCodecIdForbidden;
    acodec = SrsAudioCodecIdForbidden;
    asc_written = avcc_written = false;
    sample_rate = SrsAudioSampleRateForbidden;
    sound_bits = SrsAudioSampleBitsForbidden;
    channels = SrsAudioChannelsForbidden;
    samples = new SrsMp4SampleManager();
    br = new SrsMp4BoxReader();
    current_index = 0;
    current_offset = 0;
}

SrsMp4Decoder::~SrsMp4Decoder()
{
    srs_freep(br);
    srs_freep(stream);
    srs_freep(samples);
}

srs_error_t SrsMp4Decoder::initialize(ISrsReadSeeker* rs)
{
    srs_error_t err = srs_success;
    
    srs_assert(rs);
    rsio = rs;
    
    if ((err = br->initialize(rs)) != srs_success) {
        return srs_error_wrap(err, "init box reader");
    }
    
    // For mdat before moov, we must reset the offset to the mdat.
    off_t offset = -1;
    
    while (true) {
        SrsMp4Box* box = NULL;
        
        if ((err = load_next_box(&box, 0)) != srs_success) {
            return srs_error_wrap(err, "load box");
        }
        
        if (box->is_ftyp()) {
            SrsMp4FileTypeBox* ftyp = dynamic_cast<SrsMp4FileTypeBox*>(box);
            if ((err = parse_ftyp(ftyp)) != srs_success) {
                return srs_error_wrap(err, "parse ftyp");
            }
        } else if (box->is_mdat()) {
            off_t cur = 0;
            if ((err = rsio->lseek(0, SEEK_CUR, &cur)) != srs_success) {
                return srs_error_wrap(err, "io seek");
            }
            offset = off_t(cur - box->sz());
        } else if (box->is_moov()) {
            SrsMp4MovieBox* moov = dynamic_cast<SrsMp4MovieBox*>(box);
            if ((err = parse_moov(moov)) != srs_success) {
                return srs_error_wrap(err, "parse moov");
            }
            break;
        }
        
        srs_freep(box);
    }
    
    if (brand == SrsMp4BoxBrandForbidden) {
        return srs_error_new(ERROR_MP4_BOX_ILLEGAL_SCHEMA, "missing ftyp");
    }
    
    // Set the offset to the mdat.
    if (offset >= 0) {
        if ((err = rsio->lseek(offset, SEEK_SET, &current_offset)) != srs_success) {
            return srs_error_wrap(err, "seek to mdat");
        }
    }
    
    return err;
}

srs_error_t SrsMp4Decoder::read_sample(SrsMp4HandlerType* pht, uint16_t* pft, uint16_t* pct, uint32_t* pdts, uint32_t* ppts, uint8_t** psample, uint32_t* pnb_sample)
{
    srs_error_t err = srs_success;
    
    if (!avcc_written && !pavcc.empty()) {
        avcc_written = true;
        *pdts = *ppts = 0;
        *pht = SrsMp4HandlerTypeVIDE;
        
        uint32_t nb_sample = *pnb_sample = (uint32_t)pavcc.size();
        uint8_t* sample = *psample = new uint8_t[nb_sample];
        memcpy(sample, &pavcc[0], nb_sample);
        
        *pft = SrsVideoAvcFrameTypeKeyFrame;
        *pct = SrsVideoAvcFrameTraitSequenceHeader;
        
        return err;
    }
    
    if (!asc_written && !pasc.empty()) {
        asc_written = true;
        *pdts = *ppts = 0;
        *pht = SrsMp4HandlerTypeSOUN;
        
        uint32_t nb_sample = *pnb_sample = (uint32_t)pasc.size();
        uint8_t* sample = *psample = new uint8_t[nb_sample];
        memcpy(sample, &pasc[0], nb_sample);
        
        *pft = 0x00;
        *pct = SrsAudioAacFrameTraitSequenceHeader;
        
        return err;
    }
    
    SrsMp4Sample* ps = samples->at(current_index++);
    if (!ps) {
        return srs_error_new(ERROR_SYSTEM_FILE_EOF, "EOF");
    }
    
    if (ps->type == SrsFrameTypeVideo) {
        *pht = SrsMp4HandlerTypeVIDE;
        *pct = SrsVideoAvcFrameTraitNALU;
    } else {
        *pht = SrsMp4HandlerTypeSOUN;
        *pct = SrsAudioAacFrameTraitRawData;
    }
    *pdts = ps->dts_ms();
    *ppts = ps->pts_ms();
    *pft = ps->frame_type;
    
    // Read sample from io, for we never preload the samples(too large).
    if (ps->offset != current_offset) {
        if ((err = rsio->lseek(ps->offset, SEEK_SET, &current_offset)) != srs_success) {
            return srs_error_wrap(err, "seek to sample");
        }
    }
    
    uint32_t nb_sample = ps->nb_data;
    uint8_t* sample = new uint8_t[nb_sample];
    // TODO: FIXME: Use fully read.
    if ((err = rsio->read(sample, nb_sample, NULL)) != srs_success) {
        srs_freepa(sample);
        return srs_error_wrap(err, "read sample");
    }
    
    *psample = sample;
    *pnb_sample = nb_sample;
    current_offset += nb_sample;
    
    return err;
}

srs_error_t SrsMp4Decoder::parse_ftyp(SrsMp4FileTypeBox* ftyp)
{
    srs_error_t err = srs_success;
    
    // File Type Box (ftyp)
    bool legal_brand = false;
    static SrsMp4BoxBrand legal_brands[] = {
        SrsMp4BoxBrandISOM, SrsMp4BoxBrandISO2, SrsMp4BoxBrandAVC1, SrsMp4BoxBrandMP41,
        SrsMp4BoxBrandISO5
    };
    for (int i = 0; i < (int)(sizeof(legal_brands)/sizeof(SrsMp4BoxBrand)); i++) {
        if (ftyp->major_brand == legal_brands[i]) {
            legal_brand = true;
            break;
        }
    }
    if (!legal_brand) {
        return srs_error_new(ERROR_MP4_BOX_ILLEGAL_BRAND, "brand is illegal, brand=%d", ftyp->major_brand);
    }
    
    brand = ftyp->major_brand;
    
    return err;
}

srs_error_t SrsMp4Decoder::parse_moov(SrsMp4MovieBox* moov)
{
    srs_error_t err = srs_success;
    
    SrsMp4MovieHeaderBox* mvhd = moov->mvhd();
    if (!mvhd) {
        return srs_error_new(ERROR_MP4_ILLEGAL_MOOV, "missing mvhd");
    }
    
    SrsMp4TrackBox* vide = moov->video();
    SrsMp4TrackBox* soun = moov->audio();
    if (!vide && !soun) {
        return srs_error_new(ERROR_MP4_ILLEGAL_MOOV, "missing audio and video track");
    }
    
    SrsMp4AudioSampleEntry* mp4a = soun? soun->mp4a():NULL;
    if (mp4a) {
        uint32_t sr = mp4a->samplerate>>16;
        if (sr >= 44100) {
            sample_rate = SrsAudioSampleRate44100;
        } else if (sr >= 22050) {
            sample_rate = SrsAudioSampleRate22050;
        } else if (sr >= 11025) {
            sample_rate = SrsAudioSampleRate11025;
        } else {
            sample_rate = SrsAudioSampleRate5512;
        }
        
        if (mp4a->samplesize == 16) {
            sound_bits = SrsAudioSampleBits16bit;
        } else {
            sound_bits = SrsAudioSampleBits8bit;
        }
        
        if (mp4a->channelcount == 2) {
            channels = SrsAudioChannelsStereo;
        } else {
            channels = SrsAudioChannelsMono;
        }
    }
    
    SrsMp4AvccBox* avcc = vide? vide->avcc():NULL;
    SrsMp4DecoderSpecificInfo* asc = soun? soun->asc():NULL;
    if (vide && !avcc) {
        return srs_error_new(ERROR_MP4_ILLEGAL_MOOV, "missing video sequence header");
    }
    if (soun && !asc) {
        return srs_error_new(ERROR_MP4_ILLEGAL_MOOV, "missing audio sequence header");
    }
    
    vcodec = vide?vide->vide_codec():SrsVideoCodecIdForbidden;
    acodec = soun?soun->soun_codec():SrsAudioCodecIdForbidden;
    
    if (avcc && !avcc->avc_config.empty()) {
        pavcc = avcc->avc_config;
    }
    if (asc && !asc->asc.empty()) {
        pasc = asc->asc;
    }
    
    // Build the samples structure from moov.
    if ((err = samples->load(moov)) != srs_success) {
        return srs_error_wrap(err, "load samples");
    }
    
    stringstream ss;
    ss << "dur=" << mvhd->duration() << "ms";
    // video codec.
    ss << ", vide=" << moov->nb_vide_tracks() << "("
        << srs_video_codec_id2str(vcodec) << "," << pavcc.size() << "BSH"
        << ")";
    // audio codec.
    ss << ", soun=" << moov->nb_soun_tracks() << "("
        << srs_audio_codec_id2str(acodec) << "," << pasc.size() << "BSH"
        << "," << srs_audio_channels2str(channels)
        << "," << srs_audio_sample_bits2str(sound_bits)
        << "," << srs_audio_sample_rate2str(sample_rate)
        << ")";
    
    srs_trace("MP4 moov %s", ss.str().c_str());
    
    return err;
}

srs_error_t SrsMp4Decoder::load_next_box(SrsMp4Box** ppbox, uint32_t required_box_type)
{
    srs_error_t err = srs_success;
    
    while (true) {
        SrsMp4Box* box = NULL;
        if ((err = do_load_next_box(&box, required_box_type)) != srs_success) {
            srs_freep(box);
            return srs_error_wrap(err, "load box");
        }
        
        if (!required_box_type || (uint32_t)box->type == required_box_type) {
            *ppbox = box;
            break;
        }
        srs_freep(box);
    }
    
    return err;
}

srs_error_t SrsMp4Decoder::do_load_next_box(SrsMp4Box** ppbox, uint32_t required_box_type)
{
    srs_error_t err = srs_success;
    
    while (true) {
        SrsMp4Box* box = NULL;
        
        if ((err = br->read(stream, &box)) != srs_success) {
            return srs_error_wrap(err, "read box");
        }
        
        SrsBuffer* buffer = new SrsBuffer(stream->bytes(), stream->length());
        SrsAutoFree(SrsBuffer, buffer);
        
        // Decode the box:
        // 1. Any box, when no box type is required.
        // 2. Matched box, when box type match the required type.
        // 3. Mdat box, always decode the mdat because we only decode the header of it.
        if (!required_box_type || (uint32_t)box->type == required_box_type || box->is_mdat()) {
            err = box->decode(buffer);
        }
        
        // Skip the box from stream, move stream to next box.
        // For mdat box, skip the content in stream or underylayer reader.
        // For other boxes, skip it from stream because we already decoded it or ignore it.
        if (err == srs_success) {
            err = br->skip(box, stream);
        }
        
        if (err != srs_success) {
            srs_freep(box);
            err = srs_error_wrap(err, "decode box");
        } else {
            *ppbox = box;
        }
        
        break;
    }
    
    return err;
}

SrsMp4Encoder::SrsMp4Encoder()
{
    wsio = NULL;
    mdat_bytes = 0;
    mdat_offset = 0;
    nb_audios = nb_videos = 0;
    samples = new SrsMp4SampleManager();
    aduration = vduration = 0;
    width = height = 0;
    
    acodec = SrsAudioCodecIdForbidden;
    sample_rate = SrsAudioSampleRateForbidden;
    sound_bits = SrsAudioSampleBitsForbidden;
    channels = SrsAudioChannelsForbidden;
    vcodec = SrsVideoCodecIdForbidden;
}

SrsMp4Encoder::~SrsMp4Encoder()
{
    srs_freep(samples);
}

srs_error_t SrsMp4Encoder::initialize(ISrsWriteSeeker* ws)
{
    srs_error_t err = srs_success;
    
    wsio = ws;
    
    // Write ftyp box.
    if (true) {
        SrsMp4FileTypeBox* ftyp = new SrsMp4FileTypeBox();
        SrsAutoFree(SrsMp4FileTypeBox, ftyp);
        
        ftyp->major_brand = SrsMp4BoxBrandISOM;
        ftyp->minor_version = 512;
        ftyp->set_compatible_brands(SrsMp4BoxBrandISOM, SrsMp4BoxBrandISO2, SrsMp4BoxBrandAVC1, SrsMp4BoxBrandMP41);
        
        int nb_data = ftyp->nb_bytes();
        std::vector<char> data(nb_data);
        
        SrsBuffer* buffer = new SrsBuffer(&data[0], nb_data);
        SrsAutoFree(SrsBuffer, buffer);
        
        if ((err = ftyp->encode(buffer)) != srs_success) {
            return srs_error_wrap(err, "encode ftyp");
        }
        
        // TODO: FIXME: Ensure write ok.
        if ((err = wsio->write(&data[0], nb_data, NULL)) != srs_success) {
            return srs_error_wrap(err, "write ftyp");
        }
    }
    
    // Write mdat box.
    if (true) {
        // Write empty mdat box,
        // its payload will be writen by samples,
        // and we will update its header(size) when flush.
        SrsMp4MediaDataBox* mdat = new SrsMp4MediaDataBox();
        SrsAutoFree(SrsMp4MediaDataBox, mdat);
        
        // Update the mdat box from this offset.
        if ((err = wsio->lseek(0, SEEK_CUR, &mdat_offset)) != srs_success) {
            return srs_error_wrap(err, "seek to mdat");
        }
        
        int nb_data = mdat->sz_header();
        uint8_t* data = new uint8_t[nb_data];
        SrsAutoFreeA(uint8_t, data);
        
        SrsBuffer* buffer = new SrsBuffer((char*)data, nb_data);
        SrsAutoFree(SrsBuffer, buffer);
        
        if ((err = mdat->encode(buffer)) != srs_success) {
            return srs_error_wrap(err, "encode mdat");
        }
        
        // TODO: FIXME: Ensure all bytes are writen.
        if ((err = wsio->write(data, nb_data, NULL)) != srs_success) {
            return srs_error_wrap(err, "write mdat");
        }
        
        mdat_bytes = 0;
    }
    
    return err;
}

srs_error_t SrsMp4Encoder::write_sample(SrsMp4HandlerType ht, uint16_t ft, uint16_t ct, uint32_t dts, uint32_t pts, uint8_t* sample, uint32_t nb_sample)
{
    srs_error_t err = srs_success;
    
    SrsMp4Sample* ps = new SrsMp4Sample();
    
    // For SPS/PPS or ASC, copy it to moov.
    bool vsh = (ht == SrsMp4HandlerTypeVIDE) && (ct == (uint16_t)SrsVideoAvcFrameTraitSequenceHeader);
    bool ash = (ht == SrsMp4HandlerTypeSOUN) && (ct == (uint16_t)SrsAudioAacFrameTraitSequenceHeader);
    if (vsh || ash) {
        err = copy_sequence_header(vsh, sample, nb_sample);
        srs_freep(ps);
        return err;
    }
    
    if (ht == SrsMp4HandlerTypeVIDE) {
        ps->type = SrsFrameTypeVideo;
        ps->frame_type = (SrsVideoAvcFrameType)ft;
        ps->index = nb_videos++;
        vduration = dts;
    } else if (ht == SrsMp4HandlerTypeSOUN) {
        ps->type = SrsFrameTypeAudio;
        ps->index = nb_audios++;
        aduration = dts;
    } else {
        srs_freep(ps);
        return err;
    }
    ps->tbn = 1000;
    ps->dts = dts;
    ps->pts = pts;
    
    if ((err = do_write_sample(ps, sample, nb_sample)) != srs_success) {
        srs_freep(ps);
        return srs_error_wrap(err, "write sample");
    }
    
    // Append to manager to build the moov.
    samples->append(ps);
    
    return err;
}

srs_error_t SrsMp4Encoder::flush()
{
    srs_error_t err = srs_success;
    
    if (!nb_audios && !nb_videos) {
        return srs_error_new(ERROR_MP4_ILLEGAL_MOOV, "Missing audio and video track");
    }
    
    // Write moov.
    if (true) {
        SrsMp4MovieBox* moov = new SrsMp4MovieBox();
        SrsAutoFree(SrsMp4MovieBox, moov);
        
        SrsMp4MovieHeaderBox* mvhd = new SrsMp4MovieHeaderBox();
        moov->set_mvhd(mvhd);
        
        mvhd->timescale = 1000; // Use tbn ms.
        mvhd->duration_in_tbn = srs_max(vduration, aduration);
        mvhd->next_track_ID = 1; // Starts from 1, increase when use it.
        
        if (nb_videos) {
            SrsMp4TrackBox* trak = new SrsMp4TrackBox();
            moov->add_trak(trak);
            
            SrsMp4TrackHeaderBox* tkhd = new SrsMp4TrackHeaderBox();
            trak->set_tkhd(tkhd);
            
            tkhd->track_ID = mvhd->next_track_ID++;
            tkhd->duration = vduration;
            tkhd->width = (width << 16);
            tkhd->height = (height << 16);
            
            SrsMp4MediaBox* mdia = new SrsMp4MediaBox();
            trak->set_mdia(mdia);
            
            SrsMp4MediaHeaderBox* mdhd = new SrsMp4MediaHeaderBox();
            mdia->set_mdhd(mdhd);
            
            mdhd->timescale = 1000;
            mdhd->duration = vduration;
            mdhd->set_language0('u');
            mdhd->set_language1('n');
            mdhd->set_language2('d');
            
            SrsMp4HandlerReferenceBox* hdlr = new SrsMp4HandlerReferenceBox();
            mdia->set_hdlr(hdlr);
            
            hdlr->handler_type = SrsMp4HandlerTypeVIDE;
            hdlr->name = "VideoHandler";
            
            SrsMp4MediaInformationBox* minf = new SrsMp4MediaInformationBox();
            mdia->set_minf(minf);
            
            SrsMp4VideoMeidaHeaderBox* vmhd = new SrsMp4VideoMeidaHeaderBox();
            minf->set_vmhd(vmhd);
            
            SrsMp4DataInformationBox* dinf = new SrsMp4DataInformationBox();
            minf->set_dinf(dinf);
            
            SrsMp4DataReferenceBox* dref = new SrsMp4DataReferenceBox();
            dinf->set_dref(dref);
            
            SrsMp4DataEntryBox* url = new SrsMp4DataEntryUrlBox();
            dref->append(url);
            
            SrsMp4SampleTableBox* stbl = new SrsMp4SampleTableBox();
            minf->set_stbl(stbl);
            
            SrsMp4SampleDescriptionBox* stsd = new SrsMp4SampleDescriptionBox();
            stbl->set_stsd(stsd);
            
            SrsMp4VisualSampleEntry* avc1 = new SrsMp4VisualSampleEntry();
            stsd->append(avc1);
            
            avc1->width = width;
            avc1->height = height;
            
            SrsMp4AvccBox* avcC = new SrsMp4AvccBox();
            avc1->set_avcC(avcC);
            
            avcC->avc_config = pavcc;
        }
        
        if (nb_audios) {
            SrsMp4TrackBox* trak = new SrsMp4TrackBox();
            moov->add_trak(trak);
            
            SrsMp4TrackHeaderBox* tkhd = new SrsMp4TrackHeaderBox();
            tkhd->volume = 0x0100;
            trak->set_tkhd(tkhd);
            
            tkhd->track_ID = mvhd->next_track_ID++;
            tkhd->duration = aduration;
            
            SrsMp4MediaBox* mdia = new SrsMp4MediaBox();
            trak->set_mdia(mdia);
            
            SrsMp4MediaHeaderBox* mdhd = new SrsMp4MediaHeaderBox();
            mdia->set_mdhd(mdhd);
            
            mdhd->timescale = 1000;
            mdhd->duration = aduration;
            mdhd->set_language0('u');
            mdhd->set_language1('n');
            mdhd->set_language2('d');
            
            SrsMp4HandlerReferenceBox* hdlr = new SrsMp4HandlerReferenceBox();
            mdia->set_hdlr(hdlr);
            
            hdlr->handler_type = SrsMp4HandlerTypeSOUN;
            hdlr->name = "SoundHandler";
            
            SrsMp4MediaInformationBox* minf = new SrsMp4MediaInformationBox();
            mdia->set_minf(minf);
            
            SrsMp4SoundMeidaHeaderBox* smhd = new SrsMp4SoundMeidaHeaderBox();
            minf->set_smhd(smhd);
            
            SrsMp4DataInformationBox* dinf = new SrsMp4DataInformationBox();
            minf->set_dinf(dinf);
            
            SrsMp4DataReferenceBox* dref = new SrsMp4DataReferenceBox();
            dinf->set_dref(dref);
            
            SrsMp4DataEntryBox* url = new SrsMp4DataEntryUrlBox();
            dref->append(url);
            
            SrsMp4SampleTableBox* stbl = new SrsMp4SampleTableBox();
            minf->set_stbl(stbl);
            
            SrsMp4SampleDescriptionBox* stsd = new SrsMp4SampleDescriptionBox();
            stbl->set_stsd(stsd);
            
            SrsMp4AudioSampleEntry* mp4a = new SrsMp4AudioSampleEntry();
            mp4a->samplerate = uint32_t(srs_flv_srates[sample_rate]) << 16;
            if (sound_bits == SrsAudioSampleBits16bit) {
                mp4a->samplesize = 16;
            } else {
                mp4a->samplesize = 8;
            }
            if (channels == SrsAudioChannelsStereo) {
                mp4a->channelcount = 2;
            } else {
                mp4a->channelcount = 1;
            }
            stsd->append(mp4a);
            
            SrsMp4EsdsBox* esds = new SrsMp4EsdsBox();
            mp4a->set_esds(esds);
            
            SrsMp4ES_Descriptor* es = esds->es;
            es->ES_ID = 0x02;
            
            SrsMp4DecoderConfigDescriptor& desc = es->decConfigDescr;
            desc.objectTypeIndication = SrsMp4ObjectTypeAac;
            desc.streamType = SrsMp4StreamTypeAudioStream;
            srs_freep(desc.decSpecificInfo);
            
            SrsMp4DecoderSpecificInfo* asc = new SrsMp4DecoderSpecificInfo();
            desc.decSpecificInfo = asc;
            asc->asc = pasc;;
        }
        
        if ((err = samples->write(moov)) != srs_success) {
            return srs_error_wrap(err, "write samples");
        }
        
        int nb_data = moov->nb_bytes();
        uint8_t* data = new uint8_t[nb_data];
        SrsAutoFreeA(uint8_t, data);
        
        SrsBuffer* buffer = new SrsBuffer((char*)data, nb_data);
        SrsAutoFree(SrsBuffer, buffer);
        
        if ((err = moov->encode(buffer)) != srs_success) {
            return srs_error_wrap(err, "encode moov");
        }
        
        // TODO: FIXME: Ensure all bytes are writen.
        if ((err = wsio->write(data, nb_data, NULL)) != srs_success) {
            return srs_error_wrap(err, "write moov");
        }
    }
    
    // Write mdat box.
    if (true) {
        // Update the mdat box header.
        if ((err = wsio->lseek(mdat_offset, SEEK_SET, NULL)) != srs_success) {
            return srs_error_wrap(err, "seek to mdat");
        }
        
        // Write mdat box with size of data,
        // its payload already writen by samples,
        // and we will update its header(size) when flush.
        SrsMp4MediaDataBox* mdat = new SrsMp4MediaDataBox();
        SrsAutoFree(SrsMp4MediaDataBox, mdat);
        
        int nb_data = mdat->sz_header();
        uint8_t* data = new uint8_t[nb_data];
        SrsAutoFreeA(uint8_t, data);
        
        SrsBuffer* buffer = new SrsBuffer((char*)data, nb_data);
        SrsAutoFree(SrsBuffer, buffer);
        
        // TODO: FIXME: Support 64bits size.
        mdat->nb_data = (int)mdat_bytes;
        if ((err = mdat->encode(buffer)) != srs_success) {
            return srs_error_wrap(err, "encode mdat");
        }
        
        // TODO: FIXME: Ensure all bytes are writen.
        if ((err = wsio->write(data, nb_data, NULL)) != srs_success) {
            return srs_error_wrap(err, "write mdat");
        }
    }
    
    return err;
}

srs_error_t SrsMp4Encoder::copy_sequence_header(bool vsh, uint8_t* sample, uint32_t nb_sample)
{
    srs_error_t err = srs_success;
    
    if (vsh && !pavcc.empty()) {
        if (nb_sample == (uint32_t)pavcc.size() && srs_bytes_equals(sample, &pavcc[0], (int)pavcc.size())) {
            return err;
        }
        
        return srs_error_new(ERROR_MP4_AVCC_CHANGE, "doesn't support avcc change");
    }
    
    if (!vsh && !pasc.empty()) {
        if (nb_sample == (uint32_t)pasc.size() && srs_bytes_equals(sample, &pasc[0], (int)pasc.size())) {
            return err;
        }
        
        return srs_error_new(ERROR_MP4_ASC_CHANGE, "doesn't support asc change");
    }
    
    if (vsh) {
        pavcc = std::vector<char>(sample, sample + nb_sample);
        
        // TODO: FIXME: Parse the width and height.
    }
    
    if (!vsh) {
        pasc = std::vector<char>(sample, sample + nb_sample);
    }
    
    return err;
}

srs_error_t SrsMp4Encoder::do_write_sample(SrsMp4Sample* ps, uint8_t* sample, uint32_t nb_sample)
{
    srs_error_t err = srs_success;
    
    ps->nb_data = nb_sample;
    // Never copy data, for we already writen to writer.
    ps->data = NULL;
    
    // Update the mdat box from this offset.
    if ((err = wsio->lseek(0, SEEK_CUR, &ps->offset)) != srs_success) {
        return srs_error_wrap(err, "seek to offset in mdat");
    }
    
    // TODO: FIXME: Ensure all bytes are writen.
    if ((err = wsio->write(sample, nb_sample, NULL)) != srs_success) {
        return srs_error_wrap(err, "write sample");
    }
    
    mdat_bytes += nb_sample;
    
    return err;
}

SrsMp4M2tsInitEncoder::SrsMp4M2tsInitEncoder()
{
    writer = NULL;
}

SrsMp4M2tsInitEncoder::~SrsMp4M2tsInitEncoder()
{
}

srs_error_t SrsMp4M2tsInitEncoder::initialize(ISrsWriter* w)
{
    writer = w;
    return srs_success;
}

srs_error_t SrsMp4M2tsInitEncoder::write(SrsFormat* format, bool video, int tid)
{
    srs_error_t err = srs_success;
    
    // Write ftyp box.
    SrsMp4FileTypeBox* ftyp = new SrsMp4FileTypeBox();
    SrsAutoFree(SrsMp4FileTypeBox, ftyp);
    if (true) {
        ftyp->major_brand = SrsMp4BoxBrandISO5;
        ftyp->minor_version = 0;
        ftyp->set_compatible_brands(SrsMp4BoxBrandISOM, SrsMp4BoxBrandISO5, SrsMp4BoxBrandDASH, SrsMp4BoxBrandMP42);
    }
    
    // Write moov.
    SrsMp4MovieBox* moov = new SrsMp4MovieBox();
    SrsAutoFree(SrsMp4MovieBox, moov);
    if (true) {
        SrsMp4MovieHeaderBox* mvhd = new SrsMp4MovieHeaderBox();
        moov->set_mvhd(mvhd);
        
        mvhd->timescale = 1000; // Use tbn ms.
        mvhd->duration_in_tbn = 0;
        mvhd->next_track_ID = tid;
        
        if (video) {
            SrsMp4TrackBox* trak = new SrsMp4TrackBox();
            moov->add_trak(trak);
            
            SrsMp4TrackHeaderBox* tkhd = new SrsMp4TrackHeaderBox();
            trak->set_tkhd(tkhd);
            
            tkhd->track_ID = mvhd->next_track_ID++;
            tkhd->duration = 0;
            tkhd->width = (format->vcodec->width << 16);
            tkhd->height = (format->vcodec->height << 16);
            
            SrsMp4MediaBox* mdia = new SrsMp4MediaBox();
            trak->set_mdia(mdia);
            
            SrsMp4MediaHeaderBox* mdhd = new SrsMp4MediaHeaderBox();
            mdia->set_mdhd(mdhd);
            
            mdhd->timescale = 1000;
            mdhd->duration = 0;
            mdhd->set_language0('u');
            mdhd->set_language1('n');
            mdhd->set_language2('d');
            
            SrsMp4HandlerReferenceBox* hdlr = new SrsMp4HandlerReferenceBox();
            mdia->set_hdlr(hdlr);
            
            hdlr->handler_type = SrsMp4HandlerTypeVIDE;
            hdlr->name = "VideoHandler";
            
            SrsMp4MediaInformationBox* minf = new SrsMp4MediaInformationBox();
            mdia->set_minf(minf);
            
            SrsMp4VideoMeidaHeaderBox* vmhd = new SrsMp4VideoMeidaHeaderBox();
            minf->set_vmhd(vmhd);
            
            SrsMp4DataInformationBox* dinf = new SrsMp4DataInformationBox();
            minf->set_dinf(dinf);
            
            SrsMp4DataReferenceBox* dref = new SrsMp4DataReferenceBox();
            dinf->set_dref(dref);
            
            SrsMp4DataEntryBox* url = new SrsMp4DataEntryUrlBox();
            dref->append(url);
            
            SrsMp4SampleTableBox* stbl = new SrsMp4SampleTableBox();
            minf->set_stbl(stbl);
            
            SrsMp4SampleDescriptionBox* stsd = new SrsMp4SampleDescriptionBox();
            stbl->set_stsd(stsd);
            
            SrsMp4VisualSampleEntry* avc1 = new SrsMp4VisualSampleEntry();
            stsd->append(avc1);
            
            avc1->width = format->vcodec->width;
            avc1->height = format->vcodec->height;
            
            SrsMp4AvccBox* avcC = new SrsMp4AvccBox();
            avc1->set_avcC(avcC);
            
            avcC->avc_config = format->vcodec->avc_extra_data;
            
            SrsMp4DecodingTime2SampleBox* stts = new SrsMp4DecodingTime2SampleBox();
            stbl->set_stts(stts);
            
            SrsMp4Sample2ChunkBox* stsc = new SrsMp4Sample2ChunkBox();
            stbl->set_stsc(stsc);
            
            SrsMp4SampleSizeBox* stsz = new SrsMp4SampleSizeBox();
            stbl->set_stsz(stsz);
            
            SrsMp4ChunkOffsetBox* stco = new SrsMp4ChunkOffsetBox();
            stbl->set_stco(stco);
            
            SrsMp4MovieExtendsBox* mvex = new SrsMp4MovieExtendsBox();
            moov->set_mvex(mvex);
            
            SrsMp4TrackExtendsBox* trex = new SrsMp4TrackExtendsBox();
            mvex->set_trex(trex);
            
            trex->track_ID = tid;
            trex->default_sample_description_index = 1;
        } else {
            SrsMp4TrackBox* trak = new SrsMp4TrackBox();
            moov->add_trak(trak);
            
            SrsMp4TrackHeaderBox* tkhd = new SrsMp4TrackHeaderBox();
            tkhd->volume = 0x0100;
            trak->set_tkhd(tkhd);
            
            tkhd->track_ID = mvhd->next_track_ID++;
            tkhd->duration = 0;
            
            SrsMp4MediaBox* mdia = new SrsMp4MediaBox();
            trak->set_mdia(mdia);
            
            SrsMp4MediaHeaderBox* mdhd = new SrsMp4MediaHeaderBox();
            mdia->set_mdhd(mdhd);
            
            mdhd->timescale = 1000;
            mdhd->duration = 0;
            mdhd->set_language0('u');
            mdhd->set_language1('n');
            mdhd->set_language2('d');
            
            SrsMp4HandlerReferenceBox* hdlr = new SrsMp4HandlerReferenceBox();
            mdia->set_hdlr(hdlr);
            
            hdlr->handler_type = SrsMp4HandlerTypeSOUN;
            hdlr->name = "SoundHandler";
            
            SrsMp4MediaInformationBox* minf = new SrsMp4MediaInformationBox();
            mdia->set_minf(minf);
            
            SrsMp4SoundMeidaHeaderBox* smhd = new SrsMp4SoundMeidaHeaderBox();
            minf->set_smhd(smhd);
            
            SrsMp4DataInformationBox* dinf = new SrsMp4DataInformationBox();
            minf->set_dinf(dinf);
            
            SrsMp4DataReferenceBox* dref = new SrsMp4DataReferenceBox();
            dinf->set_dref(dref);
            
            SrsMp4DataEntryBox* url = new SrsMp4DataEntryUrlBox();
            dref->append(url);
            
            SrsMp4SampleTableBox* stbl = new SrsMp4SampleTableBox();
            minf->set_stbl(stbl);
            
            SrsMp4SampleDescriptionBox* stsd = new SrsMp4SampleDescriptionBox();
            stbl->set_stsd(stsd);
            
            SrsMp4AudioSampleEntry* mp4a = new SrsMp4AudioSampleEntry();
            mp4a->samplerate = uint32_t(srs_flv_srates[format->acodec->sound_rate]) << 16;
            if (format->acodec->sound_size == SrsAudioSampleBits16bit) {
                mp4a->samplesize = 16;
            } else {
                mp4a->samplesize = 8;
            }
            if (format->acodec->sound_type == SrsAudioChannelsStereo) {
                mp4a->channelcount = 2;
            } else {
                mp4a->channelcount = 1;
            }
            stsd->append(mp4a);
            
            SrsMp4EsdsBox* esds = new SrsMp4EsdsBox();
            mp4a->set_esds(esds);
            
            SrsMp4ES_Descriptor* es = esds->es;
            es->ES_ID = 0x02;
            
            SrsMp4DecoderConfigDescriptor& desc = es->decConfigDescr;
            desc.objectTypeIndication = SrsMp4ObjectTypeAac;
            desc.streamType = SrsMp4StreamTypeAudioStream;
            srs_freep(desc.decSpecificInfo);
            
            SrsMp4DecoderSpecificInfo* asc = new SrsMp4DecoderSpecificInfo();
            desc.decSpecificInfo = asc;
            asc->asc = format->acodec->aac_extra_data;
            
            SrsMp4DecodingTime2SampleBox* stts = new SrsMp4DecodingTime2SampleBox();
            stbl->set_stts(stts);
            
            SrsMp4Sample2ChunkBox* stsc = new SrsMp4Sample2ChunkBox();
            stbl->set_stsc(stsc);
            
            SrsMp4SampleSizeBox* stsz = new SrsMp4SampleSizeBox();
            stbl->set_stsz(stsz);
            
            SrsMp4ChunkOffsetBox* stco = new SrsMp4ChunkOffsetBox();
            stbl->set_stco(stco);
            
            SrsMp4MovieExtendsBox* mvex = new SrsMp4MovieExtendsBox();
            moov->set_mvex(mvex);
            
            SrsMp4TrackExtendsBox* trex = new SrsMp4TrackExtendsBox();
            mvex->set_trex(trex);
            
            trex->track_ID = tid;
            trex->default_sample_description_index = 1;
        }
    }
    
    int nb_data = ftyp->nb_bytes() + moov->nb_bytes();
    uint8_t* data = new uint8_t[nb_data];
    SrsAutoFreeA(uint8_t, data);
    
    SrsBuffer* buffer = new SrsBuffer();
    SrsAutoFree(SrsBuffer, buffer);
    
    if ((err = ftyp->encode(buffer)) != srs_success) {
        return srs_error_wrap(err, "encode ftyp");
    }
    if ((err = moov->encode(buffer)) != srs_success) {
        return srs_error_wrap(err, "encode moov");
    }
    
    if ((err = writer->write(data, nb_data, NULL)) != srs_success) {
        return srs_error_wrap(err, "write ftyp and moov");
    }
    
    return err;
}

SrsMp4M2tsSegmentEncoder::SrsMp4M2tsSegmentEncoder()
{
    writer = NULL;
    nb_audios = nb_videos = 0;
    samples = new SrsMp4SampleManager();
    buffer = new SrsBuffer();
    sequence_number = 0;
    decode_basetime = 0;
    data_offset = 0;
    mdat_bytes = 0;
}

SrsMp4M2tsSegmentEncoder::~SrsMp4M2tsSegmentEncoder()
{
    srs_freep(samples);
    srs_freep(buffer);
}

srs_error_t SrsMp4M2tsSegmentEncoder::initialize(ISrsWriter* w, uint32_t sequence, uint64_t basetime, uint32_t tid)
{
    srs_error_t err = srs_success;
    
    writer = w;
    track_id = tid;
    sequence_number = sequence;
    decode_basetime = basetime;
    
    // Write styp box.
    if (true) {
        SrsMp4SegmentTypeBox* styp = new SrsMp4SegmentTypeBox();
        SrsAutoFree(SrsMp4SegmentTypeBox, styp);
        
        styp->major_brand = SrsMp4BoxBrandMSDH;
        styp->minor_version = 0;
        styp->set_compatible_brands(SrsMp4BoxBrandMSDH, SrsMp4BoxBrandDASH);
        
        int nb_data = styp->nb_bytes();
        std::vector<char> data(nb_data);
        
        SrsBuffer* buffer = new SrsBuffer(&data[0], nb_data);
        SrsAutoFree(SrsBuffer, buffer);
        
        if ((err = styp->encode(buffer)) != srs_success) {
            return srs_error_wrap(err, "encode styp");
        }
        
        // TODO: FIXME: Ensure write ok.
        if ((err = writer->write(&data[0], nb_data, NULL)) != srs_success) {
            return srs_error_wrap(err, "write styp");
        }
        
        data_offset = nb_data;
    }
    return err;
}

srs_error_t SrsMp4M2tsSegmentEncoder::write_sample(SrsMp4HandlerType ht,
    uint16_t ft, uint32_t dts, uint32_t pts, uint8_t* sample, uint32_t nb_sample
) {
    srs_error_t err = srs_success;
    
    SrsMp4Sample* ps = new SrsMp4Sample();
    
    if (ht == SrsMp4HandlerTypeVIDE) {
        ps->type = SrsFrameTypeVideo;
        ps->frame_type = (SrsVideoAvcFrameType)ft;
        ps->index = nb_videos++;
    } else if (ht == SrsMp4HandlerTypeSOUN) {
        ps->type = SrsFrameTypeAudio;
        ps->index = nb_audios++;
    } else {
        srs_freep(ps);
        return err;
    }
    
    ps->tbn = 1000;
    ps->dts = dts;
    ps->pts = pts;
    ps->data = sample;
    ps->nb_data = nb_sample;
    
    // Append to manager to build the moof.
    samples->append(ps);
    
    mdat_bytes += nb_sample;
    
    return err;
}

srs_error_t SrsMp4M2tsSegmentEncoder::flush(uint64_t& dts)
{
    srs_error_t err = srs_success;
    
    if (!nb_audios && !nb_videos) {
        return srs_error_new(ERROR_MP4_ILLEGAL_MOOF, "Missing audio and video track");
    }
    
    // Create a mdat box.
    // its payload will be writen by samples,
    // and we will update its header(size) when flush.
    SrsMp4MediaDataBox* mdat = new SrsMp4MediaDataBox();
    SrsAutoFree(SrsMp4MediaDataBox, mdat);
    
    // Write moof.
    if (true) {
        SrsMp4MovieFragmentBox* moof = new SrsMp4MovieFragmentBox();
        SrsAutoFree(SrsMp4MovieFragmentBox, moof);
        
        SrsMp4MovieFragmentHeaderBox* mfhd = new SrsMp4MovieFragmentHeaderBox();
        moof->set_mfhd(mfhd);
        
        mfhd->sequence_number = sequence_number;
        
        SrsMp4TrackFragmentBox* traf = new SrsMp4TrackFragmentBox();
        moof->set_traf(traf);
        
        SrsMp4TrackFragmentHeaderBox* tfhd = new SrsMp4TrackFragmentHeaderBox();
        traf->set_tfhd(tfhd);
        
        tfhd->track_id = track_id;
        tfhd->flags = SrsMp4TfhdFlagsDefaultBaseIsMoof;
        
        SrsMp4TrackFragmentDecodeTimeBox* tfdt = new SrsMp4TrackFragmentDecodeTimeBox();
        traf->set_tfdt(tfdt);
        
        tfdt->version = 1;
        tfdt->base_media_decode_time = decode_basetime;
        
        SrsMp4TrackFragmentRunBox* trun = new SrsMp4TrackFragmentRunBox();
        traf->set_trun(trun);
        
        if ((err = samples->write(moof, dts)) != srs_success) {
            return srs_error_wrap(err, "write samples");
        }
        
        int nb_data = moof->nb_bytes();
        trun->data_offset = (int32_t)(data_offset + nb_data + mdat->sz_header());
        
        uint8_t* data = new uint8_t[nb_data];
        SrsAutoFreeA(uint8_t, data);
        
        SrsBuffer* buffer = new SrsBuffer((char*)data, nb_data);
        SrsAutoFree(SrsBuffer, buffer);
        
        if ((err = moof->encode(buffer)) != srs_success) {
            return srs_error_wrap(err, "encode moof");
        }
        
        // TODO: FIXME: Ensure all bytes are writen.
        if ((err = writer->write(data, nb_data, NULL)) != srs_success) {
            return srs_error_wrap(err, "write moof");
        }
    }
    
    // Write mdat.
    if (true) {
        mdat->nb_data = (int)mdat_bytes;
        
        int nb_data = mdat->sz_header();
        uint8_t* data = new uint8_t[nb_data];
        SrsAutoFreeA(uint8_t, data);
        
        SrsBuffer* buffer = new SrsBuffer((char*)data, nb_data);
        SrsAutoFree(SrsBuffer, buffer);
        
        if ((err = mdat->encode(buffer)) != srs_success) {
            return srs_error_wrap(err, "encode mdat");
        }
        
        // TODO: FIXME: Ensure all bytes are writen.
        if ((err = writer->write(data, nb_data, NULL)) != srs_success) {
            return srs_error_wrap(err, "write mdat");
        }
        
        vector<SrsMp4Sample*>::iterator it;
        for (it = samples->samples.begin(); it != samples->samples.end(); ++it) {
            SrsMp4Sample* sample = *it;
            
            // TODO: FIXME: Ensure all bytes are writen.
            if ((err = writer->write(sample->data, sample->nb_data, NULL)) != srs_success) {
                return srs_error_wrap(err, "write sample");
            }
        }
    }

    return err;
}

// following is generated by src/kernel/srs_kernel_file.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kernel_file.hpp>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <unistd.h>
#include <sys/uio.h>
#endif

#include <fcntl.h>
#include <sstream>
using namespace std;

//#include <srs_kernel_log.hpp>
//#include <srs_kernel_error.hpp>

SrsFileWriter::SrsFileWriter()
{
    fd = -1;
}

SrsFileWriter::~SrsFileWriter()
{
    close();
}

srs_error_t SrsFileWriter::open(string p)
{
    srs_error_t err = srs_success;
    
    if (fd > 0) {
        return srs_error_new(ERROR_SYSTEM_FILE_ALREADY_OPENED, "file %s already opened", p.c_str());
    }
    
    int flags = O_CREAT|O_WRONLY|O_TRUNC;
    mode_t mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH;
    
    if ((fd = ::open(p.c_str(), flags, mode)) < 0) {
        return srs_error_new(ERROR_SYSTEM_FILE_OPENE, "open file %s failed", p.c_str());
    }
    
    path = p;
    
    return err;
}

srs_error_t SrsFileWriter::open_append(string p)
{
    srs_error_t err = srs_success;
    
    if (fd > 0) {
        return srs_error_new(ERROR_SYSTEM_FILE_ALREADY_OPENED, "file %s already opened", path.c_str());
    }
    
    int flags = O_APPEND|O_WRONLY;
    mode_t mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH;
    
    if ((fd = ::open(p.c_str(), flags, mode)) < 0) {
        return srs_error_new(ERROR_SYSTEM_FILE_OPENE, "open file %s failed", p.c_str());
    }
    
    path = p;
    
    return err;
}

void SrsFileWriter::close()
{
    if (fd < 0) {
        return;
    }
    
    if (::close(fd) < 0) {
        srs_warn("close file %s failed", path.c_str());
    }
    fd = -1;
    
    return;
}

bool SrsFileWriter::is_open()
{
    return fd > 0;
}

void SrsFileWriter::seek2(int64_t offset)
{
    off_t r0 = ::lseek(fd, (off_t)offset, SEEK_SET);
    srs_assert(r0 != -1);
}

int64_t SrsFileWriter::tellg()
{
    return (int64_t)::lseek(fd, 0, SEEK_CUR);
}

srs_error_t SrsFileWriter::write(void* buf, size_t count, ssize_t* pnwrite)
{
    srs_error_t err = srs_success;
    
    ssize_t nwrite;
    // TODO: FIXME: use st_write.
    if ((nwrite = ::write(fd, buf, count)) < 0) {
        return srs_error_new(ERROR_SYSTEM_FILE_WRITE, "write to file %s failed", path.c_str());
    }
    
    if (pnwrite != NULL) {
        *pnwrite = nwrite;
    }
    
    return err;
}

srs_error_t SrsFileWriter::writev(const iovec* iov, int iovcnt, ssize_t* pnwrite)
{
    srs_error_t err = srs_success;
    
    ssize_t nwrite = 0;
    for (int i = 0; i < iovcnt; i++) {
        const iovec* piov = iov + i;
        ssize_t this_nwrite = 0;
        if ((err = write(piov->iov_base, piov->iov_len, &this_nwrite)) != srs_success) {
            return srs_error_wrap(err, "write file");
        }
        nwrite += this_nwrite;
    }
    
    if (pnwrite) {
        *pnwrite = nwrite;
    }
    
    return err;
}

srs_error_t SrsFileWriter::lseek(off_t offset, int whence, off_t* seeked)
{
    off_t sk = ::lseek(fd, offset, whence);
    if (sk < 0) {
        return srs_error_new(ERROR_SYSTEM_FILE_SEEK, "seek file");
    }
    
    if (seeked) {
        *seeked = sk;
    }
    
    return srs_success;
}

SrsFileReader::SrsFileReader()
{
    fd = -1;
}

SrsFileReader::~SrsFileReader()
{
    close();
}

srs_error_t SrsFileReader::open(string p)
{
    srs_error_t err = srs_success;
    
    if (fd > 0) {
        return srs_error_new(ERROR_SYSTEM_FILE_ALREADY_OPENED, "file %s already opened", path.c_str());
    }
    
    if ((fd = ::open(p.c_str(), O_RDONLY)) < 0) {
        return srs_error_new(ERROR_SYSTEM_FILE_OPENE, "open file %s failed", p.c_str());
    }
    
    path = p;
    
    return err;
}

void SrsFileReader::close()
{
    int ret = ERROR_SUCCESS;
    
    if (fd < 0) {
        return;
    }
    
    if (::close(fd) < 0) {
        ret = ERROR_SYSTEM_FILE_CLOSE;
        srs_error("close file %s failed. ret=%d", path.c_str(), ret);
        return;
    }
    fd = -1;
    
    return;
}

bool SrsFileReader::is_open()
{
    return fd > 0;
}

int64_t SrsFileReader::tellg()
{
    return (int64_t)::lseek(fd, 0, SEEK_CUR);
}

void SrsFileReader::skip(int64_t size)
{
    off_t r0 = ::lseek(fd, (off_t)size, SEEK_CUR);
    srs_assert(r0 != -1);
}

int64_t SrsFileReader::seek2(int64_t offset)
{
    return (int64_t)::lseek(fd, (off_t)offset, SEEK_SET);
}

int64_t SrsFileReader::filesize()
{
    int64_t cur = tellg();
    int64_t size = (int64_t)::lseek(fd, 0, SEEK_END);
    
    off_t r0 = ::lseek(fd, (off_t)cur, SEEK_SET);
    srs_assert(r0 != -1);
    
    return size;
}

srs_error_t SrsFileReader::read(void* buf, size_t count, ssize_t* pnread)
{
    srs_error_t err = srs_success;
    
    ssize_t nread;
    // TODO: FIXME: use st_read.
    if ((nread = ::read(fd, buf, count)) < 0) {
        return srs_error_new(ERROR_SYSTEM_FILE_READ, "read from file %s failed", path.c_str());
    }
    
    if (nread == 0) {
        return srs_error_new(ERROR_SYSTEM_FILE_EOF, "file EOF");
    }
    
    if (pnread != NULL) {
        *pnread = nread;
    }
    
    return err;
}

srs_error_t SrsFileReader::lseek(off_t offset, int whence, off_t* seeked)
{
    off_t sk = ::lseek(fd, offset, whence);
    if (sk < 0) {
        return srs_error_new(ERROR_SYSTEM_FILE_SEEK, "seek %v failed", (int)sk);
    }
    
    if (seeked) {
        *seeked = sk;
    }
    
    return srs_success;
}

// following is generated by src/protocol/srs_protocol_amf0.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_protocol_amf0.hpp>

#include <utility>
#include <vector>
#include <sstream>
using namespace std;

//#include <srs_kernel_log.hpp>
//#include <srs_kernel_error.hpp>
//#include <srs_kernel_buffer.hpp>
//#include <srs_protocol_json.hpp>

using namespace _srs_internal;

// AMF0 marker
#define RTMP_AMF0_Number                     0x00
#define RTMP_AMF0_Boolean                     0x01
#define RTMP_AMF0_String                     0x02
#define RTMP_AMF0_Object                     0x03
#define RTMP_AMF0_MovieClip                 0x04 // reserved, not supported
#define RTMP_AMF0_Null                         0x05
#define RTMP_AMF0_Undefined                 0x06
#define RTMP_AMF0_Reference                 0x07
#define RTMP_AMF0_EcmaArray                 0x08
#define RTMP_AMF0_ObjectEnd                 0x09
#define RTMP_AMF0_StrictArray                 0x0A
#define RTMP_AMF0_Date                         0x0B
#define RTMP_AMF0_LongString                 0x0C
#define RTMP_AMF0_UnSupported                 0x0D
#define RTMP_AMF0_RecordSet                 0x0E // reserved, not supported
#define RTMP_AMF0_XmlDocument                 0x0F
#define RTMP_AMF0_TypedObject                 0x10
// AVM+ object is the AMF3 object.
#define RTMP_AMF0_AVMplusObject             0x11
// origin array whos data takes the same form as LengthValueBytes
#define RTMP_AMF0_OriginStrictArray         0x20

// User defined
#define RTMP_AMF0_Invalid                     0x3F

SrsAmf0Any::SrsAmf0Any()
{
    marker = RTMP_AMF0_Invalid;
}

SrsAmf0Any::~SrsAmf0Any()
{
}

bool SrsAmf0Any::is_string()
{
    return marker == RTMP_AMF0_String;
}

bool SrsAmf0Any::is_boolean()
{
    return marker == RTMP_AMF0_Boolean;
}

bool SrsAmf0Any::is_number()
{
    return marker == RTMP_AMF0_Number;
}

bool SrsAmf0Any::is_null()
{
    return marker == RTMP_AMF0_Null;
}

bool SrsAmf0Any::is_undefined()
{
    return marker == RTMP_AMF0_Undefined;
}

bool SrsAmf0Any::is_object()
{
    return marker == RTMP_AMF0_Object;
}

bool SrsAmf0Any::is_ecma_array()
{
    return marker == RTMP_AMF0_EcmaArray;
}

bool SrsAmf0Any::is_strict_array()
{
    return marker == RTMP_AMF0_StrictArray;
}

bool SrsAmf0Any::is_date()
{
    return marker == RTMP_AMF0_Date;
}

bool SrsAmf0Any::is_complex_object()
{
    return is_object() || is_object_eof() || is_ecma_array() || is_strict_array();
}

string SrsAmf0Any::to_str()
{
    SrsAmf0String* p = dynamic_cast<SrsAmf0String*>(this);
    srs_assert(p != NULL);
    return p->value;
}

const char* SrsAmf0Any::to_str_raw()
{
    SrsAmf0String* p = dynamic_cast<SrsAmf0String*>(this);
    srs_assert(p != NULL);
    return p->value.data();
}

bool SrsAmf0Any::to_boolean()
{
    SrsAmf0Boolean* p = dynamic_cast<SrsAmf0Boolean*>(this);
    srs_assert(p != NULL);
    return p->value;
}

double SrsAmf0Any::to_number()
{
    SrsAmf0Number* p = dynamic_cast<SrsAmf0Number*>(this);
    srs_assert(p != NULL);
    return p->value;
}

int64_t SrsAmf0Any::to_date()
{
    SrsAmf0Date* p = dynamic_cast<SrsAmf0Date*>(this);
    srs_assert(p != NULL);
    return p->date();
}

int16_t SrsAmf0Any::to_date_time_zone()
{
    SrsAmf0Date* p = dynamic_cast<SrsAmf0Date*>(this);
    srs_assert(p != NULL);
    return p->time_zone();
}

SrsAmf0Object* SrsAmf0Any::to_object()
{
    SrsAmf0Object* p = dynamic_cast<SrsAmf0Object*>(this);
    srs_assert(p != NULL);
    return p;
}

SrsAmf0EcmaArray* SrsAmf0Any::to_ecma_array()
{
    SrsAmf0EcmaArray* p = dynamic_cast<SrsAmf0EcmaArray*>(this);
    srs_assert(p != NULL);
    return p;
}

SrsAmf0StrictArray* SrsAmf0Any::to_strict_array()
{
    SrsAmf0StrictArray* p = dynamic_cast<SrsAmf0StrictArray*>(this);
    srs_assert(p != NULL);
    return p;
}

void SrsAmf0Any::set_number(double value)
{
    SrsAmf0Number* p = dynamic_cast<SrsAmf0Number*>(this);
    srs_assert(p != NULL);
    p->value = value;
}

bool SrsAmf0Any::is_object_eof()
{
    return marker == RTMP_AMF0_ObjectEnd;
}

void srs_fill_level_spaces(stringstream& ss, int level)
{
    for (int i = 0; i < level; i++) {
        ss << "    ";
    }
}
void srs_amf0_do_print(SrsAmf0Any* any, stringstream& ss, int level)
{
    std::ios_base::fmtflags oflags = ss.flags();
    
    if (any->is_boolean()) {
        ss << "Boolean " << (any->to_boolean()? "true":"false") << endl;
    } else if (any->is_number()) {
        ss << "Number " << std::fixed << any->to_number() << endl;
    } else if (any->is_string()) {
        ss << "String " << any->to_str() << endl;
    } else if (any->is_date()) {
        ss << "Date " << std::hex << any->to_date()
        << "/" << std::hex << any->to_date_time_zone() << endl;
    } else if (any->is_null()) {
        ss << "Null" << endl;
    } else if (any->is_ecma_array()) {
        SrsAmf0EcmaArray* obj = any->to_ecma_array();
        ss << "EcmaArray " << "(" << obj->count() << " items)" << endl;
        for (int i = 0; i < obj->count(); i++) {
            srs_fill_level_spaces(ss, level + 1);
            ss << "Elem '" << obj->key_at(i) << "' ";
            if (obj->value_at(i)->is_complex_object()) {
                srs_amf0_do_print(obj->value_at(i), ss, level + 1);
            } else {
                srs_amf0_do_print(obj->value_at(i), ss, 0);
            }
        }
    } else if (any->is_strict_array()) {
        SrsAmf0StrictArray* obj = any->to_strict_array();
        ss << "StrictArray " << "(" << obj->count() << " items)" << endl;
        for (int i = 0; i < obj->count(); i++) {
            srs_fill_level_spaces(ss, level + 1);
            ss << "Elem ";
            if (obj->at(i)->is_complex_object()) {
                srs_amf0_do_print(obj->at(i), ss, level + 1);
            } else {
                srs_amf0_do_print(obj->at(i), ss, 0);
            }
        }
    } else if (any->is_object()) {
        SrsAmf0Object* obj = any->to_object();
        ss << "Object " << "(" << obj->count() << " items)" << endl;
        for (int i = 0; i < obj->count(); i++) {
            srs_fill_level_spaces(ss, level + 1);
            ss << "Property '" << obj->key_at(i) << "' ";
            if (obj->value_at(i)->is_complex_object()) {
                srs_amf0_do_print(obj->value_at(i), ss, level + 1);
            } else {
                srs_amf0_do_print(obj->value_at(i), ss, 0);
            }
        }
    } else {
        ss << "Unknown" << endl;
    }
    
    ss.flags(oflags);
}

char* SrsAmf0Any::human_print(char** pdata, int* psize)
{
    stringstream ss;
    
    ss.precision(1);
    
    srs_amf0_do_print(this, ss, 0);
    
    string str = ss.str();
    if (str.empty()) {
        return NULL;
    }
    
    char* data = new char[str.length() + 1];
    memcpy(data, str.data(), str.length());
    data[str.length()] = 0;
    
    if (pdata) {
        *pdata = data;
    }
    if (psize) {
        *psize = (int)str.length();
    }
    
    return data;
}

SrsJsonAny* SrsAmf0Any::to_json()
{
    switch (marker) {
        case RTMP_AMF0_String: {
            return SrsJsonAny::str(to_str().c_str());
        }
        case RTMP_AMF0_Boolean: {
            return SrsJsonAny::boolean(to_boolean());
        }
        case RTMP_AMF0_Number: {
            double dv = to_number();
            int64_t iv = (int64_t)dv;
            if (iv == dv) {
                return SrsJsonAny::integer(iv);
            } else {
                return SrsJsonAny::number(dv);
            }
        }
        case RTMP_AMF0_Null: {
            return SrsJsonAny::null();
        }
        case RTMP_AMF0_Undefined: {
            return SrsJsonAny::null();
        }
        case RTMP_AMF0_Object: {
            // amf0 object implements it.
            srs_assert(false);
        }
        case RTMP_AMF0_EcmaArray: {
            // amf0 ecma array implements it.
            srs_assert(false);
        }
        case RTMP_AMF0_StrictArray: {
            // amf0 strict array implements it.
            srs_assert(false);
        }
        case RTMP_AMF0_Date: {
            // TODO: FIXME: implements it.
            return SrsJsonAny::null();
        }
        default: {
            return SrsJsonAny::null();
        }
    }
    
}

SrsAmf0Any* SrsAmf0Any::str(const char* value)
{
    return new SrsAmf0String(value);
}

SrsAmf0Any* SrsAmf0Any::boolean(bool value)
{
    return new SrsAmf0Boolean(value);
}

SrsAmf0Any* SrsAmf0Any::number(double value)
{
    return new SrsAmf0Number(value);
}

SrsAmf0Any* SrsAmf0Any::null()
{
    return new SrsAmf0Null();
}

SrsAmf0Any* SrsAmf0Any::undefined()
{
    return new SrsAmf0Undefined();
}

SrsAmf0Object* SrsAmf0Any::object()
{
    return new SrsAmf0Object();
}

SrsAmf0Any* SrsAmf0Any::object_eof()
{
    return new SrsAmf0ObjectEOF();
}

SrsAmf0EcmaArray* SrsAmf0Any::ecma_array()
{
    return new SrsAmf0EcmaArray();
}

SrsAmf0StrictArray* SrsAmf0Any::strict_array()
{
    return new SrsAmf0StrictArray();
}

SrsAmf0Any* SrsAmf0Any::date(int64_t value)
{
    return new SrsAmf0Date(value);
}

srs_error_t SrsAmf0Any::discovery(SrsBuffer* stream, SrsAmf0Any** ppvalue)
{
    srs_error_t err = srs_success;
    
    // detect the object-eof specially
    if (srs_amf0_is_object_eof(stream)) {
        *ppvalue = new SrsAmf0ObjectEOF();
        return err;
    }
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "marker requires 1 only %d bytes", stream->left());
    }
    
    char marker = stream->read_1bytes();
    
    // backward the 1byte marker.
    stream->skip(-1);
    
    switch (marker) {
        case RTMP_AMF0_String: {
            *ppvalue = SrsAmf0Any::str();
            return err;
        }
        case RTMP_AMF0_Boolean: {
            *ppvalue = SrsAmf0Any::boolean();
            return err;
        }
        case RTMP_AMF0_Number: {
            *ppvalue = SrsAmf0Any::number();
            return err;
        }
        case RTMP_AMF0_Null: {
            *ppvalue = SrsAmf0Any::null();
            return err;
        }
        case RTMP_AMF0_Undefined: {
            *ppvalue = SrsAmf0Any::undefined();
            return err;
        }
        case RTMP_AMF0_Object: {
            *ppvalue = SrsAmf0Any::object();
            return err;
        }
        case RTMP_AMF0_EcmaArray: {
            *ppvalue = SrsAmf0Any::ecma_array();
            return err;
        }
        case RTMP_AMF0_StrictArray: {
            *ppvalue = SrsAmf0Any::strict_array();
            return err;
        }
        case RTMP_AMF0_Date: {
            *ppvalue = SrsAmf0Any::date();
            return err;
        }
        case RTMP_AMF0_Invalid:
        default: {
            return srs_error_new(ERROR_RTMP_AMF0_INVALID, "invalid amf0 message, marker=%#x", marker);
        }
    }
}

SrsUnSortedHashtable::SrsUnSortedHashtable()
{
}

SrsUnSortedHashtable::~SrsUnSortedHashtable()
{
    clear();
}

int SrsUnSortedHashtable::count()
{
    return (int)properties.size();
}

void SrsUnSortedHashtable::clear()
{
    std::vector<SrsAmf0ObjectPropertyType>::iterator it;
    for (it = properties.begin(); it != properties.end(); ++it) {
        SrsAmf0ObjectPropertyType& elem = *it;
        SrsAmf0Any* any = elem.second;
        srs_freep(any);
    }
    properties.clear();
}

string SrsUnSortedHashtable::key_at(int index)
{
    srs_assert(index < count());
    SrsAmf0ObjectPropertyType& elem = properties[index];
    return elem.first;
}

const char* SrsUnSortedHashtable::key_raw_at(int index)
{
    srs_assert(index < count());
    SrsAmf0ObjectPropertyType& elem = properties[index];
    return elem.first.data();
}

SrsAmf0Any* SrsUnSortedHashtable::value_at(int index)
{
    srs_assert(index < count());
    SrsAmf0ObjectPropertyType& elem = properties[index];
    return elem.second;
}

void SrsUnSortedHashtable::set(string key, SrsAmf0Any* value)
{
    std::vector<SrsAmf0ObjectPropertyType>::iterator it;
    
    for (it = properties.begin(); it != properties.end(); ++it) {
        SrsAmf0ObjectPropertyType& elem = *it;
        std::string name = elem.first;
        SrsAmf0Any* any = elem.second;
        
        if (key == name) {
            srs_freep(any);
            properties.erase(it);
            break;
        }
    }
    
    if (value) {
        properties.push_back(std::make_pair(key, value));
    }
}

SrsAmf0Any* SrsUnSortedHashtable::get_property(string name)
{
    std::vector<SrsAmf0ObjectPropertyType>::iterator it;
    
    for (it = properties.begin(); it != properties.end(); ++it) {
        SrsAmf0ObjectPropertyType& elem = *it;
        std::string key = elem.first;
        SrsAmf0Any* any = elem.second;
        if (key == name) {
            return any;
        }
    }
    
    return NULL;
}

SrsAmf0Any* SrsUnSortedHashtable::ensure_property_string(string name)
{
    SrsAmf0Any* prop = get_property(name);
    
    if (!prop) {
        return NULL;
    }
    
    if (!prop->is_string()) {
        return NULL;
    }
    
    return prop;
}

SrsAmf0Any* SrsUnSortedHashtable::ensure_property_number(string name)
{
    SrsAmf0Any* prop = get_property(name);
    
    if (!prop) {
        return NULL;
    }
    
    if (!prop->is_number()) {
        return NULL;
    }
    
    return prop;
}

void SrsUnSortedHashtable::remove(string name)
{
    std::vector<SrsAmf0ObjectPropertyType>::iterator it;
    
    for (it = properties.begin(); it != properties.end();) {
        std::string key = it->first;
        SrsAmf0Any* any = it->second;
        
        if (key == name) {
            srs_freep(any);
            
            it = properties.erase(it);
        } else {
            ++it;
        }
    }
}

void SrsUnSortedHashtable::copy(SrsUnSortedHashtable* src)
{
    std::vector<SrsAmf0ObjectPropertyType>::iterator it;
    for (it = src->properties.begin(); it != src->properties.end(); ++it) {
        SrsAmf0ObjectPropertyType& elem = *it;
        std::string key = elem.first;
        SrsAmf0Any* any = elem.second;
        set(key, any->copy());
    }
}

SrsAmf0ObjectEOF::SrsAmf0ObjectEOF()
{
    marker = RTMP_AMF0_ObjectEnd;
}

SrsAmf0ObjectEOF::~SrsAmf0ObjectEOF()
{
}

int SrsAmf0ObjectEOF::total_size()
{
    return SrsAmf0Size::object_eof();
}

srs_error_t SrsAmf0ObjectEOF::read(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // value
    if (!stream->require(2)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "EOF requires 2 only %d bytes", stream->left());
    }
    int16_t temp = stream->read_2bytes();
    if (temp != 0x00) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "EOF invalid marker=%#x", temp);
    }
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "EOF requires 1 only %d bytes", stream->left());
    }
    
    char marker = stream->read_1bytes();
    if (marker != RTMP_AMF0_ObjectEnd) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "EOF invalid marker=%#x", marker);
    }
    
    return err;
}

srs_error_t SrsAmf0ObjectEOF::write(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // value
    if (!stream->require(2)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "EOF requires 2 only %d bytes", stream->left());
    }
    stream->write_2bytes(0x00);
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "EOF requires 1 only %d bytes", stream->left());
    }
    
    stream->write_1bytes(RTMP_AMF0_ObjectEnd);
    
    return err;
}

SrsAmf0Any* SrsAmf0ObjectEOF::copy()
{
    return new SrsAmf0ObjectEOF();
}

SrsAmf0Object::SrsAmf0Object()
{
    properties = new SrsUnSortedHashtable();
    eof = new SrsAmf0ObjectEOF();
    marker = RTMP_AMF0_Object;
}

SrsAmf0Object::~SrsAmf0Object()
{
    srs_freep(properties);
    srs_freep(eof);
}

int SrsAmf0Object::total_size()
{
    int size = 1;
    
    for (int i = 0; i < properties->count(); i++){
        std::string name = key_at(i);
        SrsAmf0Any* value = value_at(i);
        
        size += SrsAmf0Size::utf8(name);
        size += SrsAmf0Size::any(value);
    }
    
    size += SrsAmf0Size::object_eof();
    
    return size;
}

srs_error_t SrsAmf0Object::read(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "object requires 1 only %d bytes", stream->left());
    }
    
    char marker = stream->read_1bytes();
    if (marker != RTMP_AMF0_Object) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "object invalid marker=%#x", marker);
    }
    
    // value
    while (!stream->empty()) {
        // detect whether is eof.
        if (srs_amf0_is_object_eof(stream)) {
            SrsAmf0ObjectEOF pbj_eof;
            if ((err = pbj_eof.read(stream)) != srs_success) {
                return srs_error_wrap(err, "read EOF");
            }
            break;
        }
        
        // property-name: utf8 string
        std::string property_name;
        if ((err = srs_amf0_read_utf8(stream, property_name)) != srs_success) {
            return srs_error_wrap(err, "read property name");
        }
        // property-value: any
        SrsAmf0Any* property_value = NULL;
        if ((err = srs_amf0_read_any(stream, &property_value)) != srs_success) {
            srs_freep(property_value);
            return srs_error_wrap(err, "read property value, name=%s", property_name.c_str());
        }
        
        // add property
        this->set(property_name, property_value);
    }
    
    return err;
}

srs_error_t SrsAmf0Object::write(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "object requires 1 only %d bytes", stream->left());
    }
    
    stream->write_1bytes(RTMP_AMF0_Object);
    
    // value
    for (int i = 0; i < properties->count(); i++) {
        std::string name = this->key_at(i);
        SrsAmf0Any* any = this->value_at(i);
        
        if ((err = srs_amf0_write_utf8(stream, name)) != srs_success) {
            return srs_error_wrap(err, "write property name=%s", name.c_str());
        }
        
        if ((err = srs_amf0_write_any(stream, any)) != srs_success) {
            return srs_error_wrap(err, "write property value, name=%s", name.c_str());
        }
    }
    
    if ((err = eof->write(stream)) != srs_success) {
        return srs_error_wrap(err, "write EOF");
    }
    
    return err;
}

SrsAmf0Any* SrsAmf0Object::copy()
{
    SrsAmf0Object* copy = new SrsAmf0Object();
    copy->properties->copy(properties);
    return copy;
}

SrsJsonAny* SrsAmf0Object::to_json()
{
    SrsJsonObject* obj = SrsJsonAny::object();
    
    for (int i = 0; i < properties->count(); i++) {
        std::string name = this->key_at(i);
        SrsAmf0Any* any = this->value_at(i);
        
        obj->set(name, any->to_json());
    }
    
    return obj;
}

void SrsAmf0Object::clear()
{
    properties->clear();
}

int SrsAmf0Object::count()
{
    return properties->count();
}

string SrsAmf0Object::key_at(int index)
{
    return properties->key_at(index);
}

const char* SrsAmf0Object::key_raw_at(int index)
{
    return properties->key_raw_at(index);
}

SrsAmf0Any* SrsAmf0Object::value_at(int index)
{
    return properties->value_at(index);
}

void SrsAmf0Object::set(string key, SrsAmf0Any* value)
{
    properties->set(key, value);
}

SrsAmf0Any* SrsAmf0Object::get_property(string name)
{
    return properties->get_property(name);
}

SrsAmf0Any* SrsAmf0Object::ensure_property_string(string name)
{
    return properties->ensure_property_string(name);
}

SrsAmf0Any* SrsAmf0Object::ensure_property_number(string name)
{
    return properties->ensure_property_number(name);
}

void SrsAmf0Object::remove(string name)
{
    properties->remove(name);
}

SrsAmf0EcmaArray::SrsAmf0EcmaArray()
{
    _count = 0;
    properties = new SrsUnSortedHashtable();
    eof = new SrsAmf0ObjectEOF();
    marker = RTMP_AMF0_EcmaArray;
}

SrsAmf0EcmaArray::~SrsAmf0EcmaArray()
{
    srs_freep(properties);
    srs_freep(eof);
}

int SrsAmf0EcmaArray::total_size()
{
    int size = 1 + 4;
    
    for (int i = 0; i < properties->count(); i++){
        std::string name = key_at(i);
        SrsAmf0Any* value = value_at(i);
        
        size += SrsAmf0Size::utf8(name);
        size += SrsAmf0Size::any(value);
    }
    
    size += SrsAmf0Size::object_eof();
    
    return size;
}

srs_error_t SrsAmf0EcmaArray::read(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires 1 only %d bytes", stream->left());
    }
    
    char marker = stream->read_1bytes();
    if (marker != RTMP_AMF0_EcmaArray) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "EcmaArray invalid marker=%#x", marker);
    }
    
    // count
    if (!stream->require(4)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires 4 only %d bytes", stream->left());
    }
    
    int32_t count = stream->read_4bytes();
    
    // value
    this->_count = count;
    
    while (!stream->empty()) {
        // detect whether is eof.
        if (srs_amf0_is_object_eof(stream)) {
            SrsAmf0ObjectEOF pbj_eof;
            if ((err = pbj_eof.read(stream)) != srs_success) {
                return srs_error_wrap(err, "read EOF");
            }
            break;
        }
        
        // property-name: utf8 string
        std::string property_name;
        if ((err =srs_amf0_read_utf8(stream, property_name)) != srs_success) {
            return srs_error_wrap(err, "read property name");
        }
        // property-value: any
        SrsAmf0Any* property_value = NULL;
        if ((err = srs_amf0_read_any(stream, &property_value)) != srs_success) {
            return srs_error_wrap(err, "read property value, name=%s", property_name.c_str());
        }
        
        // add property
        this->set(property_name, property_value);
    }
    
    return err;
}

srs_error_t SrsAmf0EcmaArray::write(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 1 only %d bytes", stream->left());
    }
    
    stream->write_1bytes(RTMP_AMF0_EcmaArray);
    
    // count
    if (!stream->require(4)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 4 only %d bytes", stream->left());
    }
    
    stream->write_4bytes(this->_count);
    
    // value
    for (int i = 0; i < properties->count(); i++) {
        std::string name = this->key_at(i);
        SrsAmf0Any* any = this->value_at(i);
        
        if ((err = srs_amf0_write_utf8(stream, name)) != srs_success) {
            return srs_error_wrap(err, "write property name=%s", name.c_str());
        }
        
        if ((err = srs_amf0_write_any(stream, any)) != srs_success) {
            return srs_error_wrap(err, "write property value, name=%s", name.c_str());
        }
    }
    
    if ((err = eof->write(stream)) != srs_success) {
        return srs_error_wrap(err, "write EOF");
    }
    
    return err;
}

SrsAmf0Any* SrsAmf0EcmaArray::copy()
{
    SrsAmf0EcmaArray* copy = new SrsAmf0EcmaArray();
    copy->properties->copy(properties);
    copy->_count = _count;
    return copy;
}

SrsJsonAny* SrsAmf0EcmaArray::to_json()
{
    SrsJsonObject* obj = SrsJsonAny::object();
    
    for (int i = 0; i < properties->count(); i++) {
        std::string name = this->key_at(i);
        SrsAmf0Any* any = this->value_at(i);
        
        obj->set(name, any->to_json());
    }
    
    return obj;
}

void SrsAmf0EcmaArray::clear()
{
    properties->clear();
}

int SrsAmf0EcmaArray::count()
{
    return properties->count();
}

string SrsAmf0EcmaArray::key_at(int index)
{
    return properties->key_at(index);
}

const char* SrsAmf0EcmaArray::key_raw_at(int index)
{
    return properties->key_raw_at(index);
}

SrsAmf0Any* SrsAmf0EcmaArray::value_at(int index)
{
    return properties->value_at(index);
}

void SrsAmf0EcmaArray::set(string key, SrsAmf0Any* value)
{
    properties->set(key, value);
}

SrsAmf0Any* SrsAmf0EcmaArray::get_property(string name)
{
    return properties->get_property(name);
}

SrsAmf0Any* SrsAmf0EcmaArray::ensure_property_string(string name)
{
    return properties->ensure_property_string(name);
}

SrsAmf0Any* SrsAmf0EcmaArray::ensure_property_number(string name)
{
    return properties->ensure_property_number(name);
}

SrsAmf0StrictArray::SrsAmf0StrictArray()
{
    marker = RTMP_AMF0_StrictArray;
    _count = 0;
}

SrsAmf0StrictArray::~SrsAmf0StrictArray()
{
    std::vector<SrsAmf0Any*>::iterator it;
    for (it = properties.begin(); it != properties.end(); ++it) {
        SrsAmf0Any* any = *it;
        srs_freep(any);
    }
    properties.clear();
}

int SrsAmf0StrictArray::total_size()
{
    int size = 1 + 4;
    
    for (int i = 0; i < (int)properties.size(); i++){
        SrsAmf0Any* any = properties[i];
        size += any->total_size();
    }
    
    return size;
}

srs_error_t SrsAmf0StrictArray::read(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires 1 only %d bytes", stream->left());
    }
    
    char marker = stream->read_1bytes();
    if (marker != RTMP_AMF0_StrictArray) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "StrictArray invalid marker=%#x", marker);
    }
    
    // count
    if (!stream->require(4)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires 4 only %d bytes", stream->left());
    }
    
    int32_t count = stream->read_4bytes();
    
    // value
    this->_count = count;
    
    for (int i = 0; i < count && !stream->empty(); i++) {
        // property-value: any
        SrsAmf0Any* elem = NULL;
        if ((err = srs_amf0_read_any(stream, &elem)) != srs_success) {
            return srs_error_wrap(err, "read property");
        }
        
        // add property
        properties.push_back(elem);
    }
    
    return err;
}

srs_error_t SrsAmf0StrictArray::write(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 1 only %d bytes", stream->left());
    }
    
    stream->write_1bytes(RTMP_AMF0_StrictArray);
    
    // count
    if (!stream->require(4)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 4 only %d bytes", stream->left());
    }
    
    stream->write_4bytes(this->_count);
    
    // value
    for (int i = 0; i < (int)properties.size(); i++) {
        SrsAmf0Any* any = properties[i];
        
        if ((err = srs_amf0_write_any(stream, any)) != srs_success) {
            return srs_error_wrap(err, "write property");
        }
    }
    
    return err;
}

SrsAmf0Any* SrsAmf0StrictArray::copy()
{
    SrsAmf0StrictArray* copy = new SrsAmf0StrictArray();
    
    std::vector<SrsAmf0Any*>::iterator it;
    for (it = properties.begin(); it != properties.end(); ++it) {
        SrsAmf0Any* any = *it;
        copy->append(any->copy());
    }
    
    copy->_count = _count;
    return copy;
}

SrsJsonAny* SrsAmf0StrictArray::to_json()
{
    SrsJsonArray* arr = SrsJsonAny::array();
    
    for (int i = 0; i < (int)properties.size(); i++) {
        SrsAmf0Any* any = properties[i];
        
        arr->append(any->to_json());
    }
    
    return arr;
}

void SrsAmf0StrictArray::clear()
{
    properties.clear();
}

int SrsAmf0StrictArray::count()
{
    return (int)properties.size();
}

SrsAmf0Any* SrsAmf0StrictArray::at(int index)
{
    srs_assert(index < (int)properties.size());
    return properties.at(index);
}

void SrsAmf0StrictArray::append(SrsAmf0Any* any)
{
    properties.push_back(any);
    _count = (int32_t)properties.size();
}

int SrsAmf0Size::utf8(string value)
{
    return 2 + (int)value.length();
}

int SrsAmf0Size::str(string value)
{
    return 1 + SrsAmf0Size::utf8(value);
}

int SrsAmf0Size::number()
{
    return 1 + 8;
}

int SrsAmf0Size::date()
{
    return 1 + 8 + 2;
}

int SrsAmf0Size::null()
{
    return 1;
}

int SrsAmf0Size::undefined()
{
    return 1;
}

int SrsAmf0Size::boolean()
{
    return 1 + 1;
}

int SrsAmf0Size::object(SrsAmf0Object* obj)
{
    if (!obj) {
        return 0;
    }
    
    return obj->total_size();
}

int SrsAmf0Size::object_eof()
{
    return 2 + 1;
}

int SrsAmf0Size::ecma_array(SrsAmf0EcmaArray* arr)
{
    if (!arr) {
        return 0;
    }
    
    return arr->total_size();
}

int SrsAmf0Size::strict_array(SrsAmf0StrictArray* arr)
{
    if (!arr) {
        return 0;
    }
    
    return arr->total_size();
}

int SrsAmf0Size::any(SrsAmf0Any* o)
{
    if (!o) {
        return 0;
    }
    
    return o->total_size();
}

SrsAmf0String::SrsAmf0String(const char* _value)
{
    marker = RTMP_AMF0_String;
    if (_value) {
        value = _value;
    }
}

SrsAmf0String::~SrsAmf0String()
{
}

int SrsAmf0String::total_size()
{
    return SrsAmf0Size::str(value);
}

srs_error_t SrsAmf0String::read(SrsBuffer* stream)
{
    return srs_amf0_read_string(stream, value);
}

srs_error_t SrsAmf0String::write(SrsBuffer* stream)
{
    return srs_amf0_write_string(stream, value);
}

SrsAmf0Any* SrsAmf0String::copy()
{
    SrsAmf0String* copy = new SrsAmf0String(value.c_str());
    return copy;
}

SrsAmf0Boolean::SrsAmf0Boolean(bool _value)
{
    marker = RTMP_AMF0_Boolean;
    value = _value;
}

SrsAmf0Boolean::~SrsAmf0Boolean()
{
}

int SrsAmf0Boolean::total_size()
{
    return SrsAmf0Size::boolean();
}

srs_error_t SrsAmf0Boolean::read(SrsBuffer* stream)
{
    return srs_amf0_read_boolean(stream, value);
}

srs_error_t SrsAmf0Boolean::write(SrsBuffer* stream)
{
    return srs_amf0_write_boolean(stream, value);
}

SrsAmf0Any* SrsAmf0Boolean::copy()
{
    SrsAmf0Boolean* copy = new SrsAmf0Boolean(value);
    return copy;
}

SrsAmf0Number::SrsAmf0Number(double _value)
{
    marker = RTMP_AMF0_Number;
    value = _value;
}

SrsAmf0Number::~SrsAmf0Number()
{
}

int SrsAmf0Number::total_size()
{
    return SrsAmf0Size::number();
}

srs_error_t SrsAmf0Number::read(SrsBuffer* stream)
{
    return srs_amf0_read_number(stream, value);
}

srs_error_t SrsAmf0Number::write(SrsBuffer* stream)
{
    return srs_amf0_write_number(stream, value);
}

SrsAmf0Any* SrsAmf0Number::copy()
{
    SrsAmf0Number* copy = new SrsAmf0Number(value);
    return copy;
}

SrsAmf0Date::SrsAmf0Date(int64_t value)
{
    marker = RTMP_AMF0_Date;
    _date_value = value;
    _time_zone = 0;
}

SrsAmf0Date::~SrsAmf0Date()
{
}

int SrsAmf0Date::total_size()
{
    return SrsAmf0Size::date();
}

srs_error_t SrsAmf0Date::read(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires 1 only %d bytes", stream->left());
    }
    
    char marker = stream->read_1bytes();
    if (marker != RTMP_AMF0_Date) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "Date invalid marker=%#x", marker);
    }
    
    // date value
    // An ActionScript Date is serialized as the number of milliseconds
    // elapsed since the epoch of midnight on 1st Jan 1970 in the UTC
    // time zone.
    if (!stream->require(8)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires 8 only %d bytes", stream->left());
    }
    
    _date_value = stream->read_8bytes();
    
    // time zone
    // While the design of this type reserves room for time zone offset
    // information, it should not be filled in, nor used, as it is unconventional
    // to change time zones when serializing dates on a network. It is suggested
    // that the time zone be queried independently as needed.
    if (!stream->require(2)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires 2 only %d bytes", stream->left());
    }
    
    _time_zone = stream->read_2bytes();
    
    return err;
}

srs_error_t SrsAmf0Date::write(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 1 only %d bytes", stream->left());
    }
    
    stream->write_1bytes(RTMP_AMF0_Date);
    
    // date value
    if (!stream->require(8)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 8 only %d bytes", stream->left());
    }
    
    stream->write_8bytes(_date_value);
    
    // time zone
    if (!stream->require(2)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 2 only %d bytes", stream->left());
    }
    
    stream->write_2bytes(_time_zone);
    
    return err;
}

SrsAmf0Any* SrsAmf0Date::copy()
{
    SrsAmf0Date* copy = new SrsAmf0Date(0);
    
    copy->_date_value = _date_value;
    copy->_time_zone = _time_zone;
    
    return copy;
}

int64_t SrsAmf0Date::date()
{
    return _date_value;
}

int16_t SrsAmf0Date::time_zone()
{
    return _time_zone;
}

SrsAmf0Null::SrsAmf0Null()
{
    marker = RTMP_AMF0_Null;
}

SrsAmf0Null::~SrsAmf0Null()
{
}

int SrsAmf0Null::total_size()
{
    return SrsAmf0Size::null();
}

srs_error_t SrsAmf0Null::read(SrsBuffer* stream)
{
    return srs_amf0_read_null(stream);
}

srs_error_t SrsAmf0Null::write(SrsBuffer* stream)
{
    return srs_amf0_write_null(stream);
}

SrsAmf0Any* SrsAmf0Null::copy()
{
    SrsAmf0Null* copy = new SrsAmf0Null();
    return copy;
}

SrsAmf0Undefined::SrsAmf0Undefined()
{
    marker = RTMP_AMF0_Undefined;
}

SrsAmf0Undefined::~SrsAmf0Undefined()
{
}

int SrsAmf0Undefined::total_size()
{
    return SrsAmf0Size::undefined();
}

srs_error_t SrsAmf0Undefined::read(SrsBuffer* stream)
{
    return srs_amf0_read_undefined(stream);
}

srs_error_t SrsAmf0Undefined::write(SrsBuffer* stream)
{
    return srs_amf0_write_undefined(stream);
}

SrsAmf0Any* SrsAmf0Undefined::copy()
{
    SrsAmf0Undefined* copy = new SrsAmf0Undefined();
    return copy;
}

srs_error_t srs_amf0_read_any(SrsBuffer* stream, SrsAmf0Any** ppvalue)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsAmf0Any::discovery(stream, ppvalue)) != srs_success) {
        return srs_error_wrap(err, "discovery");
    }
    
    srs_assert(*ppvalue);
    
    if ((err = (*ppvalue)->read(stream)) != srs_success) {
        srs_freep(*ppvalue);
        return srs_error_wrap(err, "parse elem");
    }
    
    return err;
}

srs_error_t srs_amf0_read_string(SrsBuffer* stream, string& value)
{
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires 1 only %d bytes", stream->left());
    }
    
    char marker = stream->read_1bytes();
    if (marker != RTMP_AMF0_String) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "String invalid marker=%#x", marker);
    }
    
    return srs_amf0_read_utf8(stream, value);
}

srs_error_t srs_amf0_write_string(SrsBuffer* stream, string value)
{   
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 1 only %d bytes", stream->left());
    }
    
    stream->write_1bytes(RTMP_AMF0_String);
    
    return srs_amf0_write_utf8(stream, value);
}

srs_error_t srs_amf0_read_boolean(SrsBuffer* stream, bool& value)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires 1 only %d bytes", stream->left());
    }
    
    char marker = stream->read_1bytes();
    if (marker != RTMP_AMF0_Boolean) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "Boolean invalid marker=%#x", marker);
    }
    
    // value
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires 1 only %d bytes", stream->left());
    }
    
    value = (stream->read_1bytes() != 0);
    
    return err;
}

srs_error_t srs_amf0_write_boolean(SrsBuffer* stream, bool value)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 1 only %d bytes", stream->left());
    }
    stream->write_1bytes(RTMP_AMF0_Boolean);
    
    // value
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 1 only %d bytes", stream->left());
    }
    
    if (value) {
        stream->write_1bytes(0x01);
    } else {
        stream->write_1bytes(0x00);
    }
    
    return err;
}

srs_error_t srs_amf0_read_number(SrsBuffer* stream, double& value)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires 1 only %d bytes", stream->left());
    }
    
    char marker = stream->read_1bytes();
    if (marker != RTMP_AMF0_Number) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "Number invalid marker=%#x", marker);
    }
    
    // value
    if (!stream->require(8)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires 8 only %d bytes", stream->left());
    }
    
    int64_t temp = stream->read_8bytes();
    memcpy(&value, &temp, 8);
    
    return err;
}

srs_error_t srs_amf0_write_number(SrsBuffer* stream, double value)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 1 only %d bytes", stream->left());
    }
    
    stream->write_1bytes(RTMP_AMF0_Number);
    
    // value
    if (!stream->require(8)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 8 only %d bytes", stream->left());
    }
    
    int64_t temp = 0x00;
    memcpy(&temp, &value, 8);
    stream->write_8bytes(temp);
    
    return err;
}

srs_error_t srs_amf0_read_null(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires 1 only %d bytes", stream->left());
    }
    
    char marker = stream->read_1bytes();
    if (marker != RTMP_AMF0_Null) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "Null invalid marker=%#x", marker);
    }
    
    return err;
}

srs_error_t srs_amf0_write_null(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 1 only %d bytes", stream->left());
    }
    
    stream->write_1bytes(RTMP_AMF0_Null);
    
    return err;
}

srs_error_t srs_amf0_read_undefined(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires 1 only %d bytes", stream->left());
    }
    
    char marker = stream->read_1bytes();
    if (marker != RTMP_AMF0_Undefined) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "Undefined invalid marker=%#x", marker);
    }
    
    return err;
}

srs_error_t srs_amf0_write_undefined(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // marker
    if (!stream->require(1)) {
        return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 1 only %d bytes", stream->left());
    }
    
    stream->write_1bytes(RTMP_AMF0_Undefined);
    
    return err;
}

namespace _srs_internal
{
    srs_error_t srs_amf0_read_utf8(SrsBuffer* stream, string& value)
    {
        srs_error_t err = srs_success;
        
        // len
        if (!stream->require(2)) {
            return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires 2 only %d bytes", stream->left());
        }
        int16_t len = stream->read_2bytes();
        
        // empty string
        if (len <= 0) {
            return err;
        }
        
        // data
        if (!stream->require(len)) {
            return srs_error_new(ERROR_RTMP_AMF0_DECODE, "requires %d only %d bytes", len, stream->left());
        }
        std::string str = stream->read_string(len);
        
        // support utf8-1 only
        // 1.3.1 Strings and UTF-8
        // UTF8-1 = %x00-7F
        // TODO: support other utf-8 strings
        /*for (int i = 0; i < len; i++) {
         char ch = *(str.data() + i);
         if ((ch & 0x80) != 0) {
         ret = ERROR_RTMP_AMF0_DECODE;
         srs_error("ignored. only support utf8-1, 0x00-0x7F, actual is %#x. ret=%d", (int)ch, ret);
         ret = ERROR_SUCCESS;
         }
         }*/
        
        value = str;
        
        return err;
    }
    
    srs_error_t srs_amf0_write_utf8(SrsBuffer* stream, string value)
    {
        srs_error_t err = srs_success;
        
        // len
        if (!stream->require(2)) {
            return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 2 only %d bytes", stream->left());
        }
        stream->write_2bytes(value.length());
        
        // empty string
        if (value.length() <= 0) {
            return err;
        }
        
        // data
        if (!stream->require((int)value.length())) {
            return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires %d only %d bytes", value.length(), stream->left());
        }
        stream->write_string(value);
        
        return err;
    }
    
    bool srs_amf0_is_object_eof(SrsBuffer* stream)
    {
        // detect the object-eof specially
        if (stream->require(3)) {
            int32_t flag = stream->read_3bytes();
            stream->skip(-3);
            
            return 0x09 == flag;
        }
        
        return false;
    }
    
    srs_error_t srs_amf0_write_object_eof(SrsBuffer* stream, SrsAmf0ObjectEOF* value)
    {
        srs_error_t err = srs_success;
        
        srs_assert(value != NULL);
        
        // value
        if (!stream->require(2)) {
            return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 2 only %d bytes", stream->left());
        }
        stream->write_2bytes(0x00);
        
        // marker
        if (!stream->require(1)) {
            return srs_error_new(ERROR_RTMP_AMF0_ENCODE, "requires 1 only %d bytes", stream->left());
        }
        
        stream->write_1bytes(RTMP_AMF0_ObjectEnd);
        
        return err;
    }
    
    srs_error_t srs_amf0_write_any(SrsBuffer* stream, SrsAmf0Any* value)
    {
        srs_assert(value != NULL);
        return value->write(stream);
    }
}

// following is generated by src/protocol/srs_protocol_io.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_protocol_io.hpp>

ISrsProtocolStatistic::ISrsProtocolStatistic()
{
}

ISrsProtocolStatistic::~ISrsProtocolStatistic()
{
}

ISrsProtocolReader::ISrsProtocolReader()
{
}

ISrsProtocolReader::~ISrsProtocolReader()
{
}

ISrsProtocolWriter::ISrsProtocolWriter()
{
}

ISrsProtocolWriter::~ISrsProtocolWriter()
{
}

ISrsProtocolReaderWriter::ISrsProtocolReaderWriter()
{
}

ISrsProtocolReaderWriter::~ISrsProtocolReaderWriter()
{
}

// following is generated by src/protocol/srs_rtmp_stack.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_rtmp_stack.hpp>

//#include <srs_protocol_amf0.hpp>
//#include <srs_protocol_io.hpp>
//#include <srs_kernel_buffer.hpp>
//#include <srs_core_autofree.hpp>
//#include <srs_kernel_utility.hpp>
//#include <srs_protocol_stream.hpp>
//#include <srs_protocol_utility.hpp>
//#include <srs_rtmp_handshake.hpp>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <unistd.h>
#endif

#include <stdlib.h>
using namespace std;

// FMLE
#define RTMP_AMF0_COMMAND_ON_FC_PUBLISH         "onFCPublish"
#define RTMP_AMF0_COMMAND_ON_FC_UNPUBLISH       "onFCUnpublish"

// default stream id for response the createStream request.
#define SRS_DEFAULT_SID                         1

// when got a messae header, there must be some data,
// increase recv timeout to got an entire message.
#define SRS_MIN_RECV_TIMEOUT_US (int64_t)(60*1000*1000LL)

/****************************************************************************
 *****************************************************************************
 ****************************************************************************/
/**
 * 6.1.2. Chunk Message Header
 * There are four different formats for the chunk message header,
 * selected by the "fmt" field in the chunk basic header.
 */
// 6.1.2.1. Type 0
// Chunks of Type 0 are 11 bytes long. This type MUST be used at the
// start of a chunk stream, and whenever the stream timestamp goes
// backward (e.g., because of a backward seek).
#define RTMP_FMT_TYPE0                          0
// 6.1.2.2. Type 1
// Chunks of Type 1 are 7 bytes long. The message stream ID is not
// included; this chunk takes the same stream ID as the preceding chunk.
// Streams with variable-sized messages (for example, many video
// formats) SHOULD use this format for the first chunk of each new
// message after the first.
#define RTMP_FMT_TYPE1                          1
// 6.1.2.3. Type 2
// Chunks of Type 2 are 3 bytes long. Neither the stream ID nor the
// message length is included; this chunk has the same stream ID and
// message length as the preceding chunk. Streams with constant-sized
// messages (for example, some audio and data formats) SHOULD use this
// format for the first chunk of each message after the first.
#define RTMP_FMT_TYPE2                          2
// 6.1.2.4. Type 3
// Chunks of Type 3 have no header. Stream ID, message length and
// timestamp delta are not present; chunks of this type take values from
// the preceding chunk. When a single message is split into chunks, all
// chunks of a message except the first one, SHOULD use this type. Refer
// to example 2 in section 6.2.2. Stream consisting of messages of
// exactly the same size, stream ID and spacing in time SHOULD use this
// type for all chunks after chunk of Type 2. Refer to example 1 in
// section 6.2.1. If the delta between the first message and the second
// message is same as the time stamp of first message, then chunk of
// type 3 would immediately follow the chunk of type 0 as there is no
// need for a chunk of type 2 to register the delta. If Type 3 chunk
// follows a Type 0 chunk, then timestamp delta for this Type 3 chunk is
// the same as the timestamp of Type 0 chunk.
#define RTMP_FMT_TYPE3                          3

/****************************************************************************
 *****************************************************************************
 ****************************************************************************/
/**
 * band width check method name, which will be invoked by client.
 * band width check mothods use SrsBandwidthPacket as its internal packet type,
 * so ensure you set command name when you use it.
 */
// server play control
#define SRS_BW_CHECK_START_PLAY                 "onSrsBandCheckStartPlayBytes"
#define SRS_BW_CHECK_STARTING_PLAY              "onSrsBandCheckStartingPlayBytes"
#define SRS_BW_CHECK_STOP_PLAY                  "onSrsBandCheckStopPlayBytes"
#define SRS_BW_CHECK_STOPPED_PLAY               "onSrsBandCheckStoppedPlayBytes"

// server publish control
#define SRS_BW_CHECK_START_PUBLISH              "onSrsBandCheckStartPublishBytes"
#define SRS_BW_CHECK_STARTING_PUBLISH           "onSrsBandCheckStartingPublishBytes"
#define SRS_BW_CHECK_STOP_PUBLISH               "onSrsBandCheckStopPublishBytes"
// @remark, flash never send out this packet, for its queue is full.
#define SRS_BW_CHECK_STOPPED_PUBLISH            "onSrsBandCheckStoppedPublishBytes"

// EOF control.
// the report packet when check finished.
#define SRS_BW_CHECK_FINISHED                   "onSrsBandCheckFinished"
// @remark, flash never send out this packet, for its queue is full.
#define SRS_BW_CHECK_FINAL                      "finalClientPacket"

// data packets
#define SRS_BW_CHECK_PLAYING                    "onSrsBandCheckPlaying"
#define SRS_BW_CHECK_PUBLISHING                 "onSrsBandCheckPublishing"

/****************************************************************************
 *****************************************************************************
 ****************************************************************************/

SrsPacket::SrsPacket()
{
}

SrsPacket::~SrsPacket()
{
}

srs_error_t SrsPacket::encode(int& psize, char*& ppayload)
{
    srs_error_t err = srs_success;
    
    int size = get_size();
    char* payload = NULL;
    
    if (size > 0) {
        payload = new char[size];
        
        SrsBuffer* stream = new SrsBuffer(payload, size);
        SrsAutoFree(SrsBuffer, stream);
        
        if ((err = encode_packet(stream)) != srs_success) {
            srs_freepa(payload);
            return srs_error_wrap(err, "encode packet");
        }
    }
    
    psize = size;
    ppayload = payload;
    
    return err;
}

srs_error_t SrsPacket::decode(SrsBuffer* stream)
{
    return srs_error_new(ERROR_SYSTEM_PACKET_INVALID, "decode");
}

int SrsPacket::get_prefer_cid()
{
    return 0;
}

int SrsPacket::get_message_type()
{
    return 0;
}

int SrsPacket::get_size()
{
    return 0;
}

srs_error_t SrsPacket::encode_packet(SrsBuffer* stream)
{
    return srs_error_new(ERROR_SYSTEM_PACKET_INVALID, "encode");
}

SrsProtocol::AckWindowSize::AckWindowSize()
{
    window = 0;
    sequence_number = nb_recv_bytes = 0;
}

SrsProtocol::SrsProtocol(ISrsProtocolReaderWriter* io)
{
    in_buffer = new SrsFastStream();
    skt = io;
    
    in_chunk_size = SRS_CONSTS_RTMP_PROTOCOL_CHUNK_SIZE;
    out_chunk_size = SRS_CONSTS_RTMP_PROTOCOL_CHUNK_SIZE;
    
    nb_out_iovs = SRS_CONSTS_IOVS_MAX;
    out_iovs = (iovec*)malloc(sizeof(iovec) * nb_out_iovs);
    // each chunk consumers atleast 2 iovs
    srs_assert(nb_out_iovs >= 2);
    
    warned_c0c3_cache_dry = false;
    auto_response_when_recv = true;
    show_debug_info = true;
    in_buffer_length = 0;
    
    cs_cache = NULL;
    if (SRS_PERF_CHUNK_STREAM_CACHE > 0) {
        cs_cache = new SrsChunkStream*[SRS_PERF_CHUNK_STREAM_CACHE];
    }
    for (int cid = 0; cid < SRS_PERF_CHUNK_STREAM_CACHE; cid++) {
        SrsChunkStream* cs = new SrsChunkStream(cid);
        // set the perfer cid of chunk,
        // which will copy to the message received.
        cs->header.perfer_cid = cid;
        
        cs_cache[cid] = cs;
    }
}

SrsProtocol::~SrsProtocol()
{
    if (true) {
        std::map<int, SrsChunkStream*>::iterator it;
        
        for (it = chunk_streams.begin(); it != chunk_streams.end(); ++it) {
            SrsChunkStream* stream = it->second;
            srs_freep(stream);
        }
        
        chunk_streams.clear();
    }
    
    if (true) {
        std::vector<SrsPacket*>::iterator it;
        for (it = manual_response_queue.begin(); it != manual_response_queue.end(); ++it) {
            SrsPacket* pkt = *it;
            srs_freep(pkt);
        }
        manual_response_queue.clear();
    }
    
    srs_freep(in_buffer);
    
    // alloc by malloc, use free directly.
    if (out_iovs) {
        free(out_iovs);
        out_iovs = NULL;
    }
    
    // free all chunk stream cache.
    for (int i = 0; i < SRS_PERF_CHUNK_STREAM_CACHE; i++) {
        SrsChunkStream* cs = cs_cache[i];
        srs_freep(cs);
    }
    srs_freepa(cs_cache);
}

void SrsProtocol::set_auto_response(bool v)
{
    auto_response_when_recv = v;
}

srs_error_t SrsProtocol::manual_response_flush()
{
    srs_error_t err = srs_success;
    
    if (manual_response_queue.empty()) {
        return err;
    }
    
    std::vector<SrsPacket*>::iterator it;
    for (it = manual_response_queue.begin(); it != manual_response_queue.end();) {
        SrsPacket* pkt = *it;
        
        // erase this packet, the send api always free it.
        it = manual_response_queue.erase(it);
        
        // use underlayer api to send, donot flush again.
        if ((err = do_send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send packet");
        }
    }
    
    return err;
}

#ifdef SRS_PERF_MERGED_READ
void SrsProtocol::set_merge_read(bool v, IMergeReadHandler* handler)
{
    in_buffer->set_merge_read(v, handler);
}

void SrsProtocol::set_recv_buffer(int buffer_size)
{
    in_buffer->set_buffer(buffer_size);
}
#endif

void SrsProtocol::set_recv_timeout(int64_t tm)
{
    return skt->set_recv_timeout(tm);
}

int64_t SrsProtocol::get_recv_timeout()
{
    return skt->get_recv_timeout();
}

void SrsProtocol::set_send_timeout(int64_t tm)
{
    return skt->set_send_timeout(tm);
}

int64_t SrsProtocol::get_send_timeout()
{
    return skt->get_send_timeout();
}

int64_t SrsProtocol::get_recv_bytes()
{
    return skt->get_recv_bytes();
}

int64_t SrsProtocol::get_send_bytes()
{
    return skt->get_send_bytes();
}

srs_error_t SrsProtocol::set_in_window_ack_size(int ack_size)
{
    in_ack_size.window = ack_size;
    return srs_success;
}

srs_error_t SrsProtocol::recv_message(SrsCommonMessage** pmsg)
{
    *pmsg = NULL;
    
    srs_error_t err = srs_success;
    
    while (true) {
        SrsCommonMessage* msg = NULL;
        
        if ((err = recv_interlaced_message(&msg)) != srs_success) {
            srs_freep(msg);
            return srs_error_wrap(err, "recv interlaced message");
        }
        
        if (!msg) {
            continue;
        }
        
        if (msg->size <= 0 || msg->header.payload_length <= 0) {
            srs_trace("ignore empty message(type=%d, size=%d, time=%" PRId64 ", sid=%d).",
                      msg->header.message_type, msg->header.payload_length,
                      msg->header.timestamp, msg->header.stream_id);
            srs_freep(msg);
            continue;
        }
        
        if ((err = on_recv_message(msg)) != srs_success) {
            srs_freep(msg);
            return srs_error_wrap(err, "on recv message");
        }
        
        *pmsg = msg;
        break;
    }
    
    return err;
}

srs_error_t SrsProtocol::decode_message(SrsCommonMessage* msg, SrsPacket** ppacket)
{
    *ppacket = NULL;
    
    srs_error_t err = srs_success;
    
    srs_assert(msg != NULL);
    srs_assert(msg->payload != NULL);
    srs_assert(msg->size > 0);
    
    SrsBuffer stream(msg->payload, msg->size);
    
    // decode the packet.
    SrsPacket* packet = NULL;
    if ((err = do_decode_message(msg->header, &stream, &packet)) != srs_success) {
        srs_freep(packet);
        return srs_error_wrap(err, "decode message");
    }
    
    // set to output ppacket only when success.
    *ppacket = packet;
    
    return err;
}

srs_error_t SrsProtocol::do_send_messages(SrsSharedPtrMessage** msgs, int nb_msgs)
{
    srs_error_t err = srs_success;
    
#ifdef SRS_PERF_COMPLEX_SEND
    int iov_index = 0;
    iovec* iovs = out_iovs + iov_index;
    
    int c0c3_cache_index = 0;
    char* c0c3_cache = out_c0c3_caches + c0c3_cache_index;
    
    // try to send use the c0c3 header cache,
    // if cache is consumed, try another loop.
    for (int i = 0; i < nb_msgs; i++) {
        SrsSharedPtrMessage* msg = msgs[i];
        
        if (!msg) {
            continue;
        }
        
        // ignore empty message.
        if (!msg->payload || msg->size <= 0) {
            continue;
        }
        
        // p set to current write position,
        // it's ok when payload is NULL and size is 0.
        char* p = msg->payload;
        char* pend = msg->payload + msg->size;
        
        // always write the header event payload is empty.
        while (p < pend) {
            // always has header
            int nb_cache = SRS_CONSTS_C0C3_HEADERS_MAX - c0c3_cache_index;
            int nbh = msg->chunk_header(c0c3_cache, nb_cache, p == msg->payload);
            srs_assert(nbh > 0);
            
            // header iov
            iovs[0].iov_base = c0c3_cache;
            iovs[0].iov_len = nbh;
            
            // payload iov
            int payload_size = srs_min(out_chunk_size, (int)(pend - p));
            iovs[1].iov_base = p;
            iovs[1].iov_len = payload_size;
            
            // consume sendout bytes.
            p += payload_size;
            
            // realloc the iovs if exceed,
            // for we donot know how many messges maybe to send entirely,
            // we just alloc the iovs, it's ok.
            if (iov_index >= nb_out_iovs - 2) {
                srs_warn("resize iovs %d => %d, max_msgs=%d", nb_out_iovs, nb_out_iovs + SRS_CONSTS_IOVS_MAX, SRS_PERF_MW_MSGS);
                
                nb_out_iovs += SRS_CONSTS_IOVS_MAX;
                int realloc_size = sizeof(iovec) * nb_out_iovs;
                out_iovs = (iovec*)realloc(out_iovs, realloc_size);
            }
            
            // to next pair of iovs
            iov_index += 2;
            iovs = out_iovs + iov_index;
            
            // to next c0c3 header cache
            c0c3_cache_index += nbh;
            c0c3_cache = out_c0c3_caches + c0c3_cache_index;
            
            // the cache header should never be realloc again,
            // for the ptr is set to iovs, so we just warn user to set larger
            // and use another loop to send again.
            int c0c3_left = SRS_CONSTS_C0C3_HEADERS_MAX - c0c3_cache_index;
            if (c0c3_left < SRS_CONSTS_RTMP_MAX_FMT0_HEADER_SIZE) {
                // only warn once for a connection.
                if (!warned_c0c3_cache_dry) {
                    srs_warn("c0c3 cache header too small, recoment to %d", SRS_CONSTS_C0C3_HEADERS_MAX + SRS_CONSTS_RTMP_MAX_FMT0_HEADER_SIZE);
                    warned_c0c3_cache_dry = true;
                }
                
                // when c0c3 cache dry,
                // sendout all messages and reset the cache, then send again.
                if ((err = do_iovs_send(out_iovs, iov_index)) != srs_success) {
                    return srs_error_wrap(err, "send iovs");
                }
                
                // reset caches, while these cache ensure
                // atleast we can sendout a chunk.
                iov_index = 0;
                iovs = out_iovs + iov_index;
                
                c0c3_cache_index = 0;
                c0c3_cache = out_c0c3_caches + c0c3_cache_index;
            }
        }
    }
    
    // maybe the iovs already sendout when c0c3 cache dry,
    // so just ignore when no iovs to send.
    if (iov_index <= 0) {
        return err;
    }
    
    return do_iovs_send(out_iovs, iov_index);
#else
    // try to send use the c0c3 header cache,
    // if cache is consumed, try another loop.
    for (int i = 0; i < nb_msgs; i++) {
        SrsSharedPtrMessage* msg = msgs[i];
        
        if (!msg) {
            continue;
        }
        
        // ignore empty message.
        if (!msg->payload || msg->size <= 0) {
            continue;
        }
        
        // p set to current write position,
        // it's ok when payload is NULL and size is 0.
        char* p = msg->payload;
        char* pend = msg->payload + msg->size;
        
        // always write the header event payload is empty.
        while (p < pend) {
            // for simple send, send each chunk one by one
            iovec* iovs = out_iovs;
            char* c0c3_cache = out_c0c3_caches;
            int nb_cache = SRS_CONSTS_C0C3_HEADERS_MAX;
            
            // always has header
            int nbh = msg->chunk_header(c0c3_cache, nb_cache, p == msg->payload);
            srs_assert(nbh > 0);
            
            // header iov
            iovs[0].iov_base = c0c3_cache;
            iovs[0].iov_len = nbh;
            
            // payload iov
            int payload_size = srs_min(out_chunk_size, pend - p);
            iovs[1].iov_base = p;
            iovs[1].iov_len = payload_size;
            
            // consume sendout bytes.
            p += payload_size;
            
            if ((er = skt->writev(iovs, 2, NULL)) != srs_success) {
                return srs_error_wrap(err, "writev");
            }
        }
    }
    
    return err;
#endif
}

srs_error_t SrsProtocol::do_iovs_send(iovec* iovs, int size)
{
    return srs_write_large_iovs(skt, iovs, size);
}

srs_error_t SrsProtocol::do_send_and_free_packet(SrsPacket* packet, int stream_id)
{
    srs_error_t err = srs_success;
    
    srs_assert(packet);
    SrsAutoFree(SrsPacket, packet);
    
    int size = 0;
    char* payload = NULL;
    if ((err = packet->encode(size, payload)) != srs_success) {
        return srs_error_wrap(err, "encode packet");
    }
    
    // encode packet to payload and size.
    if (size <= 0 || payload == NULL) {
        srs_warn("packet is empty, ignore empty message.");
        return err;
    }
    
    // to message
    SrsMessageHeader header;
    header.payload_length = size;
    header.message_type = packet->get_message_type();
    header.stream_id = stream_id;
    header.perfer_cid = packet->get_prefer_cid();
    
    err = do_simple_send(&header, payload, size);
    srs_freepa(payload);
    if (err != srs_success) {
        return srs_error_wrap(err, "simple send");
    }
    
    if ((err = on_send_packet(&header, packet)) != srs_success) {
        return srs_error_wrap(err, "on send packet");
    }
    
    return err;
}

srs_error_t SrsProtocol::do_simple_send(SrsMessageHeader* mh, char* payload, int size)
{
    srs_error_t err = srs_success;
    
    // we directly send out the packet,
    // use very simple algorithm, not very fast,
    // but it's ok.
    char* p = payload;
    char* end = p + size;
    char c0c3[SRS_CONSTS_RTMP_MAX_FMT0_HEADER_SIZE];
    while (p < end) {
        int nbh = 0;
        if (p == payload) {
            nbh = srs_chunk_header_c0(mh->perfer_cid, (uint32_t)mh->timestamp, mh->payload_length, mh->message_type, mh->stream_id, c0c3, sizeof(c0c3));
        } else {
            nbh = srs_chunk_header_c3(mh->perfer_cid, (uint32_t)mh->timestamp, c0c3, sizeof(c0c3));
        }
        srs_assert(nbh > 0);;
        
        iovec iovs[2];
        iovs[0].iov_base = c0c3;
        iovs[0].iov_len = nbh;
        
        int payload_size = srs_min((int)(end - p), out_chunk_size);
        iovs[1].iov_base = p;
        iovs[1].iov_len = payload_size;
        p += payload_size;
        
        if ((err = skt->writev(iovs, 2, NULL)) != srs_success) {
            return srs_error_wrap(err, "writev packet");
        }
    }
    
    return err;
}

srs_error_t SrsProtocol::do_decode_message(SrsMessageHeader& header, SrsBuffer* stream, SrsPacket** ppacket)
{
    srs_error_t err = srs_success;
    
    SrsPacket* packet = NULL;
    
    // decode specified packet type
    if (header.is_amf0_command() || header.is_amf3_command() || header.is_amf0_data() || header.is_amf3_data()) {
        // skip 1bytes to decode the amf3 command.
        if (header.is_amf3_command() && stream->require(1)) {
            stream->skip(1);
        }
        
        // amf0 command message.
        // need to read the command name.
        std::string command;
        if ((err = srs_amf0_read_string(stream, command)) != srs_success) {
            return srs_error_wrap(err, "decode command name");
        }
        
        // result/error packet
        if (command == RTMP_AMF0_COMMAND_RESULT || command == RTMP_AMF0_COMMAND_ERROR) {
            double transactionId = 0.0;
            if ((err = srs_amf0_read_number(stream, transactionId)) != srs_success) {
                return srs_error_wrap(err, "decode tid for %s", command.c_str());
            }
            
            // reset stream, for header read completed.
            stream->skip(-1 * stream->pos());
            if (header.is_amf3_command()) {
                stream->skip(1);
            }
            
            // find the call name
            if (requests.find(transactionId) == requests.end()) {
                return srs_error_new(ERROR_RTMP_NO_REQUEST, "find request for command=%s, tid=%.2f", command.c_str(), transactionId);
            }
            
            std::string request_name = requests[transactionId];
            if (request_name == RTMP_AMF0_COMMAND_CONNECT) {
                *ppacket = packet = new SrsConnectAppResPacket();
                return packet->decode(stream);
            } else if (request_name == RTMP_AMF0_COMMAND_CREATE_STREAM) {
                *ppacket = packet = new SrsCreateStreamResPacket(0, 0);
                return packet->decode(stream);
            } else if (request_name == RTMP_AMF0_COMMAND_RELEASE_STREAM) {
                *ppacket = packet = new SrsFMLEStartResPacket(0);
                return packet->decode(stream);
            } else if (request_name == RTMP_AMF0_COMMAND_FC_PUBLISH) {
                *ppacket = packet = new SrsFMLEStartResPacket(0);
                return packet->decode(stream);
            } else if (request_name == RTMP_AMF0_COMMAND_UNPUBLISH) {
                *ppacket = packet = new SrsFMLEStartResPacket(0);
                return packet->decode(stream);
            } else {
                return srs_error_new(ERROR_RTMP_NO_REQUEST, "request=%s, tid=%.2f", request_name.c_str(), transactionId);
            }
        }
        
        // reset to zero(amf3 to 1) to restart decode.
        stream->skip(-1 * stream->pos());
        if (header.is_amf3_command()) {
            stream->skip(1);
        }
        
        // decode command object.
        if (command == RTMP_AMF0_COMMAND_CONNECT) {
            *ppacket = packet = new SrsConnectAppPacket();
            return packet->decode(stream);
        } else if (command == RTMP_AMF0_COMMAND_CREATE_STREAM) {
            *ppacket = packet = new SrsCreateStreamPacket();
            return packet->decode(stream);
        } else if (command == RTMP_AMF0_COMMAND_PLAY) {
            *ppacket = packet = new SrsPlayPacket();
            return packet->decode(stream);
        } else if (command == RTMP_AMF0_COMMAND_PAUSE) {
            *ppacket = packet = new SrsPausePacket();
            return packet->decode(stream);
        } else if (command == RTMP_AMF0_COMMAND_RELEASE_STREAM) {
            *ppacket = packet = new SrsFMLEStartPacket();
            return packet->decode(stream);
        } else if (command == RTMP_AMF0_COMMAND_FC_PUBLISH) {
            *ppacket = packet = new SrsFMLEStartPacket();
            return packet->decode(stream);
        } else if (command == RTMP_AMF0_COMMAND_PUBLISH) {
            *ppacket = packet = new SrsPublishPacket();
            return packet->decode(stream);
        } else if (command == RTMP_AMF0_COMMAND_UNPUBLISH) {
            *ppacket = packet = new SrsFMLEStartPacket();
            return packet->decode(stream);
        } else if (command == SRS_CONSTS_RTMP_SET_DATAFRAME) {
            *ppacket = packet = new SrsOnMetaDataPacket();
            return packet->decode(stream);
        } else if (command == SRS_CONSTS_RTMP_ON_METADATA) {
            *ppacket = packet = new SrsOnMetaDataPacket();
            return packet->decode(stream);
        } else if (command == SRS_BW_CHECK_FINISHED) {
            *ppacket = packet = new SrsBandwidthPacket();
            return packet->decode(stream);
        } else if (command == SRS_BW_CHECK_PLAYING) {
            *ppacket = packet = new SrsBandwidthPacket();
            return packet->decode(stream);
        } else if (command == SRS_BW_CHECK_PUBLISHING) {
            *ppacket = packet = new SrsBandwidthPacket();
            return packet->decode(stream);
        } else if (command == SRS_BW_CHECK_STARTING_PLAY) {
            *ppacket = packet = new SrsBandwidthPacket();
            return packet->decode(stream);
        } else if (command == SRS_BW_CHECK_STARTING_PUBLISH) {
            *ppacket = packet = new SrsBandwidthPacket();
            return packet->decode(stream);
        } else if (command == SRS_BW_CHECK_START_PLAY) {
            *ppacket = packet = new SrsBandwidthPacket();
            return packet->decode(stream);
        } else if (command == SRS_BW_CHECK_START_PUBLISH) {
            *ppacket = packet = new SrsBandwidthPacket();
            return packet->decode(stream);
        } else if (command == SRS_BW_CHECK_STOPPED_PLAY) {
            *ppacket = packet = new SrsBandwidthPacket();
            return packet->decode(stream);
        } else if (command == SRS_BW_CHECK_STOP_PLAY) {
            *ppacket = packet = new SrsBandwidthPacket();
            return packet->decode(stream);
        } else if (command == SRS_BW_CHECK_STOP_PUBLISH) {
            *ppacket = packet = new SrsBandwidthPacket();
            return packet->decode(stream);
        } else if (command == SRS_BW_CHECK_STOPPED_PUBLISH) {
            *ppacket = packet = new SrsBandwidthPacket();
            return packet->decode(stream);
        } else if (command == SRS_BW_CHECK_FINAL) {
            *ppacket = packet = new SrsBandwidthPacket();
            return packet->decode(stream);
        } else if (command == RTMP_AMF0_COMMAND_CLOSE_STREAM) {
            *ppacket = packet = new SrsCloseStreamPacket();
            return packet->decode(stream);
        } else if (header.is_amf0_command() || header.is_amf3_command()) {
            *ppacket = packet = new SrsCallPacket();
            return packet->decode(stream);
        }
        
        // default packet to drop message.
        *ppacket = packet = new SrsPacket();
        return err;
    } else if (header.is_user_control_message()) {
        *ppacket = packet = new SrsUserControlPacket();
        return packet->decode(stream);
    } else if (header.is_window_ackledgement_size()) {
        *ppacket = packet = new SrsSetWindowAckSizePacket();
        return packet->decode(stream);
    } else if (header.is_set_chunk_size()) {
        *ppacket = packet = new SrsSetChunkSizePacket();
        return packet->decode(stream);
    } else {
        if (!header.is_set_peer_bandwidth() && !header.is_ackledgement()) {
            srs_trace("drop unknown message, type=%d", header.message_type);
        }
    }
    
    return err;
}

srs_error_t SrsProtocol::send_and_free_message(SrsSharedPtrMessage* msg, int stream_id)
{
    return send_and_free_messages(&msg, 1, stream_id);
}

srs_error_t SrsProtocol::send_and_free_messages(SrsSharedPtrMessage** msgs, int nb_msgs, int stream_id)
{
    // always not NULL msg.
    srs_assert(msgs);
    srs_assert(nb_msgs > 0);
    
    // update the stream id in header.
    for (int i = 0; i < nb_msgs; i++) {
        SrsSharedPtrMessage* msg = msgs[i];
        
        if (!msg) {
            continue;
        }
        
        // check perfer cid and stream,
        // when one msg stream id is ok, ignore left.
        if (msg->check(stream_id)) {
            break;
        }
    }
    
    // donot use the auto free to free the msg,
    // for performance issue.
    srs_error_t err = do_send_messages(msgs, nb_msgs);
    
    for (int i = 0; i < nb_msgs; i++) {
        SrsSharedPtrMessage* msg = msgs[i];
        srs_freep(msg);
    }
    
    // donot flush when send failed
    if (err != srs_success) {
        return srs_error_wrap(err, "send messages");
    }
    
    // flush messages in manual queue
    if ((err = manual_response_flush()) != srs_success) {
        return srs_error_wrap(err, "manual flush response");
    }
    
    print_debug_info();
    
    return err;
}

srs_error_t SrsProtocol::send_and_free_packet(SrsPacket* packet, int stream_id)
{
    srs_error_t err = srs_success;
    
    if ((err = do_send_and_free_packet(packet, stream_id)) != srs_success) {
        return srs_error_wrap(err, "send packet");
    }
    
    // flush messages in manual queue
    if ((err = manual_response_flush()) != srs_success) {
        return srs_error_wrap(err, "manual flush response");
    }
    
    return err;
}

srs_error_t SrsProtocol::recv_interlaced_message(SrsCommonMessage** pmsg)
{
    srs_error_t err = srs_success;
    
    // chunk stream basic header.
    char fmt = 0;
    int cid = 0;
    if ((err = read_basic_header(fmt, cid)) != srs_success) {
        return srs_error_wrap(err, "read basic header");
    }
    
    // the cid must not negative.
    srs_assert(cid >= 0);
    
    // get the cached chunk stream.
    SrsChunkStream* chunk = NULL;
    
    // use chunk stream cache to get the chunk info.
    // @see https://github.com/ossrs/srs/issues/249
    if (cid < SRS_PERF_CHUNK_STREAM_CACHE) {
        // already init, use it direclty
        chunk = cs_cache[cid];
    } else {
        // chunk stream cache miss, use map.
        if (chunk_streams.find(cid) == chunk_streams.end()) {
            chunk = chunk_streams[cid] = new SrsChunkStream(cid);
            // set the perfer cid of chunk,
            // which will copy to the message received.
            chunk->header.perfer_cid = cid;
        } else {
            chunk = chunk_streams[cid];
        }
    }
    
    // chunk stream message header
    if ((err = read_message_header(chunk, fmt)) != srs_success) {
        return srs_error_wrap(err, "read message header");
    }
    
    // read msg payload from chunk stream.
    SrsCommonMessage* msg = NULL;
    if ((err = read_message_payload(chunk, &msg)) != srs_success) {
        return srs_error_wrap(err, "read message payload");
    }
    
    // not got an entire RTMP message, try next chunk.
    if (!msg) {
        return err;
    }
    
    *pmsg = msg;
    return err;
}

/**
 * 6.1.1. Chunk Basic Header
 * The Chunk Basic Header encodes the chunk stream ID and the chunk
 * type(represented by fmt field in the figure below). Chunk type
 * determines the format of the encoded message header. Chunk Basic
 * Header field may be 1, 2, or 3 bytes, depending on the chunk stream
 * ID.
 *
 * The bits 0-5 (least significant) in the chunk basic header represent
 * the chunk stream ID.
 *
 * Chunk stream IDs 2-63 can be encoded in the 1-byte version of this
 * field.
 *    0 1 2 3 4 5 6 7
 *   +-+-+-+-+-+-+-+-+
 *   |fmt|   cs id   |
 *   +-+-+-+-+-+-+-+-+
 *   Figure 6 Chunk basic header 1
 *
 * Chunk stream IDs 64-319 can be encoded in the 2-byte version of this
 * field. ID is computed as (the second byte + 64).
 *   0                   1
 *   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *   |fmt|    0      | cs id - 64    |
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *   Figure 7 Chunk basic header 2
 *
 * Chunk stream IDs 64-65599 can be encoded in the 3-byte version of
 * this field. ID is computed as ((the third byte)*256 + the second byte
 * + 64).
 *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *   |fmt|     1     |         cs id - 64            |
 *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 *   Figure 8 Chunk basic header 3
 *
 * cs id: 6 bits
 * fmt: 2 bits
 * cs id - 64: 8 or 16 bits
 *
 * Chunk stream IDs with values 64-319 could be represented by both 2-
 * byte version and 3-byte version of this field.
 */
srs_error_t SrsProtocol::read_basic_header(char& fmt, int& cid)
{
    srs_error_t err = srs_success;
    
    if ((err = in_buffer->grow(skt, 1)) != srs_success) {
        return srs_error_wrap(err, "basic header requires 1 bytes");
    }
    
    fmt = in_buffer->read_1byte();
    cid = fmt & 0x3f;
    fmt = (fmt >> 6) & 0x03;
    
    // 2-63, 1B chunk header
    if (cid > 1) {
        return err;
    }
    
    // 64-319, 2B chunk header
    if (cid == 0) {
        if ((err = in_buffer->grow(skt, 1)) != srs_success) {
            return srs_error_wrap(err, "basic header requires 2 bytes");
        }
        
        cid = 64;
        cid += (uint8_t)in_buffer->read_1byte();
        // 64-65599, 3B chunk header
    } else if (cid == 1) {
        if ((err = in_buffer->grow(skt, 2)) != srs_success) {
            return srs_error_wrap(err, "basic header requires 3 bytes");
        }
        
        cid = 64;
        cid += (uint8_t)in_buffer->read_1byte();
        cid += ((uint8_t)in_buffer->read_1byte()) * 256;
    } else {
        srs_error("invalid path, impossible basic header.");
        srs_assert(false);
    }
    
    return err;
}

/**
 * parse the message header.
 *   3bytes: timestamp delta,    fmt=0,1,2
 *   3bytes: payload length,     fmt=0,1
 *   1bytes: message type,       fmt=0,1
 *   4bytes: stream id,          fmt=0
 * where:
 *   fmt=0, 0x0X
 *   fmt=1, 0x4X
 *   fmt=2, 0x8X
 *   fmt=3, 0xCX
 */
srs_error_t SrsProtocol::read_message_header(SrsChunkStream* chunk, char fmt)
{
    srs_error_t err = srs_success;
    
    /**
     * we should not assert anything about fmt, for the first packet.
     * (when first packet, the chunk->msg is NULL).
     * the fmt maybe 0/1/2/3, the FMLE will send a 0xC4 for some audio packet.
     * the previous packet is:
     *     04                // fmt=0, cid=4
     *     00 00 1a          // timestamp=26
     *     00 00 9d          // payload_length=157
     *     08                // message_type=8(audio)
     *     01 00 00 00       // stream_id=1
     * the current packet maybe:
     *     c4             // fmt=3, cid=4
     * it's ok, for the packet is audio, and timestamp delta is 26.
     * the current packet must be parsed as:
     *     fmt=0, cid=4
     *     timestamp=26+26=52
     *     payload_length=157
     *     message_type=8(audio)
     *     stream_id=1
     * so we must update the timestamp even fmt=3 for first packet.
     */
    // fresh packet used to update the timestamp even fmt=3 for first packet.
    // fresh packet always means the chunk is the first one of message.
    bool is_first_chunk_of_msg = !chunk->msg;
    
    // but, we can ensure that when a chunk stream is fresh,
    // the fmt must be 0, a new stream.
    if (chunk->msg_count == 0 && fmt != RTMP_FMT_TYPE0) {
        // for librtmp, if ping, it will send a fresh stream with fmt=1,
        // 0x42             where: fmt=1, cid=2, protocol contorl user-control message
        // 0x00 0x00 0x00   where: timestamp=0
        // 0x00 0x00 0x06   where: payload_length=6
        // 0x04             where: message_type=4(protocol control user-control message)
        // 0x00 0x06            where: event Ping(0x06)
        // 0x00 0x00 0x0d 0x0f  where: event data 4bytes ping timestamp.
        // @see: https://github.com/ossrs/srs/issues/98
        if (chunk->cid == RTMP_CID_ProtocolControl && fmt == RTMP_FMT_TYPE1) {
            srs_warn("accept cid=2, fmt=1 to make librtmp happy.");
        } else {
            // must be a RTMP protocol level error.
            return srs_error_new(ERROR_RTMP_CHUNK_START, "chunk is fresh, fmt must be %d, actual is %d. cid=%d", RTMP_FMT_TYPE0, fmt, chunk->cid);
        }
    }
    
    // when exists cache msg, means got an partial message,
    // the fmt must not be type0 which means new message.
    if (chunk->msg && fmt == RTMP_FMT_TYPE0) {
        return srs_error_new(ERROR_RTMP_CHUNK_START, "chunk exists, fmt must not be %d, actual is %d", RTMP_FMT_TYPE0, fmt);
    }
    
    // create msg when new chunk stream start
    if (!chunk->msg) {
        chunk->msg = new SrsCommonMessage();
    }
    
    // read message header from socket to buffer.
    static char mh_sizes[] = {11, 7, 3, 0};
    int mh_size = mh_sizes[(int)fmt];
    
    if (mh_size > 0 && (err = in_buffer->grow(skt, mh_size)) != srs_success) {
        return srs_error_wrap(err, "read %d bytes message header", mh_size);
    }
    
    /**
     * parse the message header.
     *   3bytes: timestamp delta,    fmt=0,1,2
     *   3bytes: payload length,     fmt=0,1
     *   1bytes: message type,       fmt=0,1
     *   4bytes: stream id,          fmt=0
     * where:
     *   fmt=0, 0x0X
     *   fmt=1, 0x4X
     *   fmt=2, 0x8X
     *   fmt=3, 0xCX
     */
    // see also: ngx_rtmp_recv
    if (fmt <= RTMP_FMT_TYPE2) {
        char* p = in_buffer->read_slice(mh_size);
        
        char* pp = (char*)&chunk->header.timestamp_delta;
        pp[2] = *p++;
        pp[1] = *p++;
        pp[0] = *p++;
        pp[3] = 0;
        
        // fmt: 0
        // timestamp: 3 bytes
        // If the timestamp is greater than or equal to 16777215
        // (hexadecimal 0x00ffffff), this value MUST be 16777215, and the
        // 'extended timestamp header' MUST be present. Otherwise, this value
        // SHOULD be the entire timestamp.
        //
        // fmt: 1 or 2
        // timestamp delta: 3 bytes
        // If the delta is greater than or equal to 16777215 (hexadecimal
        // 0x00ffffff), this value MUST be 16777215, and the 'extended
        // timestamp header' MUST be present. Otherwise, this value SHOULD be
        // the entire delta.
        chunk->extended_timestamp = (chunk->header.timestamp_delta >= RTMP_EXTENDED_TIMESTAMP);
        if (!chunk->extended_timestamp) {
            // Extended timestamp: 0 or 4 bytes
            // This field MUST be sent when the normal timsestamp is set to
            // 0xffffff, it MUST NOT be sent if the normal timestamp is set to
            // anything else. So for values less than 0xffffff the normal
            // timestamp field SHOULD be used in which case the extended timestamp
            // MUST NOT be present. For values greater than or equal to 0xffffff
            // the normal timestamp field MUST NOT be used and MUST be set to
            // 0xffffff and the extended timestamp MUST be sent.
            if (fmt == RTMP_FMT_TYPE0) {
                // 6.1.2.1. Type 0
                // For a type-0 chunk, the absolute timestamp of the message is sent
                // here.
                chunk->header.timestamp = chunk->header.timestamp_delta;
            } else {
                // 6.1.2.2. Type 1
                // 6.1.2.3. Type 2
                // For a type-1 or type-2 chunk, the difference between the previous
                // chunk's timestamp and the current chunk's timestamp is sent here.
                chunk->header.timestamp += chunk->header.timestamp_delta;
            }
        }
        
        if (fmt <= RTMP_FMT_TYPE1) {
            int32_t payload_length = 0;
            pp = (char*)&payload_length;
            pp[2] = *p++;
            pp[1] = *p++;
            pp[0] = *p++;
            pp[3] = 0;
            
            // for a message, if msg exists in cache, the size must not changed.
            // always use the actual msg size to compare, for the cache payload length can changed,
            // for the fmt type1(stream_id not changed), user can change the payload
            // length(it's not allowed in the continue chunks).
            if (!is_first_chunk_of_msg && chunk->header.payload_length != payload_length) {
                return srs_error_new(ERROR_RTMP_PACKET_SIZE, "msg in chunk cache, size=%d cannot change to %d", chunk->header.payload_length, payload_length);
            }
            
            chunk->header.payload_length = payload_length;
            chunk->header.message_type = *p++;
            
            if (fmt == RTMP_FMT_TYPE0) {
                pp = (char*)&chunk->header.stream_id;
                pp[0] = *p++;
                pp[1] = *p++;
                pp[2] = *p++;
                pp[3] = *p++;
            }
        }
    } else {
        // update the timestamp even fmt=3 for first chunk packet
        if (is_first_chunk_of_msg && !chunk->extended_timestamp) {
            chunk->header.timestamp += chunk->header.timestamp_delta;
        }
    }
    
    // read extended-timestamp
    if (chunk->extended_timestamp) {
        mh_size += 4;
        if ((err = in_buffer->grow(skt, 4)) != srs_success) {
            return srs_error_wrap(err, "read 4 bytes ext timestamp");
        }
        // the ptr to the slice maybe invalid when grow()
        // reset the p to get 4bytes slice.
        char* p = in_buffer->read_slice(4);
        
        uint32_t timestamp = 0x00;
        char* pp = (char*)&timestamp;
        pp[3] = *p++;
        pp[2] = *p++;
        pp[1] = *p++;
        pp[0] = *p++;
        
        // always use 31bits timestamp, for some server may use 32bits extended timestamp.
        // @see https://github.com/ossrs/srs/issues/111
        timestamp &= 0x7fffffff;
        
        /**
         * RTMP specification and ffmpeg/librtmp is false,
         * but, adobe changed the specification, so flash/FMLE/FMS always true.
         * default to true to support flash/FMLE/FMS.
         *
         * ffmpeg/librtmp may donot send this filed, need to detect the value.
         * @see also: http://blog.csdn.net/win_lin/article/details/13363699
         * compare to the chunk timestamp, which is set by chunk message header
         * type 0,1 or 2.
         *
         * @remark, nginx send the extended-timestamp in sequence-header,
         * and timestamp delta in continue C1 chunks, and so compatible with ffmpeg,
         * that is, there is no continue chunks and extended-timestamp in nginx-rtmp.
         *
         * @remark, srs always send the extended-timestamp, to keep simple,
         * and compatible with adobe products.
         */
        uint32_t chunk_timestamp = (uint32_t)chunk->header.timestamp;
        
        /**
         * if chunk_timestamp<=0, the chunk previous packet has no extended-timestamp,
         * always use the extended timestamp.
         */
        /**
         * about the is_first_chunk_of_msg.
         * @remark, for the first chunk of message, always use the extended timestamp.
         */
        if (!is_first_chunk_of_msg && chunk_timestamp > 0 && chunk_timestamp != timestamp) {
            mh_size -= 4;
            in_buffer->skip(-4);
        } else {
            chunk->header.timestamp = timestamp;
        }
    }
    
    // the extended-timestamp must be unsigned-int,
    //         24bits timestamp: 0xffffff = 16777215ms = 16777.215s = 4.66h
    //         32bits timestamp: 0xffffffff = 4294967295ms = 4294967.295s = 1193.046h = 49.71d
    // because the rtmp protocol says the 32bits timestamp is about "50 days":
    //         3. Byte Order, Alignment, and Time Format
    //                Because timestamps are generally only 32 bits long, they will roll
    //                over after fewer than 50 days.
    //
    // but, its sample says the timestamp is 31bits:
    //         An application could assume, for example, that all
    //        adjacent timestamps are within 2^31 milliseconds of each other, so
    //        10000 comes after 4000000000, while 3000000000 comes before
    //        4000000000.
    // and flv specification says timestamp is 31bits:
    //        Extension of the Timestamp field to form a SI32 value. This
    //        field represents the upper 8 bits, while the previous
    //        Timestamp field represents the lower 24 bits of the time in
    //        milliseconds.
    // in a word, 31bits timestamp is ok.
    // convert extended timestamp to 31bits.
    chunk->header.timestamp &= 0x7fffffff;
    
    // valid message, the payload_length is 24bits,
    // so it should never be negative.
    srs_assert(chunk->header.payload_length >= 0);
    
    // copy header to msg
    chunk->msg->header = chunk->header;
    
    // increase the msg count, the chunk stream can accept fmt=1/2/3 message now.
    chunk->msg_count++;
    
    return err;
}

srs_error_t SrsProtocol::read_message_payload(SrsChunkStream* chunk, SrsCommonMessage** pmsg)
{
    srs_error_t err = srs_success;
    
    // empty message
    if (chunk->header.payload_length <= 0) {
        srs_trace("get an empty RTMP message(type=%d, size=%d, time=%" PRId64 ", sid=%d)", chunk->header.message_type,
                  chunk->header.payload_length, chunk->header.timestamp, chunk->header.stream_id);
        
        *pmsg = chunk->msg;
        chunk->msg = NULL;
        
        return err;
    }
    srs_assert(chunk->header.payload_length > 0);
    
    // the chunk payload size.
    int payload_size = chunk->header.payload_length - chunk->msg->size;
    payload_size = srs_min(payload_size, in_chunk_size);
    
    // create msg payload if not initialized
    if (!chunk->msg->payload) {
        chunk->msg->create_payload(chunk->header.payload_length);
    }
    
    // read payload to buffer
    if ((err = in_buffer->grow(skt, payload_size)) != srs_success) {
        return srs_error_wrap(err, "read %d bytes payload", payload_size);
    }
    memcpy(chunk->msg->payload + chunk->msg->size, in_buffer->read_slice(payload_size), payload_size);
    chunk->msg->size += payload_size;
    
    // got entire RTMP message?
    if (chunk->header.payload_length == chunk->msg->size) {
        *pmsg = chunk->msg;
        chunk->msg = NULL;
        return err;
    }
    
    return err;
}

srs_error_t SrsProtocol::on_recv_message(SrsCommonMessage* msg)
{
    srs_error_t err = srs_success;
    
    srs_assert(msg != NULL);
    
    // try to response acknowledgement
    if ((err = response_acknowledgement_message()) != srs_success) {
        return srs_error_wrap(err, "response ack");
    }
    
    SrsPacket* packet = NULL;
    switch (msg->header.message_type) {
        case RTMP_MSG_SetChunkSize:
        case RTMP_MSG_UserControlMessage:
        case RTMP_MSG_WindowAcknowledgementSize:
            if ((err = decode_message(msg, &packet)) != srs_success) {
                return srs_error_wrap(err, "decode message");
            }
            break;
        case RTMP_MSG_VideoMessage:
        case RTMP_MSG_AudioMessage:
            print_debug_info();
        default:
            return err;
    }
    
    srs_assert(packet);
    
    // always free the packet.
    SrsAutoFree(SrsPacket, packet);
    
    switch (msg->header.message_type) {
        case RTMP_MSG_WindowAcknowledgementSize: {
            SrsSetWindowAckSizePacket* pkt = dynamic_cast<SrsSetWindowAckSizePacket*>(packet);
            srs_assert(pkt != NULL);
            
            if (pkt->ackowledgement_window_size > 0) {
                in_ack_size.window = (uint32_t)pkt->ackowledgement_window_size;
                // @remark, we ignore this message, for user noneed to care.
                // but it's important for dev, for client/server will block if required
                // ack msg not arrived.
            }
            break;
        }
        case RTMP_MSG_SetChunkSize: {
            SrsSetChunkSizePacket* pkt = dynamic_cast<SrsSetChunkSizePacket*>(packet);
            srs_assert(pkt != NULL);
            
            // for some server, the actual chunk size can greater than the max value(65536),
            // so we just warning the invalid chunk size, and actually use it is ok,
            // @see: https://github.com/ossrs/srs/issues/160
            if (pkt->chunk_size < SRS_CONSTS_RTMP_MIN_CHUNK_SIZE || pkt->chunk_size > SRS_CONSTS_RTMP_MAX_CHUNK_SIZE) {
                srs_warn("accept chunk=%d, should in [%d, %d], please see #160",
                         pkt->chunk_size, SRS_CONSTS_RTMP_MIN_CHUNK_SIZE,  SRS_CONSTS_RTMP_MAX_CHUNK_SIZE);
            }
            
            // @see: https://github.com/ossrs/srs/issues/541
            if (pkt->chunk_size < SRS_CONSTS_RTMP_MIN_CHUNK_SIZE) {
                return srs_error_new(ERROR_RTMP_CHUNK_SIZE, "chunk size should be %d+, value=%d", SRS_CONSTS_RTMP_MIN_CHUNK_SIZE, pkt->chunk_size);
            }
            
            in_chunk_size = pkt->chunk_size;
            break;
        }
        case RTMP_MSG_UserControlMessage: {
            SrsUserControlPacket* pkt = dynamic_cast<SrsUserControlPacket*>(packet);
            srs_assert(pkt != NULL);
            
            if (pkt->event_type == SrcPCUCSetBufferLength) {
                in_buffer_length = pkt->extra_data;
            }
            if (pkt->event_type == SrcPCUCPingRequest) {
                if ((err = response_ping_message(pkt->event_data)) != srs_success) {
                    return srs_error_wrap(err, "response ping");
                }
            }
            break;
        }
        default:
            break;
    }
    
    return err;
}

srs_error_t SrsProtocol::on_send_packet(SrsMessageHeader* mh, SrsPacket* packet)
{
    srs_error_t err = srs_success;
    
    // ignore raw bytes oriented RTMP message.
    if (packet == NULL) {
        return err;
    }
    
    switch (mh->message_type) {
        case RTMP_MSG_SetChunkSize: {
            SrsSetChunkSizePacket* pkt = dynamic_cast<SrsSetChunkSizePacket*>(packet);
            out_chunk_size = pkt->chunk_size;
            break;
        }
        case RTMP_MSG_WindowAcknowledgementSize: {
            SrsSetWindowAckSizePacket* pkt = dynamic_cast<SrsSetWindowAckSizePacket*>(packet);
            out_ack_size.window = (uint32_t)pkt->ackowledgement_window_size;
            break;
        }
        case RTMP_MSG_AMF0CommandMessage:
        case RTMP_MSG_AMF3CommandMessage: {
            if (true) {
                SrsConnectAppPacket* pkt = dynamic_cast<SrsConnectAppPacket*>(packet);
                if (pkt) {
                    requests[pkt->transaction_id] = pkt->command_name;
                    break;
                }
            }
            if (true) {
                SrsCreateStreamPacket* pkt = dynamic_cast<SrsCreateStreamPacket*>(packet);
                if (pkt) {
                    requests[pkt->transaction_id] = pkt->command_name;
                    break;
                }
            }
            if (true) {
                SrsFMLEStartPacket* pkt = dynamic_cast<SrsFMLEStartPacket*>(packet);
                if (pkt) {
                    requests[pkt->transaction_id] = pkt->command_name;
                    break;
                }
            }
            break;
        }
        case RTMP_MSG_VideoMessage:
        case RTMP_MSG_AudioMessage:
            print_debug_info();
        default:
            break;
    }
    
    return err;
}

srs_error_t SrsProtocol::response_acknowledgement_message()
{
    srs_error_t err = srs_success;
    
    if (in_ack_size.window <= 0) {
        return err;
    }
    
    // ignore when delta bytes not exceed half of window(ack size).
    uint32_t delta = (uint32_t)(skt->get_recv_bytes() - in_ack_size.nb_recv_bytes);
    if (delta < in_ack_size.window / 2) {
        return err;
    }
    in_ack_size.nb_recv_bytes = skt->get_recv_bytes();
    
    // when the sequence number overflow, reset it.
    uint32_t sequence_number = in_ack_size.sequence_number + delta;
    if (sequence_number > 0xf0000000) {
        sequence_number = delta;
    }
    in_ack_size.sequence_number = sequence_number;
    
    SrsAcknowledgementPacket* pkt = new SrsAcknowledgementPacket();
    pkt->sequence_number = sequence_number;
    
    // cache the message and use flush to send.
    if (!auto_response_when_recv) {
        manual_response_queue.push_back(pkt);
        return err;
    }
    
    // use underlayer api to send, donot flush again.
    if ((err = do_send_and_free_packet(pkt, 0)) != srs_success) {
        return srs_error_wrap(err, "send ack");
    }
    
    return err;
}

srs_error_t SrsProtocol::response_ping_message(int32_t timestamp)
{
    srs_error_t err = srs_success;
    
    srs_trace("get a ping request, response it. timestamp=%d", timestamp);
    
    SrsUserControlPacket* pkt = new SrsUserControlPacket();
    
    pkt->event_type = SrcPCUCPingResponse;
    pkt->event_data = timestamp;
    
    // cache the message and use flush to send.
    if (!auto_response_when_recv) {
        manual_response_queue.push_back(pkt);
        return err;
    }
    
    // use underlayer api to send, donot flush again.
    if ((err = do_send_and_free_packet(pkt, 0)) != srs_success) {
        return srs_error_wrap(err, "ping response");
    }
    
    return err;
}

void SrsProtocol::print_debug_info()
{
    if (show_debug_info) {
        show_debug_info = false;
        srs_trace("protocol in.buffer=%d, in.ack=%d, out.ack=%d, in.chunk=%d, out.chunk=%d", in_buffer_length,
                  in_ack_size.window, out_ack_size.window, in_chunk_size, out_chunk_size);
    }
}

SrsChunkStream::SrsChunkStream(int _cid)
{
    fmt = 0;
    cid = _cid;
    extended_timestamp = false;
    msg = NULL;
    msg_count = 0;
}

SrsChunkStream::~SrsChunkStream()
{
    srs_freep(msg);
}

SrsRequest::SrsRequest()
{
    objectEncoding = RTMP_SIG_AMF0_VER;
    duration = -1;
    port = SRS_CONSTS_RTMP_DEFAULT_PORT;
    args = NULL;
}

SrsRequest::~SrsRequest()
{
    srs_freep(args);
}

SrsRequest* SrsRequest::copy()
{
    SrsRequest* cp = new SrsRequest();
    
    cp->ip = ip;
    cp->vhost = vhost;
    cp->app = app;
    cp->objectEncoding = objectEncoding;
    cp->pageUrl = pageUrl;
    cp->host = host;
    cp->port = port;
    cp->param = param;
    cp->schema = schema;
    cp->stream = stream;
    cp->swfUrl = swfUrl;
    cp->tcUrl = tcUrl;
    cp->duration = duration;
    if (args) {
        cp->args = args->copy()->to_object();
    }
    
    return cp;
}

void SrsRequest::update_auth(SrsRequest* req)
{
    pageUrl = req->pageUrl;
    swfUrl = req->swfUrl;
    tcUrl = req->tcUrl;
    
    ip = req->ip;
    vhost = req->vhost;
    app = req->app;
    objectEncoding = req->objectEncoding;
    host = req->host;
    port = req->port;
    param = req->param;
    schema = req->schema;
    duration = req->duration;
    
    if (args) {
        srs_freep(args);
    }
    if (req->args) {
        args = req->args->copy()->to_object();
    }
    
    srs_info("update req of soruce for auth ok");
}

string SrsRequest::get_stream_url()
{
    return srs_generate_stream_url(vhost, app, stream);
}

void SrsRequest::strip()
{
    // remove the unsupported chars in names.
    host = srs_string_remove(host, "/ \n\r\t");
    vhost = srs_string_remove(vhost, "/ \n\r\t");
    app = srs_string_remove(app, " \n\r\t");
    stream = srs_string_remove(stream, " \n\r\t");
    
    // remove end slash of app/stream
    app = srs_string_trim_end(app, "/");
    stream = srs_string_trim_end(stream, "/");
    
    // remove start slash of app/stream
    app = srs_string_trim_start(app, "/");
    stream = srs_string_trim_start(stream, "/");
}

SrsResponse::SrsResponse()
{
    stream_id = SRS_DEFAULT_SID;
}

SrsResponse::~SrsResponse()
{
}

string srs_client_type_string(SrsRtmpConnType type)
{
    switch (type) {
        case SrsRtmpConnPlay: return "Play";
        case SrsRtmpConnFlashPublish: return "flash-publish";
        case SrsRtmpConnFMLEPublish: return "fmle-publish";
        case SrsRtmpConnHaivisionPublish: return "haivision-publish";
        default: return "Unknown";
    }
}

bool srs_client_type_is_publish(SrsRtmpConnType type)
{
    return type != SrsRtmpConnPlay;
}

SrsHandshakeBytes::SrsHandshakeBytes()
{
    c0c1 = s0s1s2 = c2 = NULL;
}

SrsHandshakeBytes::~SrsHandshakeBytes()
{
    srs_freepa(c0c1);
    srs_freepa(s0s1s2);
    srs_freepa(c2);
}

srs_error_t SrsHandshakeBytes::read_c0c1(ISrsProtocolReaderWriter* io)
{
    srs_error_t err = srs_success;
    
    if (c0c1) {
        return err;
    }
    
    ssize_t nsize;
    
    c0c1 = new char[1537];
    if ((err = io->read_fully(c0c1, 1537, &nsize)) != srs_success) {
        return srs_error_wrap(err, "read c0c1");
    }
    
    return err;
}

srs_error_t SrsHandshakeBytes::read_s0s1s2(ISrsProtocolReaderWriter* io)
{
    srs_error_t err = srs_success;
    
    if (s0s1s2) {
        return err;
    }
    
    ssize_t nsize;
    
    s0s1s2 = new char[3073];
    if ((err = io->read_fully(s0s1s2, 3073, &nsize)) != srs_success) {
        return srs_error_wrap(err, "read s0s1s2");
    }
    
    return err;
}

srs_error_t SrsHandshakeBytes::read_c2(ISrsProtocolReaderWriter* io)
{
    srs_error_t err = srs_success;
    
    if (c2) {
        return err;
    }
    
    ssize_t nsize;
    
    c2 = new char[1536];
    if ((err = io->read_fully(c2, 1536, &nsize)) != srs_success) {
        return srs_error_wrap(err, "read c2");
    }
    
    return err;
}

srs_error_t SrsHandshakeBytes::create_c0c1()
{
    srs_error_t err = srs_success;
    
    if (c0c1) {
        return err;
    }
    
    c0c1 = new char[1537];
    srs_random_generate(c0c1, 1537);
    
    // plain text required.
    SrsBuffer stream(c0c1, 9);
    
    stream.write_1bytes(0x03);
    stream.write_4bytes((int32_t)::time(NULL));
    stream.write_4bytes(0x00);
    
    return err;
}

srs_error_t SrsHandshakeBytes::create_s0s1s2(const char* c1)
{
    srs_error_t err = srs_success;
    
    if (s0s1s2) {
        return err;
    }
    
    s0s1s2 = new char[3073];
    srs_random_generate(s0s1s2, 3073);
    
    // plain text required.
    SrsBuffer stream(s0s1s2, 9);
    
    stream.write_1bytes(0x03);
    stream.write_4bytes((int32_t)::time(NULL));
    // s1 time2 copy from c1
    if (c0c1) {
        stream.write_bytes(c0c1 + 1, 4);
    }
    
    // if c1 specified, copy c1 to s2.
    // @see: https://github.com/ossrs/srs/issues/46
    if (c1) {
        memcpy(s0s1s2 + 1537, c1, 1536);
    }
    
    return err;
}

srs_error_t SrsHandshakeBytes::create_c2()
{
    srs_error_t err = srs_success;
    
    if (c2) {
        return err;
    }
    
    c2 = new char[1536];
    srs_random_generate(c2, 1536);
    
    // time
    SrsBuffer stream(c2, 8);
    
    stream.write_4bytes((int32_t)::time(NULL));
    // c2 time2 copy from s1
    if (s0s1s2) {
        stream.write_bytes(s0s1s2 + 1, 4);
    }
    
    return err;
}

SrsServerInfo::SrsServerInfo()
{
    pid = cid = 0;
    major = minor = revision = build = 0;
}

SrsRtmpClient::SrsRtmpClient(ISrsProtocolReaderWriter* skt)
{
    io = skt;
    protocol = new SrsProtocol(skt);
    hs_bytes = new SrsHandshakeBytes();
}

SrsRtmpClient::~SrsRtmpClient()
{
    srs_freep(protocol);
    srs_freep(hs_bytes);
}

void SrsRtmpClient::set_recv_timeout(int64_t tm)
{
    protocol->set_recv_timeout(tm);
}

void SrsRtmpClient::set_send_timeout(int64_t tm)
{
    protocol->set_send_timeout(tm);
}

int64_t SrsRtmpClient::get_recv_bytes()
{
    return protocol->get_recv_bytes();
}

int64_t SrsRtmpClient::get_send_bytes()
{
    return protocol->get_send_bytes();
}

srs_error_t SrsRtmpClient::recv_message(SrsCommonMessage** pmsg)
{
    return protocol->recv_message(pmsg);
}

srs_error_t SrsRtmpClient::decode_message(SrsCommonMessage* msg, SrsPacket** ppacket)
{
    return protocol->decode_message(msg, ppacket);
}

srs_error_t SrsRtmpClient::send_and_free_message(SrsSharedPtrMessage* msg, int stream_id)
{
    return protocol->send_and_free_message(msg, stream_id);
}

srs_error_t SrsRtmpClient::send_and_free_messages(SrsSharedPtrMessage** msgs, int nb_msgs, int stream_id)
{
    return protocol->send_and_free_messages(msgs, nb_msgs, stream_id);
}

srs_error_t SrsRtmpClient::send_and_free_packet(SrsPacket* packet, int stream_id)
{
    return protocol->send_and_free_packet(packet, stream_id);
}

srs_error_t SrsRtmpClient::handshake()
{
    srs_error_t err = srs_success;
    
    srs_assert(hs_bytes);
    
    // maybe st has problem when alloc object on stack, always alloc object at heap.
    // @see https://github.com/ossrs/srs/issues/509
    SrsComplexHandshake* complex_hs = new SrsComplexHandshake();
    SrsAutoFree(SrsComplexHandshake, complex_hs);
    
    if ((err = complex_hs->handshake_with_server(hs_bytes, io)) != srs_success) {
        if (srs_error_code(err) == ERROR_RTMP_TRY_SIMPLE_HS) {
            srs_freep(err);
            
            // always alloc object at heap.
            // @see https://github.com/ossrs/srs/issues/509
            SrsSimpleHandshake* simple_hs = new SrsSimpleHandshake();
            SrsAutoFree(SrsSimpleHandshake, simple_hs);
            
            if ((err = simple_hs->handshake_with_server(hs_bytes, io)) != srs_success) {
                return srs_error_wrap(err, "simple handshake");
            }
        } else {
            return srs_error_wrap(err, "complex handshake");
        }
    }
    
    srs_freep(hs_bytes);
    
    return err;
}

srs_error_t SrsRtmpClient::simple_handshake()
{
    srs_error_t err = srs_success;
    
    srs_assert(hs_bytes);
    
    SrsSimpleHandshake simple_hs;
    if ((err = simple_hs.handshake_with_server(hs_bytes, io)) != srs_success) {
        return srs_error_wrap(err, "simple handshake");
    }
    
    srs_freep(hs_bytes);
    
    return err;
}

srs_error_t SrsRtmpClient::complex_handshake()
{
    srs_error_t err = srs_success;
    
    srs_assert(hs_bytes);
    
    SrsComplexHandshake complex_hs;
    if ((err = complex_hs.handshake_with_server(hs_bytes, io)) != srs_success) {
        return srs_error_wrap(err, "complex handshake");
    }
    
    srs_freep(hs_bytes);
    
    return err;
}

srs_error_t SrsRtmpClient::connect_app(string app, string tcUrl, SrsRequest* r, bool dsu, SrsServerInfo* si)
{
    srs_error_t err = srs_success;
    
    // Connect(vhost, app)
    if (true) {
        SrsConnectAppPacket* pkt = new SrsConnectAppPacket();
        
        pkt->command_object->set("app", SrsAmf0Any::str(app.c_str()));
        pkt->command_object->set("flashVer", SrsAmf0Any::str("WIN 15,0,0,239"));
        if (r) {
            pkt->command_object->set("swfUrl", SrsAmf0Any::str(r->swfUrl.c_str()));
        } else {
            pkt->command_object->set("swfUrl", SrsAmf0Any::str());
        }
        if (r && r->tcUrl != "") {
            pkt->command_object->set("tcUrl", SrsAmf0Any::str(r->tcUrl.c_str()));
        } else {
            pkt->command_object->set("tcUrl", SrsAmf0Any::str(tcUrl.c_str()));
        }
        pkt->command_object->set("fpad", SrsAmf0Any::boolean(false));
        pkt->command_object->set("capabilities", SrsAmf0Any::number(239));
        pkt->command_object->set("audioCodecs", SrsAmf0Any::number(3575));
        pkt->command_object->set("videoCodecs", SrsAmf0Any::number(252));
        pkt->command_object->set("videoFunction", SrsAmf0Any::number(1));
        if (r) {
            pkt->command_object->set("pageUrl", SrsAmf0Any::str(r->pageUrl.c_str()));
        } else {
            pkt->command_object->set("pageUrl", SrsAmf0Any::str());
        }
        pkt->command_object->set("objectEncoding", SrsAmf0Any::number(0));
        
        // @see https://github.com/ossrs/srs/issues/160
        // the debug_srs_upnode is config in vhost and default to true.
        if (dsu && r && r->args) {
            srs_freep(pkt->args);
            pkt->args = r->args->copy()->to_object();
        }
        
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send packet");
        }
    }
    
    // Set Window Acknowledgement size(2500000)
    if (true) {
        SrsSetWindowAckSizePacket* pkt = new SrsSetWindowAckSizePacket();
        pkt->ackowledgement_window_size = 2500000;
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send packet");
        }
    }
    
    // expect connect _result
    SrsCommonMessage* msg = NULL;
    SrsConnectAppResPacket* pkt = NULL;
    if ((err = expect_message<SrsConnectAppResPacket>(&msg, &pkt)) != srs_success) {
        return srs_error_wrap(err, "expect connect app response");
    }
    SrsAutoFree(SrsCommonMessage, msg);
    SrsAutoFree(SrsConnectAppResPacket, pkt);
    
    // server info
    SrsAmf0Any* data = pkt->info->get_property("data");
    if (si && data && data->is_ecma_array()) {
        SrsAmf0EcmaArray* arr = data->to_ecma_array();
        
        SrsAmf0Any* prop = NULL;
        if ((prop = arr->ensure_property_string("srs_server_ip")) != NULL) {
            si->ip = prop->to_str();
        }
        if ((prop = arr->ensure_property_string("srs_server")) != NULL) {
            si->sig = prop->to_str();
        }
        if ((prop = arr->ensure_property_number("srs_id")) != NULL) {
            si->cid = (int)prop->to_number();
        }
        if ((prop = arr->ensure_property_number("srs_pid")) != NULL) {
            si->pid = (int)prop->to_number();
        }
        if ((prop = arr->ensure_property_string("srs_version")) != NULL) {
            vector<string> versions = srs_string_split(prop->to_str(), ".");
            if (versions.size() > 0) {
                si->major = ::atoi(versions.at(0).c_str());
                if (versions.size() > 1) {
                    si->minor = ::atoi(versions.at(1).c_str());
                    if (versions.size() > 2) {
                        si->revision = ::atoi(versions.at(2).c_str());
                        if (versions.size() > 3) {
                            si->build = ::atoi(versions.at(3).c_str());
                        }
                    }
                }
            }
        }
    }
    
    if (si) {
        srs_trace("connected, version=%d.%d.%d.%d, ip=%s, pid=%d, id=%d, dsu=%d",
                  si->major, si->minor, si->revision, si->build, si->ip.c_str(), si->pid, si->cid, dsu);
    } else {
        srs_trace("connected, dsu=%d", dsu);
    }
    
    return err;
}

srs_error_t SrsRtmpClient::create_stream(int& stream_id)
{
    srs_error_t err = srs_success;
    
    // CreateStream
    if (true) {
        SrsCreateStreamPacket* pkt = new SrsCreateStreamPacket();
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send packet");
        }
    }
    
    // CreateStream _result.
    if (true) {
        SrsCommonMessage* msg = NULL;
        SrsCreateStreamResPacket* pkt = NULL;
        if ((err = expect_message<SrsCreateStreamResPacket>(&msg, &pkt)) != srs_success) {
            return srs_error_wrap(err, "expect create stream response");
        }
        SrsAutoFree(SrsCommonMessage, msg);
        SrsAutoFree(SrsCreateStreamResPacket, pkt);
        
        stream_id = (int)pkt->stream_id;
    }
    
    return err;
}

srs_error_t SrsRtmpClient::play(string stream, int stream_id, int chunk_size)
{
    srs_error_t err = srs_success;
    
    // Play(stream)
    if (true) {
        SrsPlayPacket* pkt = new SrsPlayPacket();
        pkt->stream_name = stream;
        if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
            return srs_error_wrap(err, "send play stream failed. stream=%s, stream_id=%d", stream.c_str(), stream_id);
        }
    }
    
    // SetBufferLength(1000ms)
    int buffer_length_ms = 1000;
    if (true) {
        SrsUserControlPacket* pkt = new SrsUserControlPacket();
        
        pkt->event_type = SrcPCUCSetBufferLength;
        pkt->event_data = stream_id;
        pkt->extra_data = buffer_length_ms;
        
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send set buffer length failed. stream=%s, stream_id=%d, bufferLength=%d", stream.c_str(), stream_id, buffer_length_ms);
        }
    }
    
    // SetChunkSize
    if (chunk_size != SRS_CONSTS_RTMP_PROTOCOL_CHUNK_SIZE) {
        SrsSetChunkSizePacket* pkt = new SrsSetChunkSizePacket();
        pkt->chunk_size = chunk_size;
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send set chunk size failed. stream=%s, chunk_size=%d", stream.c_str(), chunk_size);
        }
    }
    
    return err;
}

srs_error_t SrsRtmpClient::publish(string stream, int stream_id, int chunk_size)
{
    srs_error_t err = srs_success;
    
    // SetChunkSize
    if (chunk_size != SRS_CONSTS_RTMP_PROTOCOL_CHUNK_SIZE) {
        SrsSetChunkSizePacket* pkt = new SrsSetChunkSizePacket();
        pkt->chunk_size = chunk_size;
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send set chunk size failed. stream=%s, chunk_size=%d", stream.c_str(), chunk_size);
        }
    }
    
    // publish(stream)
    if (true) {
        SrsPublishPacket* pkt = new SrsPublishPacket();
        pkt->stream_name = stream;
        if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
            return srs_error_wrap(err, "send publish message failed. stream=%s, stream_id=%d", stream.c_str(), stream_id);
        }
    }
    
    return err;
}

srs_error_t SrsRtmpClient::fmle_publish(string stream, int& stream_id)
{
    stream_id = 0;
    
    srs_error_t err = srs_success;
    
    // SrsFMLEStartPacket
    if (true) {
        SrsFMLEStartPacket* pkt = SrsFMLEStartPacket::create_release_stream(stream);
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send FMLE publish release stream failed. stream=%s", stream.c_str());
        }
    }
    
    // FCPublish
    if (true) {
        SrsFMLEStartPacket* pkt = SrsFMLEStartPacket::create_FC_publish(stream);
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send FMLE publish FCPublish failed. stream=%s", stream.c_str());
        }
    }
    
    // CreateStream
    if (true) {
        SrsCreateStreamPacket* pkt = new SrsCreateStreamPacket();
        pkt->transaction_id = 4;
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send FMLE publish createStream failed. stream=%s", stream.c_str());
        }
    }
    
    // expect result of CreateStream
    if (true) {
        SrsCommonMessage* msg = NULL;
        SrsCreateStreamResPacket* pkt = NULL;
        if ((err = expect_message<SrsCreateStreamResPacket>(&msg, &pkt)) != srs_success) {
            return srs_error_wrap(err, "expect create stream response message failed");
        }
        SrsAutoFree(SrsCommonMessage, msg);
        SrsAutoFree(SrsCreateStreamResPacket, pkt);
        
        stream_id = (int)pkt->stream_id;
    }
    
    // publish(stream)
    if (true) {
        SrsPublishPacket* pkt = new SrsPublishPacket();
        pkt->stream_name = stream;
        if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
            return srs_error_wrap(err, "send FMLE publish publish failed. stream=%s, stream_id=%d", stream.c_str(), stream_id);
        }
    }
    
    return err;
}

SrsRtmpServer::SrsRtmpServer(ISrsProtocolReaderWriter* skt)
{
    io = skt;
    protocol = new SrsProtocol(skt);
    hs_bytes = new SrsHandshakeBytes();
}

SrsRtmpServer::~SrsRtmpServer()
{
    srs_freep(protocol);
    srs_freep(hs_bytes);
}

void SrsRtmpServer::set_auto_response(bool v)
{
    protocol->set_auto_response(v);
}

#ifdef SRS_PERF_MERGED_READ
void SrsRtmpServer::set_merge_read(bool v, IMergeReadHandler* handler)
{
    protocol->set_merge_read(v, handler);
}

void SrsRtmpServer::set_recv_buffer(int buffer_size)
{
    protocol->set_recv_buffer(buffer_size);
}
#endif

void SrsRtmpServer::set_recv_timeout(int64_t tm)
{
    protocol->set_recv_timeout(tm);
}

int64_t SrsRtmpServer::get_recv_timeout()
{
    return protocol->get_recv_timeout();
}

void SrsRtmpServer::set_send_timeout(int64_t tm)
{
    protocol->set_send_timeout(tm);
}

int64_t SrsRtmpServer::get_send_timeout()
{
    return protocol->get_send_timeout();
}

int64_t SrsRtmpServer::get_recv_bytes()
{
    return protocol->get_recv_bytes();
}

int64_t SrsRtmpServer::get_send_bytes()
{
    return protocol->get_send_bytes();
}

srs_error_t SrsRtmpServer::recv_message(SrsCommonMessage** pmsg)
{
    return protocol->recv_message(pmsg);
}

srs_error_t SrsRtmpServer::decode_message(SrsCommonMessage* msg, SrsPacket** ppacket)
{
    return protocol->decode_message(msg, ppacket);
}

srs_error_t SrsRtmpServer::send_and_free_message(SrsSharedPtrMessage* msg, int stream_id)
{
    return protocol->send_and_free_message(msg, stream_id);
}

srs_error_t SrsRtmpServer::send_and_free_messages(SrsSharedPtrMessage** msgs, int nb_msgs, int stream_id)
{
    return protocol->send_and_free_messages(msgs, nb_msgs, stream_id);
}

srs_error_t SrsRtmpServer::send_and_free_packet(SrsPacket* packet, int stream_id)
{
    return protocol->send_and_free_packet(packet, stream_id);
}

srs_error_t SrsRtmpServer::handshake()
{
    srs_error_t err = srs_success;
    
    srs_assert(hs_bytes);
    
    SrsComplexHandshake complex_hs;
    if ((err = complex_hs.handshake_with_client(hs_bytes, io)) != srs_success) {
        if (srs_error_code(err) == ERROR_RTMP_TRY_SIMPLE_HS) {
            srs_freep(err);
            
            SrsSimpleHandshake simple_hs;
            if ((err = simple_hs.handshake_with_client(hs_bytes, io)) != srs_success) {
                return srs_error_wrap(err, "simple handshake");
            }
        } else {
            return srs_error_wrap(err, "complex handshake");
        }
    }
    
    srs_freep(hs_bytes);
    
    return err;
}

srs_error_t SrsRtmpServer::connect_app(SrsRequest* req)
{
    srs_error_t err = srs_success;
    
    SrsCommonMessage* msg = NULL;
    SrsConnectAppPacket* pkt = NULL;
    if ((err = expect_message<SrsConnectAppPacket>(&msg, &pkt)) != srs_success) {
        return srs_error_wrap(err, "expect connect app response");
    }
    SrsAutoFree(SrsCommonMessage, msg);
    SrsAutoFree(SrsConnectAppPacket, pkt);
    
    SrsAmf0Any* prop = NULL;
    
    if ((prop = pkt->command_object->ensure_property_string("tcUrl")) == NULL) {
        return srs_error_new(ERROR_RTMP_REQ_CONNECT, "invalid request without tcUrl");
    }
    req->tcUrl = prop->to_str();
    
    if ((prop = pkt->command_object->ensure_property_string("pageUrl")) != NULL) {
        req->pageUrl = prop->to_str();
    }
    
    if ((prop = pkt->command_object->ensure_property_string("swfUrl")) != NULL) {
        req->swfUrl = prop->to_str();
    }
    
    if ((prop = pkt->command_object->ensure_property_number("objectEncoding")) != NULL) {
        req->objectEncoding = prop->to_number();
    }
    
    if (pkt->args) {
        srs_freep(req->args);
        req->args = pkt->args->copy()->to_object();
    }
    
    srs_discovery_tc_url(req->tcUrl, req->schema, req->host, req->vhost, req->app, req->stream, req->port, req->param);
    req->strip();
    
    return err;
}

srs_error_t SrsRtmpServer::set_window_ack_size(int ack_size)
{
    srs_error_t err = srs_success;
    
    SrsSetWindowAckSizePacket* pkt = new SrsSetWindowAckSizePacket();
    pkt->ackowledgement_window_size = ack_size;
    if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
        return srs_error_wrap(err, "send ack");
    }
    
    return err;
}

srs_error_t SrsRtmpServer::set_in_window_ack_size(int ack_size)
{
    return protocol->set_in_window_ack_size(ack_size);
}

srs_error_t SrsRtmpServer::set_peer_bandwidth(int bandwidth, int type)
{
    srs_error_t err = srs_success;
    
    SrsSetPeerBandwidthPacket* pkt = new SrsSetPeerBandwidthPacket();
    pkt->bandwidth = bandwidth;
    pkt->type = type;
    if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
        return srs_error_wrap(err, "send set peer bandwidth");
    }
    
    return err;
}

srs_error_t SrsRtmpServer::response_connect_app(SrsRequest *req, const char* server_ip)
{
    srs_error_t err = srs_success;
    
    SrsConnectAppResPacket* pkt = new SrsConnectAppResPacket();
    
    pkt->props->set("fmsVer", SrsAmf0Any::str("FMS/" RTMP_SIG_FMS_VER));
    pkt->props->set("capabilities", SrsAmf0Any::number(127));
    pkt->props->set("mode", SrsAmf0Any::number(1));
    
    pkt->info->set(StatusLevel, SrsAmf0Any::str(StatusLevelStatus));
    pkt->info->set(StatusCode, SrsAmf0Any::str(StatusCodeConnectSuccess));
    pkt->info->set(StatusDescription, SrsAmf0Any::str("Connection succeeded"));
    pkt->info->set("objectEncoding", SrsAmf0Any::number(req->objectEncoding));
    SrsAmf0EcmaArray* data = SrsAmf0Any::ecma_array();
    pkt->info->set("data", data);
    
    data->set("version", SrsAmf0Any::str(RTMP_SIG_FMS_VER));
    data->set("srs_sig", SrsAmf0Any::str(RTMP_SIG_SRS_KEY));
    data->set("srs_server", SrsAmf0Any::str(RTMP_SIG_SRS_SERVER));
    data->set("srs_license", SrsAmf0Any::str(RTMP_SIG_SRS_LICENSE));
    data->set("srs_role", SrsAmf0Any::str(RTMP_SIG_SRS_ROLE));
    data->set("srs_url", SrsAmf0Any::str(RTMP_SIG_SRS_URL));
    data->set("srs_version", SrsAmf0Any::str(RTMP_SIG_SRS_VERSION));
    data->set("srs_site", SrsAmf0Any::str(RTMP_SIG_SRS_WEB));
    data->set("srs_email", SrsAmf0Any::str(RTMP_SIG_SRS_EMAIL));
    data->set("srs_copyright", SrsAmf0Any::str(RTMP_SIG_SRS_COPYRIGHT));
    data->set("srs_primary", SrsAmf0Any::str(RTMP_SIG_SRS_PRIMARY));
    data->set("srs_authors", SrsAmf0Any::str(RTMP_SIG_SRS_AUTHROS));
    
    if (server_ip) {
        data->set("srs_server_ip", SrsAmf0Any::str(server_ip));
    }
    // for edge to directly get the id of client.
    data->set("srs_pid", SrsAmf0Any::number(getpid()));
    data->set("srs_id", SrsAmf0Any::number(_srs_context->get_id()));
    
    if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
        return srs_error_wrap(err, "send connect app response");
    }
    
    return err;
}

#define SRS_RTMP_REDIRECT_TMMS 3000
srs_error_t SrsRtmpServer::redirect(SrsRequest* r, string host, int port, bool& accepted)
{
    srs_error_t err = srs_success;
    
    if (true) {
        string url = srs_generate_rtmp_url(host, port, r->host, r->vhost, r->app, r->stream, r->param);
        
        SrsAmf0Object* ex = SrsAmf0Any::object();
        ex->set("code", SrsAmf0Any::number(302));
        ex->set("redirect", SrsAmf0Any::str(url.c_str()));
        
        SrsOnStatusCallPacket* pkt = new SrsOnStatusCallPacket();
        
        pkt->data->set(StatusLevel, SrsAmf0Any::str(StatusLevelError));
        pkt->data->set(StatusCode, SrsAmf0Any::str(StatusCodeConnectRejected));
        pkt->data->set(StatusDescription, SrsAmf0Any::str("RTMP 302 Redirect"));
        pkt->data->set("ex", ex);
        
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send redirect/reject");
        }
    }
    
    // client must response a call message.
    // or we never know whether the client is ok to redirect.
    protocol->set_recv_timeout(SRS_RTMP_REDIRECT_TMMS);
    if (true) {
        SrsCommonMessage* msg = NULL;
        SrsCallPacket* pkt = NULL;
        if ((err = expect_message<SrsCallPacket>(&msg, &pkt)) != srs_success) {
            srs_freep(err);
            // ignore any error of redirect response.
            return srs_success;
        }
        SrsAutoFree(SrsCommonMessage, msg);
        SrsAutoFree(SrsCallPacket, pkt);
        
        string message;
        if (pkt->arguments && pkt->arguments->is_string()) {
            message = pkt->arguments->to_str();
            accepted = true;
        }
    }
    
    return err;
}

void SrsRtmpServer::response_connect_reject(SrsRequest* /*req*/, const char* desc)
{
    srs_error_t err = srs_success;
    
    SrsOnStatusCallPacket* pkt = new SrsOnStatusCallPacket();
    pkt->data->set(StatusLevel, SrsAmf0Any::str(StatusLevelError));
    pkt->data->set(StatusCode, SrsAmf0Any::str(StatusCodeConnectRejected));
    pkt->data->set(StatusDescription, SrsAmf0Any::str(desc));
    
    if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
        srs_warn("send reject response err %s", srs_error_desc(err).c_str());
        srs_freep(err);
    }
    
    return;
}

srs_error_t SrsRtmpServer::on_bw_done()
{
    srs_error_t err = srs_success;
    
    SrsOnBWDonePacket* pkt = new SrsOnBWDonePacket();
    if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
        return srs_error_wrap(err, "send onBWDone");
    }
    
    return err;
}

srs_error_t SrsRtmpServer::identify_client(int stream_id, SrsRtmpConnType& type, string& stream_name, double& duration)
{
    type = SrsRtmpConnUnknown;
    srs_error_t err = srs_success;
    
    while (true) {
        SrsCommonMessage* msg = NULL;
        if ((err = protocol->recv_message(&msg)) != srs_success) {
            return srs_error_wrap(err, "recv identify message");
        }
        
        SrsAutoFree(SrsCommonMessage, msg);
        SrsMessageHeader& h = msg->header;
        
        if (h.is_ackledgement() || h.is_set_chunk_size() || h.is_window_ackledgement_size() || h.is_user_control_message()) {
            continue;
        }
        
        if (!h.is_amf0_command() && !h.is_amf3_command()) {
            srs_trace("ignore message type=%#x", h.message_type);
            continue;
        }
        
        SrsPacket* pkt = NULL;
        if ((err = protocol->decode_message(msg, &pkt)) != srs_success) {
            return srs_error_wrap(err, "decode identify");
        }
        
        SrsAutoFree(SrsPacket, pkt);
        
        if (dynamic_cast<SrsCreateStreamPacket*>(pkt)) {
            return identify_create_stream_client(dynamic_cast<SrsCreateStreamPacket*>(pkt), stream_id, type, stream_name, duration);
        }
        if (dynamic_cast<SrsFMLEStartPacket*>(pkt)) {
            return identify_fmle_publish_client(dynamic_cast<SrsFMLEStartPacket*>(pkt), type, stream_name);
        }
        if (dynamic_cast<SrsPlayPacket*>(pkt)) {
            return identify_play_client(dynamic_cast<SrsPlayPacket*>(pkt), type, stream_name, duration);
        }
        // call msg,
        // support response null first,
        // @see https://github.com/ossrs/srs/issues/106
        // TODO: FIXME: response in right way, or forward in edge mode.
        SrsCallPacket* call = dynamic_cast<SrsCallPacket*>(pkt);
        if (call) {
            SrsCallResPacket* res = new SrsCallResPacket(call->transaction_id);
            res->command_object = SrsAmf0Any::null();
            res->response = SrsAmf0Any::null();
            if ((err = protocol->send_and_free_packet(res, 0)) != srs_success) {
                return srs_error_wrap(err, "response call");
            }
            
            // For encoder of Haivision, it always send a _checkbw call message.
            // @remark the next message is createStream, so we continue to identify it.
            // @see https://github.com/ossrs/srs/issues/844
            if (call->command_name == "_checkbw") {
                continue;
            }
            continue;
        }
        
        srs_trace("ignore AMF0/AMF3 command message.");
    }
    
    return err;
}

srs_error_t SrsRtmpServer::set_chunk_size(int chunk_size)
{
    srs_error_t err = srs_success;
    
    SrsSetChunkSizePacket* pkt = new SrsSetChunkSizePacket();
    pkt->chunk_size = chunk_size;
    if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
        return srs_error_wrap(err, "send set chunk size");
    }
    
    return err;
}

srs_error_t SrsRtmpServer::start_play(int stream_id)
{
    srs_error_t err = srs_success;
    
    // StreamBegin
    if (true) {
        SrsUserControlPacket* pkt = new SrsUserControlPacket();
        pkt->event_type = SrcPCUCStreamBegin;
        pkt->event_data = stream_id;
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send StreamBegin");
        }
    }
    
    // onStatus(NetStream.Play.Reset)
    if (true) {
        SrsOnStatusCallPacket* pkt = new SrsOnStatusCallPacket();
        
        pkt->data->set(StatusLevel, SrsAmf0Any::str(StatusLevelStatus));
        pkt->data->set(StatusCode, SrsAmf0Any::str(StatusCodeStreamReset));
        pkt->data->set(StatusDescription, SrsAmf0Any::str("Playing and resetting stream."));
        pkt->data->set(StatusDetails, SrsAmf0Any::str("stream"));
        pkt->data->set(StatusClientId, SrsAmf0Any::str(RTMP_SIG_CLIENT_ID));
        
        if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
            return srs_error_wrap(err, "send NetStream.Play.Reset");
        }
    }
    
    // onStatus(NetStream.Play.Start)
    if (true) {
        SrsOnStatusCallPacket* pkt = new SrsOnStatusCallPacket();
        
        pkt->data->set(StatusLevel, SrsAmf0Any::str(StatusLevelStatus));
        pkt->data->set(StatusCode, SrsAmf0Any::str(StatusCodeStreamStart));
        pkt->data->set(StatusDescription, SrsAmf0Any::str("Started playing stream."));
        pkt->data->set(StatusDetails, SrsAmf0Any::str("stream"));
        pkt->data->set(StatusClientId, SrsAmf0Any::str(RTMP_SIG_CLIENT_ID));
        
        if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
            return srs_error_wrap(err, "send NetStream.Play.Start");
        }
    }
    
    // |RtmpSampleAccess(false, false)
    if (true) {
        SrsSampleAccessPacket* pkt = new SrsSampleAccessPacket();
        
        // allow audio/video sample.
        // @see: https://github.com/ossrs/srs/issues/49
        pkt->audio_sample_access = true;
        pkt->video_sample_access = true;
        
        if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
            return srs_error_wrap(err, "send |RtmpSampleAccess true");
        }
    }
    
    // onStatus(NetStream.Data.Start)
    if (true) {
        SrsOnStatusDataPacket* pkt = new SrsOnStatusDataPacket();
        pkt->data->set(StatusCode, SrsAmf0Any::str(StatusCodeDataStart));
        if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
            return srs_error_wrap(err, "send NetStream.Data.Start");
        }
    }
    
    return err;
}

srs_error_t SrsRtmpServer::on_play_client_pause(int stream_id, bool is_pause)
{
    srs_error_t err = srs_success;
    
    if (is_pause) {
        // onStatus(NetStream.Pause.Notify)
        if (true) {
            SrsOnStatusCallPacket* pkt = new SrsOnStatusCallPacket();
            
            pkt->data->set(StatusLevel, SrsAmf0Any::str(StatusLevelStatus));
            pkt->data->set(StatusCode, SrsAmf0Any::str(StatusCodeStreamPause));
            pkt->data->set(StatusDescription, SrsAmf0Any::str("Paused stream."));
            
            if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
                return srs_error_wrap(err, "send NetStream.Pause.Notify");
            }
        }
        // StreamEOF
        if (true) {
            SrsUserControlPacket* pkt = new SrsUserControlPacket();
            
            pkt->event_type = SrcPCUCStreamEOF;
            pkt->event_data = stream_id;
            
            if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
                return srs_error_wrap(err, "send StreamEOF");
            }
        }
    } else {
        // onStatus(NetStream.Unpause.Notify)
        if (true) {
            SrsOnStatusCallPacket* pkt = new SrsOnStatusCallPacket();
            
            pkt->data->set(StatusLevel, SrsAmf0Any::str(StatusLevelStatus));
            pkt->data->set(StatusCode, SrsAmf0Any::str(StatusCodeStreamUnpause));
            pkt->data->set(StatusDescription, SrsAmf0Any::str("Unpaused stream."));
            
            if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
                return srs_error_wrap(err, "send NetStream.Unpause.Notify");
            }
        }
        // StreanBegin
        if (true) {
            SrsUserControlPacket* pkt = new SrsUserControlPacket();
            
            pkt->event_type = SrcPCUCStreamBegin;
            pkt->event_data = stream_id;
            
            if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
                return srs_error_wrap(err, "send StreamBegin");
            }
        }
    }
    
    return err;
}

srs_error_t SrsRtmpServer::start_fmle_publish(int stream_id)
{
    srs_error_t err = srs_success;
    
    // FCPublish
    double fc_publish_tid = 0;
    if (true) {
        SrsCommonMessage* msg = NULL;
        SrsFMLEStartPacket* pkt = NULL;
        if ((err = expect_message<SrsFMLEStartPacket>(&msg, &pkt)) != srs_success) {
            return srs_error_wrap(err, "recv FCPublish");
        }
        
        SrsAutoFree(SrsCommonMessage, msg);
        SrsAutoFree(SrsFMLEStartPacket, pkt);
        
        fc_publish_tid = pkt->transaction_id;
    }
    // FCPublish response
    if (true) {
        SrsFMLEStartResPacket* pkt = new SrsFMLEStartResPacket(fc_publish_tid);
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send FCPublish response");
        }
    }
    
    // createStream
    double create_stream_tid = 0;
    if (true) {
        SrsCommonMessage* msg = NULL;
        SrsCreateStreamPacket* pkt = NULL;
        if ((err = expect_message<SrsCreateStreamPacket>(&msg, &pkt)) != srs_success) {
            return srs_error_wrap(err, "recv createStream");
        }
        
        SrsAutoFree(SrsCommonMessage, msg);
        SrsAutoFree(SrsCreateStreamPacket, pkt);
        
        create_stream_tid = pkt->transaction_id;
    }
    // createStream response
    if (true) {
        SrsCreateStreamResPacket* pkt = new SrsCreateStreamResPacket(create_stream_tid, stream_id);
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send createStream response");
        }
    }
    
    // publish
    if (true) {
        SrsCommonMessage* msg = NULL;
        SrsPublishPacket* pkt = NULL;
        if ((err = expect_message<SrsPublishPacket>(&msg, &pkt)) != srs_success) {
            return srs_error_wrap(err, "recv publish");
        }
        
        SrsAutoFree(SrsCommonMessage, msg);
        SrsAutoFree(SrsPublishPacket, pkt);
    }
    // publish response onFCPublish(NetStream.Publish.Start)
    if (true) {
        SrsOnStatusCallPacket* pkt = new SrsOnStatusCallPacket();
        
        pkt->command_name = RTMP_AMF0_COMMAND_ON_FC_PUBLISH;
        pkt->data->set(StatusCode, SrsAmf0Any::str(StatusCodePublishStart));
        pkt->data->set(StatusDescription, SrsAmf0Any::str("Started publishing stream."));
        
        if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
            return srs_error_wrap(err, "send NetStream.Publish.Start");
        }
    }
    // publish response onStatus(NetStream.Publish.Start)
    if (true) {
        SrsOnStatusCallPacket* pkt = new SrsOnStatusCallPacket();
        
        pkt->data->set(StatusLevel, SrsAmf0Any::str(StatusLevelStatus));
        pkt->data->set(StatusCode, SrsAmf0Any::str(StatusCodePublishStart));
        pkt->data->set(StatusDescription, SrsAmf0Any::str("Started publishing stream."));
        pkt->data->set(StatusClientId, SrsAmf0Any::str(RTMP_SIG_CLIENT_ID));
        
        if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
            return srs_error_wrap(err, "send NetStream.Publish.Start");
        }
    }
    
    return err;
}

srs_error_t SrsRtmpServer::start_haivision_publish(int stream_id)
{
    srs_error_t err = srs_success;
    
    // publish
    if (true) {
        SrsCommonMessage* msg = NULL;
        SrsPublishPacket* pkt = NULL;
        if ((err = expect_message<SrsPublishPacket>(&msg, &pkt)) != srs_success) {
            return srs_error_wrap(err, "recv publish");
        }
        
        SrsAutoFree(SrsCommonMessage, msg);
        SrsAutoFree(SrsPublishPacket, pkt);
    }
    
    // publish response onFCPublish(NetStream.Publish.Start)
    if (true) {
        SrsOnStatusCallPacket* pkt = new SrsOnStatusCallPacket();
        
        pkt->command_name = RTMP_AMF0_COMMAND_ON_FC_PUBLISH;
        pkt->data->set(StatusCode, SrsAmf0Any::str(StatusCodePublishStart));
        pkt->data->set(StatusDescription, SrsAmf0Any::str("Started publishing stream."));
        
        if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
            return srs_error_wrap(err, "send NetStream.Publish.Start");
        }
    }
    
    // publish response onStatus(NetStream.Publish.Start)
    if (true) {
        SrsOnStatusCallPacket* pkt = new SrsOnStatusCallPacket();
        
        pkt->data->set(StatusLevel, SrsAmf0Any::str(StatusLevelStatus));
        pkt->data->set(StatusCode, SrsAmf0Any::str(StatusCodePublishStart));
        pkt->data->set(StatusDescription, SrsAmf0Any::str("Started publishing stream."));
        pkt->data->set(StatusClientId, SrsAmf0Any::str(RTMP_SIG_CLIENT_ID));
        
        if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
            return srs_error_wrap(err, "send NetStream.Publish.Start");
        }
    }
    
    return err;
}

srs_error_t SrsRtmpServer::fmle_unpublish(int stream_id, double unpublish_tid)
{
    srs_error_t err =srs_success;
    
    // publish response onFCUnpublish(NetStream.unpublish.Success)
    if (true) {
        SrsOnStatusCallPacket* pkt = new SrsOnStatusCallPacket();
        
        pkt->command_name = RTMP_AMF0_COMMAND_ON_FC_UNPUBLISH;
        pkt->data->set(StatusCode, SrsAmf0Any::str(StatusCodeUnpublishSuccess));
        pkt->data->set(StatusDescription, SrsAmf0Any::str("Stop publishing stream."));
        
        if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
            return srs_error_wrap(err, "send NetStream.unpublish.Success");
        }
    }
    // FCUnpublish response
    if (true) {
        SrsFMLEStartResPacket* pkt = new SrsFMLEStartResPacket(unpublish_tid);
        if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
            return srs_error_wrap(err, "send FCUnpublish response");
        }
    }
    // publish response onStatus(NetStream.Unpublish.Success)
    if (true) {
        SrsOnStatusCallPacket* pkt = new SrsOnStatusCallPacket();
        
        pkt->data->set(StatusLevel, SrsAmf0Any::str(StatusLevelStatus));
        pkt->data->set(StatusCode, SrsAmf0Any::str(StatusCodeUnpublishSuccess));
        pkt->data->set(StatusDescription, SrsAmf0Any::str("Stream is now unpublished"));
        pkt->data->set(StatusClientId, SrsAmf0Any::str(RTMP_SIG_CLIENT_ID));
        
        if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
            return srs_error_wrap(err, "send NetStream.Unpublish.Success");
        }
    }
    
    return err;
}

srs_error_t SrsRtmpServer::start_flash_publish(int stream_id)
{
    srs_error_t err = srs_success;
    
    // publish response onStatus(NetStream.Publish.Start)
    if (true) {
        SrsOnStatusCallPacket* pkt = new SrsOnStatusCallPacket();
        
        pkt->data->set(StatusLevel, SrsAmf0Any::str(StatusLevelStatus));
        pkt->data->set(StatusCode, SrsAmf0Any::str(StatusCodePublishStart));
        pkt->data->set(StatusDescription, SrsAmf0Any::str("Started publishing stream."));
        pkt->data->set(StatusClientId, SrsAmf0Any::str(RTMP_SIG_CLIENT_ID));
        
        if ((err = protocol->send_and_free_packet(pkt, stream_id)) != srs_success) {
            return srs_error_wrap(err, "send NetStream.Publish.Start");
        }
    }
    
    return err;
}

srs_error_t SrsRtmpServer::identify_create_stream_client(SrsCreateStreamPacket* req, int stream_id, SrsRtmpConnType& type, string& stream_name, double& duration)
{
    srs_error_t err = srs_success;
    
    if (true) {
        SrsCreateStreamResPacket* pkt = new SrsCreateStreamResPacket(req->transaction_id, stream_id);
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send createStream response");
        }
    }
    
    while (true) {
        SrsCommonMessage* msg = NULL;
        if ((err = protocol->recv_message(&msg)) != srs_success) {
            return srs_error_wrap(err, "recv identify");
        }
        
        SrsAutoFree(SrsCommonMessage, msg);
        SrsMessageHeader& h = msg->header;
        
        if (h.is_ackledgement() || h.is_set_chunk_size() || h.is_window_ackledgement_size() || h.is_user_control_message()) {
            continue;
        }
        
        if (!h.is_amf0_command() && !h.is_amf3_command()) {
            srs_trace("ignore message type=%#x", h.message_type);
            continue;
        }
        
        SrsPacket* pkt = NULL;
        if ((err = protocol->decode_message(msg, &pkt)) != srs_success) {
            return srs_error_wrap(err, "decode identify");
        }
        
        SrsAutoFree(SrsPacket, pkt);
        
        if (dynamic_cast<SrsPlayPacket*>(pkt)) {
            return identify_play_client(dynamic_cast<SrsPlayPacket*>(pkt), type, stream_name, duration);
        }
        if (dynamic_cast<SrsPublishPacket*>(pkt)) {
            return identify_flash_publish_client(dynamic_cast<SrsPublishPacket*>(pkt), type, stream_name);
        }
        if (dynamic_cast<SrsCreateStreamPacket*>(pkt)) {
            return identify_create_stream_client(dynamic_cast<SrsCreateStreamPacket*>(pkt), stream_id, type, stream_name, duration);
        }
        if (dynamic_cast<SrsFMLEStartPacket*>(pkt)) {
            return identify_haivision_publish_client(dynamic_cast<SrsFMLEStartPacket*>(pkt), type, stream_name);
        }
        
        srs_trace("ignore AMF0/AMF3 command message.");
    }
    
    return err;
}

srs_error_t SrsRtmpServer::identify_fmle_publish_client(SrsFMLEStartPacket* req, SrsRtmpConnType& type, string& stream_name)
{
    srs_error_t err = srs_success;
    
    type = SrsRtmpConnFMLEPublish;
    stream_name = req->stream_name;
    
    // releaseStream response
    if (true) {
        SrsFMLEStartResPacket* pkt = new SrsFMLEStartResPacket(req->transaction_id);
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send releaseStream response");
        }
    }
    
    return err;
}

srs_error_t SrsRtmpServer::identify_haivision_publish_client(SrsFMLEStartPacket* req, SrsRtmpConnType& type, string& stream_name)
{
    srs_error_t err = srs_success;
    
    type = SrsRtmpConnHaivisionPublish;
    stream_name = req->stream_name;
    
    // FCPublish response
    if (true) {
        SrsFMLEStartResPacket* pkt = new SrsFMLEStartResPacket(req->transaction_id);
        if ((err = protocol->send_and_free_packet(pkt, 0)) != srs_success) {
            return srs_error_wrap(err, "send FCPublish");
        }
    }
    
    return err;
}

srs_error_t SrsRtmpServer::identify_flash_publish_client(SrsPublishPacket* req, SrsRtmpConnType& type, string& stream_name)
{
    type = SrsRtmpConnFlashPublish;
    stream_name = req->stream_name;
    
    return srs_success;
}

srs_error_t SrsRtmpServer::identify_play_client(SrsPlayPacket* req, SrsRtmpConnType& type, string& stream_name, double& duration)
{
    type = SrsRtmpConnPlay;
    stream_name = req->stream_name;
    duration = req->duration;
    
    return srs_success;
}

SrsConnectAppPacket::SrsConnectAppPacket()
{
    command_name = RTMP_AMF0_COMMAND_CONNECT;
    transaction_id = 1;
    command_object = SrsAmf0Any::object();
    // optional
    args = NULL;
}

SrsConnectAppPacket::~SrsConnectAppPacket()
{
    srs_freep(command_object);
    srs_freep(args);
}

srs_error_t SrsConnectAppPacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_read_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    if (command_name.empty() || command_name != RTMP_AMF0_COMMAND_CONNECT) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "invalid command_name=%s", command_name.c_str());
    }
    
    if ((err = srs_amf0_read_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    // some client donot send id=1.0, so we only warn user if not match.
    if (transaction_id != 1.0) {
        srs_warn("invalid transaction_id=%.2f", transaction_id);
    }
    
    if ((err = command_object->read(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if (!stream->empty()) {
        srs_freep(args);
        
        // see: https://github.com/ossrs/srs/issues/186
        // the args maybe any amf0, for instance, a string. we should drop if not object.
        SrsAmf0Any* any = NULL;
        if ((err = SrsAmf0Any::discovery(stream, &any)) != srs_success) {
            return srs_error_wrap(err, "args");
        }
        srs_assert(any);
        
        // read the instance
        if ((err = any->read(stream)) != srs_success) {
            srs_freep(any);
            return srs_error_wrap(err, "args");
        }
        
        // drop when not an AMF0 object.
        if (!any->is_object()) {
            srs_warn("drop the args, see: '4.1.1. connect', marker=%#x", (uint8_t)any->marker);
            srs_freep(any);
        } else {
            args = any->to_object();
        }
    }
    
    return err;
}

int SrsConnectAppPacket::get_prefer_cid()
{
    return RTMP_CID_OverConnection;
}

int SrsConnectAppPacket::get_message_type()
{
    return RTMP_MSG_AMF0CommandMessage;
}

int SrsConnectAppPacket::get_size()
{
    int size = 0;
    
    size += SrsAmf0Size::str(command_name);
    size += SrsAmf0Size::number();
    size += SrsAmf0Size::object(command_object);
    if (args) {
        size += SrsAmf0Size::object(args);
    }
    
    return size;
}

srs_error_t SrsConnectAppPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_write_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = command_object->write(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if (args && (err = args->write(stream)) != srs_success) {
        return srs_error_wrap(err, "args");
    }
    
    return err;
}

SrsConnectAppResPacket::SrsConnectAppResPacket()
{
    command_name = RTMP_AMF0_COMMAND_RESULT;
    transaction_id = 1;
    props = SrsAmf0Any::object();
    info = SrsAmf0Any::object();
}

SrsConnectAppResPacket::~SrsConnectAppResPacket()
{
    srs_freep(props);
    srs_freep(info);
}

srs_error_t SrsConnectAppResPacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_read_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    if (command_name.empty() || command_name != RTMP_AMF0_COMMAND_RESULT) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "command_name=%s", command_name.c_str());
    }
    
    if ((err = srs_amf0_read_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    // some client donot send id=1.0, so we only warn user if not match.
    if (transaction_id != 1.0) {
        srs_warn("invalid transaction_id=%.2f", transaction_id);
    }
    
    // for RED5(1.0.6), the props is NULL, we must ignore it.
    // @see https://github.com/ossrs/srs/issues/418
    if (!stream->empty()) {
        SrsAmf0Any* p = NULL;
        if ((err = srs_amf0_read_any(stream, &p)) != srs_success) {
            return srs_error_wrap(err, "args");
        }
        
        // ignore when props is not amf0 object.
        if (!p->is_object()) {
            srs_warn("ignore connect response props marker=%#x.", (uint8_t)p->marker);
            srs_freep(p);
        } else {
            srs_freep(props);
            props = p->to_object();
        }
    }
    
    if ((err = info->read(stream)) != srs_success) {
        return srs_error_wrap(err, "args");
    }
    
    return err;
}

int SrsConnectAppResPacket::get_prefer_cid()
{
    return RTMP_CID_OverConnection;
}

int SrsConnectAppResPacket::get_message_type()
{
    return RTMP_MSG_AMF0CommandMessage;
}

int SrsConnectAppResPacket::get_size()
{
    return SrsAmf0Size::str(command_name) + SrsAmf0Size::number()
    + SrsAmf0Size::object(props) + SrsAmf0Size::object(info);
}

srs_error_t SrsConnectAppResPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_write_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = props->write(stream)) != srs_success) {
        return srs_error_wrap(err, "props");
    }
    
    if ((err = info->write(stream)) != srs_success) {
        return srs_error_wrap(err, "info");
    }
    
    return err;
}

SrsCallPacket::SrsCallPacket()
{
    command_name = "";
    transaction_id = 0;
    command_object = NULL;
    arguments = NULL;
}

SrsCallPacket::~SrsCallPacket()
{
    srs_freep(command_object);
    srs_freep(arguments);
}

srs_error_t SrsCallPacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_read_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    if (command_name.empty()) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "empty command_name");
    }
    
    if ((err = srs_amf0_read_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    srs_freep(command_object);
    if ((err = SrsAmf0Any::discovery(stream, &command_object)) != srs_success) {
        return srs_error_wrap(err, "discovery command_object");
    }
    if ((err = command_object->read(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if (!stream->empty()) {
        srs_freep(arguments);
        if ((err = SrsAmf0Any::discovery(stream, &arguments)) != srs_success) {
            return srs_error_wrap(err, "discovery args");
        }
        if ((err = arguments->read(stream)) != srs_success) {
            return srs_error_wrap(err, "read args");
        }
    }
    
    return err;
}

int SrsCallPacket::get_prefer_cid()
{
    return RTMP_CID_OverConnection;
}

int SrsCallPacket::get_message_type()
{
    return RTMP_MSG_AMF0CommandMessage;
}

int SrsCallPacket::get_size()
{
    int size = 0;
    
    size += SrsAmf0Size::str(command_name) + SrsAmf0Size::number();
    
    if (command_object) {
        size += command_object->total_size();
    }
    
    if (arguments) {
        size += arguments->total_size();
    }
    
    return size;
}

srs_error_t SrsCallPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_write_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if (command_object && (err = command_object->write(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if (arguments && (err = arguments->write(stream)) != srs_success) {
        return srs_error_wrap(err, "args");
    }
    
    return err;
}

SrsCallResPacket::SrsCallResPacket(double _transaction_id)
{
    command_name = RTMP_AMF0_COMMAND_RESULT;
    transaction_id = _transaction_id;
    command_object = NULL;
    response = NULL;
}

SrsCallResPacket::~SrsCallResPacket()
{
    srs_freep(command_object);
    srs_freep(response);
}

int SrsCallResPacket::get_prefer_cid()
{
    return RTMP_CID_OverConnection;
}

int SrsCallResPacket::get_message_type()
{
    return RTMP_MSG_AMF0CommandMessage;
}

int SrsCallResPacket::get_size()
{
    int size = 0;
    
    size += SrsAmf0Size::str(command_name) + SrsAmf0Size::number();
    
    if (command_object) {
        size += command_object->total_size();
    }
    
    if (response) {
        size += response->total_size();
    }
    
    return size;
}

srs_error_t SrsCallResPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_write_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if (command_object && (err = command_object->write(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if (response && (err = response->write(stream)) != srs_success) {
        return srs_error_wrap(err, "response");
    }
    
    return err;
}

SrsCreateStreamPacket::SrsCreateStreamPacket()
{
    command_name = RTMP_AMF0_COMMAND_CREATE_STREAM;
    transaction_id = 2;
    command_object = SrsAmf0Any::null();
}

SrsCreateStreamPacket::~SrsCreateStreamPacket()
{
    srs_freep(command_object);
}

srs_error_t SrsCreateStreamPacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_read_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    if (command_name.empty() || command_name != RTMP_AMF0_COMMAND_CREATE_STREAM) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "invalid command_name=%s", command_name.c_str());
    }
    
    if ((err = srs_amf0_read_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_read_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    return err;
}

int SrsCreateStreamPacket::get_prefer_cid()
{
    return RTMP_CID_OverConnection;
}

int SrsCreateStreamPacket::get_message_type()
{
    return RTMP_MSG_AMF0CommandMessage;
}

int SrsCreateStreamPacket::get_size()
{
    return SrsAmf0Size::str(command_name) + SrsAmf0Size::number()
    + SrsAmf0Size::null();
}

srs_error_t SrsCreateStreamPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_write_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_write_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    return err;
}

SrsCreateStreamResPacket::SrsCreateStreamResPacket(double _transaction_id, double _stream_id)
{
    command_name = RTMP_AMF0_COMMAND_RESULT;
    transaction_id = _transaction_id;
    command_object = SrsAmf0Any::null();
    stream_id = _stream_id;
}

SrsCreateStreamResPacket::~SrsCreateStreamResPacket()
{
    srs_freep(command_object);
}

srs_error_t SrsCreateStreamResPacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_read_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    if (command_name.empty() || command_name != RTMP_AMF0_COMMAND_RESULT) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "invalid command_name=%s", command_name.c_str());
    }
    
    if ((err = srs_amf0_read_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_read_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if ((err = srs_amf0_read_number(stream, stream_id)) != srs_success) {
        return srs_error_wrap(err, "stream_id");
    }
    
    return err;
}

int SrsCreateStreamResPacket::get_prefer_cid()
{
    return RTMP_CID_OverConnection;
}

int SrsCreateStreamResPacket::get_message_type()
{
    return RTMP_MSG_AMF0CommandMessage;
}

int SrsCreateStreamResPacket::get_size()
{
    return SrsAmf0Size::str(command_name) + SrsAmf0Size::number()
    + SrsAmf0Size::null() + SrsAmf0Size::number();
}

srs_error_t SrsCreateStreamResPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_write_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_write_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if ((err = srs_amf0_write_number(stream, stream_id)) != srs_success) {
        return srs_error_wrap(err, "stream_id");
    }
    
    return err;
}

SrsCloseStreamPacket::SrsCloseStreamPacket()
{
    command_name = RTMP_AMF0_COMMAND_CLOSE_STREAM;
    transaction_id = 0;
    command_object = SrsAmf0Any::null();
}

SrsCloseStreamPacket::~SrsCloseStreamPacket()
{
    srs_freep(command_object);
}

srs_error_t SrsCloseStreamPacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_read_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_read_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_read_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    return err;
}

SrsFMLEStartPacket::SrsFMLEStartPacket()
{
    command_name = RTMP_AMF0_COMMAND_RELEASE_STREAM;
    transaction_id = 0;
    command_object = SrsAmf0Any::null();
}

SrsFMLEStartPacket::~SrsFMLEStartPacket()
{
    srs_freep(command_object);
}

srs_error_t SrsFMLEStartPacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_read_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    bool invalid_command_name = (command_name != RTMP_AMF0_COMMAND_RELEASE_STREAM
        && command_name != RTMP_AMF0_COMMAND_FC_PUBLISH && command_name != RTMP_AMF0_COMMAND_UNPUBLISH);
    if (command_name.empty() || invalid_command_name) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "invalid command_name=%s", command_name.c_str());
    }
    
    if ((err = srs_amf0_read_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_read_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if ((err = srs_amf0_read_string(stream, stream_name)) != srs_success) {
        return srs_error_wrap(err, "stream_name");
    }
    
    return err;
}

int SrsFMLEStartPacket::get_prefer_cid()
{
    return RTMP_CID_OverConnection;
}

int SrsFMLEStartPacket::get_message_type()
{
    return RTMP_MSG_AMF0CommandMessage;
}

int SrsFMLEStartPacket::get_size()
{
    return SrsAmf0Size::str(command_name) + SrsAmf0Size::number()
    + SrsAmf0Size::null() + SrsAmf0Size::str(stream_name);
}

srs_error_t SrsFMLEStartPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_write_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_write_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if ((err = srs_amf0_write_string(stream, stream_name)) != srs_success) {
        return srs_error_wrap(err, "stream_name");
    }
    
    return err;
}

SrsFMLEStartPacket* SrsFMLEStartPacket::create_release_stream(string stream)
{
    SrsFMLEStartPacket* pkt = new SrsFMLEStartPacket();
    
    pkt->command_name = RTMP_AMF0_COMMAND_RELEASE_STREAM;
    pkt->transaction_id = 2;
    pkt->stream_name = stream;
    
    return pkt;
}

SrsFMLEStartPacket* SrsFMLEStartPacket::create_FC_publish(string stream)
{
    SrsFMLEStartPacket* pkt = new SrsFMLEStartPacket();
    
    pkt->command_name = RTMP_AMF0_COMMAND_FC_PUBLISH;
    pkt->transaction_id = 3;
    pkt->stream_name = stream;
    
    return pkt;
}

SrsFMLEStartResPacket::SrsFMLEStartResPacket(double _transaction_id)
{
    command_name = RTMP_AMF0_COMMAND_RESULT;
    transaction_id = _transaction_id;
    command_object = SrsAmf0Any::null();
    args = SrsAmf0Any::undefined();
}

SrsFMLEStartResPacket::~SrsFMLEStartResPacket()
{
    srs_freep(command_object);
    srs_freep(args);
}

srs_error_t SrsFMLEStartResPacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_read_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    if (command_name.empty() || command_name != RTMP_AMF0_COMMAND_RESULT) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "invalid command_name=%s", command_name.c_str());
    }
    
    if ((err = srs_amf0_read_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_read_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if ((err = srs_amf0_read_undefined(stream)) != srs_success) {
        return srs_error_wrap(err, "stream_id");
    }
    
    return err;
}

int SrsFMLEStartResPacket::get_prefer_cid()
{
    return RTMP_CID_OverConnection;
}

int SrsFMLEStartResPacket::get_message_type()
{
    return RTMP_MSG_AMF0CommandMessage;
}

int SrsFMLEStartResPacket::get_size()
{
    return SrsAmf0Size::str(command_name) + SrsAmf0Size::number()
    + SrsAmf0Size::null() + SrsAmf0Size::undefined();
}

srs_error_t SrsFMLEStartResPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_write_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_write_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if ((err = srs_amf0_write_undefined(stream)) != srs_success) {
        return srs_error_wrap(err, "args");
    }
    
    return err;
}

SrsPublishPacket::SrsPublishPacket()
{
    command_name = RTMP_AMF0_COMMAND_PUBLISH;
    transaction_id = 0;
    command_object = SrsAmf0Any::null();
    type = "live";
}

SrsPublishPacket::~SrsPublishPacket()
{
    srs_freep(command_object);
}

srs_error_t SrsPublishPacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_read_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    if (command_name.empty() || command_name != RTMP_AMF0_COMMAND_PUBLISH) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "invalid command_name=%s", command_name.c_str());
    }
    
    if ((err = srs_amf0_read_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_read_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if ((err = srs_amf0_read_string(stream, stream_name)) != srs_success) {
        return srs_error_wrap(err, "stream_name");
    }
    
    if (!stream->empty() && (err = srs_amf0_read_string(stream, type)) != srs_success) {
        return srs_error_wrap(err, "publish type");
    }
    
    return err;
}

int SrsPublishPacket::get_prefer_cid()
{
    return RTMP_CID_OverStream;
}

int SrsPublishPacket::get_message_type()
{
    return RTMP_MSG_AMF0CommandMessage;
}

int SrsPublishPacket::get_size()
{
    return SrsAmf0Size::str(command_name) + SrsAmf0Size::number()
    + SrsAmf0Size::null() + SrsAmf0Size::str(stream_name)
    + SrsAmf0Size::str(type);
}

srs_error_t SrsPublishPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_write_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_write_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if ((err = srs_amf0_write_string(stream, stream_name)) != srs_success) {
        return srs_error_wrap(err, "stream_name");
    }
    
    if ((err = srs_amf0_write_string(stream, type)) != srs_success) {
        return srs_error_wrap(err, "type");
    }
    
    return err;
}

SrsPausePacket::SrsPausePacket()
{
    command_name = RTMP_AMF0_COMMAND_PAUSE;
    transaction_id = 0;
    command_object = SrsAmf0Any::null();
    
    time_ms = 0;
    is_pause = true;
}

SrsPausePacket::~SrsPausePacket()
{
    srs_freep(command_object);
}

srs_error_t SrsPausePacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_read_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    if (command_name.empty() || command_name != RTMP_AMF0_COMMAND_PAUSE) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "invalid command_name=%s", command_name.c_str());
    }
    
    if ((err = srs_amf0_read_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_read_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if ((err = srs_amf0_read_boolean(stream, is_pause)) != srs_success) {
        return srs_error_wrap(err, "is_pause");
    }
    
    if ((err = srs_amf0_read_number(stream, time_ms)) != srs_success) {
        return srs_error_wrap(err, "time");
    }
    
    return err;
}

SrsPlayPacket::SrsPlayPacket()
{
    command_name = RTMP_AMF0_COMMAND_PLAY;
    transaction_id = 0;
    command_object = SrsAmf0Any::null();
    
    start = -2;
    duration = -1;
    reset = true;
}

SrsPlayPacket::~SrsPlayPacket()
{
    srs_freep(command_object);
}

srs_error_t SrsPlayPacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_read_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    if (command_name.empty() || command_name != RTMP_AMF0_COMMAND_PLAY) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "invalid command_name=%s", command_name.c_str());
    }
    
    if ((err = srs_amf0_read_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_read_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if ((err = srs_amf0_read_string(stream, stream_name)) != srs_success) {
        return srs_error_wrap(err, "stream_name");
    }
    
    if (!stream->empty() && (err = srs_amf0_read_number(stream, start)) != srs_success) {
        return srs_error_wrap(err, "start");
    }
    if (!stream->empty() && (err = srs_amf0_read_number(stream, duration)) != srs_success) {
        return srs_error_wrap(err, "duration");
    }
    
    if (stream->empty()) {
        return err;
    }
    
    SrsAmf0Any* reset_value = NULL;
    if ((err = srs_amf0_read_any(stream, &reset_value)) != srs_success) {
        return srs_error_new(ERROR_RTMP_AMF0_DECODE, "reset");
    }
    SrsAutoFree(SrsAmf0Any, reset_value);
    
    if (reset_value) {
        // check if the value is bool or number
        // An optional Boolean value or number that specifies whether
        // to flush any previous playlist
        if (reset_value->is_boolean()) {
            reset = reset_value->to_boolean();
        } else if (reset_value->is_number()) {
            reset = (reset_value->to_number() != 0);
        } else {
            return srs_error_new(ERROR_RTMP_AMF0_DECODE, "invalid marker=%#x", (uint8_t)reset_value->marker);
        }
    }
    
    return err;
}

int SrsPlayPacket::get_prefer_cid()
{
    return RTMP_CID_OverStream;
}

int SrsPlayPacket::get_message_type()
{
    return RTMP_MSG_AMF0CommandMessage;
}

int SrsPlayPacket::get_size()
{
    int size = SrsAmf0Size::str(command_name) + SrsAmf0Size::number()
    + SrsAmf0Size::null() + SrsAmf0Size::str(stream_name);
    
    if (start != -2 || duration != -1 || !reset) {
        size += SrsAmf0Size::number();
    }
    
    if (duration != -1 || !reset) {
        size += SrsAmf0Size::number();
    }
    
    if (!reset) {
        size += SrsAmf0Size::boolean();
    }
    
    return size;
}

srs_error_t SrsPlayPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_write_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_write_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if ((err = srs_amf0_write_string(stream, stream_name)) != srs_success) {
        return srs_error_wrap(err, "stream_name");
    }
    
    if ((start != -2 || duration != -1 || !reset) && (err = srs_amf0_write_number(stream, start)) != srs_success) {
        return srs_error_wrap(err, "start");
    }
    
    if ((duration != -1 || !reset) && (err = srs_amf0_write_number(stream, duration)) != srs_success) {
        return srs_error_wrap(err, "duration");
    }
    
    if (!reset && (err = srs_amf0_write_boolean(stream, reset)) != srs_success) {
        return srs_error_wrap(err, "reset");
    }
    
    return err;
}

SrsPlayResPacket::SrsPlayResPacket()
{
    command_name = RTMP_AMF0_COMMAND_RESULT;
    transaction_id = 0;
    command_object = SrsAmf0Any::null();
    desc = SrsAmf0Any::object();
}

SrsPlayResPacket::~SrsPlayResPacket()
{
    srs_freep(command_object);
    srs_freep(desc);
}

int SrsPlayResPacket::get_prefer_cid()
{
    return RTMP_CID_OverStream;
}

int SrsPlayResPacket::get_message_type()
{
    return RTMP_MSG_AMF0CommandMessage;
}

int SrsPlayResPacket::get_size()
{
    return SrsAmf0Size::str(command_name) + SrsAmf0Size::number()
    + SrsAmf0Size::null() + SrsAmf0Size::object(desc);
}

srs_error_t SrsPlayResPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_write_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_write_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    if ((err = desc->write(stream)) != srs_success) {
        return srs_error_wrap(err, "desc");
    }
    
    return err;
}

SrsOnBWDonePacket::SrsOnBWDonePacket()
{
    command_name = RTMP_AMF0_COMMAND_ON_BW_DONE;
    transaction_id = 0;
    args = SrsAmf0Any::null();
}

SrsOnBWDonePacket::~SrsOnBWDonePacket()
{
    srs_freep(args);
}

int SrsOnBWDonePacket::get_prefer_cid()
{
    return RTMP_CID_OverConnection;
}

int SrsOnBWDonePacket::get_message_type()
{
    return RTMP_MSG_AMF0CommandMessage;
}

int SrsOnBWDonePacket::get_size()
{
    return SrsAmf0Size::str(command_name) + SrsAmf0Size::number()
    + SrsAmf0Size::null();
}

srs_error_t SrsOnBWDonePacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_write_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_write_null(stream)) != srs_success) {
        return srs_error_wrap(err, "args");
    }
    
    return err;
}

SrsOnStatusCallPacket::SrsOnStatusCallPacket()
{
    command_name = RTMP_AMF0_COMMAND_ON_STATUS;
    transaction_id = 0;
    args = SrsAmf0Any::null();
    data = SrsAmf0Any::object();
}

SrsOnStatusCallPacket::~SrsOnStatusCallPacket()
{
    srs_freep(args);
    srs_freep(data);
}

int SrsOnStatusCallPacket::get_prefer_cid()
{
    return RTMP_CID_OverStream;
}

int SrsOnStatusCallPacket::get_message_type()
{
    return RTMP_MSG_AMF0CommandMessage;
}

int SrsOnStatusCallPacket::get_size()
{
    return SrsAmf0Size::str(command_name) + SrsAmf0Size::number()
    + SrsAmf0Size::null() + SrsAmf0Size::object(data);
}

srs_error_t SrsOnStatusCallPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_write_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_write_null(stream)) != srs_success) {
        return srs_error_wrap(err, "args");
    }
    
    if ((err = data->write(stream)) != srs_success) {
        return srs_error_wrap(err, "data");
    }
    
    return err;
}

SrsBandwidthPacket::SrsBandwidthPacket()
{
    command_name = RTMP_AMF0_COMMAND_ON_STATUS;
    transaction_id = 0;
    args = SrsAmf0Any::null();
    data = SrsAmf0Any::object();
}

SrsBandwidthPacket::~SrsBandwidthPacket()
{
    srs_freep(args);
    srs_freep(data);
}

srs_error_t SrsBandwidthPacket::decode(SrsBuffer *stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_read_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_read_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_read_null(stream)) != srs_success) {
        return srs_error_wrap(err, "command_object");
    }
    
    // @remark, for bandwidth test, ignore the data field.
    // only decode the stop-play, start-publish and finish packet.
    if (is_stop_play() || is_start_publish() || is_finish()) {
        if ((err = data->read(stream)) != srs_success) {
            return srs_error_wrap(err, "command_object");
        }
    }
    
    return err;
}

int SrsBandwidthPacket::get_prefer_cid()
{
    return RTMP_CID_OverStream;
}

int SrsBandwidthPacket::get_message_type()
{
    return RTMP_MSG_AMF0CommandMessage;
}

int SrsBandwidthPacket::get_size()
{
    return SrsAmf0Size::str(command_name) + SrsAmf0Size::number()
    + SrsAmf0Size::null() + SrsAmf0Size::object(data);
}

srs_error_t SrsBandwidthPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_write_number(stream, transaction_id)) != srs_success) {
        return srs_error_wrap(err, "transaction_id");
    }
    
    if ((err = srs_amf0_write_null(stream)) != srs_success) {
        return srs_error_wrap(err, "args");
    }
    
    if ((err = data->write(stream)) != srs_success) {
        return srs_error_wrap(err, "data");
    }
    
    return err;
}

bool SrsBandwidthPacket::is_start_play()
{
    return command_name == SRS_BW_CHECK_START_PLAY;
}

bool SrsBandwidthPacket::is_starting_play()
{
    return command_name == SRS_BW_CHECK_STARTING_PLAY;
}

bool SrsBandwidthPacket::is_stop_play()
{
    return command_name == SRS_BW_CHECK_STOP_PLAY;
}

bool SrsBandwidthPacket::is_stopped_play()
{
    return command_name == SRS_BW_CHECK_STOPPED_PLAY;
}

bool SrsBandwidthPacket::is_start_publish()
{
    return command_name == SRS_BW_CHECK_START_PUBLISH;
}

bool SrsBandwidthPacket::is_starting_publish()
{
    return command_name == SRS_BW_CHECK_STARTING_PUBLISH;
}

bool SrsBandwidthPacket::is_stop_publish()
{
    return command_name == SRS_BW_CHECK_STOP_PUBLISH;
}

bool SrsBandwidthPacket::is_stopped_publish()
{
    return command_name == SRS_BW_CHECK_STOPPED_PUBLISH;
}

bool SrsBandwidthPacket::is_finish()
{
    return command_name == SRS_BW_CHECK_FINISHED;
}

bool SrsBandwidthPacket::is_final()
{
    return command_name == SRS_BW_CHECK_FINAL;
}

SrsBandwidthPacket* SrsBandwidthPacket::create_start_play()
{
    SrsBandwidthPacket* pkt = new SrsBandwidthPacket();
    return pkt->set_command(SRS_BW_CHECK_START_PLAY);
}

SrsBandwidthPacket* SrsBandwidthPacket::create_starting_play()
{
    SrsBandwidthPacket* pkt = new SrsBandwidthPacket();
    return pkt->set_command(SRS_BW_CHECK_STARTING_PLAY);
}

SrsBandwidthPacket* SrsBandwidthPacket::create_playing()
{
    SrsBandwidthPacket* pkt = new SrsBandwidthPacket();
    return pkt->set_command(SRS_BW_CHECK_PLAYING);
}

SrsBandwidthPacket* SrsBandwidthPacket::create_stop_play()
{
    SrsBandwidthPacket* pkt = new SrsBandwidthPacket();
    return pkt->set_command(SRS_BW_CHECK_STOP_PLAY);
}

SrsBandwidthPacket* SrsBandwidthPacket::create_stopped_play()
{
    SrsBandwidthPacket* pkt = new SrsBandwidthPacket();
    return pkt->set_command(SRS_BW_CHECK_STOPPED_PLAY);
}

SrsBandwidthPacket* SrsBandwidthPacket::create_start_publish()
{
    SrsBandwidthPacket* pkt = new SrsBandwidthPacket();
    return pkt->set_command(SRS_BW_CHECK_START_PUBLISH);
}

SrsBandwidthPacket* SrsBandwidthPacket::create_starting_publish()
{
    SrsBandwidthPacket* pkt = new SrsBandwidthPacket();
    return pkt->set_command(SRS_BW_CHECK_STARTING_PUBLISH);
}

SrsBandwidthPacket* SrsBandwidthPacket::create_publishing()
{
    SrsBandwidthPacket* pkt = new SrsBandwidthPacket();
    return pkt->set_command(SRS_BW_CHECK_PUBLISHING);
}

SrsBandwidthPacket* SrsBandwidthPacket::create_stop_publish()
{
    SrsBandwidthPacket* pkt = new SrsBandwidthPacket();
    return pkt->set_command(SRS_BW_CHECK_STOP_PUBLISH);
}

SrsBandwidthPacket* SrsBandwidthPacket::create_stopped_publish()
{
    SrsBandwidthPacket* pkt = new SrsBandwidthPacket();
    return pkt->set_command(SRS_BW_CHECK_STOPPED_PUBLISH);
}

SrsBandwidthPacket* SrsBandwidthPacket::create_finish()
{
    SrsBandwidthPacket* pkt = new SrsBandwidthPacket();
    return pkt->set_command(SRS_BW_CHECK_FINISHED);
}

SrsBandwidthPacket* SrsBandwidthPacket::create_final()
{
    SrsBandwidthPacket* pkt = new SrsBandwidthPacket();
    return pkt->set_command(SRS_BW_CHECK_FINAL);
}

SrsBandwidthPacket* SrsBandwidthPacket::set_command(string command)
{
    command_name = command;
    
    return this;
}

SrsOnStatusDataPacket::SrsOnStatusDataPacket()
{
    command_name = RTMP_AMF0_COMMAND_ON_STATUS;
    data = SrsAmf0Any::object();
}

SrsOnStatusDataPacket::~SrsOnStatusDataPacket()
{
    srs_freep(data);
}

int SrsOnStatusDataPacket::get_prefer_cid()
{
    return RTMP_CID_OverStream;
}

int SrsOnStatusDataPacket::get_message_type()
{
    return RTMP_MSG_AMF0DataMessage;
}

int SrsOnStatusDataPacket::get_size()
{
    return SrsAmf0Size::str(command_name) + SrsAmf0Size::object(data);
}

srs_error_t SrsOnStatusDataPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = data->write(stream)) != srs_success) {
        return srs_error_wrap(err, "data");
    }
    
    return err;
}

SrsSampleAccessPacket::SrsSampleAccessPacket()
{
    command_name = RTMP_AMF0_DATA_SAMPLE_ACCESS;
    video_sample_access = false;
    audio_sample_access = false;
}

SrsSampleAccessPacket::~SrsSampleAccessPacket()
{
}

int SrsSampleAccessPacket::get_prefer_cid()
{
    return RTMP_CID_OverStream;
}

int SrsSampleAccessPacket::get_message_type()
{
    return RTMP_MSG_AMF0DataMessage;
}

int SrsSampleAccessPacket::get_size()
{
    return SrsAmf0Size::str(command_name)
    + SrsAmf0Size::boolean() + SrsAmf0Size::boolean();
}

srs_error_t SrsSampleAccessPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, command_name)) != srs_success) {
        return srs_error_wrap(err, "command_name");
    }
    
    if ((err = srs_amf0_write_boolean(stream, video_sample_access)) != srs_success) {
        return srs_error_wrap(err, "video sample access");
    }
    
    if ((err = srs_amf0_write_boolean(stream, audio_sample_access)) != srs_success) {
        return srs_error_wrap(err, "audio sample access");
    }
    
    return err;
}

SrsOnMetaDataPacket::SrsOnMetaDataPacket()
{
    name = SRS_CONSTS_RTMP_ON_METADATA;
    metadata = SrsAmf0Any::object();
}

SrsOnMetaDataPacket::~SrsOnMetaDataPacket()
{
    srs_freep(metadata);
}

srs_error_t SrsOnMetaDataPacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_read_string(stream, name)) != srs_success) {
        return srs_error_wrap(err, "name");
    }
    
    // ignore the @setDataFrame
    if (name == SRS_CONSTS_RTMP_SET_DATAFRAME) {
        if ((err = srs_amf0_read_string(stream, name)) != srs_success) {
            return srs_error_wrap(err, "name");
        }
    }
    
    // the metadata maybe object or ecma array
    SrsAmf0Any* any = NULL;
    if ((err = srs_amf0_read_any(stream, &any)) != srs_success) {
        return srs_error_wrap(err, "metadata");
    }
    
    srs_assert(any);
    if (any->is_object()) {
        srs_freep(metadata);
        metadata = any->to_object();
        return err;
    }
    
    SrsAutoFree(SrsAmf0Any, any);
    
    if (any->is_ecma_array()) {
        SrsAmf0EcmaArray* arr = any->to_ecma_array();
        
        // if ecma array, copy to object.
        for (int i = 0; i < arr->count(); i++) {
            metadata->set(arr->key_at(i), arr->value_at(i)->copy());
        }
    }
    
    return err;
}

int SrsOnMetaDataPacket::get_prefer_cid()
{
    return RTMP_CID_OverConnection2;
}

int SrsOnMetaDataPacket::get_message_type()
{
    return RTMP_MSG_AMF0DataMessage;
}

int SrsOnMetaDataPacket::get_size()
{
    return SrsAmf0Size::str(name) + SrsAmf0Size::object(metadata);
}

srs_error_t SrsOnMetaDataPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if ((err = srs_amf0_write_string(stream, name)) != srs_success) {
        return srs_error_wrap(err, "name");
    }
    
    if ((err = metadata->write(stream)) != srs_success) {
        return srs_error_wrap(err, "metadata");
    }
    
    return err;
}

SrsSetWindowAckSizePacket::SrsSetWindowAckSizePacket()
{
    ackowledgement_window_size = 0;
}

SrsSetWindowAckSizePacket::~SrsSetWindowAckSizePacket()
{
}

srs_error_t SrsSetWindowAckSizePacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if (!stream->require(4)) {
        return srs_error_new(ERROR_RTMP_MESSAGE_DECODE, "requires 4 only %d bytes", stream->left());
    }
    
    ackowledgement_window_size = stream->read_4bytes();
    
    return err;
}

int SrsSetWindowAckSizePacket::get_prefer_cid()
{
    return RTMP_CID_ProtocolControl;
}

int SrsSetWindowAckSizePacket::get_message_type()
{
    return RTMP_MSG_WindowAcknowledgementSize;
}

int SrsSetWindowAckSizePacket::get_size()
{
    return 4;
}

srs_error_t SrsSetWindowAckSizePacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if (!stream->require(4)) {
        return srs_error_new(ERROR_RTMP_MESSAGE_ENCODE, "requires 4 only %d bytes", stream->left());
    }
    
    stream->write_4bytes(ackowledgement_window_size);
    
    return err;
}

SrsAcknowledgementPacket::SrsAcknowledgementPacket()
{
    sequence_number = 0;
}

SrsAcknowledgementPacket::~SrsAcknowledgementPacket()
{
}

srs_error_t SrsAcknowledgementPacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if (!stream->require(4)) {
        return srs_error_new(ERROR_RTMP_MESSAGE_DECODE, "requires 4 only %d bytes", stream->left());
    }
    
    sequence_number = (uint32_t)stream->read_4bytes();
    
    return err;
}

int SrsAcknowledgementPacket::get_prefer_cid()
{
    return RTMP_CID_ProtocolControl;
}

int SrsAcknowledgementPacket::get_message_type()
{
    return RTMP_MSG_Acknowledgement;
}

int SrsAcknowledgementPacket::get_size()
{
    return 4;
}

srs_error_t SrsAcknowledgementPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if (!stream->require(4)) {
        return srs_error_new(ERROR_RTMP_MESSAGE_ENCODE, "requires 4 only %d bytes", stream->left());
    }
    
    stream->write_4bytes(sequence_number);
    
    return err;
}

SrsSetChunkSizePacket::SrsSetChunkSizePacket()
{
    chunk_size = SRS_CONSTS_RTMP_PROTOCOL_CHUNK_SIZE;
}

SrsSetChunkSizePacket::~SrsSetChunkSizePacket()
{
}

srs_error_t SrsSetChunkSizePacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if (!stream->require(4)) {
        return srs_error_new(ERROR_RTMP_MESSAGE_DECODE, "requires 4 only %d bytes", stream->left());
    }
    
    chunk_size = stream->read_4bytes();
    
    return err;
}

int SrsSetChunkSizePacket::get_prefer_cid()
{
    return RTMP_CID_ProtocolControl;
}

int SrsSetChunkSizePacket::get_message_type()
{
    return RTMP_MSG_SetChunkSize;
}

int SrsSetChunkSizePacket::get_size()
{
    return 4;
}

srs_error_t SrsSetChunkSizePacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if (!stream->require(4)) {
        return srs_error_new(ERROR_RTMP_MESSAGE_ENCODE, "requires 4 only %d bytes", stream->left());
    }
    
    stream->write_4bytes(chunk_size);
    
    return err;
}

SrsSetPeerBandwidthPacket::SrsSetPeerBandwidthPacket()
{
    bandwidth = 0;
    type = SrsPeerBandwidthDynamic;
}

SrsSetPeerBandwidthPacket::~SrsSetPeerBandwidthPacket()
{
}

int SrsSetPeerBandwidthPacket::get_prefer_cid()
{
    return RTMP_CID_ProtocolControl;
}

int SrsSetPeerBandwidthPacket::get_message_type()
{
    return RTMP_MSG_SetPeerBandwidth;
}

int SrsSetPeerBandwidthPacket::get_size()
{
    return 5;
}

srs_error_t SrsSetPeerBandwidthPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if (!stream->require(5)) {
        return srs_error_new(ERROR_RTMP_MESSAGE_ENCODE, "requires 5 only %d bytes", stream->left());
    }
    
    stream->write_4bytes(bandwidth);
    stream->write_1bytes(type);
    
    return err;
}

SrsUserControlPacket::SrsUserControlPacket()
{
    event_type = 0;
    event_data = 0;
    extra_data = 0;
}

SrsUserControlPacket::~SrsUserControlPacket()
{
}

srs_error_t SrsUserControlPacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if (!stream->require(2)) {
        return srs_error_new(ERROR_RTMP_MESSAGE_DECODE, "requires 2 only %d bytes", stream->left());
    }
    
    event_type = stream->read_2bytes();
    
    if (event_type == SrsPCUCFmsEvent0) {
        if (!stream->require(1)) {
            return srs_error_new(ERROR_RTMP_MESSAGE_DECODE, "requires 1 only %d bytes", stream->left());
        }
        event_data = stream->read_1bytes();
    } else {
        if (!stream->require(4)) {
            return srs_error_new(ERROR_RTMP_MESSAGE_DECODE, "requires 4 only %d bytes", stream->left());
        }
        event_data = stream->read_4bytes();
    }
    
    if (event_type == SrcPCUCSetBufferLength) {
        if (!stream->require(4)) {
            return srs_error_new(ERROR_RTMP_MESSAGE_ENCODE, "requires 4 only %d bytes", stream->left());
        }
        extra_data = stream->read_4bytes();
    }
    
    return err;
}

int SrsUserControlPacket::get_prefer_cid()
{
    return RTMP_CID_ProtocolControl;
}

int SrsUserControlPacket::get_message_type()
{
    return RTMP_MSG_UserControlMessage;
}

int SrsUserControlPacket::get_size()
{
    int size = 2;
    
    if (event_type == SrsPCUCFmsEvent0) {
        size += 1;
    } else {
        size += 4;
    }
    
    if (event_type == SrcPCUCSetBufferLength) {
        size += 4;
    }
    
    return size;
}

srs_error_t SrsUserControlPacket::encode_packet(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    if (!stream->require(get_size())) {
        return srs_error_new(ERROR_RTMP_MESSAGE_ENCODE, "requires %d only %d bytes", get_size(), stream->left());
    }
    
    stream->write_2bytes(event_type);
    
    if (event_type == SrsPCUCFmsEvent0) {
        stream->write_1bytes(event_data);
    } else {
        stream->write_4bytes(event_data);
    }
    
    // when event type is set buffer length,
    // write the extra buffer length.
    if (event_type == SrcPCUCSetBufferLength) {
        stream->write_4bytes(extra_data);
    }
    
    return err;
}


// following is generated by src/protocol/srs_rtmp_handshake.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_rtmp_handshake.hpp>

#include <time.h>

//#include <srs_core_autofree.hpp>
//#include <srs_kernel_error.hpp>
//#include <srs_kernel_log.hpp>
//#include <srs_protocol_io.hpp>
//#include <srs_protocol_utility.hpp>
//#include <srs_rtmp_stack.hpp>
//#include <srs_kernel_buffer.hpp>
//#include <srs_kernel_utility.hpp>

#ifdef SRS_AUTO_SSL

using namespace _srs_internal;

// for openssl_HMACsha256
#include <openssl/evp.h>
#include <openssl/hmac.h>
// for openssl_generate_key
#include <openssl/dh.h>

#if OPENSSL_VERSION_NUMBER < 0x10100000L

static HMAC_CTX *HMAC_CTX_new(void)
{
    HMAC_CTX *ctx = (HMAC_CTX *)malloc(sizeof(*ctx));
    if (ctx != NULL) {
        HMAC_CTX_init(ctx);
    }
    return ctx;
}

static void HMAC_CTX_free(HMAC_CTX *ctx)
{
    if (ctx != NULL) {
        HMAC_CTX_cleanup(ctx);
        free(ctx);
    }
}

static void DH_get0_key(const DH *dh, const BIGNUM **pub_key, const BIGNUM **priv_key)
{
    if (pub_key != NULL) {
        *pub_key = dh->pub_key;
    }
    if (priv_key != NULL) {
        *priv_key = dh->priv_key;
    }
}

static int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g)
{
    /* If the fields p and g in d are NULL, the corresponding input
     * parameters MUST be non-NULL.  q may remain NULL.
     */
    if ((dh->p == NULL && p == NULL)
        || (dh->g == NULL && g == NULL))
        return 0;
    
    if (p != NULL) {
        BN_free(dh->p);
        dh->p = p;
    }
    if (q != NULL) {
        BN_free(dh->q);
        dh->q = q;
    }
    if (g != NULL) {
        BN_free(dh->g);
        dh->g = g;
    }
    
    if (q != NULL) {
        dh->length = BN_num_bits(q);
    }
    
    return 1;
}

static int DH_set_length(DH *dh, long length)
{
    dh->length = length;
    return 1;
}

#endif

namespace _srs_internal
{
    // 68bytes FMS key which is used to sign the sever packet.
    uint8_t SrsGenuineFMSKey[] = {
        0x47, 0x65, 0x6e, 0x75, 0x69, 0x6e, 0x65, 0x20,
        0x41, 0x64, 0x6f, 0x62, 0x65, 0x20, 0x46, 0x6c,
        0x61, 0x73, 0x68, 0x20, 0x4d, 0x65, 0x64, 0x69,
        0x61, 0x20, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72,
        0x20, 0x30, 0x30, 0x31, // Genuine Adobe Flash Media Server 001
        0xf0, 0xee, 0xc2, 0x4a, 0x80, 0x68, 0xbe, 0xe8,
        0x2e, 0x00, 0xd0, 0xd1, 0x02, 0x9e, 0x7e, 0x57,
        0x6e, 0xec, 0x5d, 0x2d, 0x29, 0x80, 0x6f, 0xab,
        0x93, 0xb8, 0xe6, 0x36, 0xcf, 0xeb, 0x31, 0xae
    }; // 68
    
    // 62bytes FP key which is used to sign the client packet.
    uint8_t SrsGenuineFPKey[] = {
        0x47, 0x65, 0x6E, 0x75, 0x69, 0x6E, 0x65, 0x20,
        0x41, 0x64, 0x6F, 0x62, 0x65, 0x20, 0x46, 0x6C,
        0x61, 0x73, 0x68, 0x20, 0x50, 0x6C, 0x61, 0x79,
        0x65, 0x72, 0x20, 0x30, 0x30, 0x31, // Genuine Adobe Flash Player 001
        0xF0, 0xEE, 0xC2, 0x4A, 0x80, 0x68, 0xBE, 0xE8,
        0x2E, 0x00, 0xD0, 0xD1, 0x02, 0x9E, 0x7E, 0x57,
        0x6E, 0xEC, 0x5D, 0x2D, 0x29, 0x80, 0x6F, 0xAB,
        0x93, 0xB8, 0xE6, 0x36, 0xCF, 0xEB, 0x31, 0xAE
    }; // 62
    
    srs_error_t do_openssl_HMACsha256(HMAC_CTX* ctx, const void* data, int data_size, void* digest, unsigned int* digest_size)
    {
        srs_error_t err = srs_success;
        
        if (HMAC_Update(ctx, (unsigned char *) data, data_size) < 0) {
            return srs_error_new(ERROR_OpenSslSha256Update, "hmac update");
        }
        
        if (HMAC_Final(ctx, (unsigned char *) digest, digest_size) < 0) {
            return srs_error_new(ERROR_OpenSslSha256Final, "hmac final");
        }
        
        return err;
    }
    /**
     * sha256 digest algorithm.
     * @param key the sha256 key, NULL to use EVP_Digest, for instance,
     *       hashlib.sha256(data).digest().
     */
    srs_error_t openssl_HMACsha256(const void* key, int key_size, const void* data, int data_size, void* digest)
    {
        srs_error_t err = srs_success;
        
        unsigned int digest_size = 0;
        
        unsigned char* temp_key = (unsigned char*)key;
        unsigned char* temp_digest = (unsigned char*)digest;
        
        if (key == NULL) {
            // use data to digest.
            // @see ./crypto/sha/sha256t.c
            // @see ./crypto/evp/digest.c
            if (EVP_Digest(data, data_size, temp_digest, &digest_size, EVP_sha256(), NULL) < 0) {
                return srs_error_new(ERROR_OpenSslSha256EvpDigest, "evp digest");
            }
        } else {
            // use key-data to digest.
            HMAC_CTX *ctx = HMAC_CTX_new();
            if (ctx == NULL) {
                return srs_error_new(ERROR_OpenSslCreateHMAC, "hmac new");
            }
            // @remark, if no key, use EVP_Digest to digest,
            // for instance, in python, hashlib.sha256(data).digest().
            if (HMAC_Init_ex(ctx, temp_key, key_size, EVP_sha256(), NULL) < 0) {
                HMAC_CTX_free(ctx);
                return srs_error_new(ERROR_OpenSslSha256Init, "hmac init");
            }
            
            err = do_openssl_HMACsha256(ctx, data, data_size, temp_digest, &digest_size);
            HMAC_CTX_free(ctx);
            
            if (err != srs_success) {
                return srs_error_wrap(err, "hmac sha256");
            }
        }
        
        if (digest_size != 32) {
            return srs_error_new(ERROR_OpenSslSha256DigestSize, "digest size %d", digest_size);
        }
        
        return err;
    }
    
#define RFC2409_PRIME_1024 \
"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1" \
"29024E088A67CC74020BBEA63B139B22514A08798E3404DD" \
"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245" \
"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED" \
"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE65381" \
"FFFFFFFFFFFFFFFF"
    
    SrsDH::SrsDH()
    {
        pdh = NULL;
    }
    
    SrsDH::~SrsDH()
    {
        close();
    }
    
    void SrsDH::close()
    {
        if (pdh != NULL) {
            DH_free(pdh);
            pdh = NULL;
        }
    }
    
    srs_error_t SrsDH::initialize(bool ensure_128bytes_public_key)
    {
        srs_error_t err = srs_success;
        
        for (;;) {
            if ((err = do_initialize()) != srs_success) {
                return srs_error_wrap(err, "init");
            }
            
            if (ensure_128bytes_public_key) {
                const BIGNUM *pub_key = NULL;
                DH_get0_key(pdh, &pub_key, NULL);
                int32_t key_size = BN_num_bytes(pub_key);
                if (key_size != 128) {
                    srs_warn("regenerate 128B key, current=%dB", key_size);
                    continue;
                }
            }
            
            break;
        }
        
        return err;
    }
    
    srs_error_t SrsDH::copy_public_key(char* pkey, int32_t& pkey_size)
    {
        srs_error_t err = srs_success;
        
        // copy public key to bytes.
        // sometimes, the key_size is 127, seems ok.
        const BIGNUM *pub_key = NULL;
        DH_get0_key(pdh, &pub_key, NULL);
        int32_t key_size = BN_num_bytes(pub_key);
        srs_assert(key_size > 0);
        
        // maybe the key_size is 127, but dh will write all 128bytes pkey,
        // so, donot need to set/initialize the pkey.
        // @see https://github.com/ossrs/srs/issues/165
        key_size = BN_bn2bin(pub_key, (unsigned char*)pkey);
        srs_assert(key_size > 0);
        
        // output the size of public key.
        // @see https://github.com/ossrs/srs/issues/165
        srs_assert(key_size <= pkey_size);
        pkey_size = key_size;
        
        return err;
    }
    
    srs_error_t SrsDH::copy_shared_key(const char* ppkey, int32_t ppkey_size, char* skey, int32_t& skey_size)
    {
        srs_error_t err = srs_success;
        
        BIGNUM* ppk = NULL;
        if ((ppk = BN_bin2bn((const unsigned char*)ppkey, ppkey_size, 0)) == NULL) {
            return srs_error_new(ERROR_OpenSslGetPeerPublicKey, "bin2bn");
        }
        
        // if failed, donot return, do cleanup, @see ./test/dhtest.c:168
        // maybe the key_size is 127, but dh will write all 128bytes skey,
        // so, donot need to set/initialize the skey.
        // @see https://github.com/ossrs/srs/issues/165
        int32_t key_size = DH_compute_key((unsigned char*)skey, ppk, pdh);
        
        if (key_size < ppkey_size) {
            srs_warn("shared key size=%d, ppk_size=%d", key_size, ppkey_size);
        }
        
        if (key_size < 0 || key_size > skey_size) {
            err = srs_error_new(ERROR_OpenSslComputeSharedKey, "key size %d", key_size);
        } else {
            skey_size = key_size;
        }
        
        if (ppk) {
            BN_free(ppk);
        }
        
        return err;
    }
    
    srs_error_t SrsDH::do_initialize()
    {
        srs_error_t err = srs_success;
        
        int32_t bits_count = 1024;
        
        close();
        
        //1. Create the DH
        if ((pdh = DH_new()) == NULL) {
            return srs_error_new(ERROR_OpenSslCreateDH, "dh new");
        }
        
        //2. Create his internal p and g
        BIGNUM *p, *g;
        if ((p = BN_new()) == NULL) {
            return srs_error_new(ERROR_OpenSslCreateP, "dh new");
        }
        if ((g = BN_new()) == NULL) {
            BN_free(p);
            return srs_error_new(ERROR_OpenSslCreateG, "bn new");
        }
        DH_set0_pqg(pdh, p, NULL, g);
        
        //3. initialize p and g, @see ./test/ectest.c:260
        if (!BN_hex2bn(&p, RFC2409_PRIME_1024)) {
            return srs_error_new(ERROR_OpenSslParseP1024, "hex2bn");
        }
        // @see ./test/bntest.c:1764
        if (!BN_set_word(g, 2)) {
            return srs_error_new(ERROR_OpenSslSetG, "set word");
        }
        
        // 4. Set the key length
        DH_set_length(pdh, bits_count);
        
        // 5. Generate private and public key
        // @see ./test/dhtest.c:152
        if (!DH_generate_key(pdh)) {
            return srs_error_new(ERROR_OpenSslGenerateDHKeys, "dh generate key");
        }
        
        return err;
    }
    
    key_block::key_block()
    {
        offset = (int32_t)rand();
        random0 = NULL;
        random1 = NULL;
        
        int valid_offset = calc_valid_offset();
        srs_assert(valid_offset >= 0);
        
        random0_size = valid_offset;
        if (random0_size > 0) {
            random0 = new char[random0_size];
            srs_random_generate(random0, random0_size);
            snprintf(random0, random0_size, "%s", RTMP_SIG_SRS_HANDSHAKE);
        }
        
        srs_random_generate(key, sizeof(key));
        
        random1_size = 764 - valid_offset - 128 - 4;
        if (random1_size > 0) {
            random1 = new char[random1_size];
            srs_random_generate(random1, random1_size);
            snprintf(random1, random1_size, "%s", RTMP_SIG_SRS_HANDSHAKE);
        }
    }
    
    key_block::~key_block()
    {
        srs_freepa(random0);
        srs_freepa(random1);
    }
    
    srs_error_t key_block::parse(SrsBuffer* stream)
    {
        srs_error_t err = srs_success;
        
        // the key must be 764 bytes.
        srs_assert(stream->require(764));
        
        // read the last offset first, 760-763
        stream->skip(764 - sizeof(int32_t));
        offset = stream->read_4bytes();
        
        // reset stream to read others.
        stream->skip(-764);
        
        int valid_offset = calc_valid_offset();
        srs_assert(valid_offset >= 0);
        
        random0_size = valid_offset;
        if (random0_size > 0) {
            srs_freepa(random0);
            random0 = new char[random0_size];
            stream->read_bytes(random0, random0_size);
        }
        
        stream->read_bytes(key, 128);
        
        random1_size = 764 - valid_offset - 128 - 4;
        if (random1_size > 0) {
            srs_freepa(random1);
            random1 = new char[random1_size];
            stream->read_bytes(random1, random1_size);
        }
        
        return err;
    }
    
    int key_block::calc_valid_offset()
    {
        int max_offset_size = 764 - 128 - 4;
        
        int valid_offset = 0;
        uint8_t* pp = (uint8_t*)&offset;
        valid_offset += *pp++;
        valid_offset += *pp++;
        valid_offset += *pp++;
        valid_offset += *pp++;
        
        return valid_offset % max_offset_size;
    }
    
    digest_block::digest_block()
    {
        offset = (int32_t)rand();
        random0 = NULL;
        random1 = NULL;
        
        int valid_offset = calc_valid_offset();
        srs_assert(valid_offset >= 0);
        
        random0_size = valid_offset;
        if (random0_size > 0) {
            random0 = new char[random0_size];
            srs_random_generate(random0, random0_size);
            snprintf(random0, random0_size, "%s", RTMP_SIG_SRS_HANDSHAKE);
        }
        
        srs_random_generate(digest, sizeof(digest));
        
        random1_size = 764 - 4 - valid_offset - 32;
        if (random1_size > 0) {
            random1 = new char[random1_size];
            srs_random_generate(random1, random1_size);
            snprintf(random1, random1_size, "%s", RTMP_SIG_SRS_HANDSHAKE);
        }
    }
    
    digest_block::~digest_block()
    {
        srs_freepa(random0);
        srs_freepa(random1);
    }
    
    srs_error_t digest_block::parse(SrsBuffer* stream)
    {
        srs_error_t err = srs_success;
        
        // the digest must be 764 bytes.
        srs_assert(stream->require(764));
        
        offset = stream->read_4bytes();
        
        int valid_offset = calc_valid_offset();
        srs_assert(valid_offset >= 0);
        
        random0_size = valid_offset;
        if (random0_size > 0) {
            srs_freepa(random0);
            random0 = new char[random0_size];
            stream->read_bytes(random0, random0_size);
        }
        
        stream->read_bytes(digest, 32);
        
        random1_size = 764 - 4 - valid_offset - 32;
        if (random1_size > 0) {
            srs_freepa(random1);
            random1 = new char[random1_size];
            stream->read_bytes(random1, random1_size);
        }
        
        return err;
    }
    
    int digest_block::calc_valid_offset()
    {
        int max_offset_size = 764 - 32 - 4;
        
        int valid_offset = 0;
        uint8_t* pp = (uint8_t*)&offset;
        valid_offset += *pp++;
        valid_offset += *pp++;
        valid_offset += *pp++;
        valid_offset += *pp++;
        
        return valid_offset % max_offset_size;
    }
    
    c1s1_strategy::c1s1_strategy()
    {
    }
    
    c1s1_strategy::~c1s1_strategy()
    {
    }
    
    char* c1s1_strategy::get_digest()
    {
        return digest.digest;
    }
    
    char* c1s1_strategy::get_key()
    {
        return key.key;
    }
    
    srs_error_t c1s1_strategy::dump(c1s1* owner, char* _c1s1, int size)
    {
        srs_assert(size == 1536);
        return copy_to(owner, _c1s1, size, true);
    }
    
    srs_error_t c1s1_strategy::c1_create(c1s1* owner)
    {
        srs_error_t err = srs_success;
        
        // generate digest
        char* c1_digest = NULL;
        
        if ((err = calc_c1_digest(owner, c1_digest)) != srs_success) {
            return srs_error_wrap(err, "sign c1");
        }
        
        srs_assert(c1_digest != NULL);
        SrsAutoFreeA(char, c1_digest);
        
        memcpy(digest.digest, c1_digest, 32);
        
        return err;
    }
    
    srs_error_t c1s1_strategy::c1_validate_digest(c1s1* owner, bool& is_valid)
    {
        srs_error_t err = srs_success;
        
        char* c1_digest = NULL;
        
        if ((err = calc_c1_digest(owner, c1_digest)) != srs_success) {
            return srs_error_wrap(err, "validate c1");
        }
        
        srs_assert(c1_digest != NULL);
        SrsAutoFreeA(char, c1_digest);
        
        is_valid = srs_bytes_equals(digest.digest, c1_digest, 32);
        
        return err;
    }
    
    srs_error_t c1s1_strategy::s1_create(c1s1* owner, c1s1* c1)
    {
        srs_error_t err = srs_success;
        
        SrsDH dh;
        
        // ensure generate 128bytes public key.
        if ((err = dh.initialize(true)) != srs_success) {
            return srs_error_wrap(err, "dh init");
        }
        
        // directly generate the public key.
        // @see: https://github.com/ossrs/srs/issues/148
        int pkey_size = 128;
        if ((err = dh.copy_shared_key(c1->get_key(), 128, key.key, pkey_size)) != srs_success) {
            return srs_error_wrap(err, "copy shared key");
        }
        
        // although the public key is always 128bytes, but the share key maybe not.
        // we just ignore the actual key size, but if need to use the key, must use the actual size.
        // TODO: FIXME: use the actual key size.
        //srs_assert(pkey_size == 128);
        
        char* s1_digest = NULL;
        if ((err = calc_s1_digest(owner, s1_digest))  != srs_success) {
            return srs_error_wrap(err, "calc s1 digest");
        }
        
        srs_assert(s1_digest != NULL);
        SrsAutoFreeA(char, s1_digest);
        
        memcpy(digest.digest, s1_digest, 32);
        
        return err;
    }
    
    srs_error_t c1s1_strategy::s1_validate_digest(c1s1* owner, bool& is_valid)
    {
        srs_error_t err = srs_success;
        
        char* s1_digest = NULL;
        
        if ((err = calc_s1_digest(owner, s1_digest)) != srs_success) {
            return srs_error_wrap(err, "validate s1");
        }
        
        srs_assert(s1_digest != NULL);
        SrsAutoFreeA(char, s1_digest);
        
        is_valid = srs_bytes_equals(digest.digest, s1_digest, 32);
        
        return err;
    }
    
    srs_error_t c1s1_strategy::calc_c1_digest(c1s1* owner, char*& c1_digest)
    {
        srs_error_t err = srs_success;
        
        /**
         * c1s1 is splited by digest:
         *     c1s1-part1: n bytes (time, version, key and digest-part1).
         *     digest-data: 32bytes
         *     c1s1-part2: (1536-n-32)bytes (digest-part2)
         * @return a new allocated bytes, user must free it.
         */
        char* c1s1_joined_bytes = new char[1536 -32];
        SrsAutoFreeA(char, c1s1_joined_bytes);
        if ((err = copy_to(owner, c1s1_joined_bytes, 1536 - 32, false)) != srs_success) {
            return srs_error_wrap(err, "copy bytes");
        }
        
        c1_digest = new char[SRS_OpensslHashSize];
        if ((err = openssl_HMACsha256(SrsGenuineFPKey, 30, c1s1_joined_bytes, 1536 - 32, c1_digest)) != srs_success) {
            srs_freepa(c1_digest);
            return srs_error_wrap(err, "calc c1 digest");
        }
        
        return err;
    }
    
    srs_error_t c1s1_strategy::calc_s1_digest(c1s1* owner, char*& s1_digest)
    {
        srs_error_t err = srs_success;
        
        /**
         * c1s1 is splited by digest:
         *     c1s1-part1: n bytes (time, version, key and digest-part1).
         *     digest-data: 32bytes
         *     c1s1-part2: (1536-n-32)bytes (digest-part2)
         * @return a new allocated bytes, user must free it.
         */
        char* c1s1_joined_bytes = new char[1536 -32];
        SrsAutoFreeA(char, c1s1_joined_bytes);
        if ((err = copy_to(owner, c1s1_joined_bytes, 1536 - 32, false)) != srs_success) {
            return srs_error_wrap(err, "copy bytes");
        }
        
        s1_digest = new char[SRS_OpensslHashSize];
        if ((err = openssl_HMACsha256(SrsGenuineFMSKey, 36, c1s1_joined_bytes, 1536 - 32, s1_digest)) != srs_success) {
            srs_freepa(s1_digest);
            return srs_error_wrap(err, "calc s1 digest");
        }
        
        return err;
    }
    
    void c1s1_strategy::copy_time_version(SrsBuffer* stream, c1s1* owner)
    {
        srs_assert(stream->require(8));
        
        // 4bytes time
        stream->write_4bytes(owner->time);
        
        // 4bytes version
        stream->write_4bytes(owner->version);
    }
    void c1s1_strategy::copy_key(SrsBuffer* stream)
    {
        srs_assert(key.random0_size >= 0);
        srs_assert(key.random1_size >= 0);
        
        int total = key.random0_size + 128 + key.random1_size + 4;
        srs_assert(stream->require(total));
        
        // 764bytes key block
        if (key.random0_size > 0) {
            stream->write_bytes(key.random0, key.random0_size);
        }
        
        stream->write_bytes(key.key, 128);
        
        if (key.random1_size > 0) {
            stream->write_bytes(key.random1, key.random1_size);
        }
        
        stream->write_4bytes(key.offset);
    }
    void c1s1_strategy::copy_digest(SrsBuffer* stream, bool with_digest)
    {
        srs_assert(key.random0_size >= 0);
        srs_assert(key.random1_size >= 0);
        
        int total = 4 + digest.random0_size + digest.random1_size;
        if (with_digest) {
            total += 32;
        }
        srs_assert(stream->require(total));
        
        // 732bytes digest block without the 32bytes digest-data
        // nbytes digest block part1
        stream->write_4bytes(digest.offset);
        
        // digest random padding.
        if (digest.random0_size > 0) {
            stream->write_bytes(digest.random0, digest.random0_size);
        }
        
        // digest
        if (with_digest) {
            stream->write_bytes(digest.digest, 32);
        }
        
        // nbytes digest block part2
        if (digest.random1_size > 0) {
            stream->write_bytes(digest.random1, digest.random1_size);
        }
    }
    
    c1s1_strategy_schema0::c1s1_strategy_schema0()
    {
    }
    
    c1s1_strategy_schema0::~c1s1_strategy_schema0()
    {
    }
    
    srs_schema_type c1s1_strategy_schema0::schema()
    {
        return srs_schema0;
    }
    
    srs_error_t c1s1_strategy_schema0::parse(char* _c1s1, int size)
    {
        srs_error_t err = srs_success;
        
        srs_assert(size == 1536);
        
        if (true) {
            SrsBuffer stream(_c1s1 + 8, 764);
            
            if ((err = key.parse(&stream)) != srs_success) {
                return srs_error_wrap(err, "parse the c1 key");
            }
        }
        
        if (true) {
            SrsBuffer stream(_c1s1 + 8 + 764, 764);
        
            if ((err = digest.parse(&stream)) != srs_success) {
                return srs_error_wrap(err, "parse the c1 digest");
            }
        }
        
        return err;
    }
    
    srs_error_t c1s1_strategy_schema0::copy_to(c1s1* owner, char* bytes, int size, bool with_digest)
    {
        srs_error_t err = srs_success;
        
        if (with_digest) {
            srs_assert(size == 1536);
        } else {
            srs_assert(size == 1504);
        }
        
        SrsBuffer stream(bytes, size);
        
        copy_time_version(&stream, owner);
        copy_key(&stream);
        copy_digest(&stream, with_digest);
        
        srs_assert(stream.empty());
        
        return err;
    }
    
    c1s1_strategy_schema1::c1s1_strategy_schema1()
    {
    }
    
    c1s1_strategy_schema1::~c1s1_strategy_schema1()
    {
    }
    
    srs_schema_type c1s1_strategy_schema1::schema()
    {
        return srs_schema1;
    }
    
    srs_error_t c1s1_strategy_schema1::parse(char* _c1s1, int size)
    {
        srs_error_t err = srs_success;
        
        srs_assert(size == 1536);
        
        if (true) {
            SrsBuffer stream(_c1s1 + 8, 764);
            
            if ((err = digest.parse(&stream)) != srs_success) {
                return srs_error_wrap(err, "parse c1 digest");
            }
        }
        
        if (true) {
            SrsBuffer stream(_c1s1 + 8 + 764, 764);
            
            if ((err = key.parse(&stream)) != srs_success) {
                return srs_error_wrap(err, "parse c1 key");
            }
        }
        
        return err;
    }
    
    srs_error_t c1s1_strategy_schema1::copy_to(c1s1* owner, char* bytes, int size, bool with_digest)
    {
        srs_error_t err = srs_success;
        
        if (with_digest) {
            srs_assert(size == 1536);
        } else {
            srs_assert(size == 1504);
        }
        
        SrsBuffer stream(bytes, size);
        
        copy_time_version(&stream, owner);
        copy_digest(&stream, with_digest);
        copy_key(&stream);
        
        srs_assert(stream.empty());
        
        return err;
    }
    
    c1s1::c1s1()
    {
        payload = NULL;
    }
    c1s1::~c1s1()
    {
        srs_freep(payload);
    }
    
    srs_schema_type c1s1::schema()
    {
        srs_assert(payload != NULL);
        return payload->schema();
    }
    
    char* c1s1::get_digest()
    {
        srs_assert(payload != NULL);
        return payload->get_digest();
    }
    
    char* c1s1::get_key()
    {
        srs_assert(payload != NULL);
        return payload->get_key();
    }
    
    srs_error_t c1s1::dump(char* _c1s1, int size)
    {
        srs_assert(size == 1536);
        srs_assert(payload != NULL);
        return payload->dump(this, _c1s1, size);
    }
    
    srs_error_t c1s1::parse(char* _c1s1, int size, srs_schema_type schema)
    {
        srs_assert(size == 1536);
        
        if (schema != srs_schema0 && schema != srs_schema1) {
            return srs_error_new(ERROR_RTMP_CH_SCHEMA, "parse c1 failed. invalid schema=%d", schema);
        }
        
        SrsBuffer stream(_c1s1, size);
        
        time = stream.read_4bytes();
        version = stream.read_4bytes(); // client c1 version
        
        srs_freep(payload);
        if (schema == srs_schema0) {
            payload = new c1s1_strategy_schema0();
        } else {
            payload = new c1s1_strategy_schema1();
        }
        
        return payload->parse(_c1s1, size);
    }
    
    srs_error_t c1s1::c1_create(srs_schema_type schema)
    {
        if (schema != srs_schema0 && schema != srs_schema1) {
            return srs_error_new(ERROR_RTMP_CH_SCHEMA, "create c1 failed. invalid schema=%d", schema);
        }
        
        // client c1 time and version
        time = (int32_t)::time(NULL);
        version = 0x80000702; // client c1 version
        
        // generate signature by schema
        srs_freep(payload);
        if (schema == srs_schema0) {
            payload = new c1s1_strategy_schema0();
        } else {
            payload = new c1s1_strategy_schema1();
        }
        
        return payload->c1_create(this);
    }
    
    srs_error_t c1s1::c1_validate_digest(bool& is_valid)
    {
        is_valid = false;
        srs_assert(payload);
        return payload->c1_validate_digest(this, is_valid);
    }
    
    srs_error_t c1s1::s1_create(c1s1* c1)
    {
        if (c1->schema() != srs_schema0 && c1->schema() != srs_schema1) {
            return srs_error_new(ERROR_RTMP_CH_SCHEMA, "create s1 failed. invalid schema=%d", c1->schema());
        }
        
        time = ::time(NULL);
        version = 0x01000504; // server s1 version
        
        srs_freep(payload);
        if (c1->schema() == srs_schema0) {
            payload = new c1s1_strategy_schema0();
        } else {
            payload = new c1s1_strategy_schema1();
        }
        
        return payload->s1_create(this, c1);
    }
    
    srs_error_t c1s1::s1_validate_digest(bool& is_valid)
    {
        is_valid = false;
        srs_assert(payload);
        return payload->s1_validate_digest(this, is_valid);
    }
    
    c2s2::c2s2()
    {
        srs_random_generate(random, 1504);
        
        int size = snprintf(random, 1504, "%s", RTMP_SIG_SRS_HANDSHAKE);
        srs_assert(++size < 1504);
        snprintf(random + 1504 - size, size, "%s", RTMP_SIG_SRS_HANDSHAKE);
        
        srs_random_generate(digest, 32);
    }
    
    c2s2::~c2s2()
    {
    }
    
    srs_error_t c2s2::dump(char* _c2s2, int size)
    {
        srs_assert(size == 1536);
        
        memcpy(_c2s2, random, 1504);
        memcpy(_c2s2 + 1504, digest, 32);
        
        return srs_success;
    }
    
    srs_error_t c2s2::parse(char* _c2s2, int size)
    {
        srs_assert(size == 1536);
        
        memcpy(random, _c2s2, 1504);
        memcpy(digest, _c2s2 + 1504, 32);
        
        return srs_success;
    }
    
    srs_error_t c2s2::c2_create(c1s1* s1)
    {
        srs_error_t err = srs_success;
        
        char temp_key[SRS_OpensslHashSize];
        if ((err = openssl_HMACsha256(SrsGenuineFPKey, 62, s1->get_digest(), 32, temp_key)) != srs_success) {
            return srs_error_wrap(err, "create c2 temp key");
        }
        
        char _digest[SRS_OpensslHashSize];
        if ((err = openssl_HMACsha256(temp_key, 32, random, 1504, _digest)) != srs_success) {
            return srs_error_wrap(err, "create c2 digest");
        }
        
        memcpy(digest, _digest, 32);
        
        return err;
    }
    
    srs_error_t c2s2::c2_validate(c1s1* s1, bool& is_valid)
    {
        is_valid = false;
        srs_error_t err = srs_success;
        
        char temp_key[SRS_OpensslHashSize];
        if ((err = openssl_HMACsha256(SrsGenuineFPKey, 62, s1->get_digest(), 32, temp_key)) != srs_success) {
            return srs_error_wrap(err, "create c2 temp key");
        }
        
        char _digest[SRS_OpensslHashSize];
        if ((err = openssl_HMACsha256(temp_key, 32, random, 1504, _digest)) != srs_success) {
            return srs_error_wrap(err, "create c2 digest");
        }
        
        is_valid = srs_bytes_equals(digest, _digest, 32);
        
        return err;
    }
    
    srs_error_t c2s2::s2_create(c1s1* c1)
    {
        srs_error_t err = srs_success;
        
        char temp_key[SRS_OpensslHashSize];
        if ((err = openssl_HMACsha256(SrsGenuineFMSKey, 68, c1->get_digest(), 32, temp_key)) != srs_success) {
            return srs_error_wrap(err, "create s2 temp key");
        }
        
        char _digest[SRS_OpensslHashSize];
        if ((err = openssl_HMACsha256(temp_key, 32, random, 1504, _digest)) != srs_success) {
            return srs_error_wrap(err, "create s2 digest");
        }
        
        memcpy(digest, _digest, 32);
        
        return err;
    }
    
    srs_error_t c2s2::s2_validate(c1s1* c1, bool& is_valid)
    {
        is_valid = false;
        srs_error_t err = srs_success;
        
        char temp_key[SRS_OpensslHashSize];
        if ((err = openssl_HMACsha256(SrsGenuineFMSKey, 68, c1->get_digest(), 32, temp_key)) != srs_success) {
            return srs_error_wrap(err, "create s2 temp key");
        }
        
        char _digest[SRS_OpensslHashSize];
        if ((err = openssl_HMACsha256(temp_key, 32, random, 1504, _digest)) != srs_success) {
            return srs_error_wrap(err, "create s2 digest");
        }
        
        is_valid = srs_bytes_equals(digest, _digest, 32);
        
        return err;
    }
}

#endif

SrsSimpleHandshake::SrsSimpleHandshake()
{
}

SrsSimpleHandshake::~SrsSimpleHandshake()
{
}

srs_error_t SrsSimpleHandshake::handshake_with_client(SrsHandshakeBytes* hs_bytes, ISrsProtocolReaderWriter* io)
{
    srs_error_t err = srs_success;
    
    ssize_t nsize;
    
    if ((err = hs_bytes->read_c0c1(io)) != srs_success) {
        return srs_error_wrap(err, "read c0c1");
    }
    
    // plain text required.
    if (hs_bytes->c0c1[0] != 0x03) {
        return srs_error_new(ERROR_RTMP_PLAIN_REQUIRED, "only support rtmp plain text, version=%X", (uint8_t)hs_bytes->c0c1[0]);
    }
    
    if ((err = hs_bytes->create_s0s1s2(hs_bytes->c0c1 + 1)) != srs_success) {
        return srs_error_wrap(err, "create s0s1s2");
    }
    
    if ((err = io->write(hs_bytes->s0s1s2, 3073, &nsize)) != srs_success) {
        return srs_error_wrap(err, "write s0s1s2");
    }
    
    if ((err = hs_bytes->read_c2(io)) != srs_success) {
        return srs_error_wrap(err, "read c2");
    }
    
    srs_trace("simple handshake success.");
    
    return err;
}

srs_error_t SrsSimpleHandshake::handshake_with_server(SrsHandshakeBytes* hs_bytes, ISrsProtocolReaderWriter* io)
{
    srs_error_t err = srs_success;
    
    ssize_t nsize;
    
    // simple handshake
    if ((err = hs_bytes->create_c0c1()) != srs_success) {
        return srs_error_wrap(err, "create c0c1");
    }
    
    if ((err = io->write(hs_bytes->c0c1, 1537, &nsize)) != srs_success) {
        return srs_error_wrap(err, "write c0c1");
    }
    
    if ((err = hs_bytes->read_s0s1s2(io)) != srs_success) {
        return srs_error_wrap(err, "read s0s1s2");
    }
    
    // plain text required.
    if (hs_bytes->s0s1s2[0] != 0x03) {
        return srs_error_new(ERROR_RTMP_HANDSHAKE, "handshake failed, plain text required, version=%X", (uint8_t)hs_bytes->s0s1s2[0]);
    }
    
    if ((err = hs_bytes->create_c2()) != srs_success) {
        return srs_error_wrap(err, "create c2");
    }
    
    // for simple handshake, copy s1 to c2.
    // @see https://github.com/ossrs/srs/issues/418
    memcpy(hs_bytes->c2, hs_bytes->s0s1s2 + 1, 1536);
    
    if ((err = io->write(hs_bytes->c2, 1536, &nsize)) != srs_success) {
        return srs_error_wrap(err, "write c2");
    }
    
    srs_trace("simple handshake success.");
    
    return err;
}

SrsComplexHandshake::SrsComplexHandshake()
{
}

SrsComplexHandshake::~SrsComplexHandshake()
{
}

#ifndef SRS_AUTO_SSL
srs_error_t SrsComplexHandshake::handshake_with_client(SrsHandshakeBytes* /*hs_bytes*/, ISrsProtocolReaderWriter* /*io*/)
{
    srs_trace("directly use simple handshake for ssl disabled.");
    return srs_error_new(ERROR_RTMP_TRY_SIMPLE_HS, "try simple handshake");
}
#else
srs_error_t SrsComplexHandshake::handshake_with_client(SrsHandshakeBytes* hs_bytes, ISrsProtocolReaderWriter* io)
{
    srs_error_t err = srs_success;
    
    ssize_t nsize;
    
    if ((err = hs_bytes->read_c0c1(io)) != srs_success) {
        return srs_error_wrap(err, "read c0c1");
    }
    
    // decode c1
    c1s1 c1;
    // try schema0.
    // @remark, use schema0 to make flash player happy.
    if ((err = c1.parse(hs_bytes->c0c1 + 1, 1536, srs_schema0)) != srs_success) {
        return srs_error_wrap(err, "parse c1, schema=%d", srs_schema0);
    }
    // try schema1
    bool is_valid = false;
    if ((err = c1.c1_validate_digest(is_valid)) != srs_success || !is_valid) {
        srs_freep(err);
        
        if ((err = c1.parse(hs_bytes->c0c1 + 1, 1536, srs_schema1)) != srs_success) {
            return srs_error_wrap(err, "parse c0c1, schame=%d", srs_schema1);
        }
        
        if ((err = c1.c1_validate_digest(is_valid)) != srs_success || !is_valid) {
            srs_freep(err);
            return srs_error_new(ERROR_RTMP_TRY_SIMPLE_HS, "all schema valid failed, try simple handshake");
        }
    }
    
    // encode s1
    c1s1 s1;
    if ((err = s1.s1_create(&c1)) != srs_success) {
        return srs_error_wrap(err, "create s1 from c1");
    }
    // verify s1
    if ((err = s1.s1_validate_digest(is_valid)) != srs_success || !is_valid) {
        srs_freep(err);
        return srs_error_new(ERROR_RTMP_TRY_SIMPLE_HS, "verify s1 failed, try simple handshake");
    }
    
    c2s2 s2;
    if ((err = s2.s2_create(&c1)) != srs_success) {
        return srs_error_wrap(err, "create s2 from c1");
    }
    // verify s2
    if ((err = s2.s2_validate(&c1, is_valid)) != srs_success || !is_valid) {
        return srs_error_new(ERROR_RTMP_TRY_SIMPLE_HS, "verify s2 failed, try simple handshake");
    }
    
    // sendout s0s1s2
    if ((err = hs_bytes->create_s0s1s2()) != srs_success) {
        return srs_error_wrap(err, "create s0s1s2");
    }
    if ((err = s1.dump(hs_bytes->s0s1s2 + 1, 1536)) != srs_success) {
        return srs_error_wrap(err, "dump s1");
    }
    if ((err = s2.dump(hs_bytes->s0s1s2 + 1537, 1536)) != srs_success) {
        return srs_error_wrap(err, "dump s2");
    }
    if ((err = io->write(hs_bytes->s0s1s2, 3073, &nsize)) != srs_success) {
        return srs_error_wrap(err, "write s0s1s2");
    }
    
    // recv c2
    if ((err = hs_bytes->read_c2(io)) != srs_success) {
        return srs_error_wrap(err, "read c2");
    }
    c2s2 c2;
    if ((err = c2.parse(hs_bytes->c2, 1536)) != srs_success) {
        return srs_error_wrap(err, "parse c2");
    }
    
    // verify c2
    // never verify c2, for ffmpeg will failed.
    // it's ok for flash.
    
    srs_trace("complex handshake success");
    
    return err;
}
#endif

#ifndef SRS_AUTO_SSL
srs_error_t SrsComplexHandshake::handshake_with_server(SrsHandshakeBytes* /*hs_bytes*/, ISrsProtocolReaderWriter* /*io*/)
{
    return srs_error_new(ERROR_RTMP_TRY_SIMPLE_HS, "try simple handshake");
}
#else
srs_error_t SrsComplexHandshake::handshake_with_server(SrsHandshakeBytes* hs_bytes, ISrsProtocolReaderWriter* io)
{
    srs_error_t err = srs_success;
    
    ssize_t nsize;
    
    // complex handshake
    if ((err = hs_bytes->create_c0c1()) != srs_success) {
        return srs_error_wrap(err, "create c0c1");
    }
    
    // sign c1
    c1s1 c1;
    // @remark, FMS requires the schema1(digest-key), or connect failed.
    if ((err = c1.c1_create(srs_schema1)) != srs_success) {
        return srs_error_wrap(err, "create c1");
    }
    if ((err = c1.dump(hs_bytes->c0c1 + 1, 1536)) != srs_success) {
        return srs_error_wrap(err, "dump c1");
    }
    
    // verify c1
    bool is_valid;
    if ((err = c1.c1_validate_digest(is_valid)) != srs_success || !is_valid) {
        srs_freep(err);
        return srs_error_new(ERROR_RTMP_TRY_SIMPLE_HS, "try simple handshake");
    }
    
    if ((err = io->write(hs_bytes->c0c1, 1537, &nsize)) != srs_success) {
        return srs_error_wrap(err, "write c0c1");
    }
    
    // s0s1s2
    if ((err = hs_bytes->read_s0s1s2(io)) != srs_success) {
        return srs_error_wrap(err, "read s0s1s2");
    }
    
    // plain text required.
    if (hs_bytes->s0s1s2[0] != 0x03) {
        return srs_error_new(ERROR_RTMP_HANDSHAKE,  "handshake failed, plain text required, version=%X", (uint8_t)hs_bytes->s0s1s2[0]);
    }
    
    // verify s1s2
    c1s1 s1;
    if ((err = s1.parse(hs_bytes->s0s1s2 + 1, 1536, c1.schema())) != srs_success) {
        return srs_error_wrap(err, "parse s1");
    }
    
    // never verify the s1,
    // for if forward to nginx-rtmp, verify s1 will failed,
    // TODO: FIXME: find the handshake schema of nginx-rtmp.
    
    // c2
    if ((err = hs_bytes->create_c2()) != srs_success) {
        return srs_error_wrap(err, "create c2");
    }
    
    c2s2 c2;
    if ((err = c2.c2_create(&s1)) != srs_success) {
        return srs_error_wrap(err, "create c2");
    }
    
    if ((err = c2.dump(hs_bytes->c2, 1536)) != srs_success) {
        return srs_error_wrap(err, "dump c2");
    }
    if ((err = io->write(hs_bytes->c2, 1536, &nsize)) != srs_success) {
        return srs_error_wrap(err, "write c2");
    }
    
    srs_trace("complex handshake success.");
    
    return err;
}
#endif


// following is generated by src/protocol/srs_protocol_utility.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_protocol_utility.hpp>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <unistd.h>
#endif

#include <stdlib.h>
#include <sstream>
using namespace std;

//#include <srs_kernel_log.hpp>
//#include <srs_kernel_utility.hpp>
//#include <srs_kernel_buffer.hpp>
//#include <srs_rtmp_stack.hpp>
//#include <srs_kernel_codec.hpp>
//#include <srs_kernel_consts.hpp>
//#include <srs_rtmp_stack.hpp>
//#include <srs_protocol_io.hpp>

/**
 * resolve the vhost in query string
 * @pram vhost, update the vhost if query contains the vhost.
 * @param app, may contains the vhost in query string format:
 *   app?vhost=request_vhost
 *   app...vhost...request_vhost
 * @param param, the query, for example, ?vhost=xxx
 */
void srs_vhost_resolve(string& vhost, string& app, string& param)
{
    // get original param
    size_t pos = 0;
    if ((pos = app.find("?")) != std::string::npos) {
        param = app.substr(pos);
    }
    
    // filter tcUrl
    app = srs_string_replace(app, ",", "?");
    app = srs_string_replace(app, "...", "?");
    app = srs_string_replace(app, "&&", "?");
    app = srs_string_replace(app, "=", "?");
    
    if ((pos = app.find("?")) != std::string::npos) {
        std::string query = app.substr(pos + 1);
        app = app.substr(0, pos);
        
        if ((pos = query.find("vhost?")) != std::string::npos) {
            query = query.substr(pos + 6);
            if (!query.empty()) {
                vhost = query;
            }
            if ((pos = vhost.find("?")) != std::string::npos) {
                vhost = vhost.substr(0, pos);
            }
        }
    }
    
    /* others */
}

void srs_discovery_tc_url(string tcUrl, string& schema, string& host, string& vhost, string& app, string& stream, int& port, string& param)
{
    size_t pos = std::string::npos;
    std::string url = tcUrl;
    
    if ((pos = url.find("://")) != std::string::npos) {
        schema = url.substr(0, pos);
        url = url.substr(schema.length() + 3);
        srs_info("discovery schema=%s", schema.c_str());
    }
    
    if ((pos = url.find("/")) != std::string::npos) {
        host = url.substr(0, pos);
        url = url.substr(host.length() + 1);
        srs_info("discovery host=%s", host.c_str());
    }
    
    port = SRS_CONSTS_RTMP_DEFAULT_PORT;
    if ((pos = host.find(":")) != std::string::npos) {
        srs_parse_hostport(host, host, port);
        srs_info("discovery host=%s, port=%d", host.c_str(), port);
    }
    
    if (url.empty()) {
        app = SRS_CONSTS_RTMP_DEFAULT_APP;
    } else {
        app = url;
    }
    
    vhost = host;
    srs_vhost_resolve(vhost, app, param);
    srs_vhost_resolve(vhost, stream, param);
}

void srs_parse_query_string(string q, map<string,string>& query)
{
    // query string flags.
    static vector<string> flags;
    if (flags.empty()) {
        flags.push_back("=");
        flags.push_back(",");
        flags.push_back("&&");
        flags.push_back("&");
        flags.push_back(";");
    }
    
    vector<string> kvs = srs_string_split(q, flags);
    for (int i = 0; i < (int)kvs.size(); i+=2) {
        string k = kvs.at(i);
        string v = (i < (int)kvs.size() - 1)? kvs.at(i+1):"";
        
        query[k] = v;
    }
}

void srs_random_generate(char* bytes, int size)
{
    static bool _random_initialized = false;
    if (!_random_initialized) {
        srand(0);
        _random_initialized = true;
        srs_trace("srand initialized the random.");
    }
    
    for (int i = 0; i < size; i++) {
        // the common value in [0x0f, 0xf0]
        bytes[i] = 0x0f + (rand() % (256 - 0x0f - 0x0f));
    }
}

string srs_generate_tc_url(string host, string vhost, string app, int port)
{
    string tcUrl = "rtmp://";
    
    if (vhost == SRS_CONSTS_RTMP_DEFAULT_VHOST) {
        tcUrl += host;
    } else {
        tcUrl += vhost;
    }
    
    if (port != SRS_CONSTS_RTMP_DEFAULT_PORT) {
        tcUrl += ":" + srs_int2str(port);
    }
    
    tcUrl += "/" + app;
    
    return tcUrl;
}

string srs_generate_stream_with_query(string host, string vhost, string stream, string param)
{
    string url = stream;
    string query = param;
    
    // If no vhost in param, try to append one.
    string guessVhost;
    if (query.find("vhost=") == string::npos) {
        if (vhost != SRS_CONSTS_RTMP_DEFAULT_VHOST) {
            guessVhost = vhost;
        } else if (!srs_is_ipv4(host)) {
            guessVhost = host;
        }
    }
    
    // Well, if vhost exists, always append in query string.
    if (!guessVhost.empty()) {
        query += "&vhost=" + guessVhost;
    }
    
    // Remove the start & when param is empty.
    srs_string_trim_start(query, "&");
    
    // Prefix query with ?.
    if (!srs_string_starts_with(query, "?")) {
        url += "?";
    }
    
    // Append query to url.
    if (!query.empty()) {
        url += query;
    }
    
    return url;
}

template<typename T>
srs_error_t srs_do_rtmp_create_msg(char type, uint32_t timestamp, char* data, int size, int stream_id, T** ppmsg)
{
    srs_error_t err = srs_success;
    
    *ppmsg = NULL;
    T* msg = NULL;
    
    if (type == SrsFrameTypeAudio) {
        SrsMessageHeader header;
        header.initialize_audio(size, timestamp, stream_id);
        
        msg = new T();
        if ((err = msg->create(&header, data, size)) != srs_success) {
            srs_freep(msg);
            return srs_error_wrap(err, "create message");
        }
    } else if (type == SrsFrameTypeVideo) {
        SrsMessageHeader header;
        header.initialize_video(size, timestamp, stream_id);
        
        msg = new T();
        if ((err = msg->create(&header, data, size)) != srs_success) {
            srs_freep(msg);
            return srs_error_wrap(err, "create message");
        }
    } else if (type == SrsFrameTypeScript) {
        SrsMessageHeader header;
        header.initialize_amf0_script(size, stream_id);
        
        msg = new T();
        if ((err = msg->create(&header, data, size)) != srs_success) {
            srs_freep(msg);
            return srs_error_wrap(err, "create message");
        }
    } else {
        return srs_error_new(ERROR_STREAM_CASTER_FLV_TAG, "unknown tag=%#x", (uint8_t)type);
    }
    
    *ppmsg = msg;
    
    return err;
}

srs_error_t srs_rtmp_create_msg(char type, uint32_t timestamp, char* data, int size, int stream_id, SrsSharedPtrMessage** ppmsg)
{
    srs_error_t err = srs_success;
    
    // only when failed, we must free the data.
    if ((err = srs_do_rtmp_create_msg(type, timestamp, data, size, stream_id, ppmsg)) != srs_success) {
        srs_freepa(data);
        return srs_error_wrap(err, "create message");
    }
    
    return err;
}

srs_error_t srs_rtmp_create_msg(char type, uint32_t timestamp, char* data, int size, int stream_id, SrsCommonMessage** ppmsg)
{
    srs_error_t err = srs_success;
    
    // only when failed, we must free the data.
    if ((err = srs_do_rtmp_create_msg(type, timestamp, data, size, stream_id, ppmsg)) != srs_success) {
        srs_freepa(data);
        return srs_error_wrap(err, "create message");
    }
    
    return err;
}

string srs_generate_stream_url(string vhost, string app, string stream)
{
    std::string url = "";
    
    if (SRS_CONSTS_RTMP_DEFAULT_VHOST != vhost){
        url += vhost;
    }
    url += "/";
    url += app;
    url += "/";
    url += stream;
    
    return url;
}

void srs_parse_rtmp_url(string url, string& tcUrl, string& stream)
{
    size_t pos;
    
    if ((pos = url.rfind("/")) != string::npos) {
        stream = url.substr(pos + 1);
        tcUrl = url.substr(0, pos);
    } else {
        tcUrl = url;
    }
}

string srs_generate_rtmp_url(string server, int port, string host, string vhost, string app, string stream, string param)
{
    string tcUrl = "rtmp://" + server + ":" + srs_int2str(port) + "/"  + app;
    string streamWithQuery = srs_generate_stream_with_query(host, vhost, stream, param);
    string url = tcUrl + "/" + streamWithQuery;
    return url;
}

srs_error_t srs_write_large_iovs(ISrsProtocolReaderWriter* skt, iovec* iovs, int size, ssize_t* pnwrite)
{
    srs_error_t err = srs_success;
    
    // the limits of writev iovs.
    // for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
    // for linux, generally it's 1024.
    static int limits = (int)sysconf(_SC_IOV_MAX);
#else
    static int limits = 1024;
#endif
    
    // send in a time.
    if (size < limits) {
        if ((err = skt->writev(iovs, size, pnwrite)) != srs_success) {
            return srs_error_wrap(err, "writev");
        }
        return err;
    }
    
    // send in multiple times.
    int cur_iov = 0;
    while (cur_iov < size) {
        int cur_count = srs_min(limits, size - cur_iov);
        if ((err = skt->writev(iovs + cur_iov, cur_count, pnwrite)) != srs_success) {
            return srs_error_wrap(err, "writev");
        }
        cur_iov += cur_count;
    }
    
    return err;
}

string srs_join_vector_string(vector<string>& vs, string separator)
{
    string str = "";
    
    for (int i = 0; i < (int)vs.size(); i++) {
        str += vs.at(i);
        if (i != (int)vs.size() - 1) {
            str += separator;
        }
    }
    
    return str;
}

bool srs_is_ipv4(string domain)
{
    for (int i = 0; i < (int)domain.length(); i++) {
        char ch = domain.at(i);
        if (ch == '.') {
            continue;
        }
        if (ch >= '0' && ch <= '9') {
            continue;
        }
        
        return false;
    }
    
    return true;
}

// following is generated by src/protocol/srs_rtmp_msg_array.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_rtmp_msg_array.hpp>

//#include <srs_rtmp_stack.hpp>

SrsMessageArray::SrsMessageArray(int max_msgs)
{
    srs_assert(max_msgs > 0);
    
    msgs = new SrsSharedPtrMessage*[max_msgs];
    max = max_msgs;
    
    zero(max_msgs);
}

SrsMessageArray::~SrsMessageArray()
{
    // we just free the msgs itself,
    // both delete and delete[] is ok,
    // for each msg in msgs is already freed by send_and_free_messages.
    srs_freepa(msgs);
}

void SrsMessageArray::free(int count)
{
    // initialize
    for (int i = 0; i < count; i++) {
        SrsSharedPtrMessage* msg = msgs[i];
        srs_freep(msg);
        
        msgs[i] = NULL;
    }
}

void SrsMessageArray::zero(int count)
{
    // initialize
    for (int i = 0; i < count; i++) {
        msgs[i] = NULL;
    }
}


// following is generated by src/protocol/srs_protocol_stream.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_protocol_stream.hpp>

#include <stdlib.h>

//#include <srs_kernel_error.hpp>
//#include <srs_kernel_log.hpp>
//#include <srs_kernel_utility.hpp>
//#include <srs_core_performance.hpp>

// the default recv buffer size, 128KB.
#define SRS_DEFAULT_RECV_BUFFER_SIZE 131072

// limit user-space buffer to 256KB, for 3Mbps stream delivery.
//      800*2000/8=200000B(about 195KB).
// @remark it's ok for higher stream, the buffer is ok for one chunk is 256KB.
#define SRS_MAX_SOCKET_BUFFER 262144

// the max header size,
// @see SrsProtocol::read_message_header().
#define SRS_RTMP_MAX_MESSAGE_HEADER 11

#ifdef SRS_PERF_MERGED_READ
IMergeReadHandler::IMergeReadHandler()
{
}

IMergeReadHandler::~IMergeReadHandler()
{
}
#endif

SrsFastStream::SrsFastStream()
{
#ifdef SRS_PERF_MERGED_READ
    merged_read = false;
    _handler = NULL;
#endif
    
    nb_buffer = SRS_DEFAULT_RECV_BUFFER_SIZE;
    buffer = (char*)malloc(nb_buffer);
    p = end = buffer;
}

SrsFastStream::~SrsFastStream()
{
    free(buffer);
    buffer = NULL;
}

int SrsFastStream::size()
{
    return (int)(end - p);
}

char* SrsFastStream::bytes()
{
    return p;
}

void SrsFastStream::set_buffer(int buffer_size)
{
    // never exceed the max size.
    if (buffer_size > SRS_MAX_SOCKET_BUFFER) {
        srs_warn("limit the user-space buffer from %d to %d",
                 buffer_size, SRS_MAX_SOCKET_BUFFER);
    }
    
    // the user-space buffer size limit to a max value.
    int nb_resize_buf = srs_min(buffer_size, SRS_MAX_SOCKET_BUFFER);
    
    // only realloc when buffer changed bigger
    if (nb_resize_buf <= nb_buffer) {
        return;
    }
    
    // realloc for buffer change bigger.
    int start = (int)(p - buffer);
    int nb_bytes = (int)(end - p);
    
    buffer = (char*)realloc(buffer, nb_resize_buf);
    nb_buffer = nb_resize_buf;
    p = buffer + start;
    end = p + nb_bytes;
}

char SrsFastStream::read_1byte()
{
    srs_assert(end - p >= 1);
    return *p++;
}

char* SrsFastStream::read_slice(int size)
{
    srs_assert(size >= 0);
    srs_assert(end - p >= size);
    srs_assert(p + size >= buffer);
    
    char* ptr = p;
    p += size;
    
    return ptr;
}

void SrsFastStream::skip(int size)
{
    srs_assert(end - p >= size);
    srs_assert(p + size >= buffer);
    p += size;
}

srs_error_t SrsFastStream::grow(ISrsReader* reader, int required_size)
{
    srs_error_t err = srs_success;
    
    // already got required size of bytes.
    if (end - p >= required_size) {
        return err;
    }
    
    // must be positive.
    srs_assert(required_size > 0);
    
    // the free space of buffer,
    //      buffer = consumed_bytes + exists_bytes + free_space.
    int nb_free_space = (int)(buffer + nb_buffer - end);
    
    // the bytes already in buffer
    int nb_exists_bytes = (int)(end - p);
    srs_assert(nb_exists_bytes >= 0);
    
    // resize the space when no left space.
    if (nb_free_space < required_size - nb_exists_bytes) {
        // reset or move to get more space.
        if (!nb_exists_bytes) {
            // reset when buffer is empty.
            p = end = buffer;
        } else if (nb_exists_bytes < nb_buffer && p > buffer) {
            // move the left bytes to start of buffer.
            // @remark Only move memory when space is enough, or failed at next check.
            // @see https://github.com/ossrs/srs/issues/848
            buffer = (char*)memmove(buffer, p, nb_exists_bytes);
            p = buffer;
            end = p + nb_exists_bytes;
        }
        
        // check whether enough free space in buffer.
        nb_free_space = (int)(buffer + nb_buffer - end);
        if (nb_free_space < required_size - nb_exists_bytes) {
            return srs_error_new(ERROR_READER_BUFFER_OVERFLOW, "overflow, required=%d, max=%d, left=%d", required_size, nb_buffer, nb_free_space);
        }
    }
    
    // buffer is ok, read required size of bytes.
    while (end - p < required_size) {
        ssize_t nread;
        if ((err = reader->read(end, nb_free_space, &nread)) != srs_success) {
            return srs_error_wrap(err, "read bytes");
        }
        
#ifdef SRS_PERF_MERGED_READ
        /**
         * to improve read performance, merge some packets then read,
         * when it on and read small bytes, we sleep to wait more data.,
         * that is, we merge some data to read together.
         * @see https://github.com/ossrs/srs/issues/241
         */
        if (merged_read && _handler) {
            _handler->on_read(nread);
        }
#endif
        
        // we just move the ptr to next.
        srs_assert((int)nread > 0);
        end += nread;
        nb_free_space -= nread;
    }
    
    return err;
}

#ifdef SRS_PERF_MERGED_READ
void SrsFastStream::set_merge_read(bool v, IMergeReadHandler* handler)
{
    merged_read = v;
    _handler = handler;
}
#endif

// following is generated by src/protocol/srs_raw_avc.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_raw_avc.hpp>

#include <string.h>
using namespace std;

//#include <srs_kernel_error.hpp>
//#include <srs_kernel_log.hpp>
//#include <srs_kernel_buffer.hpp>
//#include <srs_kernel_utility.hpp>
//#include <srs_core_autofree.hpp>
//#include <srs_kernel_codec.hpp>

SrsRawH264Stream::SrsRawH264Stream()
{
}

SrsRawH264Stream::~SrsRawH264Stream()
{
}

srs_error_t SrsRawH264Stream::annexb_demux(SrsBuffer* stream, char** pframe, int* pnb_frame)
{
    srs_error_t err = srs_success;
    
    *pframe = NULL;
    *pnb_frame = 0;
    
    while (!stream->empty()) {
        // each frame must prefixed by annexb format.
        // about annexb, @see ISO_IEC_14496-10-AVC-2003.pdf, page 211.
        int pnb_start_code = 0;
        if (!srs_avc_startswith_annexb(stream, &pnb_start_code)) {
            return srs_error_new(ERROR_H264_API_NO_PREFIXED, "annexb start code");
        }
        int start = stream->pos() + pnb_start_code;
        
        // find the last frame prefixed by annexb format.
        stream->skip(pnb_start_code);
        while (!stream->empty()) {
            if (srs_avc_startswith_annexb(stream, NULL)) {
                break;
            }
            stream->skip(1);
        }
        
        // demux the frame.
        *pnb_frame = stream->pos() - start;
        *pframe = stream->data() + start;
        break;
    }
    
    return err;
}

bool SrsRawH264Stream::is_sps(char* frame, int nb_frame)
{
    srs_assert(nb_frame > 0);
    
    // 5bits, 7.3.1 NAL unit syntax,
    // ISO_IEC_14496-10-AVC-2003.pdf, page 44.
    //  7: SPS, 8: PPS, 5: I Frame, 1: P Frame
    uint8_t nal_unit_type = (char)frame[0] & 0x1f;
    
    return nal_unit_type == 7;
}

bool SrsRawH264Stream::is_pps(char* frame, int nb_frame)
{
    srs_assert(nb_frame > 0);
    
    // 5bits, 7.3.1 NAL unit syntax,
    // ISO_IEC_14496-10-AVC-2003.pdf, page 44.
    //  7: SPS, 8: PPS, 5: I Frame, 1: P Frame
    uint8_t nal_unit_type = (char)frame[0] & 0x1f;
    
    return nal_unit_type == 8;
}

srs_error_t SrsRawH264Stream::sps_demux(char* frame, int nb_frame, string& sps)
{
    srs_error_t err = srs_success;
    
    // atleast 1bytes for SPS to decode the type, profile, constrain and level.
    if (nb_frame < 4) {
        return err;
    }
    
    sps = "";
    if (nb_frame > 0) {
        sps.append(frame, nb_frame);
    }
    
    // should never be empty.
    if (sps.empty()) {
        return srs_error_new(ERROR_STREAM_CASTER_AVC_SPS, "no sps");
    }
    
    return err;
}

srs_error_t SrsRawH264Stream::pps_demux(char* frame, int nb_frame, string& pps)
{
    srs_error_t err = srs_success;
    
    pps = "";
    if (nb_frame > 0) {
        pps.append(frame, nb_frame);
    }
    
    // should never be empty.
    if (pps.empty()) {
        return srs_error_new(ERROR_STREAM_CASTER_AVC_PPS, "no pps");
    }
    
    return err;
}

srs_error_t SrsRawH264Stream::mux_sequence_header(string sps, string pps, uint32_t dts, uint32_t pts, string& sh)
{
    srs_error_t err = srs_success;
    
    // 5bytes sps/pps header:
    //      configurationVersion, AVCProfileIndication, profile_compatibility,
    //      AVCLevelIndication, lengthSizeMinusOne
    // 3bytes size of sps:
    //      numOfSequenceParameterSets, sequenceParameterSetLength(2B)
    // Nbytes of sps.
    //      sequenceParameterSetNALUnit
    // 3bytes size of pps:
    //      numOfPictureParameterSets, pictureParameterSetLength
    // Nbytes of pps:
    //      pictureParameterSetNALUnit
    int nb_packet = 5
    + 3 + (int)sps.length()
    + 3 + (int)pps.length();
    char* packet = new char[nb_packet];
    SrsAutoFreeA(char, packet);
    
    // use stream to generate the h264 packet.
    SrsBuffer stream(packet, nb_packet);
    
    // decode the SPS:
    // @see: 7.3.2.1.1, ISO_IEC_14496-10-AVC-2012.pdf, page 62
    if (true) {
        srs_assert((int)sps.length() >= 4);
        char* frame = (char*)sps.data();
        
        // @see: Annex A Profiles and levels, ISO_IEC_14496-10-AVC-2003.pdf, page 205
        //      Baseline profile profile_idc is 66(0x42).
        //      Main profile profile_idc is 77(0x4d).
        //      Extended profile profile_idc is 88(0x58).
        uint8_t profile_idc = frame[1];
        //uint8_t constraint_set = frame[2];
        uint8_t level_idc = frame[3];
        
        // generate the sps/pps header
        // 5.3.4.2.1 Syntax, ISO_IEC_14496-15-AVC-format-2012.pdf, page 16
        // configurationVersion
        stream.write_1bytes(0x01);
        // AVCProfileIndication
        stream.write_1bytes(profile_idc);
        // profile_compatibility
        stream.write_1bytes(0x00);
        // AVCLevelIndication
        stream.write_1bytes(level_idc);
        // lengthSizeMinusOne, or NAL_unit_length, always use 4bytes size,
        // so we always set it to 0x03.
        stream.write_1bytes(0x03);
    }
    
    // sps
    if (true) {
        // 5.3.4.2.1 Syntax, ISO_IEC_14496-15-AVC-format-2012.pdf, page 16
        // numOfSequenceParameterSets, always 1
        stream.write_1bytes(0x01);
        // sequenceParameterSetLength
        stream.write_2bytes(sps.length());
        // sequenceParameterSetNALUnit
        stream.write_string(sps);
    }
    
    // pps
    if (true) {
        // 5.3.4.2.1 Syntax, ISO_IEC_14496-15-AVC-format-2012.pdf, page 16
        // numOfPictureParameterSets, always 1
        stream.write_1bytes(0x01);
        // pictureParameterSetLength
        stream.write_2bytes(pps.length());
        // pictureParameterSetNALUnit
        stream.write_string(pps);
    }
    
    // TODO: FIXME: for more profile.
    // 5.3.4.2.1 Syntax, ISO_IEC_14496-15-AVC-format-2012.pdf, page 16
    // profile_idc == 100 || profile_idc == 110 || profile_idc == 122 || profile_idc == 144
    
    sh = "";
    sh.append(packet, nb_packet);
    
    return err;
}

srs_error_t SrsRawH264Stream::mux_ipb_frame(char* frame, int nb_frame, string& ibp)
{
    srs_error_t err = srs_success;
    
    // 4bytes size of nalu:
    //      NALUnitLength
    // Nbytes of nalu.
    //      NALUnit
    int nb_packet = 4 + nb_frame;
    char* packet = new char[nb_packet];
    SrsAutoFreeA(char, packet);
    
    // use stream to generate the h264 packet.
    SrsBuffer stream(packet, nb_packet);
    
    // 5.3.4.2.1 Syntax, ISO_IEC_14496-15-AVC-format-2012.pdf, page 16
    // lengthSizeMinusOne, or NAL_unit_length, always use 4bytes size
    uint32_t NAL_unit_length = nb_frame;
    
    // mux the avc NALU in "ISO Base Media File Format"
    // from ISO_IEC_14496-15-AVC-format-2012.pdf, page 20
    // NALUnitLength
    stream.write_4bytes(NAL_unit_length);
    // NALUnit
    stream.write_bytes(frame, nb_frame);
    
    ibp = "";
    ibp.append(packet, nb_packet);
    
    return err;
}

srs_error_t SrsRawH264Stream::mux_avc2flv(string video, int8_t frame_type, int8_t avc_packet_type, uint32_t dts, uint32_t pts, char** flv, int* nb_flv)
{
    srs_error_t err = srs_success;
    
    // for h264 in RTMP video payload, there is 5bytes header:
    //      1bytes, FrameType | CodecID
    //      1bytes, AVCPacketType
    //      3bytes, CompositionTime, the cts.
    // @see: E.4.3 Video Tags, video_file_format_spec_v10_1.pdf, page 78
    int size = (int)video.length() + 5;
    char* data = new char[size];
    char* p = data;
    
    // @see: E.4.3 Video Tags, video_file_format_spec_v10_1.pdf, page 78
    // Frame Type, Type of video frame.
    // CodecID, Codec Identifier.
    // set the rtmp header
    *p++ = (frame_type << 4) | SrsVideoCodecIdAVC;
    
    // AVCPacketType
    *p++ = avc_packet_type;
    
    // CompositionTime
    // pts = dts + cts, or
    // cts = pts - dts.
    // where cts is the header in rtmp video packet payload header.
    uint32_t cts = pts - dts;
    char* pp = (char*)&cts;
    *p++ = pp[2];
    *p++ = pp[1];
    *p++ = pp[0];
    
    // h.264 raw data.
    memcpy(p, video.data(), video.length());
    
    *flv = data;
    *nb_flv = size;
    
    return err;
}

SrsRawAacStream::SrsRawAacStream()
{
}

SrsRawAacStream::~SrsRawAacStream()
{
}

srs_error_t SrsRawAacStream::adts_demux(SrsBuffer* stream, char** pframe, int* pnb_frame, SrsRawAacStreamCodec& codec)
{
    srs_error_t err = srs_success;
    
    while (!stream->empty()) {
        int adts_header_start = stream->pos();
        
        // decode the ADTS.
        // @see ISO_IEC_13818-7-AAC-2004.pdf, page 26
        //      6.2 Audio Data Transport Stream, ADTS
        // @see https://github.com/ossrs/srs/issues/212#issuecomment-64145885
        // byte_alignment()
        
        // adts_fixed_header:
        //      12bits syncword,
        //      16bits left.
        // adts_variable_header:
        //      28bits
        //      12+16+28=56bits
        // adts_error_check:
        //      16bits if protection_absent
        //      56+16=72bits
        // if protection_absent:
        //      require(7bytes)=56bits
        // else
        //      require(9bytes)=72bits
        if (!stream->require(7)) {
            return srs_error_new(ERROR_AAC_ADTS_HEADER, "requires 7 only %d bytes", stream->left());
        }
        
        // for aac, the frame must be ADTS format.
        if (!srs_aac_startswith_adts(stream)) {
            return srs_error_new(ERROR_AAC_REQUIRED_ADTS, "not adts");
        }
        
        // syncword 12 bslbf
        stream->read_1bytes();
        // 4bits left.
        // adts_fixed_header(), 1.A.2.2.1 Fixed Header of ADTS
        // ID 1 bslbf
        // layer 2 uimsbf
        // protection_absent 1 bslbf
        int8_t pav = (stream->read_1bytes() & 0x0f);
        int8_t id = (pav >> 3) & 0x01;
        /*int8_t layer = (pav >> 1) & 0x03;*/
        int8_t protection_absent = pav & 0x01;
        
        /**
         * ID: MPEG identifier, set to '1' if the audio data in the ADTS stream are MPEG-2 AAC (See ISO/IEC 13818-7)
         * and set to '0' if the audio data are MPEG-4. See also ISO/IEC 11172-3, subclause 2.4.2.3.
         */
        if (id != 0x01) {
            // well, some system always use 0, but actually is aac format.
            // for example, houjian vod ts always set the aac id to 0, actually 1.
            // we just ignore it, and alwyas use 1(aac) to demux.
            id = 0x01;
        }
        
        int16_t sfiv = stream->read_2bytes();
        // profile 2 uimsbf
        // sampling_frequency_index 4 uimsbf
        // private_bit 1 bslbf
        // channel_configuration 3 uimsbf
        // original/copy 1 bslbf
        // home 1 bslbf
        int8_t profile = (sfiv >> 14) & 0x03;
        int8_t sampling_frequency_index = (sfiv >> 10) & 0x0f;
        /*int8_t private_bit = (sfiv >> 9) & 0x01;*/
        int8_t channel_configuration = (sfiv >> 6) & 0x07;
        /*int8_t original = (sfiv >> 5) & 0x01;*/
        /*int8_t home = (sfiv >> 4) & 0x01;*/
        //int8_t Emphasis; @remark, Emphasis is removed, @see https://github.com/ossrs/srs/issues/212#issuecomment-64154736
        // 4bits left.
        // adts_variable_header(), 1.A.2.2.2 Variable Header of ADTS
        // copyright_identification_bit 1 bslbf
        // copyright_identification_start 1 bslbf
        /*int8_t fh_copyright_identification_bit = (fh1 >> 3) & 0x01;*/
        /*int8_t fh_copyright_identification_start = (fh1 >> 2) & 0x01;*/
        // frame_length 13 bslbf: Length of the frame including headers and error_check in bytes.
        // use the left 2bits as the 13 and 12 bit,
        // the frame_length is 13bits, so we move 13-2=11.
        int16_t frame_length = (sfiv << 11) & 0x1800;
        
        int32_t abfv = stream->read_3bytes();
        // frame_length 13 bslbf: consume the first 13-2=11bits
        // the fh2 is 24bits, so we move right 24-11=13.
        frame_length |= (abfv >> 13) & 0x07ff;
        // adts_buffer_fullness 11 bslbf
        /*int16_t fh_adts_buffer_fullness = (abfv >> 2) & 0x7ff;*/
        // number_of_raw_data_blocks_in_frame 2 uimsbf
        /*int16_t number_of_raw_data_blocks_in_frame = abfv & 0x03;*/
        // adts_error_check(), 1.A.2.2.3 Error detection
        if (!protection_absent) {
            if (!stream->require(2)) {
                return srs_error_new(ERROR_AAC_ADTS_HEADER, "requires 2 only %d bytes", stream->left());
            }
            // crc_check 16 Rpchof
            /*int16_t crc_check = */stream->read_2bytes();
        }
        
        // TODO: check the sampling_frequency_index
        // TODO: check the channel_configuration
        
        // raw_data_blocks
        int adts_header_size = stream->pos() - adts_header_start;
        int raw_data_size = frame_length - adts_header_size;
        if (!stream->require(raw_data_size)) {
            return srs_error_new(ERROR_AAC_ADTS_HEADER, "requires %d only %d bytes", raw_data_size, stream->left());
        }
        
        // the codec info.
        codec.protection_absent = protection_absent;
        codec.aac_object = srs_aac_ts2rtmp((SrsAacProfile)profile);
        codec.sampling_frequency_index = sampling_frequency_index;
        codec.channel_configuration = channel_configuration;
        codec.frame_length = frame_length;
        
        // @see srs_audio_write_raw_frame().
        // TODO: FIXME: maybe need to resample audio.
        codec.sound_format = 10; // AAC
        if (sampling_frequency_index <= 0x0c && sampling_frequency_index > 0x0a) {
            codec.sound_rate = SrsAudioSampleRate5512;
        } else if (sampling_frequency_index <= 0x0a && sampling_frequency_index > 0x07) {
            codec.sound_rate = SrsAudioSampleRate11025;
        } else if (sampling_frequency_index <= 0x07 && sampling_frequency_index > 0x04) {
            codec.sound_rate = SrsAudioSampleRate22050;
        } else if (sampling_frequency_index <= 0x04) {
            codec.sound_rate = SrsAudioSampleRate44100;
        } else {
            codec.sound_rate = SrsAudioSampleRate44100;
            srs_warn("adts invalid sample rate for flv, rate=%#x", sampling_frequency_index);
        }
        codec.sound_type = srs_max(0, srs_min(1, channel_configuration - 1));
        // TODO: FIXME: finger it out the sound size by adts.
        codec.sound_size = 1; // 0(8bits) or 1(16bits).
        
        // frame data.
        *pframe = stream->data() + stream->pos();
        *pnb_frame = raw_data_size;
        stream->skip(raw_data_size);
        
        break;
    }
    
    return err;
}

srs_error_t SrsRawAacStream::mux_sequence_header(SrsRawAacStreamCodec* codec, string& sh)
{
    srs_error_t err = srs_success;
    
    // only support aac profile 1-4.
    if (codec->aac_object == SrsAacObjectTypeReserved) {
        return srs_error_new(ERROR_AAC_DATA_INVALID, "invalid aac object");
    }
    
    SrsAacObjectType audioObjectType = codec->aac_object;
    char channelConfiguration = codec->channel_configuration;
    char samplingFrequencyIndex = codec->sampling_frequency_index;
    
    // override the aac samplerate by user specified.
    // @see https://github.com/ossrs/srs/issues/212#issuecomment-64146899
    switch (codec->sound_rate) {
        case SrsAudioSampleRate11025:
            samplingFrequencyIndex = 0x0a; break;
        case SrsAudioSampleRate22050:
            samplingFrequencyIndex = 0x07; break;
        case SrsAudioSampleRate44100:
            samplingFrequencyIndex = 0x04; break;
        default:
            break;
    }
    
    sh = "";
    
    char ch = 0;
    // @see ISO_IEC_14496-3-AAC-2001.pdf
    // AudioSpecificConfig (), page 33
    // 1.6.2.1 AudioSpecificConfig
    // audioObjectType; 5 bslbf
    ch = (audioObjectType << 3) & 0xf8;
    // 3bits left.
    
    // samplingFrequencyIndex; 4 bslbf
    ch |= (samplingFrequencyIndex >> 1) & 0x07;
    sh += ch;
    ch = (samplingFrequencyIndex << 7) & 0x80;
    if (samplingFrequencyIndex == 0x0f) {
        return srs_error_new(ERROR_AAC_DATA_INVALID, "invalid sampling frequency index");
    }
    // 7bits left.
    
    // channelConfiguration; 4 bslbf
    ch |= (channelConfiguration << 3) & 0x78;
    // 3bits left.
    
    // GASpecificConfig(), page 451
    // 4.4.1 Decoder configuration (GASpecificConfig)
    // frameLengthFlag; 1 bslbf
    // dependsOnCoreCoder; 1 bslbf
    // extensionFlag; 1 bslbf
    sh += ch;
    
    return err;
}

srs_error_t SrsRawAacStream::mux_aac2flv(char* frame, int nb_frame, SrsRawAacStreamCodec* codec, uint32_t dts, char** flv, int* nb_flv)
{
    srs_error_t err = srs_success;
    
    char sound_format = codec->sound_format;
    char sound_type = codec->sound_type;
    char sound_size = codec->sound_size;
    char sound_rate = codec->sound_rate;
    char aac_packet_type = codec->aac_packet_type;
    
    // for audio frame, there is 1 or 2 bytes header:
    //      1bytes, SoundFormat|SoundRate|SoundSize|SoundType
    //      1bytes, AACPacketType for SoundFormat == 10, 0 is sequence header.
    int size = nb_frame + 1;
    if (sound_format == SrsAudioCodecIdAAC) {
        size += 1;
    }
    char* data = new char[size];
    char* p = data;
    
    uint8_t audio_header = sound_type & 0x01;
    audio_header |= (sound_size << 1) & 0x02;
    audio_header |= (sound_rate << 2) & 0x0c;
    audio_header |= (sound_format << 4) & 0xf0;
    
    *p++ = audio_header;
    
    if (sound_format == SrsAudioCodecIdAAC) {
        *p++ = aac_packet_type;
    }
    
    memcpy(p, frame, nb_frame);
    
    *flv = data;
    *nb_flv = size;
    
    return err;
}

// following is generated by src/protocol/srs_rtsp_stack.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_rtsp_stack.hpp>

#if !defined(SRS_EXPORT_LIBRTMP)

#include <stdlib.h>
#include <map>
using namespace std;

//#include <srs_protocol_io.hpp>
//#include <srs_kernel_stream.hpp>
//#include <srs_kernel_error.hpp>
//#include <srs_kernel_log.hpp>
//#include <srs_kernel_consts.hpp>
//#include <srs_core_autofree.hpp>
//#include <srs_kernel_utility.hpp>
//#include <srs_kernel_buffer.hpp>
//#include <srs_kernel_codec.hpp>

#ifdef SRS_AUTO_STREAM_CASTER

#define SRS_RTSP_BUFFER 4096

// get the status text of code.
string srs_generate_rtsp_status_text(int status)
{
    static std::map<int, std::string> _status_map;
    if (_status_map.empty()) {
        _status_map[SRS_CONSTS_RTSP_Continue] = SRS_CONSTS_RTSP_Continue_str;
        _status_map[SRS_CONSTS_RTSP_OK] = SRS_CONSTS_RTSP_OK_str;
        _status_map[SRS_CONSTS_RTSP_Created] = SRS_CONSTS_RTSP_Created_str;
        _status_map[SRS_CONSTS_RTSP_LowOnStorageSpace] = SRS_CONSTS_RTSP_LowOnStorageSpace_str;
        _status_map[SRS_CONSTS_RTSP_MultipleChoices] = SRS_CONSTS_RTSP_MultipleChoices_str;
        _status_map[SRS_CONSTS_RTSP_MovedPermanently] = SRS_CONSTS_RTSP_MovedPermanently_str;
        _status_map[SRS_CONSTS_RTSP_MovedTemporarily] = SRS_CONSTS_RTSP_MovedTemporarily_str;
        _status_map[SRS_CONSTS_RTSP_SeeOther] = SRS_CONSTS_RTSP_SeeOther_str;
        _status_map[SRS_CONSTS_RTSP_NotModified] = SRS_CONSTS_RTSP_NotModified_str;
        _status_map[SRS_CONSTS_RTSP_UseProxy] = SRS_CONSTS_RTSP_UseProxy_str;
        _status_map[SRS_CONSTS_RTSP_BadRequest] = SRS_CONSTS_RTSP_BadRequest_str;
        _status_map[SRS_CONSTS_RTSP_Unauthorized] = SRS_CONSTS_RTSP_Unauthorized_str;
        _status_map[SRS_CONSTS_RTSP_PaymentRequired] = SRS_CONSTS_RTSP_PaymentRequired_str;
        _status_map[SRS_CONSTS_RTSP_Forbidden] = SRS_CONSTS_RTSP_Forbidden_str;
        _status_map[SRS_CONSTS_RTSP_NotFound] = SRS_CONSTS_RTSP_NotFound_str;
        _status_map[SRS_CONSTS_RTSP_MethodNotAllowed] = SRS_CONSTS_RTSP_MethodNotAllowed_str;
        _status_map[SRS_CONSTS_RTSP_NotAcceptable] = SRS_CONSTS_RTSP_NotAcceptable_str;
        _status_map[SRS_CONSTS_RTSP_ProxyAuthenticationRequired] = SRS_CONSTS_RTSP_ProxyAuthenticationRequired_str;
        _status_map[SRS_CONSTS_RTSP_RequestTimeout] = SRS_CONSTS_RTSP_RequestTimeout_str;
        _status_map[SRS_CONSTS_RTSP_Gone] = SRS_CONSTS_RTSP_Gone_str;
        _status_map[SRS_CONSTS_RTSP_LengthRequired] = SRS_CONSTS_RTSP_LengthRequired_str;
        _status_map[SRS_CONSTS_RTSP_PreconditionFailed] = SRS_CONSTS_RTSP_PreconditionFailed_str;
        _status_map[SRS_CONSTS_RTSP_RequestEntityTooLarge] = SRS_CONSTS_RTSP_RequestEntityTooLarge_str;
        _status_map[SRS_CONSTS_RTSP_RequestURITooLarge] = SRS_CONSTS_RTSP_RequestURITooLarge_str;
        _status_map[SRS_CONSTS_RTSP_UnsupportedMediaType] = SRS_CONSTS_RTSP_UnsupportedMediaType_str;
        _status_map[SRS_CONSTS_RTSP_ParameterNotUnderstood] = SRS_CONSTS_RTSP_ParameterNotUnderstood_str;
        _status_map[SRS_CONSTS_RTSP_ConferenceNotFound] = SRS_CONSTS_RTSP_ConferenceNotFound_str;
        _status_map[SRS_CONSTS_RTSP_NotEnoughBandwidth] = SRS_CONSTS_RTSP_NotEnoughBandwidth_str;
        _status_map[SRS_CONSTS_RTSP_SessionNotFound] = SRS_CONSTS_RTSP_SessionNotFound_str;
        _status_map[SRS_CONSTS_RTSP_MethodNotValidInThisState] = SRS_CONSTS_RTSP_MethodNotValidInThisState_str;
        _status_map[SRS_CONSTS_RTSP_HeaderFieldNotValidForResource] = SRS_CONSTS_RTSP_HeaderFieldNotValidForResource_str;
        _status_map[SRS_CONSTS_RTSP_InvalidRange] = SRS_CONSTS_RTSP_InvalidRange_str;
        _status_map[SRS_CONSTS_RTSP_ParameterIsReadOnly] = SRS_CONSTS_RTSP_ParameterIsReadOnly_str;
        _status_map[SRS_CONSTS_RTSP_AggregateOperationNotAllowed] = SRS_CONSTS_RTSP_AggregateOperationNotAllowed_str;
        _status_map[SRS_CONSTS_RTSP_OnlyAggregateOperationAllowed] = SRS_CONSTS_RTSP_OnlyAggregateOperationAllowed_str;
        _status_map[SRS_CONSTS_RTSP_UnsupportedTransport] = SRS_CONSTS_RTSP_UnsupportedTransport_str;
        _status_map[SRS_CONSTS_RTSP_DestinationUnreachable] = SRS_CONSTS_RTSP_DestinationUnreachable_str;
        _status_map[SRS_CONSTS_RTSP_InternalServerError] = SRS_CONSTS_RTSP_InternalServerError_str;
        _status_map[SRS_CONSTS_RTSP_NotImplemented] = SRS_CONSTS_RTSP_NotImplemented_str;
        _status_map[SRS_CONSTS_RTSP_BadGateway] = SRS_CONSTS_RTSP_BadGateway_str;
        _status_map[SRS_CONSTS_RTSP_ServiceUnavailable] = SRS_CONSTS_RTSP_ServiceUnavailable_str;
        _status_map[SRS_CONSTS_RTSP_GatewayTimeout] = SRS_CONSTS_RTSP_GatewayTimeout_str;
        _status_map[SRS_CONSTS_RTSP_RTSPVersionNotSupported] = SRS_CONSTS_RTSP_RTSPVersionNotSupported_str;
        _status_map[SRS_CONSTS_RTSP_OptionNotSupported] = SRS_CONSTS_RTSP_OptionNotSupported_str;
    }
    
    std::string status_text;
    if (_status_map.find(status) == _status_map.end()) {
        status_text = "Status Unknown";
    } else {
        status_text = _status_map[status];
    }
    
    return status_text;
}

std::string srs_generate_rtsp_method_str(SrsRtspMethod method)
{
    switch (method) {
        case SrsRtspMethodDescribe: return SRS_METHOD_DESCRIBE;
        case SrsRtspMethodAnnounce: return SRS_METHOD_ANNOUNCE;
        case SrsRtspMethodGetParameter: return SRS_METHOD_GET_PARAMETER;
        case SrsRtspMethodOptions: return SRS_METHOD_OPTIONS;
        case SrsRtspMethodPause: return SRS_METHOD_PAUSE;
        case SrsRtspMethodPlay: return SRS_METHOD_PLAY;
        case SrsRtspMethodRecord: return SRS_METHOD_RECORD;
        case SrsRtspMethodRedirect: return SRS_METHOD_REDIRECT;
        case SrsRtspMethodSetup: return SRS_METHOD_SETUP;
        case SrsRtspMethodSetParameter: return SRS_METHOD_SET_PARAMETER;
        case SrsRtspMethodTeardown: return SRS_METHOD_TEARDOWN;
        default: return "Unknown";
    }
}

SrsRtpPacket::SrsRtpPacket()
{
    version = 2;
    padding = 0;
    extension = 0;
    csrc_count = 0;
    marker = 1;
    
    payload_type = 0;
    sequence_number = 0;
    timestamp = 0;
    ssrc = 0;
    
    payload = new SrsSimpleStream();
    audio = new SrsAudioFrame();
    chunked = false;
    completed = false;
}

SrsRtpPacket::~SrsRtpPacket()
{
    srs_freep(payload);
    srs_freep(audio);
}

void SrsRtpPacket::copy(SrsRtpPacket* src)
{
    version = src->version;
    padding = src->padding;
    extension = src->extension;
    csrc_count = src->csrc_count;
    marker = src->marker;
    payload_type = src->payload_type;
    sequence_number = src->sequence_number;
    timestamp = src->timestamp;
    ssrc = src->ssrc;
    
    chunked = src->chunked;
    completed = src->completed;
    
    srs_freep(audio);
    audio = new SrsAudioFrame();
}

void SrsRtpPacket::reap(SrsRtpPacket* src)
{
    copy(src);
    
    srs_freep(payload);
    payload = src->payload;
    src->payload = NULL;
    
    srs_freep(audio);
    audio = src->audio;
    src->audio = NULL;
}

srs_error_t SrsRtpPacket::decode(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // 12bytes header
    if (!stream->require(12)) {
        return srs_error_new(ERROR_RTP_HEADER_CORRUPT, "requires 12 only %d bytes", stream->left());
    }
    
    int8_t vv = stream->read_1bytes();
    version = (vv >> 6) & 0x03;
    padding = (vv >> 5) & 0x01;
    extension = (vv >> 4) & 0x01;
    csrc_count = vv & 0x0f;
    
    int8_t mv = stream->read_1bytes();
    marker = (mv >> 7) & 0x01;
    payload_type = mv & 0x7f;
    
    sequence_number = stream->read_2bytes();
    timestamp = stream->read_4bytes();
    ssrc = stream->read_4bytes();
    
    // TODO: FIXME: check sequence number.
    
    // video codec.
    if (payload_type == 96) {
        return decode_96(stream);
    } else if (payload_type == 97) {
        return decode_97(stream);
    }
    
    return err;
}

srs_error_t SrsRtpPacket::decode_97(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // atleast 2bytes content.
    if (!stream->require(2)) {
        return srs_error_new(ERROR_RTP_TYPE97_CORRUPT, "requires 2 only %d bytes", stream->left());
    }
    
    int8_t hasv = stream->read_1bytes();
    int8_t lasv = stream->read_1bytes();
    uint16_t au_size = ((hasv << 5) & 0xE0) | ((lasv >> 3) & 0x1f);
    
    if (!stream->require(au_size)) {
        return srs_error_new(ERROR_RTP_TYPE97_CORRUPT, "requires %d only %d bytes", au_size, stream->left());
    }
    
    int required_size = 0;
    
    // append left bytes to payload.
    payload->append(
                    stream->data() + stream->pos() + au_size,
                    stream->size() - stream->pos() - au_size
                    );
    char* p = payload->bytes();
    
    for (int i = 0; i < au_size; i += 2) {
        hasv = stream->read_1bytes();
        lasv = stream->read_1bytes();
        
        uint16_t sample_size = ((hasv << 5) & 0xE0) | ((lasv >> 3) & 0x1f);
        // TODO: FIXME: finger out how to parse the size of sample.
        if (sample_size < 0x100 && stream->require(required_size + sample_size + 0x100)) {
            sample_size = sample_size | 0x100;
        }
        
        char* sample = p + required_size;
        required_size += sample_size;
        
        if (!stream->require(required_size)) {
            return srs_error_new(ERROR_RTP_TYPE97_CORRUPT, "requires %d only %d bytes", required_size, stream->left());
        }
        
        if ((err = audio->add_sample(sample, sample_size)) != srs_success) {
            srs_freep(err);
            return srs_error_wrap(err, "add sample");
        }
    }
    
    // parsed ok.
    completed = true;
    
    return err;
}

srs_error_t SrsRtpPacket::decode_96(SrsBuffer* stream)
{
    srs_error_t err = srs_success;
    
    // atleast 2bytes content.
    if (!stream->require(2)) {
        return srs_error_new(ERROR_RTP_TYPE96_CORRUPT, "requires 2 only %d bytes", stream->left());
    }
    
    // frame type
    // 0... .... reserverd
    // .11. .... NALU[0]&0x60
    // ...1 11.. FU indicator
    // .... ..00 reserverd
    int8_t ftv = stream->read_1bytes();
    int8_t nalu_0x60 = ftv & 0x60;
    int8_t fu_indicator = ftv & 0x1c;
    
    // nri, whatever
    // 10.. .... first chunk.
    // 00.. .... continous chunk.
    // 01.. .... last chunk.
    // ...1 1111 NALU[0]&0x1f
    int8_t nriv = stream->read_1bytes();
    bool first_chunk = (nriv & 0xC0) == 0x80;
    bool last_chunk = (nriv & 0xC0) == 0x40;
    bool contious_chunk = (nriv & 0xC0) == 0x00;
    int8_t nalu_0x1f = nriv & 0x1f;
    
    // chunked, generate the first byte NALU.
    if (fu_indicator == 0x1c && (first_chunk || last_chunk || contious_chunk)) {
        chunked = true;
        completed = last_chunk;
        
        // generate and append the first byte NALU.
        if (first_chunk) {
            int8_t nalu_byte0 = nalu_0x60 | nalu_0x1f;
            payload->append((char*)&nalu_byte0, 1);
        }
        
        payload->append(stream->data() + stream->pos(), stream->size() - stream->pos());
        return err;
    }
    
    // no chunked, append to payload.
    stream->skip(-2);
    payload->append(stream->data() + stream->pos(), stream->size() - stream->pos());
    completed = true;
    
    return err;
}

SrsRtspSdp::SrsRtspSdp()
{
    state = SrsRtspSdpStateOthers;
}

SrsRtspSdp::~SrsRtspSdp()
{
}

srs_error_t SrsRtspSdp::parse(string token)
{
    srs_error_t err = srs_success;
    
    if (token.empty()) {
        // ignore empty token
        return err;
    }
    
    size_t pos = string::npos;
    
    char* start = (char*)token.data();
    char* end = start + (int)token.length();
    char* p = start;
    
    // key, first 2bytes.
    // v=0
    // o=- 0 0 IN IP4 127.0.0.1
    // s=No Name
    // c=IN IP4 192.168.43.23
    // t=0 0
    // a=tool:libavformat 53.9.0
    // m=video 0 RTP/AVP 96
    // b=AS:850
    // a=rtpmap:96 H264/90000
    // a=fmtp:96 packetization-mode=1; sprop-parameter-sets=Z2QAKKzRwFAFu/8ALQAiEAAAAwAQAAADAwjxgxHg,aOmrLIs=
    // a=control:streamid=0
    // m=audio 0 RTP/AVP 97
    // b=AS:49
    // a=rtpmap:97 MPEG4-GENERIC/44100/2
    // a=fmtp:97 profile-level-id=1;mode=AAC-hbr;sizelength=13;indexlength=3;indexdeltalength=3; config=139056E5A0
    // a=control:streamid=1
    char key = p[0];
    p += 2;
    
    // left bytes as attr string.
    std::string attr_str;
    if (end - p) {
        attr_str.append(p, end - p);
    }
    
    // parse the attributes from left bytes.
    std::vector<std::string> attrs;
    while (p < end) {
        // parse an attribute, split by SP.
        char* pa = p;
        for (; p < end && p[0] != SRS_RTSP_SP; p++) {
        }
        std::string attr;
        if (p > pa) {
            attr.append(pa, p - pa);
            attrs.push_back(attr);
        }
        p++;
    }
    
    // parse the first attr as desc, update the first elem for desc.
    // for example, the value can be "tool", "AS", "rtpmap", "fmtp", "control"
    std::string desc_key;
    if (attrs.size() > 0) {
        std::string attr = attrs.at(0);
        if ((pos = attr.find(":")) != string::npos) {
            desc_key = attr.substr(0, pos);
            attr = attr.substr(pos + 1);
            attr_str = attr_str.substr(pos + 1);
            attrs[0] = attr;
        } else {
            desc_key = attr;
        }
    }
    
    // interpret the attribute according by key.
    switch (key) {
        case 'v': version = attr_str; break;
        case 'o':
            owner_username = (attrs.size() > 0)? attrs[0]:"";
            owner_session_id = (attrs.size() > 1)? attrs[1]:"";
            owner_session_version = (attrs.size() > 2)? attrs[2]:"";
            owner_network_type = (attrs.size() > 3)? attrs[3]:"";
            owner_address_type = (attrs.size() > 4)? attrs[4]:"";
            owner_address = (attrs.size() > 5)? attrs[5]:"";
            break;
        case 's': session_name = attr_str; break;
        case 'c':
            connection_network_type = (attrs.size() > 0)? attrs[0]:"";
            connection_address_type = (attrs.size() > 0)? attrs[0]:"";
            connection_address = (attrs.size() > 0)? attrs[0]:"";
            break;
        case 'a':
            if (desc_key == "tool") {
                tool = attr_str;
            } else if (desc_key == "rtpmap") {
                if (state == SrsRtspSdpStateVideo) {
                    video_codec = (attrs.size() > 1)? attrs[1]:"";
                    if ((pos = video_codec.find("/")) != string::npos) {
                        video_sample_rate = video_codec.substr(pos + 1);
                        video_codec = video_codec.substr(0, pos);
                    }
                } else if (state == SrsRtspSdpStateAudio) {
                    audio_codec = (attrs.size() > 1)? attrs[1]:"";
                    if ((pos = audio_codec.find("/")) != string::npos) {
                        audio_sample_rate = audio_codec.substr(pos + 1);
                        audio_codec = audio_codec.substr(0, pos);
                    }
                    if ((pos = audio_sample_rate.find("/")) != string::npos) {
                        audio_channel = audio_sample_rate.substr(pos + 1);
                        audio_sample_rate = audio_sample_rate.substr(0, pos);
                    }
                }
            } else if (desc_key == "fmtp") {
                for (int i = 1; i < (int)attrs.size(); i++) {
                    std::string attr = attrs.at(i);
                    if ((err = parse_fmtp_attribute(attr)) != srs_success) {
                        return srs_error_wrap(err, "parse fmtp attr=%s", attr.c_str());
                    }
                }
            } else if (desc_key == "control") {
                for (int i = 0; i < (int)attrs.size(); i++) {
                    std::string attr = attrs.at(i);
                    if ((err = parse_control_attribute(attr)) != srs_success) {
                        return srs_error_wrap(err, "parse control attr=%s", attr.c_str());
                    }
                }
            }
            break;
        case 'm':
            if (desc_key == "video") {
                state = SrsRtspSdpStateVideo;
                video_port = (attrs.size() > 1)? attrs[1]:"";
                video_protocol = (attrs.size() > 2)? attrs[2]:"";
                video_transport_format = (attrs.size() > 3)? attrs[3]:"";
            } else if (desc_key == "audio") {
                state = SrsRtspSdpStateAudio;
                audio_port = (attrs.size() > 1)? attrs[1]:"";
                audio_protocol = (attrs.size() > 2)? attrs[2]:"";
                audio_transport_format = (attrs.size() > 3)? attrs[3]:"";
            }
            break;
        case 'b':
            if (desc_key == "AS") {
                if (state == SrsRtspSdpStateVideo) {
                    video_bandwidth_kbps = (attrs.size() > 0)? attrs[0]:"";
                } else if (state == SrsRtspSdpStateAudio) {
                    audio_bandwidth_kbps = (attrs.size() > 0)? attrs[0]:"";
                }
            }
            break;
        case 't':
        default: break;
    }
    
    return err;
}

srs_error_t SrsRtspSdp::parse_fmtp_attribute(string attr)
{
    srs_error_t err = srs_success;
    
    size_t pos = string::npos;
    std::string token = attr;
    
    while (!token.empty()) {
        std::string item = token;
        if ((pos = item.find(";")) != string::npos) {
            item = token.substr(0, pos);
            token = token.substr(pos + 1);
        } else {
            token = "";
        }
        
        std::string item_key = item, item_value;
        if ((pos = item.find("=")) != string::npos) {
            item_key = item.substr(0, pos);
            item_value = item.substr(pos + 1);
        }
        
        if (state == SrsRtspSdpStateVideo) {
            if (item_key == "packetization-mode") {
                video_packetization_mode = item_value;
            } else if (item_key == "sprop-parameter-sets") {
                video_sps = item_value;
                if ((pos = video_sps.find(",")) != string::npos) {
                    video_pps = video_sps.substr(pos + 1);
                    video_sps = video_sps.substr(0, pos);
                }
                // decode the sps/pps by base64
                video_sps = base64_decode(video_sps);
                video_pps = base64_decode(video_pps);
            }
        } else if (state == SrsRtspSdpStateAudio) {
            if (item_key == "profile-level-id") {
                audio_profile_level_id = item_value;
            } else if (item_key == "mode") {
                audio_mode = item_value;
            } else if (item_key == "sizelength") {
                audio_size_length = item_value;
            } else if (item_key == "indexlength") {
                audio_index_length = item_value;
            } else if (item_key == "indexdeltalength") {
                audio_index_delta_length = item_value;
            } else if (item_key == "config") {
                if (item_value.length() <= 0) {
                    return srs_error_new(ERROR_RTSP_AUDIO_CONFIG, "audio config");
                }
                
                char* tmp_sh = new char[item_value.length()];
                SrsAutoFreeA(char, tmp_sh);
                
                int nb_tmp_sh = srs_hex_to_data((uint8_t*)tmp_sh, item_value.c_str(), item_value.length());
                if (nb_tmp_sh <= 0) {
                    return srs_error_new(ERROR_RTSP_AUDIO_CONFIG, "audio config");
                }
                
                audio_sh.append(tmp_sh, nb_tmp_sh);
            }
        }
    }
    
    return err;
}

srs_error_t SrsRtspSdp::parse_control_attribute(string attr)
{
    srs_error_t err = srs_success;
    
    size_t pos = string::npos;
    std::string token = attr;
    
    while (!token.empty()) {
        std::string item = token;
        if ((pos = item.find(";")) != string::npos) {
            item = token.substr(0, pos);
            token = token.substr(pos + 1);
        } else {
            token = "";
        }
        
        std::string item_key = item, item_value;
        if ((pos = item.find("=")) != string::npos) {
            item_key = item.substr(0, pos);
            item_value = item.substr(pos + 1);
        }
        
        if (state == SrsRtspSdpStateVideo) {
            if (item_key == "streamid") {
                video_stream_id = item_value;
            }
        } else if (state == SrsRtspSdpStateAudio) {
            if (item_key == "streamid") {
                audio_stream_id = item_value;
            }
        }
    }
    
    return err;
}

string SrsRtspSdp::base64_decode(string cipher)
{
    if (cipher.empty()) {
        return "";
    }
    
    string plaintext;
    srs_error_t err = srs_av_base64_decode(cipher, plaintext);
    srs_freep(err);
    
    return plaintext;
}

SrsRtspTransport::SrsRtspTransport()
{
    client_port_min = 0;
    client_port_max = 0;
}

SrsRtspTransport::~SrsRtspTransport()
{
}

srs_error_t SrsRtspTransport::parse(string attr)
{
    srs_error_t err = srs_success;
    
    size_t pos = string::npos;
    std::string token = attr;
    
    while (!token.empty()) {
        std::string item = token;
        if ((pos = item.find(";")) != string::npos) {
            item = token.substr(0, pos);
            token = token.substr(pos + 1);
        } else {
            token = "";
        }
        
        std::string item_key = item, item_value;
        if ((pos = item.find("=")) != string::npos) {
            item_key = item.substr(0, pos);
            item_value = item.substr(pos + 1);
        }
        
        if (transport.empty()) {
            transport = item_key;
            if ((pos = transport.find("/")) != string::npos) {
                profile = transport.substr(pos + 1);
                transport = transport.substr(0, pos);
            }
            if ((pos = profile.find("/")) != string::npos) {
                lower_transport = profile.substr(pos + 1);
                profile = profile.substr(0, pos);
            }
        }
        
        if (item_key == "unicast" || item_key == "multicast") {
            cast_type = item_key;
        } else if (item_key == "mode") {
            mode = item_value;
        } else if (item_key == "client_port") {
            std::string sport = item_value;
            std::string eport = item_value;
            if ((pos = eport.find("-")) != string::npos) {
                sport = eport.substr(0, pos);
                eport = eport.substr(pos + 1);
            }
            client_port_min = ::atoi(sport.c_str());
            client_port_max = ::atoi(eport.c_str());
        }
    }
    
    return err;
}

SrsRtspRequest::SrsRtspRequest()
{
    seq = 0;
    content_length = 0;
    stream_id = 0;
    sdp = NULL;
    transport = NULL;
}

SrsRtspRequest::~SrsRtspRequest()
{
    srs_freep(sdp);
    srs_freep(transport);
}

bool SrsRtspRequest::is_options()
{
    return method == SRS_METHOD_OPTIONS;
}

bool SrsRtspRequest::is_announce()
{
    return method == SRS_METHOD_ANNOUNCE;
}

bool SrsRtspRequest::is_setup()
{
    return method == SRS_METHOD_SETUP;
}

bool SrsRtspRequest::is_record()
{
    return method == SRS_METHOD_RECORD;
}

SrsRtspResponse::SrsRtspResponse(int cseq)
{
    seq = cseq;
    status = SRS_CONSTS_RTSP_OK;
}

SrsRtspResponse::~SrsRtspResponse()
{
}

srs_error_t SrsRtspResponse::encode(stringstream& ss)
{
    srs_error_t err = srs_success;
    
    // status line
    ss << SRS_RTSP_VERSION << SRS_RTSP_SP
    << status << SRS_RTSP_SP
    << srs_generate_rtsp_status_text(status) << SRS_RTSP_CRLF;
    
    // cseq
    ss << SRS_RTSP_TOKEN_CSEQ << ":" << SRS_RTSP_SP << seq << SRS_RTSP_CRLF;
    
    // others.
    ss << "Cache-Control: no-store" << SRS_RTSP_CRLF
    << "Pragma: no-cache" << SRS_RTSP_CRLF
    << "Server: " << RTMP_SIG_SRS_SERVER << SRS_RTSP_CRLF;
    
    // session if specified.
    if (!session.empty()) {
        ss << SRS_RTSP_TOKEN_SESSION << ":" << session << SRS_RTSP_CRLF;
    }
    
    if ((err = encode_header(ss)) != srs_success) {
        return srs_error_wrap(err, "encode header");
    };
    
    // header EOF.
    ss << SRS_RTSP_CRLF;
    
    return err;
}

srs_error_t SrsRtspResponse::encode_header(std::stringstream& ss)
{
    return srs_success;
}

SrsRtspOptionsResponse::SrsRtspOptionsResponse(int cseq) : SrsRtspResponse(cseq)
{
    methods = (SrsRtspMethod)(SrsRtspMethodDescribe | SrsRtspMethodOptions
        | SrsRtspMethodPause | SrsRtspMethodPlay | SrsRtspMethodSetup | SrsRtspMethodTeardown
        | SrsRtspMethodAnnounce | SrsRtspMethodRecord);
}

SrsRtspOptionsResponse::~SrsRtspOptionsResponse()
{
}

srs_error_t SrsRtspOptionsResponse::encode_header(stringstream& ss)
{
    SrsRtspMethod rtsp_methods[] = {
        SrsRtspMethodDescribe,
        SrsRtspMethodAnnounce,
        SrsRtspMethodGetParameter,
        SrsRtspMethodOptions,
        SrsRtspMethodPause,
        SrsRtspMethodPlay,
        SrsRtspMethodRecord,
        SrsRtspMethodRedirect,
        SrsRtspMethodSetup,
        SrsRtspMethodSetParameter,
        SrsRtspMethodTeardown,
    };
    
    ss << SRS_RTSP_TOKEN_PUBLIC << ":" << SRS_RTSP_SP;
    
    bool appended = false;
    int nb_methods = (int)(sizeof(rtsp_methods) / sizeof(SrsRtspMethod));
    for (int i = 0; i < nb_methods; i++) {
        SrsRtspMethod method = rtsp_methods[i];
        if (((int)methods & (int)method) != (int)method) {
            continue;
        }
        
        if (appended) {
            ss << ", ";
        }
        ss << srs_generate_rtsp_method_str(method);
        appended = true;
    }
    ss << SRS_RTSP_CRLF;
    
    return srs_success;
}

SrsRtspSetupResponse::SrsRtspSetupResponse(int seq) : SrsRtspResponse(seq)
{
    local_port_min = 0;
    local_port_max = 0;
}

SrsRtspSetupResponse::~SrsRtspSetupResponse()
{
}

srs_error_t SrsRtspSetupResponse::encode_header(stringstream& ss)
{
    ss << SRS_RTSP_TOKEN_SESSION << ":" << SRS_RTSP_SP << session << SRS_RTSP_CRLF;
    ss << SRS_RTSP_TOKEN_TRANSPORT << ":" << SRS_RTSP_SP
    << "RTP/AVP;unicast;client_port=" << client_port_min << "-" << client_port_max << ";"
    << "server_port=" << local_port_min << "-" << local_port_max
    << SRS_RTSP_CRLF;
    return srs_success;
}

SrsRtspStack::SrsRtspStack(ISrsProtocolReaderWriter* s)
{
    buf = new SrsSimpleStream();
    skt = s;
}

SrsRtspStack::~SrsRtspStack()
{
    srs_freep(buf);
}

srs_error_t SrsRtspStack::recv_message(SrsRtspRequest** preq)
{
    srs_error_t err = srs_success;
    
    SrsRtspRequest* req = new SrsRtspRequest();
    if ((err = do_recv_message(req)) != srs_success) {
        srs_freep(req);
        return srs_error_wrap(err, "recv message");
    }
    
    *preq = req;
    
    return err;
}

srs_error_t SrsRtspStack::send_message(SrsRtspResponse* res)
{
    srs_error_t err = srs_success;
    
    std::stringstream ss;
    // encode the message to string.
    res->encode(ss);
    
    std::string str = ss.str();
    srs_assert(!str.empty());
    
    if ((err = skt->write((char*)str.c_str(), (int)str.length(), NULL)) != srs_success) {
        return srs_error_wrap(err, "write message");
    }
    
    return err;
}

srs_error_t SrsRtspStack::do_recv_message(SrsRtspRequest* req)
{
    srs_error_t err = srs_success;
    
    // parse request line.
    if ((err = recv_token_normal(req->method)) != srs_success) {
        return srs_error_wrap(err, "method");
    }
    
    if ((err = recv_token_normal(req->uri)) != srs_success) {
        return srs_error_wrap(err, "uri");
    }
    
    if ((err = recv_token_eof(req->version)) != srs_success) {
        return srs_error_wrap(err, "version");
    }
    
    // parse headers.
    for (;;) {
        // parse the header name
        std::string token;
        if ((err = recv_token_normal(token)) != srs_success) {
            if (srs_error_code(err) == ERROR_RTSP_REQUEST_HEADER_EOF) {
                srs_error_reset(err);
                break;
            }
            return srs_error_wrap(err, "recv token");
        }
        
        // parse the header value according by header name
        if (token == SRS_RTSP_TOKEN_CSEQ) {
            std::string seq;
            if ((err = recv_token_eof(seq)) != srs_success) {
                return srs_error_wrap(err, "seq");
            }
            req->seq = ::atol(seq.c_str());
        } else if (token == SRS_RTSP_TOKEN_CONTENT_TYPE) {
            std::string ct;
            if ((err = recv_token_eof(ct)) != srs_success) {
                return srs_error_wrap(err, "ct");
            }
            req->content_type = ct;
        } else if (token == SRS_RTSP_TOKEN_CONTENT_LENGTH) {
            std::string cl;
            if ((err = recv_token_eof(cl)) != srs_success) {
                return srs_error_wrap(err, "cl");
            }
            req->content_length = ::atol(cl.c_str());
        } else if (token == SRS_RTSP_TOKEN_TRANSPORT) {
            std::string transport;
            if ((err = recv_token_eof(transport)) != srs_success) {
                return srs_error_wrap(err, "transport");
            }
            if (!req->transport) {
                req->transport = new SrsRtspTransport();
            }
            if ((err = req->transport->parse(transport)) != srs_success) {
                return srs_error_wrap(err, "parse transport=%s", transport.c_str());
            }
        } else if (token == SRS_RTSP_TOKEN_SESSION) {
            if ((err = recv_token_eof(req->session)) != srs_success) {
                return srs_error_wrap(err, "session");
            }
        } else {
            // unknown header name, parse util EOF.
            SrsRtspTokenState state = SrsRtspTokenStateNormal;
            while (state == SrsRtspTokenStateNormal) {
                std::string value;
                if ((err = recv_token(value, state)) != srs_success) {
                    return srs_error_wrap(err, "state");
                }
                srs_trace("rtsp: ignore header %s=%s", token.c_str(), value.c_str());
            }
        }
    }
    
    // for setup, parse the stream id from uri.
    if (req->is_setup()) {
        size_t pos = string::npos;
        std::string stream_id = srs_path_basename(req->uri);
        if ((pos = stream_id.find("=")) != string::npos) {
            stream_id = stream_id.substr(pos + 1);
        }
        req->stream_id = ::atoi(stream_id.c_str());
        srs_info("rtsp: setup stream id=%d", req->stream_id);
    }
    
    // parse rdp body.
    long consumed = 0;
    while (consumed < req->content_length) {
        if (!req->sdp) {
            req->sdp = new SrsRtspSdp();
        }
        
        int nb_token = 0;
        std::string token;
        if ((err = recv_token_util_eof(token, &nb_token)) != srs_success) {
            return srs_error_wrap(err, "recv token");
        }
        consumed += nb_token;
        
        if ((err = req->sdp->parse(token)) != srs_success) {
            return srs_error_wrap(err, "parse token");
        }
    }
    
    return err;
}

srs_error_t SrsRtspStack::recv_token_normal(std::string& token)
{
    srs_error_t err = srs_success;
    
    SrsRtspTokenState state;
    
    if ((err = recv_token(token, state)) != srs_success) {
        if (srs_error_code(err) == ERROR_RTSP_REQUEST_HEADER_EOF) {
            return srs_error_wrap(err, "EOF");
        }
        return srs_error_wrap(err, "recv token");
    }
    
    if (state != SrsRtspTokenStateNormal) {
        return srs_error_new(ERROR_RTSP_TOKEN_NOT_NORMAL, "invalid state=%d", state);
    }
    
    return err;
}

srs_error_t SrsRtspStack::recv_token_eof(std::string& token)
{
    srs_error_t err = srs_success;
    
    SrsRtspTokenState state;
    
    if ((err = recv_token(token, state)) != srs_success) {
        if (srs_error_code(err) == ERROR_RTSP_REQUEST_HEADER_EOF) {
            return srs_error_wrap(err, "EOF");
        }
        return srs_error_wrap(err, "recv token");
    }
    
    if (state != SrsRtspTokenStateEOF) {
        return srs_error_new(ERROR_RTSP_TOKEN_NOT_NORMAL, "invalid state=%d", state);
    }
    
    return err;
}

srs_error_t SrsRtspStack::recv_token_util_eof(std::string& token, int* pconsumed)
{
    srs_error_t err = srs_success;
    
    SrsRtspTokenState state;
    
    // use 0x00 as ignore the normal token flag.
    if ((err = recv_token(token, state, 0x00, pconsumed)) != srs_success) {
        if (srs_error_code(err) == ERROR_RTSP_REQUEST_HEADER_EOF) {
            return srs_error_wrap(err, "EOF");
        }
        return srs_error_wrap(err, "recv token");
    }
    
    if (state != SrsRtspTokenStateEOF) {
        return srs_error_new(ERROR_RTSP_TOKEN_NOT_NORMAL, "invalid state=%d", state);
    }
    
    return err;
}

srs_error_t SrsRtspStack::recv_token(std::string& token, SrsRtspTokenState& state, char normal_ch, int* pconsumed)
{
    srs_error_t err = srs_success;
    
    // whatever, default to error state.
    state = SrsRtspTokenStateError;
    
    // when buffer is empty, append bytes first.
    bool append_bytes = buf->length() == 0;
    
    // parse util token.
    for (;;) {
        // append bytes if required.
        if (append_bytes) {
            append_bytes = false;
            
            char buffer[SRS_RTSP_BUFFER];
            ssize_t nb_read = 0;
            if ((err = skt->read(buffer, SRS_RTSP_BUFFER, &nb_read)) != srs_success) {
                return srs_error_wrap(err, "recv data");
            }
            
            buf->append(buffer, (int)nb_read);
        }
        
        // parse one by one.
        char* start = buf->bytes();
        char* end = start + buf->length();
        char* p = start;
        
        // find util SP/CR/LF, max 2 EOF, to finger out the EOF of message.
        for (; p < end && p[0] != normal_ch && p[0] != SRS_RTSP_CR && p[0] != SRS_RTSP_LF; p++) {
        }
        
        // matched.
        if (p < end) {
            // finger out the state.
            if (p[0] == normal_ch) {
                state = SrsRtspTokenStateNormal;
            } else {
                state = SrsRtspTokenStateEOF;
            }
            
            // got the token.
            int nb_token = (int)(p - start);
            // trim last ':' character.
            if (nb_token && p[-1] == ':') {
                nb_token--;
            }
            if (nb_token) {
                token.append(start, nb_token);
            } else {
                err = srs_error_new(ERROR_RTSP_REQUEST_HEADER_EOF, "EOF");
            }
            
            // ignore SP/CR/LF
            for (int i = 0; i < 2 && p < end && (p[0] == normal_ch || p[0] == SRS_RTSP_CR || p[0] == SRS_RTSP_LF); p++, i++) {
            }
            
            // consume the token bytes.
            srs_assert(p - start);
            buf->erase((int)(p - start));
            if (pconsumed) {
                *pconsumed = (int)(p - start);
            }
            break;
        }
        
        // append more and parse again.
        append_bytes = true;
    }
    
    return err;
}

#endif

#endif

// following is generated by src/protocol/srs_http_stack.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_http_stack.hpp>

#if !defined(SRS_EXPORT_LIBRTMP)

#include <stdlib.h>
#include <sstream>
#include <algorithm>
using namespace std;

//#include <srs_kernel_error.hpp>
//#include <srs_kernel_log.hpp>
//#include <srs_kernel_utility.hpp>
//#include <srs_kernel_file.hpp>
//#include <srs_protocol_json.hpp>

#define SRS_HTTP_DEFAULT_PAGE "index.html"

// get the status text of code.
string srs_generate_http_status_text(int status)
{
    static std::map<int, std::string> _status_map;
    if (_status_map.empty()) {
        _status_map[SRS_CONSTS_HTTP_Continue] = SRS_CONSTS_HTTP_Continue_str;
        _status_map[SRS_CONSTS_HTTP_SwitchingProtocols] = SRS_CONSTS_HTTP_SwitchingProtocols_str;
        _status_map[SRS_CONSTS_HTTP_OK] = SRS_CONSTS_HTTP_OK_str;
        _status_map[SRS_CONSTS_HTTP_Created] = SRS_CONSTS_HTTP_Created_str;
        _status_map[SRS_CONSTS_HTTP_Accepted] = SRS_CONSTS_HTTP_Accepted_str;
        _status_map[SRS_CONSTS_HTTP_NonAuthoritativeInformation] = SRS_CONSTS_HTTP_NonAuthoritativeInformation_str;
        _status_map[SRS_CONSTS_HTTP_NoContent] = SRS_CONSTS_HTTP_NoContent_str;
        _status_map[SRS_CONSTS_HTTP_ResetContent] = SRS_CONSTS_HTTP_ResetContent_str;
        _status_map[SRS_CONSTS_HTTP_PartialContent] = SRS_CONSTS_HTTP_PartialContent_str;
        _status_map[SRS_CONSTS_HTTP_MultipleChoices] = SRS_CONSTS_HTTP_MultipleChoices_str;
        _status_map[SRS_CONSTS_HTTP_MovedPermanently] = SRS_CONSTS_HTTP_MovedPermanently_str;
        _status_map[SRS_CONSTS_HTTP_Found] = SRS_CONSTS_HTTP_Found_str;
        _status_map[SRS_CONSTS_HTTP_SeeOther] = SRS_CONSTS_HTTP_SeeOther_str;
        _status_map[SRS_CONSTS_HTTP_NotModified] = SRS_CONSTS_HTTP_NotModified_str;
        _status_map[SRS_CONSTS_HTTP_UseProxy] = SRS_CONSTS_HTTP_UseProxy_str;
        _status_map[SRS_CONSTS_HTTP_TemporaryRedirect] = SRS_CONSTS_HTTP_TemporaryRedirect_str;
        _status_map[SRS_CONSTS_HTTP_BadRequest] = SRS_CONSTS_HTTP_BadRequest_str;
        _status_map[SRS_CONSTS_HTTP_Unauthorized] = SRS_CONSTS_HTTP_Unauthorized_str;
        _status_map[SRS_CONSTS_HTTP_PaymentRequired] = SRS_CONSTS_HTTP_PaymentRequired_str;
        _status_map[SRS_CONSTS_HTTP_Forbidden] = SRS_CONSTS_HTTP_Forbidden_str;
        _status_map[SRS_CONSTS_HTTP_NotFound] = SRS_CONSTS_HTTP_NotFound_str;
        _status_map[SRS_CONSTS_HTTP_MethodNotAllowed] = SRS_CONSTS_HTTP_MethodNotAllowed_str;
        _status_map[SRS_CONSTS_HTTP_NotAcceptable] = SRS_CONSTS_HTTP_NotAcceptable_str;
        _status_map[SRS_CONSTS_HTTP_ProxyAuthenticationRequired] = SRS_CONSTS_HTTP_ProxyAuthenticationRequired_str;
        _status_map[SRS_CONSTS_HTTP_RequestTimeout] = SRS_CONSTS_HTTP_RequestTimeout_str;
        _status_map[SRS_CONSTS_HTTP_Conflict] = SRS_CONSTS_HTTP_Conflict_str;
        _status_map[SRS_CONSTS_HTTP_Gone] = SRS_CONSTS_HTTP_Gone_str;
        _status_map[SRS_CONSTS_HTTP_LengthRequired] = SRS_CONSTS_HTTP_LengthRequired_str;
        _status_map[SRS_CONSTS_HTTP_PreconditionFailed] = SRS_CONSTS_HTTP_PreconditionFailed_str;
        _status_map[SRS_CONSTS_HTTP_RequestEntityTooLarge] = SRS_CONSTS_HTTP_RequestEntityTooLarge_str;
        _status_map[SRS_CONSTS_HTTP_RequestURITooLarge] = SRS_CONSTS_HTTP_RequestURITooLarge_str;
        _status_map[SRS_CONSTS_HTTP_UnsupportedMediaType] = SRS_CONSTS_HTTP_UnsupportedMediaType_str;
        _status_map[SRS_CONSTS_HTTP_RequestedRangeNotSatisfiable] = SRS_CONSTS_HTTP_RequestedRangeNotSatisfiable_str;
        _status_map[SRS_CONSTS_HTTP_ExpectationFailed] = SRS_CONSTS_HTTP_ExpectationFailed_str;
        _status_map[SRS_CONSTS_HTTP_InternalServerError] = SRS_CONSTS_HTTP_InternalServerError_str;
        _status_map[SRS_CONSTS_HTTP_NotImplemented] = SRS_CONSTS_HTTP_NotImplemented_str;
        _status_map[SRS_CONSTS_HTTP_BadGateway] = SRS_CONSTS_HTTP_BadGateway_str;
        _status_map[SRS_CONSTS_HTTP_ServiceUnavailable] = SRS_CONSTS_HTTP_ServiceUnavailable_str;
        _status_map[SRS_CONSTS_HTTP_GatewayTimeout] = SRS_CONSTS_HTTP_GatewayTimeout_str;
        _status_map[SRS_CONSTS_HTTP_HTTPVersionNotSupported] = SRS_CONSTS_HTTP_HTTPVersionNotSupported_str;
    }
    
    std::string status_text;
    if (_status_map.find(status) == _status_map.end()) {
        status_text = "Status Unknown";
    } else {
        status_text = _status_map[status];
    }
    
    return status_text;
}

// bodyAllowedForStatus reports whether a given response status code
// permits a body.  See RFC2616, section 4.4.
bool srs_go_http_body_allowd(int status)
{
    if (status >= 100 && status <= 199) {
        return false;
    } else if (status == 204 || status == 304) {
        return false;
    }
    
    return true;
}

// DetectContentType implements the algorithm described
// at http://mimesniff.spec.whatwg.org/ to determine the
// Content-Type of the given data.  It considers at most the
// first 512 bytes of data.  DetectContentType always returns
// a valid MIME type: if it cannot determine a more specific one, it
// returns "application/octet-stream".
string srs_go_http_detect(char* data, int size)
{
    // detect only when data specified.
    if (data) {
    }
    return "application/octet-stream"; // fallback
}

srs_error_t srs_go_http_error(ISrsHttpResponseWriter* w, int code)
{
    return srs_go_http_error(w, code, srs_generate_http_status_text(code));
}

srs_error_t srs_go_http_error(ISrsHttpResponseWriter* w, int code, string error)
{
    srs_error_t err = srs_success;
    
    w->header()->set_content_type("text/plain; charset=utf-8");
    w->header()->set_content_length(error.length());
    w->write_header(code);
    
    if ((err = w->write((char*)error.data(), (int)error.length())) != srs_success) {
        return srs_error_wrap(err, "http write");
    }
    
    return err;
}

SrsHttpHeader::SrsHttpHeader()
{
}

SrsHttpHeader::~SrsHttpHeader()
{
}

void SrsHttpHeader::set(string key, string value)
{
    headers[key] = value;
}

string SrsHttpHeader::get(string key)
{
    std::string v;
    
    if (headers.find(key) != headers.end()) {
        v = headers[key];
    }
    
    return v;
}

int64_t SrsHttpHeader::content_length()
{
    std::string cl = get("Content-Length");
    
    if (cl.empty()) {
        return -1;
    }
    
    return (int64_t)::atof(cl.c_str());
}

void SrsHttpHeader::set_content_length(int64_t size)
{
    set("Content-Length", srs_int2str(size));
}

string SrsHttpHeader::content_type()
{
    return get("Content-Type");
}

void SrsHttpHeader::set_content_type(string ct)
{
    set("Content-Type", ct);
}

void SrsHttpHeader::write(stringstream& ss)
{
    std::map<std::string, std::string>::iterator it;
    for (it = headers.begin(); it != headers.end(); ++it) {
        ss << it->first << ": " << it->second << SRS_HTTP_CRLF;
    }
}

ISrsHttpResponseWriter::ISrsHttpResponseWriter()
{
}

ISrsHttpResponseWriter::~ISrsHttpResponseWriter()
{
}

ISrsHttpResponseReader::ISrsHttpResponseReader()
{
}

ISrsHttpResponseReader::~ISrsHttpResponseReader()
{
}

ISrsHttpHandler::ISrsHttpHandler()
{
    entry = NULL;
}

ISrsHttpHandler::~ISrsHttpHandler()
{
}

bool ISrsHttpHandler::is_not_found()
{
    return false;
}

SrsHttpRedirectHandler::SrsHttpRedirectHandler(string u, int c)
{
    url = u;
    code = c;
}

SrsHttpRedirectHandler::~SrsHttpRedirectHandler()
{
}

srs_error_t SrsHttpRedirectHandler::serve_http(ISrsHttpResponseWriter* w, ISrsHttpMessage* r)
{
    string location = url;
    if (!r->query().empty()) {
        location += "?" + r->query();
    }
    
    string msg = "Redirect to" + location;
    
    w->header()->set_content_type("text/plain; charset=utf-8");
    w->header()->set_content_length(msg.length());
    w->header()->set("Location", location);
    w->write_header(code);
    
    w->write((char*)msg.data(), (int)msg.length());
    w->final_request();
    
    srs_info("redirect to %s.", location.c_str());
    return srs_success;
}

SrsHttpNotFoundHandler::SrsHttpNotFoundHandler()
{
}

SrsHttpNotFoundHandler::~SrsHttpNotFoundHandler()
{
}

bool SrsHttpNotFoundHandler::is_not_found()
{
    return true;
}

srs_error_t SrsHttpNotFoundHandler::serve_http(ISrsHttpResponseWriter* w, ISrsHttpMessage* r)
{
    return srs_go_http_error(w, SRS_CONSTS_HTTP_NotFound);
}

SrsHttpFileServer::SrsHttpFileServer(string root_dir)
{
    dir = root_dir;
}

SrsHttpFileServer::~SrsHttpFileServer()
{
}

srs_error_t SrsHttpFileServer::serve_http(ISrsHttpResponseWriter* w, ISrsHttpMessage* r)
{
    string upath = r->path();
    
    // add default pages.
    if (srs_string_ends_with(upath, "/")) {
        upath += SRS_HTTP_DEFAULT_PAGE;
    }
    
    string fullpath = dir + "/";
    
    // remove the virtual directory.
    srs_assert(entry);
    size_t pos = entry->pattern.find("/");
    if (upath.length() > entry->pattern.length() && pos != string::npos) {
        fullpath += upath.substr(entry->pattern.length() - pos);
    } else {
        fullpath += upath;
    }
    
    // stat current dir, if exists, return error.
    if (!srs_path_exists(fullpath)) {
        srs_warn("http miss file=%s, pattern=%s, upath=%s",
                 fullpath.c_str(), entry->pattern.c_str(), upath.c_str());
        return SrsHttpNotFoundHandler().serve_http(w, r);
    }
    srs_trace("http match file=%s, pattern=%s, upath=%s",
              fullpath.c_str(), entry->pattern.c_str(), upath.c_str());
    
    // handle file according to its extension.
    // use vod stream for .flv/.fhv
    if (srs_string_ends_with(fullpath, ".flv") || srs_string_ends_with(fullpath, ".fhv")) {
        return serve_flv_file(w, r, fullpath);
    } else if (srs_string_ends_with(fullpath, ".mp4")) {
        return serve_mp4_file(w, r, fullpath);
    }
    
    // serve common static file.
    return serve_file(w, r, fullpath);
}

srs_error_t SrsHttpFileServer::serve_file(ISrsHttpResponseWriter* w, ISrsHttpMessage* r, string fullpath)
{
    srs_error_t err = srs_success;
    
    // open the target file.
    SrsFileReader fs;
    
    if ((err = fs.open(fullpath)) != srs_success) {
        return srs_error_wrap(err, "open file %s", fullpath.c_str());
    }
    
    int64_t length = fs.filesize();
    
    // unset the content length to encode in chunked encoding.
    w->header()->set_content_length(length);
    
    static std::map<std::string, std::string> _mime;
    if (_mime.empty()) {
        _mime[".ts"] = "video/MP2T";
        _mime[".flv"] = "video/x-flv";
        _mime[".m4v"] = "video/x-m4v";
        _mime[".3gpp"] = "video/3gpp";
        _mime[".3gp"] = "video/3gpp";
        _mime[".mp4"] = "video/mp4";
        _mime[".aac"] = "audio/x-aac";
        _mime[".mp3"] = "audio/mpeg";
        _mime[".m4a"] = "audio/x-m4a";
        _mime[".ogg"] = "audio/ogg";
        // @see hls-m3u8-draft-pantos-http-live-streaming-12.pdf, page 5.
        _mime[".m3u8"] = "application/vnd.apple.mpegurl"; // application/x-mpegURL
        _mime[".rss"] = "application/rss+xml";
        _mime[".json"] = "application/json";
        _mime[".swf"] = "application/x-shockwave-flash";
        _mime[".doc"] = "application/msword";
        _mime[".zip"] = "application/zip";
        _mime[".rar"] = "application/x-rar-compressed";
        _mime[".xml"] = "text/xml";
        _mime[".html"] = "text/html";
        _mime[".js"] = "text/javascript";
        _mime[".css"] = "text/css";
        _mime[".ico"] = "image/x-icon";
        _mime[".png"] = "image/png";
        _mime[".jpeg"] = "image/jpeg";
        _mime[".jpg"] = "image/jpeg";
        _mime[".gif"] = "image/gif";
        // For MPEG-DASH.
        //_mime[".mpd"] = "application/dash+xml";
        _mime[".mpd"] = "text/xml";
        _mime[".m4s"] = "video/iso.segment";
        _mime[".mp4v"] = "video/mp4";
    }
    
    if (true) {
        std::string ext = srs_path_filext(fullpath);
        
        if (_mime.find(ext) == _mime.end()) {
            w->header()->set_content_type("application/octet-stream");
        } else {
            w->header()->set_content_type(_mime[ext]);
        }
    }
    
    // write body.
    int64_t left = length;
    if ((err = copy(w, &fs, r, (int)left)) != srs_success) {
        return srs_error_wrap(err, "copy file=%s size=%d", fullpath.c_str(), left);
    }
    
    if ((err = w->final_request()) != srs_success) {
        return srs_error_wrap(err, "final request");
    }
    
    return err;
}

srs_error_t SrsHttpFileServer::serve_flv_file(ISrsHttpResponseWriter* w, ISrsHttpMessage* r, string fullpath)
{
    std::string start = r->query_get("start");
    if (start.empty()) {
        return serve_file(w, r, fullpath);
    }
    
    int offset = ::atoi(start.c_str());
    if (offset <= 0) {
        return serve_file(w, r, fullpath);
    }
    
    return serve_flv_stream(w, r, fullpath, offset);
}

srs_error_t SrsHttpFileServer::serve_mp4_file(ISrsHttpResponseWriter* w, ISrsHttpMessage* r, string fullpath)
{
    // for flash to request mp4 range in query string.
    // for example, http://digitalprimates.net/dash/DashTest.html?url=http://dashdemo.edgesuite.net/digitalprimates/nexus/oops-20120802-manifest.mpd
    std::string range = r->query_get("range");
    // or, use bytes to request range,
    // for example, http://dashas.castlabs.com/demo/try.html
    if (range.empty()) {
        range = r->query_get("bytes");
    }
    
    // rollback to serve whole file.
    size_t pos = string::npos;
    if (range.empty() || (pos = range.find("-")) == string::npos) {
        return serve_file(w, r, fullpath);
    }
    
    // parse the start in query string
    int start = 0;
    if (pos > 0) {
        start = ::atoi(range.substr(0, pos).c_str());
    }
    
    // parse end in query string.
    int end = -1;
    if (pos < range.length() - 1) {
        end = ::atoi(range.substr(pos + 1).c_str());
    }
    
    // invalid param, serve as whole mp4 file.
    if (start < 0 || (end != -1 && start > end)) {
        return serve_file(w, r, fullpath);
    }
    
    return serve_mp4_stream(w, r, fullpath, start, end);
}

srs_error_t SrsHttpFileServer::serve_flv_stream(ISrsHttpResponseWriter* w, ISrsHttpMessage* r, string fullpath, int offset)
{
    return serve_file(w, r, fullpath);
}

srs_error_t SrsHttpFileServer::serve_mp4_stream(ISrsHttpResponseWriter* w, ISrsHttpMessage* r, string fullpath, int start, int end)
{
    return serve_file(w, r, fullpath);
}

srs_error_t SrsHttpFileServer::copy(ISrsHttpResponseWriter* w, SrsFileReader* fs, ISrsHttpMessage* r, int size)
{
    srs_error_t err = srs_success;
    
    int left = size;
    char* buf = r->http_ts_send_buffer();
    
    while (left > 0) {
        ssize_t nread = -1;
        int max_read = srs_min(left, SRS_HTTP_TS_SEND_BUFFER_SIZE);
        if ((err = fs->read(buf, max_read, &nread)) != srs_success) {
            break;
        }
        
        left -= nread;
        if ((err = w->write(buf, (int)nread)) != srs_success) {
            break;
        }
    }
    
    if (err != srs_success) {
        return srs_error_wrap(err, "copy");
    }
    
    return err;
}

SrsHttpMuxEntry::SrsHttpMuxEntry()
{
    enabled = true;
    explicit_match = false;
    handler = NULL;
}

SrsHttpMuxEntry::~SrsHttpMuxEntry()
{
    srs_freep(handler);
}

ISrsHttpMatchHijacker::ISrsHttpMatchHijacker()
{
}

ISrsHttpMatchHijacker::~ISrsHttpMatchHijacker()
{
}

ISrsHttpServeMux::ISrsHttpServeMux()
{
}

ISrsHttpServeMux::~ISrsHttpServeMux()
{
}

SrsHttpServeMux::SrsHttpServeMux()
{
}

SrsHttpServeMux::~SrsHttpServeMux()
{
    std::map<std::string, SrsHttpMuxEntry*>::iterator it;
    for (it = entries.begin(); it != entries.end(); ++it) {
        SrsHttpMuxEntry* entry = it->second;
        srs_freep(entry);
    }
    entries.clear();
    
    vhosts.clear();
    hijackers.clear();
}

srs_error_t SrsHttpServeMux::initialize()
{
    srs_error_t err = srs_success;
    
    // TODO: FIXME: Implements it.
    
    return err;
}

void SrsHttpServeMux::hijack(ISrsHttpMatchHijacker* h)
{
    std::vector<ISrsHttpMatchHijacker*>::iterator it = ::find(hijackers.begin(), hijackers.end(), h);
    if (it != hijackers.end()) {
        return;
    }
    hijackers.push_back(h);
}

void SrsHttpServeMux::unhijack(ISrsHttpMatchHijacker* h)
{
    std::vector<ISrsHttpMatchHijacker*>::iterator it = ::find(hijackers.begin(), hijackers.end(), h);
    if (it == hijackers.end()) {
        return;
    }
    hijackers.erase(it);
}

srs_error_t SrsHttpServeMux::handle(std::string pattern, ISrsHttpHandler* handler)
{
    srs_assert(handler);
    
    if (pattern.empty()) {
        return srs_error_new(ERROR_HTTP_PATTERN_EMPTY, "empty pattern");
    }
    
    if (entries.find(pattern) != entries.end()) {
        SrsHttpMuxEntry* exists = entries[pattern];
        if (exists->explicit_match) {
            return srs_error_new(ERROR_HTTP_PATTERN_DUPLICATED, "pattern=%s exists", pattern.c_str());
        }
    }
    
    std::string vhost = pattern;
    if (pattern.at(0) != '/') {
        if (pattern.find("/") != string::npos) {
            vhost = pattern.substr(0, pattern.find("/"));
        }
        vhosts[vhost] = handler;
    }
    
    if (true) {
        SrsHttpMuxEntry* entry = new SrsHttpMuxEntry();
        entry->explicit_match = true;
        entry->handler = handler;
        entry->pattern = pattern;
        entry->handler->entry = entry;
        
        if (entries.find(pattern) != entries.end()) {
            SrsHttpMuxEntry* exists = entries[pattern];
            srs_freep(exists);
        }
        entries[pattern] = entry;
    }
    
    // Helpful behavior:
    // If pattern is /tree/, insert an implicit permanent redirect for /tree.
    // It can be overridden by an explicit registration.
    if (pattern != "/" && !pattern.empty() && pattern.at(pattern.length() - 1) == '/') {
        std::string rpattern = pattern.substr(0, pattern.length() - 1);
        SrsHttpMuxEntry* entry = NULL;
        
        // free the exists not explicit entry
        if (entries.find(rpattern) != entries.end()) {
            SrsHttpMuxEntry* exists = entries[rpattern];
            if (!exists->explicit_match) {
                entry = exists;
            }
        }
        
        // create implicit redirect.
        if (!entry || entry->explicit_match) {
            srs_freep(entry);
            
            entry = new SrsHttpMuxEntry();
            entry->explicit_match = false;
            entry->handler = new SrsHttpRedirectHandler(pattern, SRS_CONSTS_HTTP_Found);
            entry->pattern = pattern;
            entry->handler->entry = entry;
            
            entries[rpattern] = entry;
        }
    }
    
    return srs_success;
}

srs_error_t SrsHttpServeMux::serve_http(ISrsHttpResponseWriter* w, ISrsHttpMessage* r)
{
    srs_error_t err = srs_success;
    
    ISrsHttpHandler* h = NULL;
    if ((err = find_handler(r, &h)) != srs_success) {
        return srs_error_wrap(err, "find handler");
    }
    
    srs_assert(h);
    if ((err = h->serve_http(w, r)) != srs_success) {
        return srs_error_wrap(err, "serve http");
    }
    
    return err;
}

srs_error_t SrsHttpServeMux::find_handler(ISrsHttpMessage* r, ISrsHttpHandler** ph)
{
    srs_error_t err = srs_success;
    
    // TODO: FIXME: support the path . and ..
    if (r->url().find("..") != std::string::npos) {
        return srs_error_new(ERROR_HTTP_URL_NOT_CLEAN, "url %s not canonical", r->url().c_str());
    }
    
    if ((err = match(r, ph)) != srs_success) {
        return srs_error_wrap(err, "http match");
    }
    
    // always hijack.
    if (!hijackers.empty()) {
        // notice all hijacker the match failed.
        std::vector<ISrsHttpMatchHijacker*>::iterator it;
        for (it = hijackers.begin(); it != hijackers.end(); ++it) {
            ISrsHttpMatchHijacker* hijacker = *it;
            if ((err = hijacker->hijack(r, ph)) != srs_success) {
                return srs_error_wrap(err, "http hijack");
            }
        }
    }
    
    static ISrsHttpHandler* h404 = new SrsHttpNotFoundHandler();
    if (*ph == NULL) {
        *ph = h404;
    }
    
    return err;
}

srs_error_t SrsHttpServeMux::match(ISrsHttpMessage* r, ISrsHttpHandler** ph)
{
    std::string path = r->path();
    
    // Host-specific pattern takes precedence over generic ones
    if (!vhosts.empty() && vhosts.find(r->host()) != vhosts.end()) {
        path = r->host() + path;
    }
    
    int nb_matched = 0;
    ISrsHttpHandler* h = NULL;
    
    std::map<std::string, SrsHttpMuxEntry*>::iterator it;
    for (it = entries.begin(); it != entries.end(); ++it) {
        std::string pattern = it->first;
        SrsHttpMuxEntry* entry = it->second;
        
        if (!entry->enabled) {
            continue;
        }
        
        if (!path_match(pattern, path)) {
            continue;
        }
        
        if (!h || (int)pattern.length() > nb_matched) {
            nb_matched = (int)pattern.length();
            h = entry->handler;
        }
    }
    
    *ph = h;
    
    return srs_success;
}

bool SrsHttpServeMux::path_match(string pattern, string path)
{
    if (pattern.empty()) {
        return false;
    }
    
    int n = (int)pattern.length();
    
    // not endswith '/', exactly match.
    if (pattern.at(n - 1) != '/') {
        return pattern == path;
    }
    
    // endswith '/', match any,
    // for example, '/api/' match '/api/[N]'
    if ((int)path.length() >= n) {
        if (memcmp(pattern.data(), path.data(), n) == 0) {
            return true;
        }
    }
    
    return false;
}

SrsHttpCorsMux::SrsHttpCorsMux()
{
    next = NULL;
    enabled = false;
    required = false;
}

SrsHttpCorsMux::~SrsHttpCorsMux()
{
}

srs_error_t SrsHttpCorsMux::initialize(ISrsHttpServeMux* worker, bool cros_enabled)
{
    next = worker;
    enabled = cros_enabled;
    
    return srs_success;
}

srs_error_t SrsHttpCorsMux::serve_http(ISrsHttpResponseWriter* w, ISrsHttpMessage* r)
{
    srs_error_t err = srs_success;
    
    // If CORS enabled, and there is a "Origin" header, it's CORS.
    if (enabled) {
        for (int i = 0; i < r->request_header_count(); i++) {
            string k = r->request_header_key_at(i);
            if (k == "Origin" || k == "origin") {
                required = true;
                break;
            }
        }
    }
    
    // When CORS required, set the CORS headers.
    if (required) {
        SrsHttpHeader* h = w->header();
        h->set("Access-Control-Allow-Origin", "*");
        h->set("Access-Control-Allow-Methods", "GET, POST, HEAD, PUT, DELETE, OPTIONS");
        h->set("Access-Control-Expose-Headers", "Server,range,Content-Length,Content-Range");
        h->set("Access-Control-Allow-Headers", "origin,range,accept-encoding,referer,Cache-Control,X-Proxy-Authorization,X-Requested-With,Content-Type");
    }
    
    // handle the http options.
    if (r->is_http_options()) {
        w->header()->set_content_length(0);
        if (enabled) {
            w->write_header(SRS_CONSTS_HTTP_OK);
        } else {
            w->write_header(SRS_CONSTS_HTTP_MethodNotAllowed);
        }
        if ((err = w->final_request()) != srs_success) {
            return srs_error_wrap(err, "final request");
        }
    }
    
    srs_assert(next);
    return next->serve_http(w, r);
}

ISrsHttpMessage::ISrsHttpMessage()
{
    _http_ts_send_buffer = new char[SRS_HTTP_TS_SEND_BUFFER_SIZE];
}

ISrsHttpMessage::~ISrsHttpMessage()
{
    srs_freepa(_http_ts_send_buffer);
}

char* ISrsHttpMessage::http_ts_send_buffer()
{
    return _http_ts_send_buffer;
}

#endif

/* Based on src/http/ngx_http_parse.c from NGINX copyright Igor Sysoev
 *
 * Additional changes are licensed under the same terms as NGINX and
 * copyright Joyent, Inc. and other Node contributors. All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */
//#include "http_parser.h"
#include <assert.h>
#include <stddef.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#ifndef ULLONG_MAX
# define ULLONG_MAX ((uint64_t) -1) /* 2^64-1 */
#endif

#ifndef MIN
# define MIN(a,b) ((a) < (b) ? (a) : (b))
#endif

#ifndef ARRAY_SIZE
# define ARRAY_SIZE(a) (sizeof(a) / sizeof((a)[0]))
#endif

#ifndef BIT_AT
# define BIT_AT(a, i)                                                \
(!!((unsigned int) (a)[(unsigned int) (i) >> 3] &                  \
(1 << ((unsigned int) (i) & 7))))
#endif

#ifndef ELEM_AT
# define ELEM_AT(a, i, v) ((unsigned int) (i) < ARRAY_SIZE(a) ? (a)[(i)] : (v))
#endif

#define SET_ERRNO(e)                                                 \
do {                                                                 \
parser->http_errno = (e);                                          \
} while(0)


/* Run the notify callback FOR, returning ER if it fails */
#define CALLBACK_NOTIFY_(FOR, ER)                                    \
do {                                                                 \
assert(HTTP_PARSER_ERRNO(parser) == HPE_OK);                       \
\
if (settings->on_##FOR) {                                          \
if (0 != settings->on_##FOR(parser)) {                           \
SET_ERRNO(HPE_CB_##FOR);                                       \
}                                                                \
\
/* We either errored above or got paused; get out */             \
if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {                       \
return (ER);                                                   \
}                                                                \
}                                                                  \
} while (0)

/* Run the notify callback FOR and consume the current byte */
#define CALLBACK_NOTIFY(FOR)            CALLBACK_NOTIFY_(FOR, p - data + 1)

/* Run the notify callback FOR and don't consume the current byte */
#define CALLBACK_NOTIFY_NOADVANCE(FOR)  CALLBACK_NOTIFY_(FOR, p - data)

/* Run data callback FOR with LEN bytes, returning ER if it fails */
#define CALLBACK_DATA_(FOR, LEN, ER)                                 \
do {                                                                 \
assert(HTTP_PARSER_ERRNO(parser) == HPE_OK);                       \
\
if (FOR##_mark) {                                                  \
if (settings->on_##FOR) {                                        \
if (0 != settings->on_##FOR(parser, FOR##_mark, (LEN))) {      \
SET_ERRNO(HPE_CB_##FOR);                                     \
}                                                              \
\
/* We either errored above or got paused; get out */           \
if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {                     \
return (ER);                                                 \
}                                                              \
}                                                                \
FOR##_mark = NULL;                                               \
}                                                                  \
} while (0)

/* Run the data callback FOR and consume the current byte */
#define CALLBACK_DATA(FOR)                                           \
CALLBACK_DATA_(FOR, p - FOR##_mark, p - data + 1)

/* Run the data callback FOR and don't consume the current byte */
#define CALLBACK_DATA_NOADVANCE(FOR)                                 \
CALLBACK_DATA_(FOR, p - FOR##_mark, p - data)

/* Set the mark FOR; non-destructive if mark is already set */
#define MARK(FOR)                                                    \
do {                                                                 \
if (!FOR##_mark) {                                                 \
FOR##_mark = p;                                                  \
}                                                                  \
} while (0)


#define PROXY_CONNECTION "proxy-connection"
#define CONNECTION "connection"
#define CONTENT_LENGTH "content-length"
#define TRANSFER_ENCODING "transfer-encoding"
#define UPGRADE "upgrade"
#define CHUNKED "chunked"
#define KEEP_ALIVE "keep-alive"
#define CLOSE "close"


static const char *method_strings[] =
{
#define XX(num, name, string) #string,
    HTTP_METHOD_MAP(XX)
#undef XX
};


/* Tokens as defined by rfc 2616. Also lowercases them.
 *        token       = 1*<any CHAR except CTLs or separators>
 *     separators     = "(" | ")" | "<" | ">" | "@"
 *                    | "," | ";" | ":" | "\" | <">
 *                    | "/" | "[" | "]" | "?" | "="
 *                    | "{" | "}" | SP | HT
 */
static const char tokens[256] = {
    /*   0 nul    1 soh    2 stx    3 etx    4 eot    5 enq    6 ack    7 bel  */
    0,       0,       0,       0,       0,       0,       0,       0,
    /*   8 bs     9 ht    10 nl    11 vt    12 np    13 cr    14 so    15 si   */
    0,       0,       0,       0,       0,       0,       0,       0,
    /*  16 dle   17 dc1   18 dc2   19 dc3   20 dc4   21 nak   22 syn   23 etb */
    0,       0,       0,       0,       0,       0,       0,       0,
    /*  24 can   25 em    26 sub   27 esc   28 fs    29 gs    30 rs    31 us  */
    0,       0,       0,       0,       0,       0,       0,       0,
    /*  32 sp    33  !    34  "    35  #    36  $    37  %    38  &    39  '  */
    0,      '!',      0,      '#',     '$',     '%',     '&',    '\'',
    /*  40  (    41  )    42  *    43  +    44  ,    45  -    46  .    47  /  */
    0,       0,      '*',     '+',      0,      '-',     '.',      0,
    /*  48  0    49  1    50  2    51  3    52  4    53  5    54  6    55  7  */
    '0',     '1',     '2',     '3',     '4',     '5',     '6',     '7',
    /*  56  8    57  9    58  :    59  ;    60  <    61  =    62  >    63  ?  */
    '8',     '9',      0,       0,       0,       0,       0,       0,
    /*  64  @    65  A    66  B    67  C    68  D    69  E    70  F    71  G  */
    0,      'a',     'b',     'c',     'd',     'e',     'f',     'g',
    /*  72  H    73  I    74  J    75  K    76  L    77  M    78  N    79  O  */
    'h',     'i',     'j',     'k',     'l',     'm',     'n',     'o',
    /*  80  P    81  Q    82  R    83  S    84  T    85  U    86  V    87  W  */
    'p',     'q',     'r',     's',     't',     'u',     'v',     'w',
    /*  88  X    89  Y    90  Z    91  [    92  \    93  ]    94  ^    95  _  */
    'x',     'y',     'z',      0,       0,       0,      '^',     '_',
    /*  96  `    97  a    98  b    99  c   100  d   101  e   102  f   103  g  */
    '`',     'a',     'b',     'c',     'd',     'e',     'f',     'g',
    /* 104  h   105  i   106  j   107  k   108  l   109  m   110  n   111  o  */
    'h',     'i',     'j',     'k',     'l',     'm',     'n',     'o',
    /* 112  p   113  q   114  r   115  s   116  t   117  u   118  v   119  w  */
    'p',     'q',     'r',     's',     't',     'u',     'v',     'w',
    /* 120  x   121  y   122  z   123  {   124  |   125  }   126  ~   127 del */
    'x',     'y',     'z',      0,      '|',      0,      '~',       0 };


static const int8_t unhex[256] =
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
    ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
    ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
    , 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1
    ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1
    ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
    ,-1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1
    ,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
};


#if HTTP_PARSER_STRICT
# define T(v) 0
#else
# define T(v) v
#endif


static const uint8_t normal_url_char[32] = {
    /*   0 nul    1 soh    2 stx    3 etx    4 eot    5 enq    6 ack    7 bel  */
    0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,
    /*   8 bs     9 ht    10 nl    11 vt    12 np    13 cr    14 so    15 si   */
    0    | T(2)   |   0    |   0    | T(16)  |   0    |   0    |   0,
    /*  16 dle   17 dc1   18 dc2   19 dc3   20 dc4   21 nak   22 syn   23 etb */
    0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,
    /*  24 can   25 em    26 sub   27 esc   28 fs    29 gs    30 rs    31 us  */
    0    |   0    |   0    |   0    |   0    |   0    |   0    |   0,
    /*  32 sp    33  !    34  "    35  #    36  $    37  %    38  &    39  '  */
    0    |   2    |   4    |   0    |   16   |   32   |   64   |  128,
    /*  40  (    41  )    42  *    43  +    44  ,    45  -    46  .    47  /  */
    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
    /*  48  0    49  1    50  2    51  3    52  4    53  5    54  6    55  7  */
    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
    /*  56  8    57  9    58  :    59  ;    60  <    61  =    62  >    63  ?  */
    1    |   2    |   4    |   8    |   16   |   32   |   64   |   0,
    /*  64  @    65  A    66  B    67  C    68  D    69  E    70  F    71  G  */
    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
    /*  72  H    73  I    74  J    75  K    76  L    77  M    78  N    79  O  */
    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
    /*  80  P    81  Q    82  R    83  S    84  T    85  U    86  V    87  W  */
    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
    /*  88  X    89  Y    90  Z    91  [    92  \    93  ]    94  ^    95  _  */
    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
    /*  96  `    97  a    98  b    99  c   100  d   101  e   102  f   103  g  */
    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
    /* 104  h   105  i   106  j   107  k   108  l   109  m   110  n   111  o  */
    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
    /* 112  p   113  q   114  r   115  s   116  t   117  u   118  v   119  w  */
    1    |   2    |   4    |   8    |   16   |   32   |   64   |  128,
    /* 120  x   121  y   122  z   123  {   124  |   125  }   126  ~   127 del */
    1    |   2    |   4    |   8    |   16   |   32   |   64   |   0, };

#undef T

enum state
{ s_dead = 1 /* important that this is > 0 */
    
    , s_start_req_or_res
    , s_res_or_resp_H
    , s_start_res
    , s_res_H
    , s_res_HT
    , s_res_HTT
    , s_res_HTTP
    , s_res_first_http_major
    , s_res_http_major
    , s_res_first_http_minor
    , s_res_http_minor
    , s_res_first_status_code
    , s_res_status_code
    , s_res_status
    , s_res_line_almost_done
    
    , s_start_req
    
    , s_req_method
    , s_req_spaces_before_url
    , s_req_schema
    , s_req_schema_slash
    , s_req_schema_slash_slash
    , s_req_server_start
    , s_req_server
    , s_req_server_with_at
    , s_req_path
    , s_req_query_string_start
    , s_req_query_string
    , s_req_fragment_start
    , s_req_fragment
    , s_req_http_start
    , s_req_http_H
    , s_req_http_HT
    , s_req_http_HTT
    , s_req_http_HTTP
    , s_req_first_http_major
    , s_req_http_major
    , s_req_first_http_minor
    , s_req_http_minor
    , s_req_line_almost_done
    
    , s_header_field_start
    , s_header_field
    , s_header_value_start
    , s_header_value
    , s_header_value_lws
    
    , s_header_almost_done
    
    , s_chunk_size_start
    , s_chunk_size
    , s_chunk_parameters
    , s_chunk_size_almost_done
    
    , s_headers_almost_done
    , s_headers_done
    
    /* Important: 's_headers_done' must be the last 'header' state. All
     * states beyond this must be 'body' states. It is used for overflow
     * checking. See the PARSING_HEADER() macro.
     */
    
    , s_chunk_data
    , s_chunk_data_almost_done
    , s_chunk_data_done
    
    , s_body_identity
    , s_body_identity_eof
    
    , s_message_done
};


#define PARSING_HEADER(state) (state <= s_headers_done)


enum header_states
{ h_general = 0
    , h_C
    , h_CO
    , h_CON
    
    , h_matching_connection
    , h_matching_proxy_connection
    , h_matching_content_length
    , h_matching_transfer_encoding
    , h_matching_upgrade
    
    , h_connection
    , h_content_length
    , h_transfer_encoding
    , h_upgrade
    
    , h_matching_transfer_encoding_chunked
    , h_matching_connection_keep_alive
    , h_matching_connection_close
    
    , h_transfer_encoding_chunked
    , h_connection_keep_alive
    , h_connection_close
};

enum http_host_state
{
    s_http_host_dead = 1
    , s_http_userinfo_start
    , s_http_userinfo
    , s_http_host_start
    , s_http_host_v6_start
    , s_http_host
    , s_http_host_v6
    , s_http_host_v6_end
    , s_http_host_port_start
    , s_http_host_port
};

/* Macros for character classes; depends on strict-mode  */
#define CR                  '\r'
#define LF                  '\n'
#define LOWER(c)            (unsigned char)(c | 0x20)
#define IS_ALPHA(c)         (LOWER(c) >= 'a' && LOWER(c) <= 'z')
#define IS_NUM(c)           ((c) >= '0' && (c) <= '9')
#define IS_ALPHANUM(c)      (IS_ALPHA(c) || IS_NUM(c))
#define IS_HEX(c)           (IS_NUM(c) || (LOWER(c) >= 'a' && LOWER(c) <= 'f'))
#define IS_MARK(c)          ((c) == '-' || (c) == '_' || (c) == '.' || \
(c) == '!' || (c) == '~' || (c) == '*' || (c) == '\'' || (c) == '(' || \
(c) == ')')
#define IS_USERINFO_CHAR(c) (IS_ALPHANUM(c) || IS_MARK(c) || (c) == '%' || \
(c) == ';' || (c) == ':' || (c) == '&' || (c) == '=' || (c) == '+' || \
(c) == '$' || (c) == ',')

#if HTTP_PARSER_STRICT
#define TOKEN(c)            (tokens[(unsigned char)c])
#define IS_URL_CHAR(c)      (BIT_AT(normal_url_char, (unsigned char)c))
#define IS_HOST_CHAR(c)     (IS_ALPHANUM(c) || (c) == '.' || (c) == '-')
#else
#define TOKEN(c)            ((c == ' ') ? ' ' : tokens[(unsigned char)c])
#define IS_URL_CHAR(c)                                                         \
(BIT_AT(normal_url_char, (unsigned char)c) || ((c) & 0x80))
#define IS_HOST_CHAR(c)                                                        \
(IS_ALPHANUM(c) || (c) == '.' || (c) == '-' || (c) == '_')
#endif


#define start_state (parser->type == HTTP_REQUEST ? s_start_req : s_start_res)


#if HTTP_PARSER_STRICT
# define STRICT_CHECK(cond)                                          \
do {                                                                 \
if (cond) {                                                        \
SET_ERRNO(HPE_STRICT);                                           \
goto error;                                                      \
}                                                                  \
} while (0)
# define NEW_MESSAGE() (http_should_keep_alive(parser) ? start_state : s_dead)
#else
# define STRICT_CHECK(cond)
# define NEW_MESSAGE() start_state
#endif


/* Map errno values to strings for human-readable output */
#define HTTP_STRERROR_GEN(n, s) { "HPE_" #n, s },
static struct {
    const char *name;
    const char *description;
} http_strerror_tab[] = {
    HTTP_ERRNO_MAP(HTTP_STRERROR_GEN)
};
#undef HTTP_STRERROR_GEN

int http_message_needs_eof(const http_parser *parser);

/* Our URL parser.
 *
 * This is designed to be shared by http_parser_execute() for URL validation,
 * hence it has a state transition + byte-for-byte interface. In addition, it
 * is meant to be embedded in http_parser_parse_url(), which does the dirty
 * work of turning state transitions URL components for its API.
 *
 * This function should only be invoked with non-space characters. It is
 * assumed that the caller cares about (and can detect) the transition between
 * URL and non-URL states by looking for these.
 */
static enum state
parse_url_char(enum state s, const char ch)
{
    if (ch == ' ' || ch == '\r' || ch == '\n') {
        return s_dead;
    }
    
#if HTTP_PARSER_STRICT
    if (ch == '\t' || ch == '\f') {
        return s_dead;
    }
#endif
    
    switch (s) {
        case s_req_spaces_before_url:
            /* Proxied requests are followed by scheme of an absolute URI (alpha).
             * All methods except CONNECT are followed by '/' or '*'.
             */
            
            if (ch == '/' || ch == '*') {
                return s_req_path;
            }
            
            if (IS_ALPHA(ch)) {
                return s_req_schema;
            }
            
            break;
            
        case s_req_schema:
            if (IS_ALPHA(ch)) {
                return s;
            }
            
            if (ch == ':') {
                return s_req_schema_slash;
            }
            
            break;
            
        case s_req_schema_slash:
            if (ch == '/') {
                return s_req_schema_slash_slash;
            }
            
            break;
            
        case s_req_schema_slash_slash:
            if (ch == '/') {
                return s_req_server_start;
            }
            
            break;
            
        case s_req_server_with_at:
            if (ch == '@') {
                return s_dead;
            }
            
            /* FALLTHROUGH */
        case s_req_server_start:
        case s_req_server:
            if (ch == '/') {
                return s_req_path;
            }
            
            if (ch == '?') {
                return s_req_query_string_start;
            }
            
            if (ch == '@') {
                return s_req_server_with_at;
            }
            
            if (IS_USERINFO_CHAR(ch) || ch == '[' || ch == ']') {
                return s_req_server;
            }
            
            break;
            
        case s_req_path:
            if (IS_URL_CHAR(ch)) {
                return s;
            }
            
            switch (ch) {
                case '?':
                    return s_req_query_string_start;
                    
                case '#':
                    return s_req_fragment_start;
            }
            
            break;
            
        case s_req_query_string_start:
        case s_req_query_string:
            if (IS_URL_CHAR(ch)) {
                return s_req_query_string;
            }
            
            switch (ch) {
                case '?':
                    /* allow extra '?' in query string */
                    return s_req_query_string;
                    
                case '#':
                    return s_req_fragment_start;
            }
            
            break;
            
        case s_req_fragment_start:
            if (IS_URL_CHAR(ch)) {
                return s_req_fragment;
            }
            
            switch (ch) {
                case '?':
                    return s_req_fragment;
                    
                case '#':
                    return s;
            }
            
            break;
            
        case s_req_fragment:
            if (IS_URL_CHAR(ch)) {
                return s;
            }
            
            switch (ch) {
                case '?':
                case '#':
                    return s;
            }
            
            break;
            
        default:
            break;
    }
    
    /* We should never fall out of the switch above unless there's an error */
    return s_dead;
}

size_t http_parser_execute (http_parser *parser,
                            const http_parser_settings *settings,
                            const char *data,
                            size_t len)
{
    char c, ch;
    int8_t unhex_val;
    const char *p = data;
    const char *header_field_mark = 0;
    const char *header_value_mark = 0;
    const char *url_mark = 0;
    const char *body_mark = 0;
    
    /* We're in an error state. Don't bother doing anything. */
    if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {
        return 0;
    }
    
    if (len == 0) {
        switch (parser->state) {
            case s_body_identity_eof:
                /* Use of CALLBACK_NOTIFY() here would erroneously return 1 byte read if
                 * we got paused.
                 */
                CALLBACK_NOTIFY_NOADVANCE(message_complete);
                return 0;
                
            case s_dead:
            case s_start_req_or_res:
            case s_start_res:
            case s_start_req:
                return 0;
                
            default:
                SET_ERRNO(HPE_INVALID_EOF_STATE);
                return 1;
        }
    }
    
    
    if (parser->state == s_header_field)
        header_field_mark = data;
    if (parser->state == s_header_value)
        header_value_mark = data;
    switch (parser->state) {
        case s_req_path:
        case s_req_schema:
        case s_req_schema_slash:
        case s_req_schema_slash_slash:
        case s_req_server_start:
        case s_req_server:
        case s_req_server_with_at:
        case s_req_query_string_start:
        case s_req_query_string:
        case s_req_fragment_start:
        case s_req_fragment:
            url_mark = data;
            break;
    }
    
    for (p=data; p != data + len; p++) {
        ch = *p;
        
        if (PARSING_HEADER(parser->state)) {
            ++parser->nread;
            /* Buffer overflow attack */
            if (parser->nread > HTTP_MAX_HEADER_SIZE) {
                SET_ERRNO(HPE_HEADER_OVERFLOW);
                goto error;
            }
        }
        
    reexecute_byte:
        switch (parser->state) {
                
            case s_dead:
                /* this state is used after a 'Connection: close' message
                 * the parser will error out if it reads another message
                 */
                if (ch == CR || ch == LF)
                    break;
                
                SET_ERRNO(HPE_CLOSED_CONNECTION);
                goto error;
                
            case s_start_req_or_res:
            {
                if (ch == CR || ch == LF)
                    break;
                parser->flags = 0;
                parser->content_length = ULLONG_MAX;
                
                if (ch == 'H') {
                    parser->state = s_res_or_resp_H;
                    
                    CALLBACK_NOTIFY(message_begin);
                } else {
                    parser->type = HTTP_REQUEST;
                    parser->state = s_start_req;
                    goto reexecute_byte;
                }
                
                break;
            }
                
            case s_res_or_resp_H:
                if (ch == 'T') {
                    parser->type = HTTP_RESPONSE;
                    parser->state = s_res_HT;
                } else {
                    if (ch != 'E') {
                        SET_ERRNO(HPE_INVALID_CONSTANT);
                        goto error;
                    }
                    
                    parser->type = HTTP_REQUEST;
                    parser->method = HTTP_HEAD;
                    parser->index = 2;
                    parser->state = s_req_method;
                }
                break;
                
            case s_start_res:
            {
                parser->flags = 0;
                parser->content_length = ULLONG_MAX;
                
                switch (ch) {
                    case 'H':
                        parser->state = s_res_H;
                        break;
                        
                    case CR:
                    case LF:
                        break;
                        
                    default:
                        SET_ERRNO(HPE_INVALID_CONSTANT);
                        goto error;
                }
                
                CALLBACK_NOTIFY(message_begin);
                break;
            }
                
            case s_res_H:
                STRICT_CHECK(ch != 'T');
                parser->state = s_res_HT;
                break;
                
            case s_res_HT:
                STRICT_CHECK(ch != 'T');
                parser->state = s_res_HTT;
                break;
                
            case s_res_HTT:
                STRICT_CHECK(ch != 'P');
                parser->state = s_res_HTTP;
                break;
                
            case s_res_HTTP:
                STRICT_CHECK(ch != '/');
                parser->state = s_res_first_http_major;
                break;
                
            case s_res_first_http_major:
                if (ch < '0' || ch > '9') {
                    SET_ERRNO(HPE_INVALID_VERSION);
                    goto error;
                }
                
                parser->http_major = ch - '0';
                parser->state = s_res_http_major;
                break;
                
                /* major HTTP version or dot */
            case s_res_http_major:
            {
                if (ch == '.') {
                    parser->state = s_res_first_http_minor;
                    break;
                }
                
                if (!IS_NUM(ch)) {
                    SET_ERRNO(HPE_INVALID_VERSION);
                    goto error;
                }
                
                parser->http_major *= 10;
                parser->http_major += ch - '0';
                
                if (parser->http_major > 999) {
                    SET_ERRNO(HPE_INVALID_VERSION);
                    goto error;
                }
                
                break;
            }
                
                /* first digit of minor HTTP version */
            case s_res_first_http_minor:
                if (!IS_NUM(ch)) {
                    SET_ERRNO(HPE_INVALID_VERSION);
                    goto error;
                }
                
                parser->http_minor = ch - '0';
                parser->state = s_res_http_minor;
                break;
                
                /* minor HTTP version or end of request line */
            case s_res_http_minor:
            {
                if (ch == ' ') {
                    parser->state = s_res_first_status_code;
                    break;
                }
                
                if (!IS_NUM(ch)) {
                    SET_ERRNO(HPE_INVALID_VERSION);
                    goto error;
                }
                
                parser->http_minor *= 10;
                parser->http_minor += ch - '0';
                
                if (parser->http_minor > 999) {
                    SET_ERRNO(HPE_INVALID_VERSION);
                    goto error;
                }
                
                break;
            }
                
            case s_res_first_status_code:
            {
                if (!IS_NUM(ch)) {
                    if (ch == ' ') {
                        break;
                    }
                    
                    SET_ERRNO(HPE_INVALID_STATUS);
                    goto error;
                }
                parser->status_code = ch - '0';
                parser->state = s_res_status_code;
                break;
            }
                
            case s_res_status_code:
            {
                if (!IS_NUM(ch)) {
                    switch (ch) {
                        case ' ':
                            parser->state = s_res_status;
                            break;
                        case CR:
                            parser->state = s_res_line_almost_done;
                            break;
                        case LF:
                            parser->state = s_header_field_start;
                            break;
                        default:
                            SET_ERRNO(HPE_INVALID_STATUS);
                            goto error;
                    }
                    break;
                }
                
                parser->status_code *= 10;
                parser->status_code += ch - '0';
                
                if (parser->status_code > 999) {
                    SET_ERRNO(HPE_INVALID_STATUS);
                    goto error;
                }
                
                break;
            }
                
            case s_res_status:
                /* the human readable status. e.g. "NOT FOUND"
                 * we are not humans so just ignore this */
                if (ch == CR) {
                    parser->state = s_res_line_almost_done;
                    break;
                }
                
                if (ch == LF) {
                    parser->state = s_header_field_start;
                    break;
                }
                break;
                
            case s_res_line_almost_done:
                STRICT_CHECK(ch != LF);
                parser->state = s_header_field_start;
                CALLBACK_NOTIFY(status_complete);
                break;
                
            case s_start_req:
            {
                if (ch == CR || ch == LF)
                    break;
                parser->flags = 0;
                parser->content_length = ULLONG_MAX;
                
                if (!IS_ALPHA(ch)) {
                    SET_ERRNO(HPE_INVALID_METHOD);
                    goto error;
                }
                
                parser->method = (enum http_method) 0;
                parser->index = 1;
                switch (ch) {
                    case 'C': parser->method = HTTP_CONNECT; /* or COPY, CHECKOUT */ break;
                    case 'D': parser->method = HTTP_DELETE; break;
                    case 'G': parser->method = HTTP_GET; break;
                    case 'H': parser->method = HTTP_HEAD; break;
                    case 'L': parser->method = HTTP_LOCK; break;
                    case 'M': parser->method = HTTP_MKCOL; /* or MOVE, MKACTIVITY, MERGE, M-SEARCH */ break;
                    case 'N': parser->method = HTTP_NOTIFY; break;
                    case 'O': parser->method = HTTP_OPTIONS; break;
                    case 'P': parser->method = HTTP_POST;
                        /* or PROPFIND|PROPPATCH|PUT|PATCH|PURGE */
                        break;
                    case 'R': parser->method = HTTP_REPORT; break;
                    case 'S': parser->method = HTTP_SUBSCRIBE; /* or SEARCH */ break;
                    case 'T': parser->method = HTTP_TRACE; break;
                    case 'U': parser->method = HTTP_UNLOCK; /* or UNSUBSCRIBE */ break;
                    default:
                        SET_ERRNO(HPE_INVALID_METHOD);
                        goto error;
                }
                parser->state = s_req_method;
                
                CALLBACK_NOTIFY(message_begin);
                
                break;
            }
                
            case s_req_method:
            {
                const char *matcher;
                if (ch == '\0') {
                    SET_ERRNO(HPE_INVALID_METHOD);
                    goto error;
                }
                
                matcher = method_strings[parser->method];
                if (ch == ' ' && matcher[parser->index] == '\0') {
                    parser->state = s_req_spaces_before_url;
                } else if (ch == matcher[parser->index]) {
                    ; /* nada */
                } else if (parser->method == HTTP_CONNECT) {
                    if (parser->index == 1 && ch == 'H') {
                        parser->method = HTTP_CHECKOUT;
                    } else if (parser->index == 2  && ch == 'P') {
                        parser->method = HTTP_COPY;
                    } else {
                        goto error;
                    }
                } else if (parser->method == HTTP_MKCOL) {
                    if (parser->index == 1 && ch == 'O') {
                        parser->method = HTTP_MOVE;
                    } else if (parser->index == 1 && ch == 'E') {
                        parser->method = HTTP_MERGE;
                    } else if (parser->index == 1 && ch == '-') {
                        parser->method = HTTP_MSEARCH;
                    } else if (parser->index == 2 && ch == 'A') {
                        parser->method = HTTP_MKACTIVITY;
                    } else {
                        goto error;
                    }
                } else if (parser->method == HTTP_SUBSCRIBE) {
                    if (parser->index == 1 && ch == 'E') {
                        parser->method = HTTP_SEARCH;
                    } else {
                        goto error;
                    }
                } else if (parser->index == 1 && parser->method == HTTP_POST) {
                    if (ch == 'R') {
                        parser->method = HTTP_PROPFIND; /* or HTTP_PROPPATCH */
                    } else if (ch == 'U') {
                        parser->method = HTTP_PUT; /* or HTTP_PURGE */
                    } else if (ch == 'A') {
                        parser->method = HTTP_PATCH;
                    } else {
                        goto error;
                    }
                } else if (parser->index == 2) {
                    if (parser->method == HTTP_PUT) {
                        if (ch == 'R') parser->method = HTTP_PURGE;
                    } else if (parser->method == HTTP_UNLOCK) {
                        if (ch == 'S') parser->method = HTTP_UNSUBSCRIBE;
                    }
                } else if (parser->index == 4 && parser->method == HTTP_PROPFIND && ch == 'P') {
                    parser->method = HTTP_PROPPATCH;
                } else {
                    SET_ERRNO(HPE_INVALID_METHOD);
                    goto error;
                }
                
                ++parser->index;
                break;
            }
                
            case s_req_spaces_before_url:
            {
                if (ch == ' ') break;
                
                MARK(url);
                if (parser->method == HTTP_CONNECT) {
                    parser->state = s_req_server_start;
                }
                
                parser->state = parse_url_char((enum state)parser->state, ch);
                if (parser->state == s_dead) {
                    SET_ERRNO(HPE_INVALID_URL);
                    goto error;
                }
                
                break;
            }
                
            case s_req_schema:
            case s_req_schema_slash:
            case s_req_schema_slash_slash:
            case s_req_server_start:
            {
                switch (ch) {
                        /* No whitespace allowed here */
                    case ' ':
                    case CR:
                    case LF:
                        SET_ERRNO(HPE_INVALID_URL);
                        goto error;
                    default:
                        parser->state = parse_url_char((enum state)parser->state, ch);
                        if (parser->state == s_dead) {
                            SET_ERRNO(HPE_INVALID_URL);
                            goto error;
                        }
                }
                
                break;
            }
                
            case s_req_server:
            case s_req_server_with_at:
            case s_req_path:
            case s_req_query_string_start:
            case s_req_query_string:
            case s_req_fragment_start:
            case s_req_fragment:
            {
                switch (ch) {
                    case ' ':
                        parser->state = s_req_http_start;
                        CALLBACK_DATA(url);
                        break;
                    case CR:
                    case LF:
                        parser->http_major = 0;
                        parser->http_minor = 9;
                        parser->state = (ch == CR) ?
                        s_req_line_almost_done :
                        s_header_field_start;
                        CALLBACK_DATA(url);
                        break;
                    default:
                        parser->state = parse_url_char((enum state)parser->state, ch);
                        if (parser->state == s_dead) {
                            SET_ERRNO(HPE_INVALID_URL);
                            goto error;
                        }
                }
                break;
            }
                
            case s_req_http_start:
                switch (ch) {
                    case 'H':
                        parser->state = s_req_http_H;
                        break;
                    case ' ':
                        break;
                    default:
                        SET_ERRNO(HPE_INVALID_CONSTANT);
                        goto error;
                }
                break;
                
            case s_req_http_H:
                STRICT_CHECK(ch != 'T');
                parser->state = s_req_http_HT;
                break;
                
            case s_req_http_HT:
                STRICT_CHECK(ch != 'T');
                parser->state = s_req_http_HTT;
                break;
                
            case s_req_http_HTT:
                STRICT_CHECK(ch != 'P');
                parser->state = s_req_http_HTTP;
                break;
                
            case s_req_http_HTTP:
                STRICT_CHECK(ch != '/');
                parser->state = s_req_first_http_major;
                break;
                
                /* first digit of major HTTP version */
            case s_req_first_http_major:
                if (ch < '1' || ch > '9') {
                    SET_ERRNO(HPE_INVALID_VERSION);
                    goto error;
                }
                
                parser->http_major = ch - '0';
                parser->state = s_req_http_major;
                break;
                
                /* major HTTP version or dot */
            case s_req_http_major:
            {
                if (ch == '.') {
                    parser->state = s_req_first_http_minor;
                    break;
                }
                
                if (!IS_NUM(ch)) {
                    SET_ERRNO(HPE_INVALID_VERSION);
                    goto error;
                }
                
                parser->http_major *= 10;
                parser->http_major += ch - '0';
                
                if (parser->http_major > 999) {
                    SET_ERRNO(HPE_INVALID_VERSION);
                    goto error;
                }
                
                break;
            }
                
                /* first digit of minor HTTP version */
            case s_req_first_http_minor:
                if (!IS_NUM(ch)) {
                    SET_ERRNO(HPE_INVALID_VERSION);
                    goto error;
                }
                
                parser->http_minor = ch - '0';
                parser->state = s_req_http_minor;
                break;
                
                /* minor HTTP version or end of request line */
            case s_req_http_minor:
            {
                if (ch == CR) {
                    parser->state = s_req_line_almost_done;
                    break;
                }
                
                if (ch == LF) {
                    parser->state = s_header_field_start;
                    break;
                }
                
                /* XXX allow spaces after digit? */
                
                if (!IS_NUM(ch)) {
                    SET_ERRNO(HPE_INVALID_VERSION);
                    goto error;
                }
                
                parser->http_minor *= 10;
                parser->http_minor += ch - '0';
                
                if (parser->http_minor > 999) {
                    SET_ERRNO(HPE_INVALID_VERSION);
                    goto error;
                }
                
                break;
            }
                
                /* end of request line */
            case s_req_line_almost_done:
            {
                if (ch != LF) {
                    SET_ERRNO(HPE_LF_EXPECTED);
                    goto error;
                }
                
                parser->state = s_header_field_start;
                break;
            }
                
            case s_header_field_start:
            {
                if (ch == CR) {
                    parser->state = s_headers_almost_done;
                    break;
                }
                
                if (ch == LF) {
                    /* they might be just sending \n instead of \r\n so this would be
                     * the second \n to denote the end of headers*/
                    parser->state = s_headers_almost_done;
                    goto reexecute_byte;
                }
                
                c = TOKEN(ch);
                
                if (!c) {
                    SET_ERRNO(HPE_INVALID_HEADER_TOKEN);
                    goto error;
                }
                
                MARK(header_field);
                
                parser->index = 0;
                parser->state = s_header_field;
                
                switch (c) {
                    case 'c':
                        parser->header_state = h_C;
                        break;
                        
                    case 'p':
                        parser->header_state = h_matching_proxy_connection;
                        break;
                        
                    case 't':
                        parser->header_state = h_matching_transfer_encoding;
                        break;
                        
                    case 'u':
                        parser->header_state = h_matching_upgrade;
                        break;
                        
                    default:
                        parser->header_state = h_general;
                        break;
                }
                break;
            }
                
            case s_header_field:
            {
                c = TOKEN(ch);
                
                if (c) {
                    switch (parser->header_state) {
                        case h_general:
                            break;
                            
                        case h_C:
                            parser->index++;
                            parser->header_state = (c == 'o' ? h_CO : h_general);
                            break;
                            
                        case h_CO:
                            parser->index++;
                            parser->header_state = (c == 'n' ? h_CON : h_general);
                            break;
                            
                        case h_CON:
                            parser->index++;
                            switch (c) {
                                case 'n':
                                    parser->header_state = h_matching_connection;
                                    break;
                                case 't':
                                    parser->header_state = h_matching_content_length;
                                    break;
                                default:
                                    parser->header_state = h_general;
                                    break;
                            }
                            break;
                            
                            /* connection */
                            
                        case h_matching_connection:
                            parser->index++;
                            if (parser->index > sizeof(CONNECTION)-1
                                || c != CONNECTION[parser->index]) {
                                parser->header_state = h_general;
                            } else if (parser->index == sizeof(CONNECTION)-2) {
                                parser->header_state = h_connection;
                            }
                            break;
                            
                            /* proxy-connection */
                            
                        case h_matching_proxy_connection:
                            parser->index++;
                            if (parser->index > sizeof(PROXY_CONNECTION)-1
                                || c != PROXY_CONNECTION[parser->index]) {
                                parser->header_state = h_general;
                            } else if (parser->index == sizeof(PROXY_CONNECTION)-2) {
                                parser->header_state = h_connection;
                            }
                            break;
                            
                            /* content-length */
                            
                        case h_matching_content_length:
                            parser->index++;
                            if (parser->index > sizeof(CONTENT_LENGTH)-1
                                || c != CONTENT_LENGTH[parser->index]) {
                                parser->header_state = h_general;
                            } else if (parser->index == sizeof(CONTENT_LENGTH)-2) {
                                parser->header_state = h_content_length;
                            }
                            break;
                            
                            /* transfer-encoding */
                            
                        case h_matching_transfer_encoding:
                            parser->index++;
                            if (parser->index > sizeof(TRANSFER_ENCODING)-1
                                || c != TRANSFER_ENCODING[parser->index]) {
                                parser->header_state = h_general;
                            } else if (parser->index == sizeof(TRANSFER_ENCODING)-2) {
                                parser->header_state = h_transfer_encoding;
                            }
                            break;
                            
                            /* upgrade */
                            
                        case h_matching_upgrade:
                            parser->index++;
                            if (parser->index > sizeof(UPGRADE)-1
                                || c != UPGRADE[parser->index]) {
                                parser->header_state = h_general;
                            } else if (parser->index == sizeof(UPGRADE)-2) {
                                parser->header_state = h_upgrade;
                            }
                            break;
                            
                        case h_connection:
                        case h_content_length:
                        case h_transfer_encoding:
                        case h_upgrade:
                            if (ch != ' ') parser->header_state = h_general;
                            break;
                            
                        default:
                            assert(0 && "Unknown header_state");
                            break;
                    }
                    break;
                }
                
                if (ch == ':') {
                    parser->state = s_header_value_start;
                    CALLBACK_DATA(header_field);
                    break;
                }
                
                if (ch == CR) {
                    parser->state = s_header_almost_done;
                    CALLBACK_DATA(header_field);
                    break;
                }
                
                if (ch == LF) {
                    parser->state = s_header_field_start;
                    CALLBACK_DATA(header_field);
                    break;
                }
                
                SET_ERRNO(HPE_INVALID_HEADER_TOKEN);
                goto error;
            }
                
            case s_header_value_start:
            {
                if (ch == ' ' || ch == '\t') break;
                
                MARK(header_value);
                
                parser->state = s_header_value;
                parser->index = 0;
                
                if (ch == CR) {
                    parser->header_state = h_general;
                    parser->state = s_header_almost_done;
                    CALLBACK_DATA(header_value);
                    break;
                }
                
                if (ch == LF) {
                    parser->state = s_header_field_start;
                    CALLBACK_DATA(header_value);
                    break;
                }
                
                c = LOWER(ch);
                
                switch (parser->header_state) {
                    case h_upgrade:
                        parser->flags |= F_UPGRADE;
                        parser->header_state = h_general;
                        break;
                        
                    case h_transfer_encoding:
                        /* looking for 'Transfer-Encoding: chunked' */
                        if ('c' == c) {
                            parser->header_state = h_matching_transfer_encoding_chunked;
                        } else {
                            parser->header_state = h_general;
                        }
                        break;
                        
                    case h_content_length:
                        if (!IS_NUM(ch)) {
                            SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
                            goto error;
                        }
                        
                        parser->content_length = ch - '0';
                        break;
                        
                    case h_connection:
                        /* looking for 'Connection: keep-alive' */
                        if (c == 'k') {
                            parser->header_state = h_matching_connection_keep_alive;
                            /* looking for 'Connection: close' */
                        } else if (c == 'c') {
                            parser->header_state = h_matching_connection_close;
                        } else {
                            parser->header_state = h_general;
                        }
                        break;
                        
                    default:
                        parser->header_state = h_general;
                        break;
                }
                break;
            }
                
            case s_header_value:
            {
                
                if (ch == CR) {
                    parser->state = s_header_almost_done;
                    CALLBACK_DATA(header_value);
                    break;
                }
                
                if (ch == LF) {
                    parser->state = s_header_almost_done;
                    CALLBACK_DATA_NOADVANCE(header_value);
                    goto reexecute_byte;
                }
                
                c = LOWER(ch);
                
                switch (parser->header_state) {
                    case h_general:
                        break;
                        
                    case h_connection:
                    case h_transfer_encoding:
                        assert(0 && "Shouldn't get here.");
                        break;
                        
                    case h_content_length:
                    {
                        uint64_t t;
                        
                        if (ch == ' ') break;
                        
                        if (!IS_NUM(ch)) {
                            SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
                            goto error;
                        }
                        
                        t = parser->content_length;
                        t *= 10;
                        t += ch - '0';
                        
                        /* Overflow? */
                        if (t < parser->content_length || t == ULLONG_MAX) {
                            SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
                            goto error;
                        }
                        
                        parser->content_length = t;
                        break;
                    }
                        
                        /* Transfer-Encoding: chunked */
                    case h_matching_transfer_encoding_chunked:
                        parser->index++;
                        if (parser->index > sizeof(CHUNKED)-1
                            || c != CHUNKED[parser->index]) {
                            parser->header_state = h_general;
                        } else if (parser->index == sizeof(CHUNKED)-2) {
                            parser->header_state = h_transfer_encoding_chunked;
                        }
                        break;
                        
                        /* looking for 'Connection: keep-alive' */
                    case h_matching_connection_keep_alive:
                        parser->index++;
                        if (parser->index > sizeof(KEEP_ALIVE)-1
                            || c != KEEP_ALIVE[parser->index]) {
                            parser->header_state = h_general;
                        } else if (parser->index == sizeof(KEEP_ALIVE)-2) {
                            parser->header_state = h_connection_keep_alive;
                        }
                        break;
                        
                        /* looking for 'Connection: close' */
                    case h_matching_connection_close:
                        parser->index++;
                        if (parser->index > sizeof(CLOSE)-1 || c != CLOSE[parser->index]) {
                            parser->header_state = h_general;
                        } else if (parser->index == sizeof(CLOSE)-2) {
                            parser->header_state = h_connection_close;
                        }
                        break;
                        
                    case h_transfer_encoding_chunked:
                    case h_connection_keep_alive:
                    case h_connection_close:
                        if (ch != ' ') parser->header_state = h_general;
                        break;
                        
                    default:
                        parser->state = s_header_value;
                        parser->header_state = h_general;
                        break;
                }
                break;
            }
                
            case s_header_almost_done:
            {
                STRICT_CHECK(ch != LF);
                
                parser->state = s_header_value_lws;
                
                switch (parser->header_state) {
                    case h_connection_keep_alive:
                        parser->flags |= F_CONNECTION_KEEP_ALIVE;
                        break;
                    case h_connection_close:
                        parser->flags |= F_CONNECTION_CLOSE;
                        break;
                    case h_transfer_encoding_chunked:
                        parser->flags |= F_CHUNKED;
                        break;
                    default:
                        break;
                }
                
                break;
            }
                
            case s_header_value_lws:
            {
                if (ch == ' ' || ch == '\t')
                    parser->state = s_header_value_start;
                else
                {
                    parser->state = s_header_field_start;
                    goto reexecute_byte;
                }
                break;
            }
                
            case s_headers_almost_done:
            {
                STRICT_CHECK(ch != LF);
                
                if (parser->flags & F_TRAILING) {
                    /* End of a chunked request */
                    parser->state = NEW_MESSAGE();
                    CALLBACK_NOTIFY(message_complete);
                    break;
                }
                
                parser->state = s_headers_done;
                
                /* Set this here so that on_headers_complete() callbacks can see it */
                parser->upgrade =
                (parser->flags & F_UPGRADE || parser->method == HTTP_CONNECT);
                
                /* Here we call the headers_complete callback. This is somewhat
                 * different than other callbacks because if the user returns 1, we
                 * will interpret that as saying that this message has no body. This
                 * is needed for the annoying case of recieving a response to a HEAD
                 * request.
                 *
                 * We'd like to use CALLBACK_NOTIFY_NOADVANCE() here but we cannot, so
                 * we have to simulate it by handling a change in errno below.
                 */
                if (settings->on_headers_complete) {
                    switch (settings->on_headers_complete(parser)) {
                        case 0:
                            break;
                            
                        case 1:
                            parser->flags |= F_SKIPBODY;
                            break;
                            
                        default:
                            SET_ERRNO(HPE_CB_headers_complete);
                            return p - data; /* Error */
                    }
                }
                
                if (HTTP_PARSER_ERRNO(parser) != HPE_OK) {
                    return p - data;
                }
                
                goto reexecute_byte;
            }
                
            case s_headers_done:
            {
                STRICT_CHECK(ch != LF);
                
                parser->nread = 0;
                
                /* Exit, the rest of the connect is in a different protocol. */
                if (parser->upgrade) {
                    parser->state = NEW_MESSAGE();
                    CALLBACK_NOTIFY(message_complete);
                    return (p - data) + 1;
                }
                
                if (parser->flags & F_SKIPBODY) {
                    parser->state = NEW_MESSAGE();
                    CALLBACK_NOTIFY(message_complete);
                } else if (parser->flags & F_CHUNKED) {
                    /* chunked encoding - ignore Content-Length header */
                    parser->state = s_chunk_size_start;
                } else {
                    if (parser->content_length == 0) {
                        /* Content-Length header given but zero: Content-Length: 0\r\n */
                        parser->state = NEW_MESSAGE();
                        CALLBACK_NOTIFY(message_complete);
                    } else if (parser->content_length != ULLONG_MAX) {
                        /* Content-Length header given and non-zero */
                        parser->state = s_body_identity;
                    } else {
                        if (parser->type == HTTP_REQUEST ||
                            !http_message_needs_eof(parser)) {
                            /* Assume content-length 0 - read the next */
                            parser->state = NEW_MESSAGE();
                            CALLBACK_NOTIFY(message_complete);
                        } else {
                            /* Read body until EOF */
                            parser->state = s_body_identity_eof;
                        }
                    }
                }
                
                break;
            }
                
            case s_body_identity:
            {
                uint64_t to_read = MIN(parser->content_length,
                                       (uint64_t) ((data + len) - p));
                
                assert(parser->content_length != 0
                       && parser->content_length != ULLONG_MAX);
                
                /* The difference between advancing content_length and p is because
                 * the latter will automaticaly advance on the next loop iteration.
                 * Further, if content_length ends up at 0, we want to see the last
                 * byte again for our message complete callback.
                 */
                MARK(body);
                parser->content_length -= to_read;
                p += to_read - 1;
                
                if (parser->content_length == 0) {
                    parser->state = s_message_done;
                    
                    /* Mimic CALLBACK_DATA_NOADVANCE() but with one extra byte.
                     *
                     * The alternative to doing this is to wait for the next byte to
                     * trigger the data callback, just as in every other case. The
                     * problem with this is that this makes it difficult for the test
                     * harness to distinguish between complete-on-EOF and
                     * complete-on-length. It's not clear that this distinction is
                     * important for applications, but let's keep it for now.
                     */
                    CALLBACK_DATA_(body, p - body_mark + 1, p - data);
                    goto reexecute_byte;
                }
                
                break;
            }
                
                /* read until EOF */
            case s_body_identity_eof:
                MARK(body);
                p = data + len - 1;
                
                break;
                
            case s_message_done:
                parser->state = NEW_MESSAGE();
                CALLBACK_NOTIFY(message_complete);
                break;
                
            case s_chunk_size_start:
            {
                assert(parser->nread == 1);
                assert(parser->flags & F_CHUNKED);
                
                unhex_val = unhex[(unsigned char)ch];
                if (unhex_val == -1) {
                    SET_ERRNO(HPE_INVALID_CHUNK_SIZE);
                    goto error;
                }
                
                parser->content_length = unhex_val;
                parser->state = s_chunk_size;
                break;
            }
                
            case s_chunk_size:
            {
                uint64_t t;
                
                assert(parser->flags & F_CHUNKED);
                
                if (ch == CR) {
                    parser->state = s_chunk_size_almost_done;
                    break;
                }
                
                unhex_val = unhex[(unsigned char)ch];
                
                if (unhex_val == -1) {
                    if (ch == ';' || ch == ' ') {
                        parser->state = s_chunk_parameters;
                        break;
                    }
                    
                    SET_ERRNO(HPE_INVALID_CHUNK_SIZE);
                    goto error;
                }
                
                t = parser->content_length;
                t *= 16;
                t += unhex_val;
                
                /* Overflow? */
                if (t < parser->content_length || t == ULLONG_MAX) {
                    SET_ERRNO(HPE_INVALID_CONTENT_LENGTH);
                    goto error;
                }
                
                parser->content_length = t;
                break;
            }
                
            case s_chunk_parameters:
            {
                assert(parser->flags & F_CHUNKED);
                /* just ignore this shit. TODO check for overflow */
                if (ch == CR) {
                    parser->state = s_chunk_size_almost_done;
                    break;
                }
                break;
            }
                
            case s_chunk_size_almost_done:
            {
                assert(parser->flags & F_CHUNKED);
                STRICT_CHECK(ch != LF);
                
                parser->nread = 0;
                
                if (parser->content_length == 0) {
                    parser->flags |= F_TRAILING;
                    parser->state = s_header_field_start;
                } else {
                    parser->state = s_chunk_data;
                }
                break;
            }
                
            case s_chunk_data:
            {
                uint64_t to_read = MIN(parser->content_length,
                                       (uint64_t) ((data + len) - p));
                
                assert(parser->flags & F_CHUNKED);
                assert(parser->content_length != 0
                       && parser->content_length != ULLONG_MAX);
                
                /* See the explanation in s_body_identity for why the content
                 * length and data pointers are managed this way.
                 */
                MARK(body);
                parser->content_length -= to_read;
                p += to_read - 1;
                
                if (parser->content_length == 0) {
                    parser->state = s_chunk_data_almost_done;
                }
                
                break;
            }
                
            case s_chunk_data_almost_done:
                assert(parser->flags & F_CHUNKED);
                assert(parser->content_length == 0);
                STRICT_CHECK(ch != CR);
                parser->state = s_chunk_data_done;
                CALLBACK_DATA(body);
                break;
                
            case s_chunk_data_done:
                assert(parser->flags & F_CHUNKED);
                STRICT_CHECK(ch != LF);
                parser->nread = 0;
                parser->state = s_chunk_size_start;
                break;
                
            default:
                assert(0 && "unhandled state");
                SET_ERRNO(HPE_INVALID_INTERNAL_STATE);
                goto error;
        }
    }
    
    /* Run callbacks for any marks that we have leftover after we ran our of
     * bytes. There should be at most one of these set, so it's OK to invoke
     * them in series (unset marks will not result in callbacks).
     *
     * We use the NOADVANCE() variety of callbacks here because 'p' has already
     * overflowed 'data' and this allows us to correct for the off-by-one that
     * we'd otherwise have (since CALLBACK_DATA() is meant to be run with a 'p'
     * value that's in-bounds).
     */
    
    assert(((header_field_mark ? 1 : 0) +
            (header_value_mark ? 1 : 0) +
            (url_mark ? 1 : 0)  +
            (body_mark ? 1 : 0)) <= 1);
    
    CALLBACK_DATA_NOADVANCE(header_field);
    CALLBACK_DATA_NOADVANCE(header_value);
    CALLBACK_DATA_NOADVANCE(url);
    CALLBACK_DATA_NOADVANCE(body);
    
    return len;
    
error:
    if (HTTP_PARSER_ERRNO(parser) == HPE_OK) {
        SET_ERRNO(HPE_UNKNOWN);
    }
    
    return (p - data);
}


/* Does the parser need to see an EOF to find the end of the message? */
int
http_message_needs_eof (const http_parser *parser)
{
    if (parser->type == HTTP_REQUEST) {
        return 0;
    }
    
    /* See RFC 2616 section 4.4 */
    if (parser->status_code / 100 == 1 || /* 1xx e.g. Continue */
        parser->status_code == 204 ||     /* No Content */
        parser->status_code == 304 ||     /* Not Modified */
        parser->flags & F_SKIPBODY) {     /* response to a HEAD request */
        return 0;
    }
    
    if ((parser->flags & F_CHUNKED) || parser->content_length != ULLONG_MAX) {
        return 0;
    }
    
    return 1;
}


int
http_should_keep_alive (const http_parser *parser)
{
    if (parser->http_major > 0 && parser->http_minor > 0) {
        /* HTTP/1.1 */
        if (parser->flags & F_CONNECTION_CLOSE) {
            return 0;
        }
    } else {
        /* HTTP/1.0 or earlier */
        if (!(parser->flags & F_CONNECTION_KEEP_ALIVE)) {
            return 0;
        }
    }
    
    return !http_message_needs_eof(parser);
}


const char *
http_method_str (enum http_method m)
{
    return ELEM_AT(method_strings, m, "<unknown>");
}


void
http_parser_init (http_parser *parser, enum http_parser_type t)
{
    void *data = parser->data; /* preserve application data */
    memset(parser, 0, sizeof(*parser));
    parser->data = data;
    parser->type = t;
    parser->state = (t == HTTP_REQUEST ? s_start_req : (t == HTTP_RESPONSE ? s_start_res : s_start_req_or_res));
    parser->http_errno = HPE_OK;
}

const char *
http_errno_name(enum http_errno err) {
    assert(err < (sizeof(http_strerror_tab)/sizeof(http_strerror_tab[0])));
    return http_strerror_tab[err].name;
}

const char *
http_errno_description(enum http_errno err) {
    assert(err < (sizeof(http_strerror_tab)/sizeof(http_strerror_tab[0])));
    return http_strerror_tab[err].description;
}

static enum http_host_state
http_parse_host_char(enum http_host_state s, const char ch) {
    switch(s) {
        case s_http_userinfo:
        case s_http_userinfo_start:
            if (ch == '@') {
                return s_http_host_start;
            }
            
            if (IS_USERINFO_CHAR(ch)) {
                return s_http_userinfo;
            }
            break;
            
        case s_http_host_start:
            if (ch == '[') {
                return s_http_host_v6_start;
            }
            
            if (IS_HOST_CHAR(ch)) {
                return s_http_host;
            }
            
            break;
            
        case s_http_host:
            if (IS_HOST_CHAR(ch)) {
                return s_http_host;
            }
            
            /* FALLTHROUGH */
        case s_http_host_v6_end:
            if (ch == ':') {
                return s_http_host_port_start;
            }
            
            break;
            
        case s_http_host_v6:
            if (ch == ']') {
                return s_http_host_v6_end;
            }
            
            /* FALLTHROUGH */
        case s_http_host_v6_start:
            if (IS_HEX(ch) || ch == ':' || ch == '.') {
                return s_http_host_v6;
            }
            
            break;
            
        case s_http_host_port:
        case s_http_host_port_start:
            if (IS_NUM(ch)) {
                return s_http_host_port;
            }
            
            break;
            
        default:
            break;
    }
    return s_http_host_dead;
}

static int
http_parse_host(const char * buf, struct http_parser_url *u, int found_at) {
    enum http_host_state s;
    
    const char *p;
    size_t buflen = u->field_data[UF_HOST].off + u->field_data[UF_HOST].len;
    
    u->field_data[UF_HOST].len = 0;
    
    s = found_at ? s_http_userinfo_start : s_http_host_start;
    
    for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++) {
        enum http_host_state new_s = http_parse_host_char(s, *p);
        
        if (new_s == s_http_host_dead) {
            return 1;
        }
        
        switch(new_s) {
            case s_http_host:
                if (s != s_http_host) {
                    u->field_data[UF_HOST].off = p - buf;
                }
                u->field_data[UF_HOST].len++;
                break;
                
            case s_http_host_v6:
                if (s != s_http_host_v6) {
                    u->field_data[UF_HOST].off = p - buf;
                }
                u->field_data[UF_HOST].len++;
                break;
                
            case s_http_host_port:
                if (s != s_http_host_port) {
                    u->field_data[UF_PORT].off = p - buf;
                    u->field_data[UF_PORT].len = 0;
                    u->field_set |= (1 << UF_PORT);
                }
                u->field_data[UF_PORT].len++;
                break;
                
            case s_http_userinfo:
                if (s != s_http_userinfo) {
                    u->field_data[UF_USERINFO].off = p - buf;
                    u->field_data[UF_USERINFO].len = 0;
                    u->field_set |= (1 << UF_USERINFO);
                }
                u->field_data[UF_USERINFO].len++;
                break;
                
            default:
                break;
        }
        s = new_s;
    }
    
    /* Make sure we don't end somewhere unexpected */
    switch (s) {
        case s_http_host_start:
        case s_http_host_v6_start:
        case s_http_host_v6:
        case s_http_host_port_start:
        case s_http_userinfo:
        case s_http_userinfo_start:
            return 1;
        default:
            break;
    }
    
    return 0;
}

int
http_parser_parse_url(const char *buf, size_t buflen, int is_connect,
                      struct http_parser_url *u)
{
    enum state s;
    const char *p;
    enum http_parser_url_fields uf, old_uf;
    int found_at = 0;
    
    u->port = u->field_set = 0;
    s = is_connect ? s_req_server_start : s_req_spaces_before_url;
    uf = old_uf = UF_MAX;
    
    for (p = buf; p < buf + buflen; p++) {
        s = parse_url_char(s, *p);
        
        /* Figure out the next field that we're operating on */
        switch (s) {
            case s_dead:
                return 1;
                
                /* Skip delimeters */
            case s_req_schema_slash:
            case s_req_schema_slash_slash:
            case s_req_server_start:
            case s_req_query_string_start:
            case s_req_fragment_start:
                continue;
                
            case s_req_schema:
                uf = UF_SCHEMA;
                break;
                
            case s_req_server_with_at:
                found_at = 1;
                
                /* FALLTROUGH */
            case s_req_server:
                uf = UF_HOST;
                break;
                
            case s_req_path:
                uf = UF_PATH;
                break;
                
            case s_req_query_string:
                uf = UF_QUERY;
                break;
                
            case s_req_fragment:
                uf = UF_FRAGMENT;
                break;
                
            default:
                assert(!"Unexpected state");
                return 1;
        }
        
        /* Nothing's changed; soldier on */
        if (uf == old_uf) {
            u->field_data[uf].len++;
            continue;
        }
        
        u->field_data[uf].off = p - buf;
        u->field_data[uf].len = 1;
        
        u->field_set |= (1 << uf);
        old_uf = uf;
    }
    
    /* host must be present if there is a schema */
    /* parsing http:///toto will fail */
    if ((u->field_set & ((1 << UF_SCHEMA) | (1 << UF_HOST))) != 0) {
        if (http_parse_host(buf, u, found_at) != 0) {
            return 1;
        }
    }
    
    /* CONNECT requests can only contain "hostname:port" */
    if (is_connect && u->field_set != ((1 << UF_HOST)|(1 << UF_PORT))) {
        return 1;
    }
    
    if (u->field_set & (1 << UF_PORT)) {
        /* Don't bother with endp; we've already validated the string */
        unsigned long v = strtoul(buf + u->field_data[UF_PORT].off, NULL, 10);
        
        /* Ports have a max value of 2^16 */
        if (v > 0xffff) {
            return 1;
        }
        
        u->port = (uint16_t) v;
    }
    
    return 0;
}

void
http_parser_pause(http_parser *parser, int paused) {
    /* Users should only be pausing/unpausing a parser that is not in an error
     * state. In non-debug builds, there's not much that we can do about this
     * other than ignore it.
     */
    if (HTTP_PARSER_ERRNO(parser) == HPE_OK ||
        HTTP_PARSER_ERRNO(parser) == HPE_PAUSED) {
        SET_ERRNO((paused) ? HPE_PAUSED : HPE_OK);
    } else {
        assert(0 && "Attempting to pause parser in error state");
    }
}

int
http_body_is_final(const struct http_parser *parser) {
    return parser->state == s_message_done;
}

/*
 The MIT License (MIT)
 
 Copyright (c) 2013-2018 Winlin
 
 Permission is hereby granted, free of charge, to any person obtaining a copy of
 this software and associated documentation files (the "Software"), to deal in
 the Software without restriction, including without limitation the rights to
 use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 the Software, and to permit persons to whom the Software is furnished to do so,
 subject to the following conditions:
 
 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
SrsHttpUri::SrsHttpUri()
{
    port = SRS_DEFAULT_HTTP_PORT;
}

SrsHttpUri::~SrsHttpUri()
{
}

srs_error_t SrsHttpUri::initialize(string _url)
{
    srs_error_t err = srs_success;
    
    schema = host = path = query = "";
    
    url = _url;
    const char* purl = url.c_str();
    
    http_parser_url hp_u;
    int r0;
    if((r0 = http_parser_parse_url(purl, url.length(), 0, &hp_u)) != 0){
        return srs_error_new(ERROR_HTTP_PARSE_URI, "parse url %s failed, code=%d", purl, r0);
    }
    
    std::string field = get_uri_field(url, &hp_u, UF_SCHEMA);
    if(!field.empty()){
        schema = field;
    }
    
    host = get_uri_field(url, &hp_u, UF_HOST);
    
    field = get_uri_field(url, &hp_u, UF_PORT);
    if(!field.empty()){
        port = atoi(field.c_str());
    }
    if(port<=0){
        port = SRS_DEFAULT_HTTP_PORT;
    }
    
    path = get_uri_field(url, &hp_u, UF_PATH);
    query = get_uri_field(url, &hp_u, UF_QUERY);
    
    return err;
}

string SrsHttpUri::get_url()
{
    return url;
}

string SrsHttpUri::get_schema()
{
    return schema;
}

string SrsHttpUri::get_host()
{
    return host;
}

int SrsHttpUri::get_port()
{
    return port;
}

string SrsHttpUri::get_path()
{
    return path;
}

string SrsHttpUri::get_query()
{
    return query;
}

string SrsHttpUri::get_uri_field(string uri, http_parser_url* hp_u, http_parser_url_fields field)
{
    if((hp_u->field_set & (1 << field)) == 0){
        return "";
    }
    
    int offset = hp_u->field_data[field].off;
    int len = hp_u->field_data[field].len;
    
    return uri.substr(offset, len);
}


// following is generated by src/protocol/srs_protocol_kbps.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_protocol_kbps.hpp>

//#include <srs_kernel_utility.hpp>

SrsKbpsSample::SrsKbpsSample()
{
    bytes = time = 0;
    kbps = 0;
}

SrsKbpsSlice::SrsKbpsSlice()
{
    io.in = NULL;
    io.out = NULL;
    last_bytes = io_bytes_base = starttime = bytes = delta_bytes = 0;
}

SrsKbpsSlice::~SrsKbpsSlice()
{
}

int64_t SrsKbpsSlice::get_total_bytes()
{
    return bytes + last_bytes - io_bytes_base;
}

void SrsKbpsSlice::sample()
{
    int64_t now = srs_get_system_time_ms();
    int64_t total_bytes = get_total_bytes();
    
    if (sample_30s.time <= 0) {
        sample_30s.kbps = 0;
        sample_30s.time = now;
        sample_30s.bytes = total_bytes;
    }
    if (sample_1m.time <= 0) {
        sample_1m.kbps = 0;
        sample_1m.time = now;
        sample_1m.bytes = total_bytes;
    }
    if (sample_5m.time <= 0) {
        sample_5m.kbps = 0;
        sample_5m.time = now;
        sample_5m.bytes = total_bytes;
    }
    if (sample_60m.time <= 0) {
        sample_60m.kbps = 0;
        sample_60m.time = now;
        sample_60m.bytes = total_bytes;
    }
    
    if (now - sample_30s.time > 30 * 1000) {
        sample_30s.kbps = (int)((total_bytes - sample_30s.bytes) * 8 / (now - sample_30s.time));
        sample_30s.time = now;
        sample_30s.bytes = total_bytes;
    }
    if (now - sample_1m.time > 60 * 1000) {
        sample_1m.kbps = (int)((total_bytes - sample_1m.bytes) * 8 / (now - sample_1m.time));
        sample_1m.time = now;
        sample_1m.bytes = total_bytes;
    }
    if (now - sample_5m.time > 300 * 1000) {
        sample_5m.kbps = (int)((total_bytes - sample_5m.bytes) * 8 / (now - sample_5m.time));
        sample_5m.time = now;
        sample_5m.bytes = total_bytes;
    }
    if (now - sample_60m.time > 3600 * 1000) {
        sample_60m.kbps = (int)((total_bytes - sample_60m.bytes) * 8 / (now - sample_60m.time));
        sample_60m.time = now;
        sample_60m.bytes = total_bytes;
    }
}

IKbpsDelta::IKbpsDelta()
{
}

IKbpsDelta::~IKbpsDelta()
{
}

SrsKbps::SrsKbps()
{
}

SrsKbps::~SrsKbps()
{
}

void SrsKbps::set_io(ISrsProtocolStatistic* in, ISrsProtocolStatistic* out)
{
    // set input stream
    // now, set start time.
    if (is.starttime == 0) {
        is.starttime = srs_get_system_time_ms();
    }
    // save the old in bytes.
    if (is.io.in) {
        is.bytes += is.io.in->get_recv_bytes() - is.io_bytes_base;
    }
    // use new io.
    is.io.in = in;
    is.last_bytes = is.io_bytes_base = 0;
    if (in) {
        is.last_bytes = is.io_bytes_base = in->get_recv_bytes();
    }
    // resample
    is.sample();
    
    // set output stream
    // now, set start time.
    if (os.starttime == 0) {
        os.starttime = srs_get_system_time_ms();
    }
    // save the old in bytes.
    if (os.io.out) {
        os.bytes += os.io.out->get_send_bytes() - os.io_bytes_base;
    }
    // use new io.
    os.io.out = out;
    os.last_bytes = os.io_bytes_base = 0;
    if (out) {
        os.last_bytes = os.io_bytes_base = out->get_send_bytes();
    }
    // resample
    os.sample();
}

int SrsKbps::get_send_kbps()
{
    int64_t duration = srs_get_system_time_ms() - is.starttime;
    if (duration <= 0) {
        return 0;
    }
    int64_t bytes = get_send_bytes();
    return (int)(bytes * 8 / duration);
}

int SrsKbps::get_recv_kbps()
{
    int64_t duration = srs_get_system_time_ms() - os.starttime;
    if (duration <= 0) {
        return 0;
    }
    int64_t bytes = get_recv_bytes();
    return (int)(bytes * 8 / duration);
}

int SrsKbps::get_send_kbps_30s()
{
    return os.sample_30s.kbps;
}

int SrsKbps::get_recv_kbps_30s()
{
    return is.sample_30s.kbps;
}

int SrsKbps::get_send_kbps_5m()
{
    return os.sample_5m.kbps;
}

int SrsKbps::get_recv_kbps_5m()
{
    return is.sample_5m.kbps;
}

int64_t SrsKbps::get_send_bytes()
{
    // we must calc the send bytes dynamically,
    // to not depends on the sample(which used to calc the kbps).
    // @read https://github.com/ossrs/srs/issues/588
    
    // session start bytes.
    int64_t bytes = os.bytes;
    
    // When exists active session, use it to get the last bytes.
    if (os.io.out) {
        bytes += os.io.out->get_send_bytes() - os.io_bytes_base;
        return bytes;
    }
    
    // When no active session, the last_bytes record the last valid bytes.
    // TODO: Maybe the bellow bytes is zero, because the ios.io.out is NULL.
    bytes += os.last_bytes - os.io_bytes_base;
    
    return bytes;
}

int64_t SrsKbps::get_recv_bytes()
{
    // we must calc the send bytes dynamically,
    // to not depends on the sample(which used to calc the kbps).
    // @read https://github.com/ossrs/srs/issues/588
    
    // session start bytes.
    int64_t bytes = is.bytes;
    
    // When exists active session, use it to get the last bytes.
    if (is.io.in) {
        bytes += is.io.in->get_recv_bytes() - is.io_bytes_base;
        return bytes;
    }
    
    // When no active session, the last_bytes record the last valid bytes.
    // TODO: Maybe the bellow bytes is zero, because the ios.io.out is NULL.
    bytes += is.last_bytes - is.io_bytes_base;
    
    return bytes;
}

void SrsKbps::resample()
{
    sample();
}

int64_t SrsKbps::get_send_bytes_delta()
{
    int64_t delta = os.get_total_bytes() - os.delta_bytes;
    return delta;
}

int64_t SrsKbps::get_recv_bytes_delta()
{
    int64_t delta = is.get_total_bytes() - is.delta_bytes;
    return delta;
}

void SrsKbps::cleanup()
{
    os.delta_bytes = os.get_total_bytes();
    is.delta_bytes = is.get_total_bytes();
}

void SrsKbps::add_delta(IKbpsDelta* delta)
{
    srs_assert(delta);
    
    // update the total bytes
    is.last_bytes += delta->get_recv_bytes_delta();
    os.last_bytes += delta->get_send_bytes_delta();
    
    // we donot sample, please use sample() to do resample.
}

void SrsKbps::sample()
{
    // update the total bytes
    if (os.io.out) {
        os.last_bytes = os.io.out->get_send_bytes();
    }
    
    if (is.io.in) {
        is.last_bytes = is.io.in->get_recv_bytes();
    }
    
    // resample
    is.sample();
    os.sample();
}

int SrsKbps::size_memory()
{
    return sizeof(SrsKbps);
}

// following is generated by src/protocol/srs_protocol_json.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_core.hpp>

/* vim: set et ts=3 sw=3 sts=3 ft=c:
 *
 * Copyright (C) 2012, 2013, 2014 James McLaughlin et al.  All rights reserved.
 * https://github.com/udp/json-parser
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#ifndef _JSON_H
#define _JSON_H

#ifndef json_char
#define json_char char
#endif

#ifndef json_int_t
#ifndef _MSC_VER
#include <inttypes.h>
#define json_int_t int64_t
#else
#define json_int_t __int64
#endif
#endif

#include <stdlib.h>

#ifdef __cplusplus

#include <string.h>

extern "C"
{
    
#endif
    
    typedef struct
    {
        unsigned long max_memory;
        int settings;
        
        /* Custom allocator support (leave null to use malloc/free)
         */
        
        void * (* mem_alloc) (size_t, int zero, void * user_data);
        void (* mem_free) (void *, void * user_data);
        
        void * user_data;  /* will be passed to mem_alloc and mem_free */
        
        size_t value_extra;  /* how much extra space to allocate for values? */
        
    } json_settings;
    
#define json_enable_comments  0x01
    
    typedef enum
    {
        json_none,
        json_object,
        json_array,
        json_integer,
        json_double,
        json_string,
        json_boolean,
        json_null
        
    } json_type;
    
    extern const struct _json_value json_value_none;
    
    typedef struct _json_object_entry
    {
        json_char * name;
        unsigned int name_length;
        
        struct _json_value * value;
        
    } json_object_entry;
    
    typedef struct _json_value
    {
        struct _json_value * parent;
        
        json_type type;
        
        union
        {
            int boolean;
            json_int_t integer;
            double dbl;
            
            struct
            {
                unsigned int length;
                json_char * ptr; /* null terminated */
                
            } string;
            
            struct
            {
                unsigned int length;
                
                json_object_entry * values;
                
#if defined(__cplusplus) && __cplusplus >= 201103L
                decltype(values) begin () const
                {  return values;
                }
                decltype(values) end () const
                {  return values + length;
                }
#endif
                
            } object;
            
            struct
            {
                unsigned int length;
                struct _json_value ** values;
                
#if defined(__cplusplus) && __cplusplus >= 201103L
                decltype(values) begin () const
                {  return values;
                }
                decltype(values) end () const
                {  return values + length;
                }
#endif
                
            } array;
            
        } u;
        
        union
        {
            struct _json_value * next_alloc;
            void * object_mem;
            
        } _reserved;
        
#ifdef JSON_TRACK_SOURCE
        
        /* Location of the value in the source JSON
         */
        unsigned int line, col;
        
#endif
        
        
        /* Some C++ operator sugar */
        
#ifdef __cplusplus
        
    public:
        
        inline _json_value ()
        {  memset (this, 0, sizeof (_json_value));
        }
        
        inline const struct _json_value &operator [] (int index) const
        {
            if (type != json_array || index < 0
                || ((unsigned int) index) >= u.array.length)
            {
                return json_value_none;
            }
            
            return *u.array.values [index];
        }
        
        inline const struct _json_value &operator [] (const char * index) const
        {
            if (type != json_object)
                return json_value_none;
            
            for (unsigned int i = 0; i < u.object.length; ++ i)
                if (!strcmp (u.object.values [i].name, index))
                    return *u.object.values [i].value;
            
            return json_value_none;
        }
        
        inline operator const char * () const
        {
            switch (type)
            {
                case json_string:
                    return u.string.ptr;
                    
                default:
                    return "";
            };
        }
        
        inline operator json_int_t () const
        {
            switch (type)
            {
                case json_integer:
                    return u.integer;
                    
                case json_double:
                    return (json_int_t) u.dbl;
                    
                default:
                    return 0;
            };
        }
        
        inline operator bool () const
        {
            if (type != json_boolean)
                return false;
            
            return u.boolean != 0;
        }
        
        inline operator double () const
        {
            switch (type)
            {
                case json_integer:
                    return (double) u.integer;
                    
                case json_double:
                    return u.dbl;
                    
                default:
                    return 0;
            };
        }
        
#endif
        
    } json_value;
    
    json_value * json_parse (const json_char * json,
                             size_t length);
    
#define json_error_max 128
    json_value * json_parse_ex (json_settings * settings,
                                const json_char * json,
                                size_t length,
                                char * error);
    
    void json_value_free (json_value *);
    
    
    /* Not usually necessary, unless you used a custom mem_alloc and now want to
     * use a custom mem_free.
     */
    void json_value_free_ex (json_settings * settings,
                             json_value *);
    
    
#ifdef __cplusplus
} /* extern "C" */
#endif

/* vim: set et ts=3 sw=3 sts=3 ft=c:
 *
 * Copyright (C) 2012, 2013, 2014 James McLaughlin et al.  All rights reserved.
 * https://github.com/udp/json-parser
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

//#include "json.h"

#ifdef _MSC_VER
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif
#endif

const struct _json_value json_value_none;

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

typedef unsigned int json_uchar;

static unsigned char hex_value (json_char c)
{
    if (isdigit(c))
        return c - '0';
    
    switch (c) {
        case 'a': case 'A': return 0x0A;
        case 'b': case 'B': return 0x0B;
        case 'c': case 'C': return 0x0C;
        case 'd': case 'D': return 0x0D;
        case 'e': case 'E': return 0x0E;
        case 'f': case 'F': return 0x0F;
        default: return 0xFF;
    }
}

typedef struct
{
    unsigned long used_memory;
    
    unsigned int uint_max;
    unsigned long ulong_max;
    
    json_settings settings;
    int first_pass;
    
    const json_char * ptr;
    unsigned int cur_line, cur_col;
    
} json_state;

static void * default_alloc (size_t size, int zero, void * user_data)
{
    return zero ? calloc (1, size) : malloc (size);
}

static void default_free (void * ptr, void * user_data)
{
    free (ptr);
}

static void * json_alloc (json_state * state, unsigned long size, int zero)
{
    if ((state->ulong_max - state->used_memory) < size)
        return 0;
    
    if (state->settings.max_memory
        && (state->used_memory += size) > state->settings.max_memory)
    {
        return 0;
    }
    
    return state->settings.mem_alloc (size, zero, state->settings.user_data);
}

static int new_value (json_state * state,
                      json_value ** top, json_value ** root, json_value ** alloc,
                      json_type type)
{
    json_value * value;
    int values_size;
    
    if (!state->first_pass)
    {
        value = *top = *alloc;
        *alloc = (*alloc)->_reserved.next_alloc;
        
        if (!*root)
            *root = value;
        
        switch (value->type)
        {
            case json_array:
                
                if (value->u.array.length == 0)
                    break;
                
                if (! (value->u.array.values = (json_value **) json_alloc
                       (state, value->u.array.length * sizeof (json_value *), 0)) )
                {
                    return 0;
                }
                
                value->u.array.length = 0;
                break;
                
            case json_object:
                
                if (value->u.object.length == 0)
                    break;
                
                values_size = sizeof (*value->u.object.values) * value->u.object.length;
                
                if (! (value->u.object.values = (json_object_entry *) json_alloc
                       (state, values_size + ((unsigned long) value->u.object.values), 0)) )
                {
                    return 0;
                }
                
                value->_reserved.object_mem = (*(char **) &value->u.object.values) + values_size;
                
                value->u.object.length = 0;
                break;
                
            case json_string:
                
                if (! (value->u.string.ptr = (json_char *) json_alloc
                       (state, (value->u.string.length + 1) * sizeof (json_char), 0)) )
                {
                    return 0;
                }
                
                value->u.string.length = 0;
                break;
                
            default:
                break;
        };
        
        return 1;
    }
    
    if (! (value = (json_value *) json_alloc
           (state, sizeof (json_value) + state->settings.value_extra, 1)))
    {
        return 0;
    }
    
    if (!*root)
        *root = value;
    
    value->type = type;
    value->parent = *top;
    
#ifdef JSON_TRACK_SOURCE
    value->line = state->cur_line;
    value->col = state->cur_col;
#endif
    
    if (*alloc)
        (*alloc)->_reserved.next_alloc = value;
    
    *alloc = *top = value;
    
    return 1;
}

#define whitespace \
case '\n': ++ state.cur_line;  state.cur_col = 0; \
case ' ': case '\t': case '\r'

#define string_add(b)  \
do { if (!state.first_pass) string [string_length] = b;  ++ string_length; } while (0);

#define line_and_col \
state.cur_line, state.cur_col

static const long
flag_next             = 1 << 0,
flag_reproc           = 1 << 1,
flag_need_comma       = 1 << 2,
flag_seek_value       = 1 << 3,
flag_escaped          = 1 << 4,
flag_string           = 1 << 5,
flag_need_colon       = 1 << 6,
flag_done             = 1 << 7,
flag_num_negative     = 1 << 8,
flag_num_zero         = 1 << 9,
flag_num_e            = 1 << 10,
flag_num_e_got_sign   = 1 << 11,
flag_num_e_negative   = 1 << 12,
flag_line_comment     = 1 << 13,
flag_block_comment    = 1 << 14;

json_value * json_parse_ex (json_settings * settings,
                            const json_char * json,
                            size_t length,
                            char * error_buf)
{
    json_char error [json_error_max];
    const json_char * end;
    json_value * top, * root, * alloc = 0;
    json_state state = { 0 };
    long flags;
    long num_digits = 0, num_e = 0;
    json_int_t num_fraction = 0;
    
    /* Skip UTF-8 BOM
     */
    if (length >= 3 && ((unsigned char) json [0]) == 0xEF
        && ((unsigned char) json [1]) == 0xBB
        && ((unsigned char) json [2]) == 0xBF)
    {
        json += 3;
        length -= 3;
    }
    
    error[0] = '\0';
    end = (json + length);
    
    memcpy (&state.settings, settings, sizeof (json_settings));
    
    if (!state.settings.mem_alloc)
        state.settings.mem_alloc = default_alloc;
    
    if (!state.settings.mem_free)
        state.settings.mem_free = default_free;
    
    memset (&state.uint_max, 0xFF, sizeof (state.uint_max));
    memset (&state.ulong_max, 0xFF, sizeof (state.ulong_max));
    
    state.uint_max -= 8; /* limit of how much can be added before next check */
    state.ulong_max -= 8;
    
    for (state.first_pass = 1; state.first_pass >= 0; -- state.first_pass)
    {
        json_uchar uchar;
        unsigned char uc_b1, uc_b2, uc_b3, uc_b4;
        json_char * string = 0;
        unsigned int string_length = 0;
        
        top = root = 0;
        flags = flag_seek_value;
        
        state.cur_line = 1;
        
        for (state.ptr = json ;; ++ state.ptr)
        {
            json_char b = (state.ptr == end ? 0 : *state.ptr);
            
            if (flags & flag_string)
            {
                if (!b)
                {  sprintf (error, "Unexpected EOF in string (at %d:%d)", line_and_col);
                    goto e_failed;
                }
                
                if (string_length > state.uint_max)
                    goto e_overflow;
                
                if (flags & flag_escaped)
                {
                    flags &= ~ flag_escaped;
                    
                    switch (b)
                    {
                        case 'b':  string_add ('\b');  break;
                        case 'f':  string_add ('\f');  break;
                        case 'n':  string_add ('\n');  break;
                        case 'r':  string_add ('\r');  break;
                        case 't':  string_add ('\t');  break;
                        case 'u':
                            
                            if (end - state.ptr < 4 ||
                                (uc_b1 = hex_value (*++ state.ptr)) == 0xFF ||
                                (uc_b2 = hex_value (*++ state.ptr)) == 0xFF ||
                                (uc_b3 = hex_value (*++ state.ptr)) == 0xFF ||
                                (uc_b4 = hex_value (*++ state.ptr)) == 0xFF)
                            {
                                sprintf (error, "Invalid character value `%c` (at %d:%d)", b, line_and_col);
                                goto e_failed;
                            }
                            
                            uc_b1 = (uc_b1 << 4) | uc_b2;
                            uc_b2 = (uc_b3 << 4) | uc_b4;
                            uchar = (uc_b1 << 8) | uc_b2;
                            
                            if ((uchar & 0xF800) == 0xD800) {
                                json_uchar uchar2;
                                
                                if (end - state.ptr < 6 || (*++ state.ptr) != '\\' || (*++ state.ptr) != 'u' ||
                                    (uc_b1 = hex_value (*++ state.ptr)) == 0xFF ||
                                    (uc_b2 = hex_value (*++ state.ptr)) == 0xFF ||
                                    (uc_b3 = hex_value (*++ state.ptr)) == 0xFF ||
                                    (uc_b4 = hex_value (*++ state.ptr)) == 0xFF)
                                {
                                    sprintf (error, "Invalid character value `%c` (at %d:%d)", b, line_and_col);
                                    goto e_failed;
                                }
                                
                                uc_b1 = (uc_b1 << 4) | uc_b2;
                                uc_b2 = (uc_b3 << 4) | uc_b4;
                                uchar2 = (uc_b1 << 8) | uc_b2;
                                
                                uchar = 0x010000 | ((uchar & 0x3FF) << 10) | (uchar2 & 0x3FF);
                            }
                            
                            if (sizeof (json_char) >= sizeof (json_uchar) || (uchar <= 0x7F))
                            {
                                string_add ((json_char) uchar);
                                break;
                            }
                            
                            if (uchar <= 0x7FF)
                            {
                                if (state.first_pass)
                                    string_length += 2;
                                else
                                {  string [string_length ++] = 0xC0 | (uchar >> 6);
                                    string [string_length ++] = 0x80 | (uchar & 0x3F);
                                }
                                
                                break;
                            }
                            
                            if (uchar <= 0xFFFF) {
                                if (state.first_pass)
                                    string_length += 3;
                                else
                                {  string [string_length ++] = 0xE0 | (uchar >> 12);
                                    string [string_length ++] = 0x80 | ((uchar >> 6) & 0x3F);
                                    string [string_length ++] = 0x80 | (uchar & 0x3F);
                                }
                                
                                break;
                            }
                            
                            if (state.first_pass)
                                string_length += 4;
                            else
                            {  string [string_length ++] = 0xF0 | (uchar >> 18);
                                string [string_length ++] = 0x80 | ((uchar >> 12) & 0x3F);
                                string [string_length ++] = 0x80 | ((uchar >> 6) & 0x3F);
                                string [string_length ++] = 0x80 | (uchar & 0x3F);
                            }
                            
                            break;
                            
                        default:
                            string_add (b);
                    };
                    
                    continue;
                }
                
                if (b == '\\')
                {
                    flags |= flag_escaped;
                    continue;
                }
                
                if (b == '"')
                {
                    if (!state.first_pass)
                        string [string_length] = 0;
                    
                    flags &= ~ flag_string;
                    string = 0;
                    
                    switch (top->type)
                    {
                        case json_string:
                            
                            top->u.string.length = string_length;
                            flags |= flag_next;
                            
                            break;
                            
                        case json_object:
                            
                            if (state.first_pass)
                                (*(json_char **) &top->u.object.values) += string_length + 1;
                            else
                            {
                                top->u.object.values [top->u.object.length].name
                                = (json_char *) top->_reserved.object_mem;
                                
                                top->u.object.values [top->u.object.length].name_length
                                = string_length;
                                
                                (*(json_char **) &top->_reserved.object_mem) += string_length + 1;
                            }
                            
                            flags |= flag_seek_value | flag_need_colon;
                            continue;
                            
                        default:
                            break;
                    };
                }
                else
                {
                    string_add (b);
                    continue;
                }
            }
            
            if (state.settings.settings & json_enable_comments)
            {
                if (flags & (flag_line_comment | flag_block_comment))
                {
                    if (flags & flag_line_comment)
                    {
                        if (b == '\r' || b == '\n' || !b)
                        {
                            flags &= ~ flag_line_comment;
                            -- state.ptr;  /* so null can be reproc'd */
                        }
                        
                        continue;
                    }
                    
                    if (flags & flag_block_comment)
                    {
                        if (!b)
                        {  sprintf (error, "%d:%d: Unexpected EOF in block comment", line_and_col);
                            goto e_failed;
                        }
                        
                        if (b == '*' && state.ptr < (end - 1) && state.ptr [1] == '/')
                        {
                            flags &= ~ flag_block_comment;
                            ++ state.ptr;  /* skip closing sequence */
                        }
                        
                        continue;
                    }
                }
                else if (b == '/')
                {
                    if (! (flags & (flag_seek_value | flag_done)) && top->type != json_object)
                    {  sprintf (error, "%d:%d: Comment not allowed here", line_and_col);
                        goto e_failed;
                    }
                    
                    if (++ state.ptr == end)
                    {  sprintf (error, "%d:%d: EOF unexpected", line_and_col);
                        goto e_failed;
                    }
                    
                    switch (b = *state.ptr)
                    {
                        case '/':
                            flags |= flag_line_comment;
                            continue;
                            
                        case '*':
                            flags |= flag_block_comment;
                            continue;
                            
                        default:
                            sprintf (error, "%d:%d: Unexpected `%c` in comment opening sequence", line_and_col, b);
                            goto e_failed;
                    };
                }
            }
            
            if (flags & flag_done)
            {
                if (!b)
                    break;
                
                switch (b)
                {
                    whitespace:
                        continue;
                        
                    default:
                        
                        sprintf (error, "%d:%d: Trailing garbage: `%c`",
                                 state.cur_line, state.cur_col, b);
                        
                        goto e_failed;
                };
            }
            
            if (flags & flag_seek_value)
            {
                switch (b)
                {
                    whitespace:
                        continue;
                        
                    case ']':
                        
                        if (top && top->type == json_array)
                            flags = (flags & ~ (flag_need_comma | flag_seek_value)) | flag_next;
                        else
                        {  sprintf (error, "%d:%d: Unexpected ]", line_and_col);
                            goto e_failed;
                        }
                        
                        break;
                        
                    default:
                        
                        if (flags & flag_need_comma)
                        {
                            if (b == ',')
                            {  flags &= ~ flag_need_comma;
                                continue;
                            }
                            else
                            {
                                sprintf (error, "%d:%d: Expected , before %c",
                                         state.cur_line, state.cur_col, b);
                                
                                goto e_failed;
                            }
                        }
                        
                        if (flags & flag_need_colon)
                        {
                            if (b == ':')
                            {  flags &= ~ flag_need_colon;
                                continue;
                            }
                            else
                            {
                                sprintf (error, "%d:%d: Expected : before %c",
                                         state.cur_line, state.cur_col, b);
                                
                                goto e_failed;
                            }
                        }
                        
                        flags &= ~ flag_seek_value;
                        
                        switch (b)
                    {
                        case '{':
                            
                            if (!new_value (&state, &top, &root, &alloc, json_object))
                                goto e_alloc_failure;
                            
                            continue;
                            
                        case '[':
                            
                            if (!new_value (&state, &top, &root, &alloc, json_array))
                                goto e_alloc_failure;
                            
                            flags |= flag_seek_value;
                            continue;
                            
                        case '"':
                            
                            if (!new_value (&state, &top, &root, &alloc, json_string))
                                goto e_alloc_failure;
                            
                            flags |= flag_string;
                            
                            string = top->u.string.ptr;
                            string_length = 0;
                            
                            continue;
                            
                        case 't':
                            
                            if ((end - state.ptr) < 3 || *(++ state.ptr) != 'r' ||
                                *(++ state.ptr) != 'u' || *(++ state.ptr) != 'e')
                            {
                                goto e_unknown_value;
                            }
                            
                            if (!new_value (&state, &top, &root, &alloc, json_boolean))
                                goto e_alloc_failure;
                            
                            top->u.boolean = 1;
                            
                            flags |= flag_next;
                            break;
                            
                        case 'f':
                            
                            if ((end - state.ptr) < 4 || *(++ state.ptr) != 'a' ||
                                *(++ state.ptr) != 'l' || *(++ state.ptr) != 's' ||
                                *(++ state.ptr) != 'e')
                            {
                                goto e_unknown_value;
                            }
                            
                            if (!new_value (&state, &top, &root, &alloc, json_boolean))
                                goto e_alloc_failure;
                            
                            flags |= flag_next;
                            break;
                            
                        case 'n':
                            
                            if ((end - state.ptr) < 3 || *(++ state.ptr) != 'u' ||
                                *(++ state.ptr) != 'l' || *(++ state.ptr) != 'l')
                            {
                                goto e_unknown_value;
                            }
                            
                            if (!new_value (&state, &top, &root, &alloc, json_null))
                                goto e_alloc_failure;
                            
                            flags |= flag_next;
                            break;
                            
                        default:
                            
                            if (isdigit (b) || b == '-')
                            {
                                if (!new_value (&state, &top, &root, &alloc, json_integer))
                                    goto e_alloc_failure;
                                
                                if (!state.first_pass)
                                {
                                    while (isdigit (b) || b == '+' || b == '-'
                                           || b == 'e' || b == 'E' || b == '.')
                                    {
                                        if ( (++ state.ptr) == end)
                                        {
                                            b = 0;
                                            break;
                                        }
                                        
                                        b = *state.ptr;
                                    }
                                    
                                    flags |= flag_next | flag_reproc;
                                    break;
                                }
                                
                                flags &= ~ (flag_num_negative | flag_num_e |
                                            flag_num_e_got_sign | flag_num_e_negative |
                                            flag_num_zero);
                                
                                num_digits = 0;
                                num_fraction = 0;
                                num_e = 0;
                                
                                if (b != '-')
                                {
                                    flags |= flag_reproc;
                                    break;
                                }
                                
                                flags |= flag_num_negative;
                                continue;
                            }
                            else
                            {  sprintf (error, "%d:%d: Unexpected %c when seeking value", line_and_col, b);
                                goto e_failed;
                            }
                    };
                };
            }
            else
            {
                switch (top->type)
                {
                    case json_object:
                        
                        switch (b)
                    {
                        whitespace:
                            continue;
                            
                        case '"':
                            
                            if (flags & flag_need_comma)
                            {  sprintf (error, "%d:%d: Expected , before \"", line_and_col);
                                goto e_failed;
                            }
                            
                            flags |= flag_string;
                            
                            string = (json_char *) top->_reserved.object_mem;
                            string_length = 0;
                            
                            break;
                            
                        case '}':
                            
                            flags = (flags & ~ flag_need_comma) | flag_next;
                            break;
                            
                        case ',':
                            
                            if (flags & flag_need_comma)
                            {
                                flags &= ~ flag_need_comma;
                                break;
                            }
                            
                        default:
                            sprintf (error, "%d:%d: Unexpected `%c` in object", line_and_col, b);
                            goto e_failed;
                    };
                        
                        break;
                        
                    case json_integer:
                    case json_double:
                        
                        if (isdigit (b))
                        {
                            ++ num_digits;
                            
                            if (top->type == json_integer || flags & flag_num_e)
                            {
                                if (! (flags & flag_num_e))
                                {
                                    if (flags & flag_num_zero)
                                    {  sprintf (error, "%d:%d: Unexpected `0` before `%c`", line_and_col, b);
                                        goto e_failed;
                                    }
                                    
                                    if (num_digits == 1 && b == '0')
                                        flags |= flag_num_zero;
                                }
                                else
                                {
                                    flags |= flag_num_e_got_sign;
                                    num_e = (num_e * 10) + (b - '0');
                                    continue;
                                }
                                
                                top->u.integer = (top->u.integer * 10) + (b - '0');
                                continue;
                            }
                            
                            num_fraction = (num_fraction * 10) + (b - '0');
                            continue;
                        }
                        
                        if (b == '+' || b == '-')
                        {
                            if ( (flags & flag_num_e) && !(flags & flag_num_e_got_sign))
                            {
                                flags |= flag_num_e_got_sign;
                                
                                if (b == '-')
                                    flags |= flag_num_e_negative;
                                
                                continue;
                            }
                        }
                        else if (b == '.' && top->type == json_integer)
                        {
                            if (!num_digits)
                            {  sprintf (error, "%d:%d: Expected digit before `.`", line_and_col);
                                goto e_failed;
                            }
                            
                            top->type = json_double;
                            top->u.dbl = (double) top->u.integer;
                            
                            num_digits = 0;
                            continue;
                        }
                        
                        if (! (flags & flag_num_e))
                        {
                            if (top->type == json_double)
                            {
                                if (!num_digits)
                                {  sprintf (error, "%d:%d: Expected digit after `.`", line_and_col);
                                    goto e_failed;
                                }
                                
                                top->u.dbl += ((double) num_fraction) / (pow (10.0, (double) num_digits));
                            }
                            
                            if (b == 'e' || b == 'E')
                            {
                                flags |= flag_num_e;
                                
                                if (top->type == json_integer)
                                {
                                    top->type = json_double;
                                    top->u.dbl = (double) top->u.integer;
                                }
                                
                                num_digits = 0;
                                flags &= ~ flag_num_zero;
                                
                                continue;
                            }
                        }
                        else
                        {
                            if (!num_digits)
                            {  sprintf (error, "%d:%d: Expected digit after `e`", line_and_col);
                                goto e_failed;
                            }
                            
                            top->u.dbl *= pow (10.0, (double)
                                               (flags & flag_num_e_negative ? - num_e : num_e));
                        }
                        
                        if (flags & flag_num_negative)
                        {
                            if (top->type == json_integer)
                                top->u.integer = - top->u.integer;
                            else
                                top->u.dbl = - top->u.dbl;
                        }
                        
                        flags |= flag_next | flag_reproc;
                        break;
                        
                    default:
                        break;
                };
            }
            
            if (flags & flag_reproc)
            {
                flags &= ~ flag_reproc;
                -- state.ptr;
            }
            
            if (flags & flag_next)
            {
                flags = (flags & ~ flag_next) | flag_need_comma;
                
                if (!top->parent)
                {
                    /* root value done */
                    
                    flags |= flag_done;
                    continue;
                }
                
                if (top->parent->type == json_array)
                    flags |= flag_seek_value;
                
                if (!state.first_pass)
                {
                    json_value * parent = top->parent;
                    
                    switch (parent->type)
                    {
                        case json_object:
                            
                            parent->u.object.values
                            [parent->u.object.length].value = top;
                            
                            break;
                            
                        case json_array:
                            
                            parent->u.array.values
                            [parent->u.array.length] = top;
                            
                            break;
                            
                        default:
                            break;
                    };
                }
                
                if ( (++ top->parent->u.array.length) > state.uint_max)
                    goto e_overflow;
                
                top = top->parent;
                
                continue;
            }
        }
        
        alloc = root;
    }
    
    return root;
    
e_unknown_value:
    
    sprintf (error, "%d:%d: Unknown value", line_and_col);
    goto e_failed;
    
e_alloc_failure:
    
    strcpy (error, "Memory allocation failure");
    goto e_failed;
    
e_overflow:
    
    sprintf (error, "%d:%d: Too long (caught overflow)", line_and_col);
    goto e_failed;
    
e_failed:
    
    if (error_buf)
    {
        if (*error)
            strcpy (error_buf, error);
        else
            strcpy (error_buf, "Unknown error");
    }
    
    if (state.first_pass)
        alloc = root;
    
    while (alloc)
    {
        top = alloc->_reserved.next_alloc;
        state.settings.mem_free (alloc, state.settings.user_data);
        alloc = top;
    }
    
    if (!state.first_pass)
        json_value_free_ex (&state.settings, root);
    
    return 0;
}

json_value * json_parse (const json_char * json, size_t length)
{
    json_settings settings = { 0 };
    return json_parse_ex (&settings, json, length, 0);
}

void json_value_free_ex (json_settings * settings, json_value * value)
{
    json_value * cur_value;
    
    if (!value)
        return;
    
    value->parent = 0;
    
    while (value)
    {
        switch (value->type)
        {
            case json_array:
                
                if (!value->u.array.length)
                {
                    settings->mem_free (value->u.array.values, settings->user_data);
                    break;
                }
                
                value = value->u.array.values [-- value->u.array.length];
                continue;
                
            case json_object:
                
                if (!value->u.object.length)
                {
                    settings->mem_free (value->u.object.values, settings->user_data);
                    break;
                }
                
                value = value->u.object.values [-- value->u.object.length].value;
                continue;
                
            case json_string:
                
                settings->mem_free (value->u.string.ptr, settings->user_data);
                break;
                
            default:
                break;
        };
        
        cur_value = value;
        value = value->parent;
        settings->mem_free (cur_value, settings->user_data);
    }
}

void json_value_free (json_value * value)
{
    json_settings settings = { 0 };
    settings.mem_free = default_free;
    json_value_free_ex (&settings, value);
}

#endif

/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_protocol_json.hpp>

#include <sstream>
using namespace std;

//#include <srs_kernel_log.hpp>
//#include <srs_protocol_amf0.hpp>
//#include <srs_kernel_utility.hpp>

/* json encode
 cout<< SRS_JOBJECT_START
         << SRS_JFIELD_STR("name", "srs") << SRS_JFIELD_CONT
         << SRS_JFIELD_ORG("version", 100) << SRS_JFIELD_CONT
         << SRS_JFIELD_NAME("features") << SRS_JOBJECT_START
             << SRS_JFIELD_STR("rtmp", "released") << SRS_JFIELD_CONT
             << SRS_JFIELD_STR("hls", "released") << SRS_JFIELD_CONT
             << SRS_JFIELD_STR("dash", "plan")
         << SRS_JOBJECT_END << SRS_JFIELD_CONT
         << SRS_JFIELD_STR("author", "srs team")
     << SRS_JOBJECT_END
 it's:
 cont<< "{"
         << "name:" << "srs" << ","
         << "version:" << 100 << ","
         << "features:" << "{"
             << "rtmp:" << "released" << ","
             << "hls:" << "released" << ","
             << "dash:" << "plan"
         << "}" << ","
         << "author:" << "srs team"
     << "}"
 that is:
 """
 {
     "name": "srs",
     "version": 100,
     "features": {
         "rtmp": "released",
         "hls": "released",
         "dash": "plan"
     },
     "author": "srs team"
 }
 """
 */
#define SRS_JOBJECT_START "{"
#define SRS_JFIELD_NAME(k) "\"" << k << "\":"
#define SRS_JFIELD_OBJ(k) SRS_JFIELD_NAME(k) << SRS_JOBJECT_START
#define SRS_JFIELD_STR(k, v) SRS_JFIELD_NAME(k) << "\"" << v << "\""
#define SRS_JFIELD_ORG(k, v) SRS_JFIELD_NAME(k) << std::dec << v
#define SRS_JFIELD_BOOL(k, v) SRS_JFIELD_ORG(k, (v? "true":"false"))
#define SRS_JFIELD_NULL(k) SRS_JFIELD_NAME(k) << "null"
#define SRS_JFIELD_ERROR(ret) "\"" << "code" << "\":" << ret
#define SRS_JFIELD_CONT ","
#define SRS_JOBJECT_END "}"
#define SRS_JARRAY_START "["
#define SRS_JARRAY_END "]"

// Json marker
#define SRS_JSON_Boolean                   0x01
#define SRS_JSON_String                    0x02
#define SRS_JSON_Object                    0x03
#define SRS_JSON_Integer                   0x04
#define SRS_JSON_Number                    0x05
#define SRS_JSON_Null                      0x06
#define SRS_JSON_Array                     0x07

class SrsJsonString : public SrsJsonAny
{
public:
    std::string value;
    
    SrsJsonString(const char* v)
    {
        marker = SRS_JSON_String;
        if (v) {
            value = v;
        }
    }
    SrsJsonString(const char* v, int s)
    {
        marker = SRS_JSON_String;
        if (v) {
            value.append(v, s);
        }
    }
    virtual ~SrsJsonString()
    {
    }
};

class SrsJsonBoolean : public SrsJsonAny
{
public:
    bool value;
    
    SrsJsonBoolean(bool v)
    {
        marker = SRS_JSON_Boolean;
        value = v;
    }
    virtual ~SrsJsonBoolean()
    {
    }
};

class SrsJsonInteger : public SrsJsonAny
{
public:
    int64_t value;
    
    SrsJsonInteger(int64_t v)
    {
        marker = SRS_JSON_Integer;
        value = v;
    }
    virtual ~SrsJsonInteger()
    {
    }
};

class SrsJsonNumber : public SrsJsonAny
{
public:
    double value;
    
    SrsJsonNumber(double v)
    {
        marker = SRS_JSON_Number;
        value = v;
    }
    virtual ~SrsJsonNumber()
    {
    }
};

class SrsJsonNull : public SrsJsonAny
{
public:
    SrsJsonNull() {
        marker = SRS_JSON_Null;
    }
    virtual ~SrsJsonNull() {
    }
};

SrsJsonAny::SrsJsonAny()
{
    marker = 0;
}

SrsJsonAny::~SrsJsonAny()
{
}

bool SrsJsonAny::is_string()
{
    return marker == SRS_JSON_String;
}

bool SrsJsonAny::is_boolean()
{
    return marker == SRS_JSON_Boolean;
}

bool SrsJsonAny::is_number()
{
    return marker == SRS_JSON_Number;
}

bool SrsJsonAny::is_integer()
{
    return marker == SRS_JSON_Integer;
}

bool SrsJsonAny::is_object()
{
    return marker == SRS_JSON_Object;
}

bool SrsJsonAny::is_array()
{
    return marker == SRS_JSON_Array;
}

bool SrsJsonAny::is_null()
{
    return marker == SRS_JSON_Null;
}

string SrsJsonAny::to_str()
{
    SrsJsonString* p = dynamic_cast<SrsJsonString*>(this);
    srs_assert(p != NULL);
    return p->value;
}

bool SrsJsonAny::to_boolean()
{
    SrsJsonBoolean* p = dynamic_cast<SrsJsonBoolean*>(this);
    srs_assert(p != NULL);
    return p->value;
}

int64_t SrsJsonAny::to_integer()
{
    SrsJsonInteger* p = dynamic_cast<SrsJsonInteger*>(this);
    srs_assert(p != NULL);
    return p->value;
}

double SrsJsonAny::to_number()
{
    SrsJsonNumber* p = dynamic_cast<SrsJsonNumber*>(this);
    srs_assert(p != NULL);
    return p->value;
}

SrsJsonObject* SrsJsonAny::to_object()
{
    SrsJsonObject* p = dynamic_cast<SrsJsonObject*>(this);
    srs_assert(p != NULL);
    return p;
}

SrsJsonArray* SrsJsonAny::to_array()
{
    SrsJsonArray* p = dynamic_cast<SrsJsonArray*>(this);
    srs_assert(p != NULL);
    return p;
}

string SrsJsonAny::dumps()
{
    switch (marker) {
        case SRS_JSON_String: {
            return "\"" + to_str() + "\"";
        }
        case SRS_JSON_Boolean: {
            return to_boolean()? "true":"false";
        }
        case SRS_JSON_Integer: {
            return srs_int2str(to_integer());
        }
        case SRS_JSON_Number: {
            // len(max int64_t) is 20, plus one "+-."
            char tmp[22];
            snprintf(tmp, 22, "%.6f", to_number());
            return tmp;
        }
        case SRS_JSON_Null: {
            return "null";
        }
        case SRS_JSON_Object: {
            SrsJsonObject* obj = to_object();
            return obj->dumps();
        }
        case SRS_JSON_Array: {
            SrsJsonArray* arr = to_array();
            return arr->dumps();
        }
        default: {
            break;
        }
    }
    
    return "null";
}

SrsAmf0Any* SrsJsonAny::to_amf0()
{
    switch (marker) {
        case SRS_JSON_String: {
            return SrsAmf0Any::str(to_str().c_str());
        }
        case SRS_JSON_Boolean: {
            return SrsAmf0Any::boolean(to_boolean());
        }
        case SRS_JSON_Integer: {
            return SrsAmf0Any::number(to_integer());
        }
        case SRS_JSON_Number: {
            return SrsAmf0Any::number(to_number());
        }
        case SRS_JSON_Null: {
            return SrsAmf0Any::null();
        }
        case SRS_JSON_Object: {
            // json object must override this method.
            srs_assert(false);
        }
        case SRS_JSON_Array: {
            // json array must override this method.
            srs_assert(false);
        }
        default: {
            break;
        }
    }
    
    return SrsAmf0Any::null();
}

SrsJsonAny* SrsJsonAny::str(const char* value)
{
    return new SrsJsonString(value);
}

SrsJsonAny* SrsJsonAny::str(const char* value, int length)
{
    return new SrsJsonString(value, length);
}

SrsJsonAny* SrsJsonAny::boolean(bool value)
{
    return new SrsJsonBoolean(value);
}

SrsJsonAny* SrsJsonAny::integer(int64_t value)
{
    return new SrsJsonInteger(value);
}

SrsJsonAny* SrsJsonAny::number(double value)
{
    return new SrsJsonNumber(value);
}

SrsJsonAny* SrsJsonAny::null()
{
    return new SrsJsonNull();
}

SrsJsonObject* SrsJsonAny::object()
{
    return new SrsJsonObject();
}

SrsJsonArray* SrsJsonAny::array()
{
    return new SrsJsonArray();
}

SrsJsonAny* srs_json_parse_tree(json_value* node)
{
    if (!node) {
        return NULL;
    }
    
    switch (node->type) {
        case json_null:
            return SrsJsonAny::null();
        case json_string:
            return SrsJsonAny::str(node->u.string.ptr, node->u.string.length);
        case json_integer:
            return SrsJsonAny::integer(node->u.integer);
        case json_double:
            return SrsJsonAny::number(node->u.dbl);
        case json_boolean:
            return SrsJsonAny::boolean(node->u.boolean != 0);
        case json_object: {
            SrsJsonObject* obj = SrsJsonAny::object();
            for (int i = 0; i < node->u.object.length; i++) {
                json_object_entry& entry = node->u.object.values[i];
                SrsJsonAny* value = srs_json_parse_tree(entry.value);
                
                if (!value) {
                    srs_freep(obj);
                    return NULL;
                }
                
                obj->set(string(entry.name, entry.name_length), value);
            }
            return obj;
        }
        case json_array: {
            SrsJsonArray* arr = SrsJsonAny::array();
            for (int i = 0; i < node->u.array.length; i++) {
                json_value* p = node->u.array.values[i];
                SrsJsonAny* value = srs_json_parse_tree(p);
                
                if (!value) {
                    srs_freep(arr);
                    return NULL;
                }
                
                arr->add(value);
            }
            return arr;
        }
        default:
            return NULL;
    }
    
    return NULL;
}

SrsJsonAny* SrsJsonAny::loads(const string& str)
{
    if (str.empty()) {
        return NULL;
    }
    
    json_value* j = json_parse(str.data(), str.length());
    SrsJsonAny* sj = srs_json_parse_tree(j);
    json_value_free(j);
    
    return sj;
}

SrsJsonObject::SrsJsonObject()
{
    marker = SRS_JSON_Object;
}

SrsJsonObject::~SrsJsonObject()
{
    std::vector<SrsJsonObjectPropertyType>::iterator it;
    for (it = properties.begin(); it != properties.end(); ++it) {
        SrsJsonObjectPropertyType item = *it;
        SrsJsonAny* obj = item.second;
        srs_freep(obj);
    }
    properties.clear();
}

int SrsJsonObject::count()
{
    return (int)properties.size();
}

string SrsJsonObject::key_at(int index)
{
    srs_assert(index < count());
    SrsJsonObjectPropertyType& elem = properties[index];
    return elem.first;
}

SrsJsonAny* SrsJsonObject::value_at(int index)
{
    srs_assert(index < count());
    SrsJsonObjectPropertyType& elem = properties[index];
    return elem.second;
}

string SrsJsonObject::dumps()
{
    stringstream ss;
    
    ss << SRS_JOBJECT_START;
    
    for (int i = 0; i < (int)properties.size(); i++) {
        std::string name = this->key_at(i);
        SrsJsonAny* any = this->value_at(i);
        
        ss << SRS_JFIELD_NAME(name) << any->dumps();
        if (i < (int)properties.size() - 1) {
            ss << SRS_JFIELD_CONT;
        }
    }
    
    ss << SRS_JOBJECT_END;
    
    return ss.str();
}

SrsAmf0Any* SrsJsonObject::to_amf0()
{
    SrsAmf0Object* obj = SrsAmf0Any::object();
    
    for (int i = 0; i < (int)properties.size(); i++) {
        std::string name = this->key_at(i);
        SrsJsonAny* any = this->value_at(i);
        
        obj->set(name, any->to_amf0());
    }
    
    return obj;
}

SrsJsonObject* SrsJsonObject::set(string key, SrsJsonAny* value)
{
    if (!value) {
        srs_warn("add a NULL propertity %s", key.c_str());
        return this;
    }
    
    std::vector<SrsJsonObjectPropertyType>::iterator it;
    
    for (it = properties.begin(); it != properties.end(); ++it) {
        SrsJsonObjectPropertyType& elem = *it;
        std::string name = elem.first;
        SrsJsonAny* any = elem.second;
        
        if (key == name) {
            srs_freep(any);
            properties.erase(it);
            break;
        }
    }
    
    properties.push_back(std::make_pair(key, value));
    return this;
}

SrsJsonAny* SrsJsonObject::get_property(string name)
{
    std::vector<SrsJsonObjectPropertyType>::iterator it;
    
    for (it = properties.begin(); it != properties.end(); ++it) {
        SrsJsonObjectPropertyType& elem = *it;
        std::string key = elem.first;
        SrsJsonAny* any = elem.second;
        if (key == name) {
            return any;
        }
    }
    
    return NULL;
}

SrsJsonAny* SrsJsonObject::ensure_property_string(string name)
{
    SrsJsonAny* prop = get_property(name);
    
    if (!prop) {
        return NULL;
    }
    
    if (!prop->is_string()) {
        return NULL;
    }
    
    return prop;
}

SrsJsonAny* SrsJsonObject::ensure_property_integer(string name)
{
    SrsJsonAny* prop = get_property(name);
    
    if (!prop) {
        return NULL;
    }
    
    if (!prop->is_integer()) {
        return NULL;
    }
    
    return prop;
}

SrsJsonAny* SrsJsonObject::ensure_property_number(string name)
{
    SrsJsonAny* prop = get_property(name);
    
    if (!prop) {
        return NULL;
    }
    
    if (!prop->is_number()) {
        return NULL;
    }
    
    return prop;
}

SrsJsonAny* SrsJsonObject::ensure_property_boolean(string name)
{
    SrsJsonAny* prop = get_property(name);
    
    if (!prop) {
        return NULL;
    }
    
    if (!prop->is_boolean()) {
        return NULL;
    }
    
    return prop;
}

SrsJsonAny* SrsJsonObject::ensure_property_object(string name)
{
    SrsJsonAny* prop = get_property(name);
    
    if (!prop) {
        return NULL;
    }
    
    if (!prop->is_object()) {
        return NULL;
    }
    
    return prop;
}

SrsJsonAny* SrsJsonObject::ensure_property_array(string name)
{
    SrsJsonAny* prop = get_property(name);
    
    if (!prop) {
        return NULL;
    }
    
    if (!prop->is_array()) {
        return NULL;
    }
    
    return prop;
}

SrsJsonArray::SrsJsonArray()
{
    marker = SRS_JSON_Array;
}

SrsJsonArray::~SrsJsonArray()
{
    std::vector<SrsJsonAny*>::iterator it;
    for (it = properties.begin(); it != properties.end(); ++it) {
        SrsJsonAny* item = *it;
        srs_freep(item);
    }
    properties.clear();
}

int SrsJsonArray::count()
{
    return (int)properties.size();
}

SrsJsonAny* SrsJsonArray::at(int index)
{
    srs_assert(index < count());
    SrsJsonAny* elem = properties[index];
    return elem;
}

void SrsJsonArray::add(SrsJsonAny* value)
{
    properties.push_back(value);
}

SrsJsonArray* SrsJsonArray::append(SrsJsonAny* value)
{
    add(value);
    return this;
}

string SrsJsonArray::dumps()
{
    stringstream ss;
    
    ss << SRS_JARRAY_START;
    
    for (int i = 0; i < (int)properties.size(); i++) {
        SrsJsonAny* any = properties[i];
        
        ss << any->dumps();
        
        if (i < (int)properties.size() - 1) {
            ss << SRS_JFIELD_CONT;
        }
    }
    
    ss << SRS_JARRAY_END;
    
    return ss.str();
}

SrsAmf0Any* SrsJsonArray::to_amf0()
{
    SrsAmf0StrictArray* arr = SrsAmf0Any::strict_array();
    
    for (int i = 0; i < (int)properties.size(); i++) {
        SrsJsonAny* any = properties[i];
        
        arr->append(any->to_amf0());
    }
    
    return arr;
}

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////


// following is generated by src/protocol/srs_kafka_stack.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_kafka_stack.hpp>

#include <sstream>
using namespace std;

//#include <srs_kernel_error.hpp>
//#include <srs_core_autofree.hpp>
//#include <srs_kernel_log.hpp>
//#include <srs_protocol_io.hpp>
//#include <srs_protocol_stream.hpp>
//#include <srs_kernel_utility.hpp>
//#include <srs_protocol_utility.hpp>
//#include <srs_protocol_json.hpp>

#ifdef SRS_AUTO_KAFKA

#define SRS_KAFKA_PRODUCER_MESSAGE_TIMEOUT_MS 300000

SrsKafkaString::SrsKafkaString()
{
    _size = -1;
    data = NULL;
}

SrsKafkaString::SrsKafkaString(string v)
{
    _size = -1;
    data = NULL;
    
    set_value(v);
}

SrsKafkaString::~SrsKafkaString()
{
    srs_freepa(data);
}

bool SrsKafkaString::null()
{
    return _size == -1;
}

bool SrsKafkaString::empty()
{
    return _size <= 0;
}

string SrsKafkaString::to_str()
{
    string ret;
    if (_size > 0) {
        ret.append(data, _size);
    }
    return ret;
}

void SrsKafkaString::set_value(string v)
{
    // free previous data.
    srs_freepa(data);
    
    // copy new value to data.
    _size = (int16_t)v.length();
    
    srs_assert(_size > 0);
    data = new char[_size];
    memcpy(data, v.data(), _size);
}

int SrsKafkaString::nb_bytes()
{
    return _size == -1? 2 : 2 + _size;
}

srs_error_t SrsKafkaString::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if (!buf->require(2)) {
        return srs_error_new(ERROR_KAFKA_CODEC_STRING, "requires 2 only %d bytes", buf->left());
    }
    buf->write_2bytes(_size);
    
    if (_size <= 0) {
        return err;
    }
    
    if (!buf->require(_size)) {
        return srs_error_new(ERROR_KAFKA_CODEC_STRING, "requires %d only %d bytes", _size, buf->left());
    }
    buf->write_bytes(data, _size);
    
    return err;
}

srs_error_t SrsKafkaString::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if (!buf->require(2)) {
        return srs_error_new(ERROR_KAFKA_CODEC_STRING, "requires 2 only %d bytes", buf->left());
    }
    _size = buf->read_2bytes();
    
    if (_size != -1 && _size < 0) {
        return srs_error_new(ERROR_KAFKA_CODEC_STRING, "invalid size=%d", _size);
    }
    
    if (_size <= 0) {
        return err;
    }
    
    if (!buf->require(_size)) {
        return srs_error_new(ERROR_KAFKA_CODEC_STRING, "requires %d only %d bytes", _size, buf->left());
    }
    
    srs_freepa(data);
    data = new char[_size];
    
    buf->read_bytes(data, _size);
    
    return err;
}

SrsKafkaBytes::SrsKafkaBytes()
{
    _size = -1;
    _data = NULL;
}

SrsKafkaBytes::SrsKafkaBytes(const char* v, int nb_v)
{
    _size = -1;
    _data = NULL;
    
    set_value(v, nb_v);
}

SrsKafkaBytes::~SrsKafkaBytes()
{
    srs_freepa(_data);
}

char* SrsKafkaBytes::data()
{
    return _data;
}

int SrsKafkaBytes::size()
{
    return _size;
}

bool SrsKafkaBytes::null()
{
    return _size == -1;
}

bool SrsKafkaBytes::empty()
{
    return _size <= 0;
}

void SrsKafkaBytes::set_value(string v)
{
    set_value(v.data(), (int)v.length());
}

void SrsKafkaBytes::set_value(const char* v, int nb_v)
{
    // free previous data.
    srs_freepa(_data);
    
    // copy new value to data.
    _size = (int16_t)nb_v;
    
    srs_assert(_size > 0);
    _data = new char[_size];
    memcpy(_data, v, _size);
}

uint32_t SrsKafkaBytes::crc32(uint32_t previous)
{
    char bsize[4];
    SrsBuffer(bsize, 4).write_4bytes(_size);
    
    if (_size <= 0) {
        return srs_crc32_ieee(bsize, 4, previous);
    }
    
    uint32_t crc = srs_crc32_ieee(bsize, 4, previous);
    crc = srs_crc32_ieee(_data, _size, crc);
    
    return crc;
}

int SrsKafkaBytes::nb_bytes()
{
    return 4 + (_size == -1? 0 : _size);
}

srs_error_t SrsKafkaBytes::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if (!buf->require(4)) {
        return srs_error_new(ERROR_KAFKA_CODEC_BYTES, "requires 4 only %d bytes", buf->left());
    }
    buf->write_4bytes(_size);
    
    if (_size <= 0) {
        return err;
    }
    
    if (!buf->require(_size)) {
        return srs_error_new(ERROR_KAFKA_CODEC_BYTES, "requires %d only %d bytes", _size, buf->left());
    }
    buf->write_bytes(_data, _size);
    
    return err;
}

srs_error_t SrsKafkaBytes::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if (!buf->require(4)) {
        return srs_error_new(ERROR_KAFKA_CODEC_BYTES, "requires 4 only %d bytes", buf->left());
    }
    _size = buf->read_4bytes();
    
    if (_size != -1 && _size < 0) {
        return srs_error_new(ERROR_KAFKA_CODEC_BYTES, "invalid size=%d", _size);
    }
    
    if (!buf->require(_size)) {
        return srs_error_new(ERROR_KAFKA_CODEC_BYTES, "requires %d only %d bytes", _size, buf->left());
    }
    
    srs_freepa(_data);
    _data = new char[_size];
    buf->read_bytes(_data, _size);
    
    return err;
}

SrsKafkaRequestHeader::SrsKafkaRequestHeader()
{
    _size = 0;
    _api_key = api_version = 0;
    _correlation_id = 0;
    client_id = new SrsKafkaString();
}

SrsKafkaRequestHeader::~SrsKafkaRequestHeader()
{
    srs_freep(client_id);
}

int SrsKafkaRequestHeader::header_size()
{
    return 2 + 2 + 4 + client_id->nb_bytes();
}

int SrsKafkaRequestHeader::message_size()
{
    return _size - header_size();
}

int SrsKafkaRequestHeader::total_size()
{
    return 4 + _size;
}

void SrsKafkaRequestHeader::set_total_size(int s)
{
    _size = s - 4;
}

int32_t SrsKafkaRequestHeader::correlation_id()
{
    return _correlation_id;
}

void SrsKafkaRequestHeader::set_correlation_id(int32_t cid)
{
    _correlation_id = cid;
}

SrsKafkaApiKey SrsKafkaRequestHeader::api_key()
{
    return (SrsKafkaApiKey)_api_key;
}

void SrsKafkaRequestHeader::set_api_key(SrsKafkaApiKey key)
{
    _api_key = (int16_t)key;
}

bool SrsKafkaRequestHeader::is_producer_request()
{
    return _api_key == SrsKafkaApiKeyProduceRequest;
}

bool SrsKafkaRequestHeader::is_fetch_request()
{
    return _api_key == SrsKafkaApiKeyFetchRequest;
}

bool SrsKafkaRequestHeader::is_offset_request()
{
    return _api_key == SrsKafkaApiKeyOffsetRequest;
}

bool SrsKafkaRequestHeader::is_metadata_request()
{
    return _api_key == SrsKafkaApiKeyMetadataRequest;
}

bool SrsKafkaRequestHeader::is_offset_commit_request()
{
    return _api_key == SrsKafkaApiKeyOffsetCommitRequest;
}

bool SrsKafkaRequestHeader::is_offset_fetch_request()
{
    return _api_key == SrsKafkaApiKeyOffsetFetchRequest;
}

bool SrsKafkaRequestHeader::is_consumer_metadata_request()
{
    return _api_key == SrsKafkaApiKeyConsumerMetadataRequest;
}

int SrsKafkaRequestHeader::nb_bytes()
{
    return 4 + header_size();
}

srs_error_t SrsKafkaRequestHeader::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if (!buf->require(4 + _size)) {
        return srs_error_new(ERROR_KAFKA_CODEC_REQUEST, "requires %d only %d bytes", 4 + _size, buf->left());
    }
    
    buf->write_4bytes(_size);
    buf->write_2bytes(_api_key);
    buf->write_2bytes(api_version);
    buf->write_4bytes(_correlation_id);
    
    if ((err = client_id->encode(buf)) != srs_success) {
        return srs_error_wrap(err, "encode client_id");
    }
    
    return err;
}

srs_error_t SrsKafkaRequestHeader::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if (!buf->require(4)) {
        return srs_error_new(ERROR_KAFKA_CODEC_REQUEST, "requires %d only %d bytes", 4, buf->left());
    }
    _size = buf->read_4bytes();
    
    if (_size <= 0) {
        srs_warn("kafka got empty request");
        return err;
    }
    
    if (!buf->require(_size)) {
        return srs_error_new(ERROR_KAFKA_CODEC_REQUEST, "requires %d only %d bytes", _size, buf->left());
    }
    _api_key = buf->read_2bytes();
    api_version = buf->read_2bytes();
    _correlation_id = buf->read_4bytes();
    
    if ((err = client_id->decode(buf)) != srs_success) {
        return srs_error_wrap(err, "decode client_id");
    }
    
    return err;
}

SrsKafkaResponseHeader::SrsKafkaResponseHeader()
{
    _size = 0;
    _correlation_id = 0;
}

SrsKafkaResponseHeader::~SrsKafkaResponseHeader()
{
}

int SrsKafkaResponseHeader::header_size()
{
    return 4;
}

int SrsKafkaResponseHeader::message_size()
{
    return _size - header_size();
}

int SrsKafkaResponseHeader::total_size()
{
    return 4 + _size;
}

void SrsKafkaResponseHeader::set_total_size(int s)
{
    _size = s - 4;
}

int32_t SrsKafkaResponseHeader::correlation_id()
{
    return _correlation_id;
}

int SrsKafkaResponseHeader::nb_bytes()
{
    return 4 + header_size();
}

srs_error_t SrsKafkaResponseHeader::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if (!buf->require(4 + _size)) {
        return srs_error_new(ERROR_KAFKA_CODEC_RESPONSE, "requires %d only %d bytes", 4 + _size, buf->left());
    }
    
    buf->write_4bytes(_size);
    buf->write_4bytes(_correlation_id);
    
    return err;
}

srs_error_t SrsKafkaResponseHeader::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if (!buf->require(4)) {
        return srs_error_new(ERROR_KAFKA_CODEC_RESPONSE, "requires %d only %d bytes", 4, buf->left());
    }
    _size = buf->read_4bytes();
    
    if (_size <= 0) {
        srs_warn("kafka got empty response");
        return err;
    }
    
    if (!buf->require(_size)) {
        return srs_error_new(ERROR_KAFKA_CODEC_RESPONSE, "requires %d only %d bytes", _size, buf->left());
    }
    _correlation_id = buf->read_4bytes();
    
    return err;
}

SrsKafkaRawMessage::SrsKafkaRawMessage()
{
    offset = 0;
    message_size = 0;
    
    crc = 0;
    magic_byte = attributes = 0;
    key = new SrsKafkaBytes();
    value = new SrsKafkaBytes();
}

SrsKafkaRawMessage::~SrsKafkaRawMessage()
{
    srs_freep(key);
    srs_freep(value);
}

srs_error_t SrsKafkaRawMessage::create(SrsJsonObject* obj)
{
    srs_error_t err = srs_success;
    
    // current must be 0.
    magic_byte = 0;
    
    // no compression codec.
    attributes = 0;
    
    // dumps the json to string.
    value->set_value(obj->dumps());
    
    // crc32 message.
    crc = srs_crc32_ieee(&magic_byte, 1);
    crc = srs_crc32_ieee(&attributes, 1, crc);
    crc = key->crc32(crc);
    crc = value->crc32(crc);
    
    srs_info("crc32 message is %#x", crc);
    
    message_size = raw_message_size();
    
    return err;
}

int SrsKafkaRawMessage::raw_message_size()
{
    return 4 + 1 + 1 + key->nb_bytes() + value->nb_bytes();
}

int SrsKafkaRawMessage::nb_bytes()
{
    return 8 + 4 + 4 + 1 + 1 + key->nb_bytes() + value->nb_bytes();
}

srs_error_t SrsKafkaRawMessage::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    int nb_required = 8 + 4 + 4 + 1 + 1;
    if (!buf->require(nb_required)) {
        return srs_error_new(ERROR_KAFKA_CODEC_MESSAGE, "requires %d only %d bytes", nb_required, buf->left());
    }
    buf->write_8bytes(offset);
    buf->write_4bytes(message_size);
    buf->write_4bytes(crc);
    buf->write_1bytes(magic_byte);
    buf->write_1bytes(attributes);
    
    if ((err = key->encode(buf)) != srs_success) {
        return srs_error_wrap(err, "encode key");
    }
    
    if ((err = value->encode(buf)) != srs_success) {
        return srs_error_wrap(err, "encode value");
    }
    
    return err;
}

srs_error_t SrsKafkaRawMessage::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    int nb_required = 8 + 4 + 4 + 1 + 1;
    if (!buf->require(nb_required)) {
        return srs_error_new(ERROR_KAFKA_CODEC_MESSAGE, "requires %d only %d bytes", nb_required, buf->left());
    }
    offset = buf->read_8bytes();
    message_size = buf->read_4bytes();
    crc = buf->read_4bytes();
    magic_byte = buf->read_1bytes();
    attributes = buf->read_1bytes();
    
    if ((err = key->decode(buf)) != srs_success) {
        return srs_error_wrap(err, "decode key");
    }
    
    if ((err = value->decode(buf)) != srs_success) {
        return srs_error_wrap(err, "decode value");
    }
    
    return err;
}

SrsKafkaRawMessageSet::SrsKafkaRawMessageSet()
{
}

SrsKafkaRawMessageSet::~SrsKafkaRawMessageSet()
{
    vector<SrsKafkaRawMessage*>::iterator it;
    for (it = messages.begin(); it != messages.end(); ++it) {
        SrsKafkaRawMessage* message = *it;
        srs_freep(message);
    }
    messages.clear();
}

void SrsKafkaRawMessageSet::append(SrsKafkaRawMessage* msg)
{
    messages.push_back(msg);
}

int SrsKafkaRawMessageSet::nb_bytes()
{
    int s = 0;
    
    vector<SrsKafkaRawMessage*>::iterator it;
    for (it = messages.begin(); it != messages.end(); ++it) {
        SrsKafkaRawMessage* message = *it;
        s += message->nb_bytes();
    }
    
    return s;
}

srs_error_t SrsKafkaRawMessageSet::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    vector<SrsKafkaRawMessage*>::iterator it;
    for (it = messages.begin(); it != messages.end(); ++it) {
        SrsKafkaRawMessage* message = *it;
        if ((err = message->encode(buf)) != srs_success) {
            return srs_error_wrap(err, "encode message");
        }
    }
    
    return err;
}

srs_error_t SrsKafkaRawMessageSet::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    while (!buf->empty()) {
        SrsKafkaRawMessage* message = new SrsKafkaRawMessage();
        
        if ((err = message->decode(buf)) != srs_success) {
            srs_freep(message);
            return srs_error_wrap(err, "decode message");
        }
        
        messages.push_back(message);
    }
    
    return err;
}

SrsKafkaRequest::SrsKafkaRequest()
{
    header.set_correlation_id(SrsKafkaCorrelationPool::instance()->generate_correlation_id());
}

SrsKafkaRequest::~SrsKafkaRequest()
{
}

void SrsKafkaRequest::update_header(int s)
{
    header.set_total_size(s);
}

int32_t SrsKafkaRequest::correlation_id()
{
    return header.correlation_id();
}

SrsKafkaApiKey SrsKafkaRequest::api_key()
{
    return header.api_key();
}

int SrsKafkaRequest::nb_bytes()
{
    return header.nb_bytes();
}

srs_error_t SrsKafkaRequest::encode(SrsBuffer* buf)
{
    return header.encode(buf);
}

srs_error_t SrsKafkaRequest::decode(SrsBuffer* buf)
{
    return header.decode(buf);
}

SrsKafkaResponse::SrsKafkaResponse()
{
}

SrsKafkaResponse::~SrsKafkaResponse()
{
}

void SrsKafkaResponse::update_header(int s)
{
    header.set_total_size(s);
}

int SrsKafkaResponse::nb_bytes()
{
    return header.nb_bytes();
}

srs_error_t SrsKafkaResponse::encode(SrsBuffer* buf)
{
    return header.encode(buf);
}

srs_error_t SrsKafkaResponse::decode(SrsBuffer* buf)
{
    return header.decode(buf);
}

SrsKafkaTopicMetadataRequest::SrsKafkaTopicMetadataRequest()
{
    header.set_api_key(SrsKafkaApiKeyMetadataRequest);
}

SrsKafkaTopicMetadataRequest::~SrsKafkaTopicMetadataRequest()
{
}

void SrsKafkaTopicMetadataRequest::add_topic(string topic)
{
    topics.append(new SrsKafkaString(topic));
}

int SrsKafkaTopicMetadataRequest::nb_bytes()
{
    return SrsKafkaRequest::nb_bytes() + topics.nb_bytes();
}

srs_error_t SrsKafkaTopicMetadataRequest::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsKafkaRequest::encode(buf)) != srs_success) {
        return srs_error_wrap(err, "encode request");
    }
    
    if ((err = topics.encode(buf)) != srs_success) {
        return srs_error_wrap(err, "encode topics");
    }
    
    return err;
}

srs_error_t SrsKafkaTopicMetadataRequest::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsKafkaRequest::decode(buf)) != srs_success) {
        return srs_error_wrap(err, "decode request");
    }
    
    if ((err = topics.decode(buf)) != srs_success) {
        return srs_error_wrap(err, "decode topics");
    }
    
    return err;
}

SrsKafkaBroker::SrsKafkaBroker()
{
    node_id = port = 0;
}

SrsKafkaBroker::~SrsKafkaBroker()
{
}

int SrsKafkaBroker::nb_bytes()
{
    return 4 + host.nb_bytes() + 4;
}

srs_error_t SrsKafkaBroker::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if (!buf->require(4)) {
        return srs_error_new(ERROR_KAFKA_CODEC_METADATA, "requires %d only %d bytes", 4, buf->left());
    }
    buf->write_4bytes(node_id);
    
    if ((err = host.encode(buf)) != srs_success) {
        return srs_error_wrap(err, "host");
    }
    
    if (!buf->require(4)) {
        return srs_error_new(ERROR_KAFKA_CODEC_METADATA, "requires %d only %d bytes", 4, buf->left());
    }
    buf->write_4bytes(port);
    
    return err;
}

srs_error_t SrsKafkaBroker::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if (!buf->require(4)) {
        return srs_error_new(ERROR_KAFKA_CODEC_METADATA, "requires %d only %d bytes", 4, buf->left());
    }
    node_id = buf->read_4bytes();
    
    if ((err = host.decode(buf)) != srs_success) {
        return srs_error_wrap(err, "host");
    }
    
    if (!buf->require(4)) {
        return srs_error_new(ERROR_KAFKA_CODEC_METADATA, "requires %d only %d bytes", 4, buf->left());
    }
    port = buf->read_4bytes();
    
    return err;
}

SrsKafkaPartitionMetadata::SrsKafkaPartitionMetadata()
{
    error_code = 0;
    partition_id = 0;
    leader = 0;
}

SrsKafkaPartitionMetadata::~SrsKafkaPartitionMetadata()
{
}

int SrsKafkaPartitionMetadata::nb_bytes()
{
    return 2 + 4 + 4 + replicas.nb_bytes() + isr.nb_bytes();
}

srs_error_t SrsKafkaPartitionMetadata::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    int nb_required = 2 + 4 + 4;
    if (!buf->require(nb_required)) {
        return srs_error_new(ERROR_KAFKA_CODEC_METADATA, "requires %d only %d bytes", nb_required, buf->left());
    }
    buf->write_2bytes(error_code);
    buf->write_4bytes(partition_id);
    buf->write_4bytes(leader);
    
    if ((err = replicas.encode(buf)) != srs_success) {
        return srs_error_wrap(err, "replicas");
    }
    if ((err = isr.encode(buf)) != srs_success) {
        return srs_error_wrap(err, "isr");
    }
    
    return err;
}

srs_error_t SrsKafkaPartitionMetadata::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    int nb_required = 2 + 4 + 4;
    if (!buf->require(nb_required)) {
        return srs_error_new(ERROR_KAFKA_CODEC_METADATA, "requires %d only %d bytes", nb_required, buf->left());
    }
    error_code = buf->read_2bytes();
    partition_id = buf->read_4bytes();
    leader = buf->read_4bytes();
    
    if ((err = replicas.decode(buf)) != srs_success) {
        return srs_error_wrap(err, "replicas");
    }
    if ((err = isr.decode(buf)) != srs_success) {
        return srs_error_wrap(err, "isr");
    }
    
    return err;
}

SrsKafkaTopicMetadata::SrsKafkaTopicMetadata()
{
    error_code = 0;
}

SrsKafkaTopicMetadata::~SrsKafkaTopicMetadata()
{
}

int SrsKafkaTopicMetadata::nb_bytes()
{
    return 2 + name.nb_bytes() + metadatas.nb_bytes();
}

srs_error_t SrsKafkaTopicMetadata::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if (!buf->require(2)) {
        return srs_error_new(ERROR_KAFKA_CODEC_METADATA, "requires %d only %d bytes", 2, buf->left());
    }
    buf->write_2bytes(error_code);
    
    if ((err = name.encode(buf)) != srs_success) {
        return srs_error_wrap(err, "name");
    }
    
    if ((err = metadatas.encode(buf)) != srs_success) {
        return srs_error_wrap(err, "metadatas");
    }
    
    return err;
}

srs_error_t SrsKafkaTopicMetadata::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if (!buf->require(2)) {
        return srs_error_new(ERROR_KAFKA_CODEC_METADATA, "requires %d only %d bytes", 2, buf->left());
    }
    error_code = buf->read_2bytes();
    
    if ((err = name.decode(buf)) != srs_success) {
        return srs_error_wrap(err, "name");
    }
    
    if ((err = metadatas.decode(buf)) != srs_success) {
        return srs_error_wrap(err, "metadatas");
    }
    
    return err;
}

SrsKafkaTopicMetadataResponse::SrsKafkaTopicMetadataResponse()
{
}

SrsKafkaTopicMetadataResponse::~SrsKafkaTopicMetadataResponse()
{
}

int SrsKafkaTopicMetadataResponse::nb_bytes()
{
    return SrsKafkaResponse::nb_bytes() + brokers.nb_bytes() + metadatas.nb_bytes();
}

srs_error_t SrsKafkaTopicMetadataResponse::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsKafkaResponse::encode(buf)) != srs_success) {
        return srs_error_wrap(err, "encode response");
    }
    
    if ((err = brokers.encode(buf)) != srs_success) {
        return srs_error_wrap(err, "brokers");
    }
    
    if ((err = metadatas.encode(buf)) != srs_success) {
        return srs_error_wrap(err, "metadatas");
    }
    
    return err;
}

srs_error_t SrsKafkaTopicMetadataResponse::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsKafkaResponse::decode(buf)) != srs_success) {
        return srs_error_wrap(err, "decode response");
    }
    
    if ((err = brokers.decode(buf)) != srs_success) {
        return srs_error_wrap(err, "brokers");
    }
    
    if ((err = metadatas.decode(buf)) != srs_success) {
        return srs_error_wrap(err, "metadatas");
    }
    
    return err;
}

int SrsKafkaProducerPartitionMessages::nb_bytes()
{
    return 4 + 4 + messages.nb_bytes();
}

srs_error_t SrsKafkaProducerPartitionMessages::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    int nb_required = 4 + 4;
    if (!buf->require(nb_required)) {
        return srs_error_new(ERROR_KAFKA_CODEC_PRODUCER, "requires %d only %d bytes", nb_required, buf->left());
    }
    buf->write_4bytes(partition);
    buf->write_4bytes(message_set_size);
    
    if ((err = messages.encode(buf)) != srs_success) {
        return srs_error_wrap(err, "messages");
    }
    
    return err;
}

srs_error_t SrsKafkaProducerPartitionMessages::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    int nb_required = 4 + 4;
    if (!buf->require(nb_required)) {
        return srs_error_new(ERROR_KAFKA_CODEC_PRODUCER, "requires %d only %d bytes", nb_required, buf->left());
    }
    partition = buf->read_4bytes();
    message_set_size = buf->read_4bytes();
    
    // for the message set decode util empty, we must create a new buffer when
    // there exists other objects after message set.
    if (buf->left() != message_set_size) {
        SrsBuffer* tbuf = new SrsBuffer(buf->data() + buf->pos(), message_set_size);
        SrsAutoFree(SrsBuffer, tbuf);
        
        if ((err = messages.decode(buf)) != srs_success) {
            return srs_error_wrap(err, "messages");
        }
    } else {
        if ((err = messages.decode(buf)) != srs_success) {
            return srs_error_wrap(err, "messages");
        }
    }
    
    return err;
}

int SrsKafkaProducerTopicMessages::nb_bytes()
{
    return topic_name.nb_bytes() + partitions.nb_bytes();
}

srs_error_t SrsKafkaProducerTopicMessages::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = topic_name.encode(buf)) != srs_success) {
        return srs_error_wrap(err, "topic_name");
    }
    
    if ((err = partitions.encode(buf)) != srs_success) {
        return srs_error_wrap(err, "partitions");
    }
    
    return err;
}

srs_error_t SrsKafkaProducerTopicMessages::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = topic_name.decode(buf)) != srs_success) {
        return srs_error_wrap(err, "topic_name");
    }
    
    if ((err = partitions.decode(buf)) != srs_success) {
        return srs_error_wrap(err, "partitions");
    }
    
    return err;
}

SrsKafkaProducerRequest::SrsKafkaProducerRequest()
{
    required_acks = 0;
    timeout = 0;
}

SrsKafkaProducerRequest::~SrsKafkaProducerRequest()
{
}

int SrsKafkaProducerRequest::nb_bytes()
{
    return SrsKafkaRequest::nb_bytes() + 2 + 4 + topics.nb_bytes();
}

srs_error_t SrsKafkaProducerRequest::encode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsKafkaRequest::encode(buf)) != srs_success) {
        return srs_error_wrap(err, "encode request");
    }
    
    int nb_required = 2 + 4;
    if (!buf->require(nb_required)) {
        return srs_error_new(ERROR_KAFKA_CODEC_PRODUCER, "requires %d only %d bytes", nb_required, buf->left());
    }
    buf->write_2bytes(required_acks);
    buf->write_4bytes(timeout);
    
    if ((err = topics.encode(buf)) != srs_success) {
        return srs_error_wrap(err, "encode topics");
    }
    
    return err;
}

srs_error_t SrsKafkaProducerRequest::decode(SrsBuffer* buf)
{
    srs_error_t err = srs_success;
    
    if ((err = SrsKafkaRequest::decode(buf)) != srs_success) {
        return srs_error_wrap(err, "decode request");
    }
    
    int nb_required = 2 + 4;
    if (!buf->require(nb_required)) {
        return srs_error_new(ERROR_KAFKA_CODEC_PRODUCER, "requires %d only %d bytes", nb_required, buf->left());
    }
    required_acks = buf->read_2bytes();
    timeout = buf->read_4bytes();
    
    if ((err = topics.decode(buf)) != srs_success) {
        return srs_error_wrap(err, "decode topics");
    }
    
    return err;
}

SrsKafkaCorrelationPool* SrsKafkaCorrelationPool::_instance = new SrsKafkaCorrelationPool();

SrsKafkaCorrelationPool* SrsKafkaCorrelationPool::instance()
{
    return _instance;
}

SrsKafkaCorrelationPool::SrsKafkaCorrelationPool()
{
}

SrsKafkaCorrelationPool::~SrsKafkaCorrelationPool()
{
    correlation_ids.clear();
}

int32_t SrsKafkaCorrelationPool::generate_correlation_id()
{
    static int32_t cid = 1;
    return cid++;
}

SrsKafkaApiKey SrsKafkaCorrelationPool::set(int32_t correlation_id, SrsKafkaApiKey request)
{
    SrsKafkaApiKey previous = SrsKafkaApiKeyUnknown;
    
    std::map<int32_t, SrsKafkaApiKey>::iterator it = correlation_ids.find(correlation_id);
    if (it != correlation_ids.end()) {
        previous = it->second;
    }
    
    correlation_ids[correlation_id] = request;
    
    return previous;
}

SrsKafkaApiKey SrsKafkaCorrelationPool::unset(int32_t correlation_id)
{
    std::map<int32_t, SrsKafkaApiKey>::iterator it = correlation_ids.find(correlation_id);
    
    if (it != correlation_ids.end()) {
        SrsKafkaApiKey key = it->second;
        correlation_ids.erase(it);
        return key;
    }
    
    return SrsKafkaApiKeyUnknown;
}

SrsKafkaApiKey SrsKafkaCorrelationPool::get(int32_t correlation_id)
{
    if (correlation_ids.find(correlation_id) == correlation_ids.end()) {
        return SrsKafkaApiKeyUnknown;
    }
    
    return correlation_ids[correlation_id];
}

SrsKafkaProtocol::SrsKafkaProtocol(ISrsProtocolReaderWriter* io)
{
    skt = io;
    reader = new SrsFastStream();
}

SrsKafkaProtocol::~SrsKafkaProtocol()
{
    srs_freep(reader);
}

srs_error_t SrsKafkaProtocol::send_and_free_message(SrsKafkaRequest* msg)
{
    srs_error_t err = srs_success;
    
    // TODO: FIXME: refine for performance issue.
    SrsAutoFree(SrsKafkaRequest, msg);
    
    int size = msg->nb_bytes();
    if (size <= 0) {
        return err;
    }
    
    // update the header of message.
    msg->update_header(size);
    
    // cache the request correlation id to discovery response message.
    SrsKafkaCorrelationPool* pool = SrsKafkaCorrelationPool::instance();
    pool->set(msg->correlation_id(), msg->api_key());
    
    // TODO: FIXME: refine for performance issue.
    char* bytes = new char[size];
    SrsAutoFreeA(char, bytes);
    
    // TODO: FIXME: refine for performance issue.
    SrsBuffer* buf = new SrsBuffer(bytes, size);
    SrsAutoFree(SrsBuffer, buf);
    
    if ((err = msg->encode(buf)) != srs_success) {
        return srs_error_wrap(err, "encode msg");
    }
    
    if ((err = skt->write(bytes, size, NULL)) != srs_success) {
        return srs_error_wrap(err, "write msg");
    }
    
    return err;
}

srs_error_t SrsKafkaProtocol::recv_message(SrsKafkaResponse** pmsg)
{
    *pmsg = NULL;
    
    srs_error_t err = srs_success;
    
    while (true) {
        SrsKafkaResponseHeader header;
        
        // ensure enough bytes for response header.
        if ((err = reader->grow(skt, header.nb_bytes())) != srs_success) {
            return srs_error_wrap(err, "grow buffer");
        }
        
        // decode response header.
        SrsBuffer* buf = new SrsBuffer(reader->bytes(), reader->size());
        SrsAutoFree(SrsBuffer, buf);
        
        if ((err = header.decode(buf)) != srs_success) {
            return srs_error_wrap(err, "decode header");
        }
        
        // skip the used buffer for header.
        buf->skip(-1 * buf->pos());
        
        // fetch cached api key.
        SrsKafkaCorrelationPool* pool = SrsKafkaCorrelationPool::instance();
        SrsKafkaApiKey key = pool->unset(header.correlation_id());
        srs_info("kafka got %d bytes response, key=%d", header.total_size(), header.correlation_id());
        
        // create message by cached api key.
        SrsKafkaResponse* res = NULL;
        switch (key) {
            case SrsKafkaApiKeyMetadataRequest:
                srs_info("kafka got metadata response");
                res = new SrsKafkaTopicMetadataResponse();
                break;
            case SrsKafkaApiKeyUnknown:
            default:
                break;
        }
        
        // ensure enough bytes to decode message.
        if ((err = reader->grow(skt, header.total_size())) != srs_success) {
            srs_freep(res);
            return srs_error_wrap(err, "grow buffer");
        }
        
        // dropped message, fetch next.
        if (!res) {
            reader->skip(header.total_size());
            srs_warn("kafka ignore unknown message, size=%d.", header.total_size());
            continue;
        }
        
        // parse the whole message.
        if ((err = res->decode(buf)) != srs_success) {
            srs_freep(res);
            return srs_error_wrap(err, "decode response");
        }
        
        *pmsg = res;
        break;
    }
    
    return err;
}

SrsKafkaClient::SrsKafkaClient(ISrsProtocolReaderWriter* io)
{
    protocol = new SrsKafkaProtocol(io);
}

SrsKafkaClient::~SrsKafkaClient()
{
    srs_freep(protocol);
}

srs_error_t SrsKafkaClient::fetch_metadata(string topic, SrsKafkaTopicMetadataResponse** pmsg)
{
    *pmsg = NULL;
    
    srs_error_t err = srs_success;
    
    SrsKafkaTopicMetadataRequest* req = new SrsKafkaTopicMetadataRequest();
    
    req->add_topic(topic);
    
    if ((err = protocol->send_and_free_message(req)) != srs_success) {
        return srs_error_wrap(err, "send request");
    }
    
    if ((err = protocol->expect_message(pmsg)) != srs_success) {
        return srs_error_wrap(err, "expect message");
    }
    
    return err;
}

srs_error_t SrsKafkaClient::write_messages(std::string topic, int32_t partition, vector<SrsJsonObject*>& msgs)
{
    srs_error_t err = srs_success;
    
    SrsKafkaProducerRequest* req = new SrsKafkaProducerRequest();
    
    // 0 the server will not send any response.
    req->required_acks = 0;
    // timeout of producer message.
    req->timeout = SRS_KAFKA_PRODUCER_MESSAGE_TIMEOUT_MS;
    
    // create the topic and partition to write message to.
    SrsKafkaProducerTopicMessages* topics = new SrsKafkaProducerTopicMessages();
    SrsKafkaProducerPartitionMessages* partitions = new SrsKafkaProducerPartitionMessages();
    
    topics->partitions.append(partitions);
    req->topics.append(topics);
    
    topics->topic_name.set_value(topic);
    partitions->partition = partition;
    
    // convert json objects to kafka raw messages.
    vector<SrsJsonObject*>::iterator it;
    for (it = msgs.begin(); it != msgs.end(); ++it) {
        SrsJsonObject* obj = *it;
        SrsKafkaRawMessage* msg = new SrsKafkaRawMessage();
        
        if ((err = msg->create(obj)) != srs_success) {
            srs_freep(msg);
            srs_freep(req);
            return srs_error_wrap(err, "create message");
        }
        
        partitions->messages.append(msg);
    }
    
    partitions->message_set_size = partitions->messages.nb_bytes();
    
    // write to kafka cluster.
    if ((err = protocol->send_and_free_message(req)) != srs_success) {
        return srs_error_wrap(err, "send request");
    }
    
    return err;
}

vector<string> srs_kafka_array2vector(SrsKafkaArray<SrsKafkaString>* arr)
{
    vector<string> strs;
    
    for (int i = 0; i < arr->size(); i++) {
        SrsKafkaString* elem = arr->at(i);
        strs.push_back(elem->to_str());
    }
    
    return strs;
}

vector<string> srs_kafka_array2vector(SrsKafkaArray<int32_t>* arr)
{
    vector<string> strs;
    
    for (int i = 0; i < arr->size(); i++) {
        int32_t elem = arr->at(i);
        strs.push_back(srs_int2str(elem));
    }
    
    return strs;
}

#endif

// following is generated by src/protocol/srs_protocol_format.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_protocol_format.hpp>

//#include <srs_kernel_error.hpp>
//#include <srs_kernel_codec.hpp>
//#include <srs_rtmp_stack.hpp>
//#include <srs_kernel_buffer.hpp>
//#include <srs_core_autofree.hpp>
//#include <srs_kernel_utility.hpp>

SrsRtmpFormat::SrsRtmpFormat()
{
}

SrsRtmpFormat::~SrsRtmpFormat()
{
}

srs_error_t SrsRtmpFormat::on_metadata(SrsOnMetaDataPacket* meta)
{
    // TODO: FIXME: Try to initialize format from metadata.
    return srs_success;
}

srs_error_t SrsRtmpFormat::on_audio(SrsSharedPtrMessage* shared_audio)
{
    SrsSharedPtrMessage* msg = shared_audio;
    char* data = msg->payload;
    int size = msg->size;
    
    return SrsFormat::on_audio(msg->timestamp, data, size);
}

srs_error_t SrsRtmpFormat::on_audio(int64_t timestamp, char* data, int size)
{
    return SrsFormat::on_audio(timestamp, data, size);
}

srs_error_t SrsRtmpFormat::on_video(SrsSharedPtrMessage* shared_video)
{
    SrsSharedPtrMessage* msg = shared_video;
    char* data = msg->payload;
    int size = msg->size;
    
    return SrsFormat::on_video(msg->timestamp, data, size);
}

srs_error_t SrsRtmpFormat::on_video(int64_t timestamp, char* data, int size)
{
    return SrsFormat::on_video(timestamp, data, size);
}

// following is generated by src/libs/srs_librtmp.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_librtmp.hpp>

#include <stdlib.h>
#include <sys/socket.h>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <sys/time.h>
#include <unistd.h>
#endif

#include <string>
#include <sstream>
using namespace std;

//#include <srs_kernel_error.hpp>
//#include <srs_rtmp_stack.hpp>
//#include <srs_lib_simple_socket.hpp>
//#include <srs_protocol_utility.hpp>
//#include <srs_core_autofree.hpp>
//#include <srs_rtmp_stack.hpp>
//#include <srs_kernel_utility.hpp>
//#include <srs_kernel_buffer.hpp>
//#include <srs_protocol_amf0.hpp>
//#include <srs_kernel_flv.hpp>
//#include <srs_kernel_codec.hpp>
//#include <srs_kernel_file.hpp>
//#include <srs_lib_bandwidth.hpp>
//#include <srs_raw_avc.hpp>
//#include <srs_kernel_mp4.hpp>

// kernel module.
ISrsLog* _srs_log = new ISrsLog();
ISrsThreadContext* _srs_context = new ISrsThreadContext();

// The default socket timeout in ms.
#define SRS_SOCKET_DEFAULT_TMMS (30 * 1000)

/**
 * export runtime context.
 */
struct Context
{
    // The original RTMP url.
    std::string url;
    
    // Parse from url.
    std::string tcUrl;
    std::string host;
    std::string vhost;
    std::string app;
    std::string stream;
    std::string param;
    
    // Parse ip:port from host.
    std::string ip;
    int port;
    
    // The URL schema, about vhost/app/stream?param
    srs_url_schema schema;
    // The server information, response by connect app.
    SrsServerInfo si;
    
    // The extra request object for connect to server, NULL to ignore.
    SrsRequest* req;
    
    // the message received cache,
    // for example, when got aggregate message,
    // the context will parse to videos/audios,
    // and return one by one.
    std::vector<SrsCommonMessage*> msgs;
    
    SrsRtmpClient* rtmp;
    SimpleSocketStream* skt;
    int stream_id;
    
    // the remux raw codec.
    SrsRawH264Stream avc_raw;
    SrsRawAacStream aac_raw;
    
    // about SPS, @see: 7.3.2.1.1, ISO_IEC_14496-10-AVC-2012.pdf, page 62
    std::string h264_sps;
    std::string h264_pps;
    // whether the sps and pps sent,
    // @see https://github.com/ossrs/srs/issues/203
    bool h264_sps_pps_sent;
    // only send the ssp and pps when both changed.
    // @see https://github.com/ossrs/srs/issues/204
    bool h264_sps_changed;
    bool h264_pps_changed;
    // the aac sequence header.
    std::string aac_specific_config;
    
    // user set timeout, in ms.
    int64_t stimeout;
    int64_t rtimeout;
    
    // The RTMP handler level buffer, can used to format packet.
    char buffer[1024];
    
    Context() : port(0) {
        rtmp = NULL;
        skt = NULL;
        req = NULL;
        stream_id = 0;
        h264_sps_pps_sent = false;
        h264_sps_changed = false;
        h264_pps_changed = false;
        rtimeout = stimeout = SRS_CONSTS_NO_TMMS;
        schema = srs_url_schema_normal;
    }
    virtual ~Context() {
        srs_freep(req);
        srs_freep(rtmp);
        srs_freep(skt);
        
        std::vector<SrsCommonMessage*>::iterator it;
        for (it = msgs.begin(); it != msgs.end(); ++it) {
            SrsCommonMessage* msg = *it;
            srs_freep(msg);
        }
        msgs.clear();
    }
};

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifdef _WIN32
int gettimeofday(struct timeval* tv, struct timezone* tz)
{
    time_t clock;
    struct tm tm;
    SYSTEMTIME win_time;
    
    GetLocalTime(&win_time);
    
    tm.tm_year = win_time.wYear - 1900;
    tm.tm_mon = win_time.wMonth - 1;
    tm.tm_mday = win_time.wDay;
    tm.tm_hour = win_time.wHour;
    tm.tm_min = win_time.wMinute;
    tm.tm_sec = win_time.wSecond;
    tm.tm_isdst = -1;
    
    clock = mktime(&tm);
    
    tv->tv_sec = (long)clock;
    tv->tv_usec = win_time.wMilliseconds * 1000;
    
    return 0;
}

int socket_setup()
{
    WORD wVersionRequested;
    WSADATA wsaData;
    int err;
    
    /* Use the MAKEWORD(lowbyte, highbyte) macro declared in Windef.h */
    wVersionRequested = MAKEWORD(2, 2);
    
    err = WSAStartup(wVersionRequested, &wsaData);
    if (err != 0) {
        /* Tell the user that we could not find a usable */
        /* Winsock DLL.                                  */
        //printf("WSAStartup failed with error: %d\n", err);
        return -1;
    }
    return 0;
}

int socket_cleanup()
{
    WSACleanup();
    return 0;
}

pid_t getpid(void)
{
    return (pid_t)GetCurrentProcessId();
}

int usleep(useconds_t usec)
{
    Sleep((DWORD)(usec / 1000));
    return 0;
}

ssize_t writev(int fd, const struct iovec *iov, int iovcnt)
{
    ssize_t nwrite = 0;
    for (int i = 0; i < iovcnt; i++) {
        const struct iovec* current = iov + i;
        
        int nsent = ::send(fd, (char*)current->iov_base, current->iov_len, 0);
        if (nsent < 0) {
            return nsent;
        }
        
        nwrite += nsent;
        if (nsent == 0) {
            return nwrite;
        }
    }
    return nwrite;
}

////////////////////////   strlcpy.c (modified) //////////////////////////

/*    $OpenBSD: strlcpy.c,v 1.11 2006/05/05 15:27:38 millert Exp $    */

/*-
 * Copyright (c) 1998 Todd C. Miller <Todd.Miller@courtesan.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

//#include <sys/cdefs.h> // ****
//#include <cstddef> // ****
// __FBSDID("$FreeBSD: stable/9/sys/libkern/strlcpy.c 243811 2012-12-03 18:08:44Z delphij $"); // ****

// #include <sys/types.h> // ****
// #include <sys/libkern.h> // ****

/*
 * Copy src to string dst of size siz.  At most siz-1 characters
 * will be copied.  Always NUL terminates (unless siz == 0).
 * Returns strlen(src); if retval >= siz, truncation occurred.
 */

//#define __restrict // ****

std::size_t strlcpy(char * __restrict dst, const char * __restrict src, size_t siz)
{
    char *d = dst;
    const char *s = src;
    size_t n = siz;
    
    /* Copy as many bytes as will fit */
    if (n != 0) {
        while (--n != 0) {
            if ((*d++ = *s++) == '\0')
                break;
        }
    }
    
    /* Not enough room in dst, add NUL and traverse rest of src */
    if (n == 0) {
        if (siz != 0)
            *d = '\0';        /* NUL-terminate dst */
        while (*s++)
            ;
    }
    
    return(s - src - 1);    /* count does not include NUL */
}

// http://www.cplusplus.com/forum/general/141779/////////////////////////   inet_ntop.c (modified) //////////////////////////
/*
 * Copyright (c) 2004 by Internet Systems Consortium, Inc. ("ISC")
 * Copyright (c) 1996-1999 by Internet Software Consortium.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

// #if defined(LIBC_SCCS) && !defined(lint) // ****
//static const char rcsid[] = "$Id: inet_ntop.c,v 1.3.18.2 2005/11/03 23:02:22 marka Exp $";
// #endif /* LIBC_SCCS and not lint */ // ****
// #include <sys/cdefs.h> // ****
// __FBSDID("$FreeBSD: stable/9/sys/libkern/inet_ntop.c 213103 2010-09-24 15:01:45Z attilio $"); // ****

//#define _WIN32_WINNT _WIN32_WINNT_WIN8 // ****
//#include <Ws2tcpip.h> // ****
#pragma comment(lib, "Ws2_32.lib") // ****
//#include <cstdio> // ****

// #include <sys/param.h> // ****
// #include <sys/socket.h> // ****
// #include <sys/systm.h> // ****

// #include <netinet/in.h> // ****

/*%
 * WARNING: Don't even consider trying to compile this on a system where
 * sizeof(int) < 4.  sizeof(int) > 4 is fine; all the world's not a VAX.
 */

static char *inet_ntop4(const u_char *src, char *dst, socklen_t size);
static char *inet_ntop6(const u_char *src, char *dst, socklen_t size);

/* char *
 * inet_ntop(af, src, dst, size)
 *    convert a network format address to presentation format.
 * return:
 *    pointer to presentation format address (`dst'), or NULL (see errno).
 * author:
 *    Paul Vixie, 1996.
 */
const char* inet_ntop(int af, const void *src, char *dst, socklen_t size)
{
    switch (af) {
    case AF_INET:
        return (inet_ntop4((unsigned char*)src, (char*)dst, size));
    case AF_INET6:
       return (char*)(inet_ntop6((unsigned char*)src, (char*)dst, size));
    default:
        return (NULL);
    }
    /* NOTREACHED */
}

/* const char *
 * inet_ntop4(src, dst, size)
 *    format an IPv4 address
 * return:
 *    `dst' (as a const)
 * notes:
 *    (1) uses no statics
 *    (2) takes a u_char* not an in_addr as input
 * author:
 *    Paul Vixie, 1996.
 */
static char * inet_ntop4(const u_char *src, char *dst, socklen_t size)
{
    static const char fmt[128] = "%u.%u.%u.%u";
    char tmp[sizeof "255.255.255.255"];
    int l;
    
    l = snprintf(tmp, sizeof(tmp), fmt, src[0], src[1], src[2], src[3]); // ****
    if (l <= 0 || (socklen_t) l >= size) {
        return (NULL);
    }
    strlcpy(dst, tmp, size);
    return (dst);
}

/* const char *
 * inet_ntop6(src, dst, size)
 *    convert IPv6 binary address into presentation (printable) format
 * author:
 *    Paul Vixie, 1996.
 */
static char * inet_ntop6(const u_char *src, char *dst, socklen_t size)
{
    /*
     * Note that int32_t and int16_t need only be "at least" large enough
     * to contain a value of the specified size.  On some systems, like
     * Crays, there is no such thing as an integer variable with 16 bits.
     * Keep this in mind if you think this function should have been coded
     * to use pointer overlays.  All the world's not a VAX.
     */
    char tmp[sizeof "ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255"], *tp;
    struct { int base, len; } best, cur;
#define NS_IN6ADDRSZ 16
#define NS_INT16SZ 2
    u_int words[NS_IN6ADDRSZ / NS_INT16SZ];
    int i;
    
    /*
     * Preprocess:
     *    Copy the input (bytewise) array into a wordwise array.
     *    Find the longest run of 0x00's in src[] for :: shorthanding.
     */
    memset(words, '\0', sizeof words);
    for (i = 0; i < NS_IN6ADDRSZ; i++)
        words[i / 2] |= (src[i] << ((1 - (i % 2)) << 3));
    best.base = -1;
    best.len = 0;
    cur.base = -1;
    cur.len = 0;
    for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
        if (words[i] == 0) {
            if (cur.base == -1)
                cur.base = i, cur.len = 1;
            else
                cur.len++;
        } else {
            if (cur.base != -1) {
                if (best.base == -1 || cur.len > best.len)
                    best = cur;
                cur.base = -1;
            }
        }
    }
    if (cur.base != -1) {
        if (best.base == -1 || cur.len > best.len)
            best = cur;
    }
    if (best.base != -1 && best.len < 2)
        best.base = -1;
    
    /*
     * Format the result.
     */
    tp = tmp;
    for (i = 0; i < (NS_IN6ADDRSZ / NS_INT16SZ); i++) {
        /* Are we inside the best run of 0x00's? */
        if (best.base != -1 && i >= best.base &&
            i < (best.base + best.len)) {
            if (i == best.base)
                *tp++ = ':';
            continue;
        }
        /* Are we following an initial run of 0x00s or any real hex? */
        if (i != 0)
            *tp++ = ':';
        /* Is this address an encapsulated IPv4? */
        if (i == 6 && best.base == 0 && (best.len == 6 ||
                                         (best.len == 7 && words[7] != 0x0001) ||
                                         (best.len == 5 && words[5] == 0xffff))) {
            if (!inet_ntop4(src+12, tp, sizeof tmp - (tp - tmp)))
                return (NULL);
            tp += strlen(tp);
            break;
        }
        tp += std::sprintf(tp, "%x", words[i]); // ****
    }
    /* Was it a trailing run of 0x00's? */
    if (best.base != -1 && (best.base + best.len) ==
        (NS_IN6ADDRSZ / NS_INT16SZ))
        *tp++ = ':';
    *tp++ = '\0';
    
    /*
     * Check for overflow, copy, and we're done.
     */
    if ((socklen_t)(tp - tmp) > size) {
        return (NULL);
    }
    strcpy(dst, tmp);
    return (dst);
}
#endif

int srs_librtmp_context_parse_uri(Context* context)
{
    int ret = ERROR_SUCCESS;
    
    std::string schema;

    srs_parse_rtmp_url(context->url, context->tcUrl, context->stream);
    
    // when connect, we only need to parse the tcUrl
    srs_discovery_tc_url(context->tcUrl,
        schema, context->host, context->vhost, context->app, context->stream, context->port,
        context->param);
    
    return ret;
}

int srs_librtmp_context_resolve_host(Context* context)
{
    int ret = ERROR_SUCCESS;
    
    // connect to server:port
    int family = AF_UNSPEC;
    context->ip = srs_dns_resolve(context->host, family);
    if (context->ip.empty()) {
        return ERROR_SYSTEM_DNS_RESOLVE;
    }
    
    return ret;
}

int srs_librtmp_context_connect(Context* context)
{
    int ret = ERROR_SUCCESS;
    
    srs_assert(context->skt);
    
    std::string ip = context->ip;
    if ((ret = context->skt->connect(ip.c_str(), context->port)) != ERROR_SUCCESS) {
        return ret;
    }
    
    return ret;
}

#ifdef __cplusplus
extern "C"{
#endif
    
int srs_version_major()
{
    return VERSION_MAJOR;
}

int srs_version_minor()
{
    return VERSION_MINOR;
}

int srs_version_revision()
{
    return VERSION_REVISION;
}

srs_rtmp_t srs_rtmp_create(const char* url)
{
    int ret = ERROR_SUCCESS;
    
    Context* context = new Context();
    context->url = url;
    
    // create socket
    srs_freep(context->skt);
    context->skt = new SimpleSocketStream();
    
    if ((ret = context->skt->create_socket(context)) != ERROR_SUCCESS) {
        srs_human_error("Create socket failed, ret=%d", ret);
        
        // free the context and return NULL
        srs_freep(context);
        return NULL;
    }
    
    return context;
}

int srs_rtmp_set_timeout(srs_rtmp_t rtmp, int recv_timeout_ms, int send_timeout_ms)
{
    int ret = ERROR_SUCCESS;
    
    if (!rtmp) {
        return ret;
    }
    
    Context* context = (Context*)rtmp;
    
    context->stimeout = send_timeout_ms;
    context->rtimeout = recv_timeout_ms;
    
    context->skt->set_recv_timeout(context->rtimeout);
    context->skt->set_send_timeout(context->stimeout);
    
    return ret;
}

void srs_rtmp_destroy(srs_rtmp_t rtmp)
{
    if (!rtmp) {
        return;
    }
    
    Context* context = (Context*)rtmp;
    
    srs_freep(context);
}

int srs_rtmp_handshake(srs_rtmp_t rtmp)
{
    int ret = ERROR_SUCCESS;
    
    if ((ret = srs_rtmp_dns_resolve(rtmp)) != ERROR_SUCCESS) {
        return ret;
    }
    
    if ((ret = srs_rtmp_connect_server(rtmp)) != ERROR_SUCCESS) {
        return ret;
    }
    
    if ((ret = srs_rtmp_do_simple_handshake(rtmp)) != ERROR_SUCCESS) {
        return ret;
    }
    
    return ret;
}

int srs_rtmp_dns_resolve(srs_rtmp_t rtmp)
{
    int ret = ERROR_SUCCESS;
    
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    
    // parse uri
    if ((ret = srs_librtmp_context_parse_uri(context)) != ERROR_SUCCESS) {
        return ret;
    }
    // resolve host
    if ((ret = srs_librtmp_context_resolve_host(context)) != ERROR_SUCCESS) {
        return ret;
    }
    
    return ret;
}

int srs_rtmp_connect_server(srs_rtmp_t rtmp)
{
    int ret = ERROR_SUCCESS;
    
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    
    // set timeout if user not set.
    if (context->stimeout == SRS_CONSTS_NO_TMMS) {
        context->stimeout = SRS_SOCKET_DEFAULT_TMMS;
        context->skt->set_send_timeout(context->stimeout);
    }
    if (context->rtimeout == SRS_CONSTS_NO_TMMS) {
        context->rtimeout = SRS_SOCKET_DEFAULT_TMMS;
        context->skt->set_recv_timeout(context->rtimeout);
    }
    
    if ((ret = srs_librtmp_context_connect(context)) != ERROR_SUCCESS) {
        return ret;
    }
    
    return ret;
}

int srs_rtmp_do_complex_handshake(srs_rtmp_t rtmp)
{
#ifndef SRS_AUTO_SSL
    // complex handshake requires ssl
    return ERROR_RTMP_HS_SSL_REQUIRE;
#else
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    
    srs_assert(context->skt != NULL);
    
    // simple handshake
    srs_freep(context->rtmp);
    context->rtmp = new SrsRtmpClient(context->skt);
    
    if ((err = context->rtmp->complex_handshake()) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    return ret;
#endif
}

int srs_rtmp_do_simple_handshake(srs_rtmp_t rtmp)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    
    srs_assert(context->skt != NULL);
    
    // simple handshake
    srs_freep(context->rtmp);
    context->rtmp = new SrsRtmpClient(context->skt);
    
    if ((err = context->rtmp->simple_handshake()) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    return ret;
}

int srs_rtmp_set_connect_args(srs_rtmp_t rtmp, const char* tcUrl, const char* swfUrl, const char* pageUrl, srs_amf0_t args)
{
    int ret = ERROR_SUCCESS;
    
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    
    srs_freep(context->req);
    context->req = new SrsRequest();
    
    if (args) {
        context->req->args = (SrsAmf0Object*)args;
    }
    if (tcUrl) {
        context->req->tcUrl = tcUrl;
    }
    if (swfUrl) {
        context->req->swfUrl = swfUrl;
    }
    if (pageUrl) {
        context->req->pageUrl = pageUrl;
    }
    
    return ret;
}

int srs_rtmp_set_schema(srs_rtmp_t rtmp, enum srs_url_schema schema)
{
    int ret = ERROR_SUCCESS;
    
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    
    context->schema = schema;
    
    return ret;
}

int srs_rtmp_connect_app(srs_rtmp_t rtmp)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    
    string tcUrl;
    switch(context->schema) {
        // For SRS3, only use one format url.
        case srs_url_schema_normal:
        case srs_url_schema_via:
        case srs_url_schema_vis:
        case srs_url_schema_vis2:
            tcUrl = srs_generate_tc_url(context->ip, context->vhost, context->app, context->port);
        default:
            break;
    }
    
    Context* c = context;
    if ((err = context->rtmp->connect_app(c->app, tcUrl, c->req, true, &c->si)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    return ret;
}

int srs_rtmp_get_server_id(srs_rtmp_t rtmp, char** ip, int* pid, int* cid)
{
    int ret = ERROR_SUCCESS;
    
    Context* context = (Context*)rtmp;
    *pid = context->si.pid;
    *cid = context->si.cid;
    *ip = context->si.ip.empty()? NULL:(char*)context->si.ip.c_str();
    
    return ret;
}

int srs_rtmp_get_server_sig(srs_rtmp_t rtmp, char** sig)
{
    int ret = ERROR_SUCCESS;
    
    Context* context = (Context*)rtmp;
    *sig = context->si.sig.empty()? NULL:(char*)context->si.sig.c_str();
    
    return ret;
}

int srs_rtmp_get_server_version(srs_rtmp_t rtmp, int* major, int* minor, int* revision, int* build)
{
    int ret = ERROR_SUCCESS;
    
    Context* context = (Context*)rtmp;
    *major = context->si.major;
    *minor = context->si.minor;
    *revision = context->si.revision;
    *build = context->si.build;
    
    return ret;
}

int srs_rtmp_play_stream(srs_rtmp_t rtmp)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    
    if ((err = context->rtmp->create_stream(context->stream_id)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    // Pass params in stream, @see https://github.com/ossrs/srs/issues/1031#issuecomment-409745733
    string stream = srs_generate_stream_with_query(context->host, context->vhost, context->stream, context->param);
    
    if ((err = context->rtmp->play(stream, context->stream_id, SRS_CONSTS_RTMP_PROTOCOL_CHUNK_SIZE)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    return ret;
}

int srs_rtmp_publish_stream(srs_rtmp_t rtmp)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    
    // Pass params in stream, @see https://github.com/ossrs/srs/issues/1031#issuecomment-409745733
    string stream = srs_generate_stream_with_query(context->host, context->vhost, context->stream, context->param);
    
    if ((err = context->rtmp->fmle_publish(stream, context->stream_id)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    return ret;
}

int srs_rtmp_bandwidth_check(srs_rtmp_t rtmp,
    int64_t* start_time, int64_t* end_time,
    int* play_kbps, int* publish_kbps,
    int* play_bytes, int* publish_bytes,
    int* play_duration, int* publish_duration
) {
    *start_time = 0;
    *end_time = 0;
    *play_kbps = 0;
    *publish_kbps = 0;
    *play_bytes = 0;
    *publish_bytes = 0;
    *play_duration = 0;
    *publish_duration = 0;
    
    int ret = ERROR_SUCCESS;
    
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    
    SrsBandwidthClient client;
    
    if ((ret = client.initialize(context->rtmp)) != ERROR_SUCCESS) {
        return ret;
    }
    
    if ((ret = client.bandwidth_check(
        start_time, end_time, play_kbps, publish_kbps,
        play_bytes, publish_bytes, play_duration, publish_duration)) != ERROR_SUCCESS
    ) {
        return ret;
    }
    
    return ret;
}


int srs_rtmp_on_aggregate(Context* context, SrsCommonMessage* msg)
{
    int ret = ERROR_SUCCESS;
    
    SrsBuffer* stream = new SrsBuffer(msg->payload, msg->size);
    SrsAutoFree(SrsBuffer, stream);
    
    // the aggregate message always use abs time.
    int delta = -1;
    
    while (!stream->empty()) {
        if (!stream->require(1)) {
            ret = ERROR_RTMP_AGGREGATE;
            srs_error("invalid aggregate message type. ret=%d", ret);
            return ret;
        }
        int8_t type = stream->read_1bytes();
        
        if (!stream->require(3)) {
            ret = ERROR_RTMP_AGGREGATE;
            srs_error("invalid aggregate message size. ret=%d", ret);
            return ret;
        }
        int32_t data_size = stream->read_3bytes();
        
        if (data_size < 0) {
            ret = ERROR_RTMP_AGGREGATE;
            srs_error("invalid aggregate message size(negative). ret=%d", ret);
            return ret;
        }
        
        if (!stream->require(3)) {
            ret = ERROR_RTMP_AGGREGATE;
            srs_error("invalid aggregate message time. ret=%d", ret);
            return ret;
        }
        int32_t timestamp = stream->read_3bytes();
        
        if (!stream->require(1)) {
            ret = ERROR_RTMP_AGGREGATE;
            srs_error("invalid aggregate message time(high). ret=%d", ret);
            return ret;
        }
        int32_t time_h = stream->read_1bytes();
        
        timestamp |= time_h<<24;
        timestamp &= 0x7FFFFFFF;
        
        // adjust abs timestamp in aggregate msg.
        if (delta < 0) {
            delta = (int)msg->header.timestamp - (int)timestamp;
        }
        timestamp += delta;
        
        if (!stream->require(3)) {
            ret = ERROR_RTMP_AGGREGATE;
            srs_error("invalid aggregate message stream_id. ret=%d", ret);
            return ret;
        }
        int32_t stream_id = stream->read_3bytes();
        
        if (data_size > 0 && !stream->require(data_size)) {
            ret = ERROR_RTMP_AGGREGATE;
            srs_error("invalid aggregate message data. ret=%d", ret);
            return ret;
        }
        
        // to common message.
        SrsCommonMessage o;
        
        o.header.message_type = type;
        o.header.payload_length = data_size;
        o.header.timestamp_delta = timestamp;
        o.header.timestamp = timestamp;
        o.header.stream_id = stream_id;
        o.header.perfer_cid = msg->header.perfer_cid;
        
        if (data_size > 0) {
            o.size = data_size;
            o.payload = new char[o.size];
            stream->read_bytes(o.payload, o.size);
        }
        
        if (!stream->require(4)) {
            ret = ERROR_RTMP_AGGREGATE;
            srs_error("invalid aggregate message previous tag size. ret=%d", ret);
            return ret;
        }
        stream->read_4bytes();
        
        // process parsed message
        SrsCommonMessage* parsed_msg = new SrsCommonMessage();
        parsed_msg->header = o.header;
        parsed_msg->payload = o.payload;
        parsed_msg->size = o.size;
        o.payload = NULL;
        context->msgs.push_back(parsed_msg);
    }
    
    return ret;
}

int srs_rtmp_go_packet(Context* context, SrsCommonMessage* msg,
    char* type, uint32_t* timestamp, char** data, int* size,
    bool* got_msg
) {
    int ret = ERROR_SUCCESS;
    
    // generally we got a message.
    *got_msg = true;
    
    if (msg->header.is_audio()) {
        *type = SRS_RTMP_TYPE_AUDIO;
        *timestamp = (uint32_t)msg->header.timestamp;
        *data = (char*)msg->payload;
        *size = (int)msg->size;
        // detach bytes from packet.
        msg->payload = NULL;
    } else if (msg->header.is_video()) {
        *type = SRS_RTMP_TYPE_VIDEO;
        *timestamp = (uint32_t)msg->header.timestamp;
        *data = (char*)msg->payload;
        *size = (int)msg->size;
        // detach bytes from packet.
        msg->payload = NULL;
    } else if (msg->header.is_amf0_data() || msg->header.is_amf3_data()) {
        *type = SRS_RTMP_TYPE_SCRIPT;
        *data = (char*)msg->payload;
        *size = (int)msg->size;
        // detach bytes from packet.
        msg->payload = NULL;
    } else if (msg->header.is_aggregate()) {
        if ((ret = srs_rtmp_on_aggregate(context, msg)) != ERROR_SUCCESS) {
            return ret;
        }
        *got_msg = false;
    } else {
        *type = msg->header.message_type;
        *data = (char*)msg->payload;
        *size = (int)msg->size;
        // detach bytes from packet.
        msg->payload = NULL;
    }
    
    return ret;
}

int srs_rtmp_read_packet(srs_rtmp_t rtmp, char* type, uint32_t* timestamp, char** data, int* size)
{
    *type = 0;
    *timestamp = 0;
    *data = NULL;
    *size = 0;
    
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    
    for (;;) {
        SrsCommonMessage* msg = NULL;
        
        // read from cache first.
        if (!context->msgs.empty()) {
            std::vector<SrsCommonMessage*>::iterator it = context->msgs.begin();
            msg = *it;
            context->msgs.erase(it);
        }
        
        // read from protocol sdk.
        if (!msg && (err = context->rtmp->recv_message(&msg)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            return ret;
        }
        
        // no msg, try again.
        if (!msg) {
            continue;
        }
        
        SrsAutoFree(SrsCommonMessage, msg);
        
        // process the got packet, if nothing, try again.
        bool got_msg;
        if ((ret = srs_rtmp_go_packet(context, msg, type, timestamp, data, size, &got_msg)) != ERROR_SUCCESS) {
            return ret;
        }
        
        // got expected message.
        if (got_msg) {
            break;
        }
    }
    
    return ret;
}

int srs_rtmp_write_packet(srs_rtmp_t rtmp, char type, uint32_t timestamp, char* data, int size)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    
    SrsSharedPtrMessage* msg = NULL;
    
    if ((err = srs_rtmp_create_msg(type, timestamp, data, size, context->stream_id, &msg)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    srs_assert(msg);
    
    // send out encoded msg.
    if ((err = context->rtmp->send_and_free_message(msg, context->stream_id)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    return ret;
}

void srs_rtmp_free_packet(char* data)
{
    srs_freepa(data);
}

srs_bool srs_rtmp_is_onMetaData(char type, char* data, int size)
{
    srs_error_t err = srs_success;
    
    if (type != SRS_RTMP_TYPE_SCRIPT) {
        return false;
    }
    
    SrsBuffer stream(data, size);
    
    std::string name;
    if ((err = srs_amf0_read_string(&stream, name)) != srs_success) {
        srs_freep(err);
        return false;
    }
    
    if (name == SRS_CONSTS_RTMP_ON_METADATA) {
        return true;
    }
    
    if (name == SRS_CONSTS_RTMP_SET_DATAFRAME) {
        return true;
    }
    
    return false;
}

/**
 * directly write a audio frame.
 */
int srs_write_audio_raw_frame(Context* context, char* frame, int frame_size, SrsRawAacStreamCodec* codec, uint32_t timestamp)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    char* data = NULL;
    int size = 0;
    if ((err = context->aac_raw.mux_aac2flv(frame, frame_size, codec, timestamp, &data, &size)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    return srs_rtmp_write_packet(context, SRS_RTMP_TYPE_AUDIO, timestamp, data, size);
}

/**
 * write aac frame in adts.
 */
int srs_write_aac_adts_frame(Context* context, SrsRawAacStreamCodec* codec, char* frame, int frame_size, uint32_t timestamp)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    // send out aac sequence header if not sent.
    if (context->aac_specific_config.empty()) {
        std::string sh;
        if ((err = context->aac_raw.mux_sequence_header(codec, sh)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            return ret;
        }
        context->aac_specific_config = sh;
        
        codec->aac_packet_type = 0;
        
        if ((ret = srs_write_audio_raw_frame(context, (char*)sh.data(), (int)sh.length(), codec, timestamp)) != ERROR_SUCCESS) {
            return ret;
        }
    }
    
    codec->aac_packet_type = 1;
    return srs_write_audio_raw_frame(context, frame, frame_size, codec, timestamp);
}

/**
 * write aac frames in adts.
 */
int srs_write_aac_adts_frames(Context* context, char sound_format, char sound_rate,
    char sound_size, char sound_type, char* frames, int frames_size, uint32_t timestamp
) {
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    SrsBuffer* stream = new SrsBuffer(frames, frames_size);
    SrsAutoFree(SrsBuffer, stream);
    
    while (!stream->empty()) {
        char* frame = NULL;
        int frame_size = 0;
        SrsRawAacStreamCodec codec;
        if ((err = context->aac_raw.adts_demux(stream, &frame, &frame_size, codec)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            return ret;
        }
        
        // override by user specified.
        codec.sound_format = sound_format;
        codec.sound_rate = sound_rate;
        codec.sound_size = sound_size;
        codec.sound_type = sound_type;
        
        if ((ret = srs_write_aac_adts_frame(context, &codec, frame, frame_size, timestamp)) != ERROR_SUCCESS) {
            return ret;
        }
    }
    
    return ret;
}

/**
 * write audio raw frame to SRS.
 */
int srs_audio_write_raw_frame(srs_rtmp_t rtmp, char sound_format, char sound_rate,
    char sound_size, char sound_type, char* frame, int frame_size, uint32_t timestamp
) {
    int ret = ERROR_SUCCESS;
    
    Context* context = (Context*)rtmp;
    srs_assert(context);
    
    if (sound_format == SrsAudioCodecIdAAC) {
        // for aac, the frame must be ADTS format.
        if (!srs_aac_is_adts(frame, frame_size)) {
            return ERROR_AAC_REQUIRED_ADTS;
        }
        
        // for aac, demux the ADTS to RTMP format.
        return srs_write_aac_adts_frames(context, sound_format, sound_rate, sound_size, sound_type, frame, frame_size, timestamp);
    } else {
        // use codec info for aac.
        SrsRawAacStreamCodec codec;
        codec.sound_format = sound_format;
        codec.sound_rate = sound_rate;
        codec.sound_size = sound_size;
        codec.sound_type = sound_type;
        codec.aac_packet_type = 0;
        
        // for other data, directly write frame.
        return srs_write_audio_raw_frame(context, frame, frame_size, &codec, timestamp);
    }
    
    return ret;
}

/**
 * whether aac raw data is in adts format,
 * which bytes sequence matches '1111 1111 1111'B, that is 0xFFF.
 */
srs_bool srs_aac_is_adts(char* aac_raw_data, int ac_raw_size)
{
    SrsBuffer stream(aac_raw_data, ac_raw_size);
    return srs_aac_startswith_adts(&stream);
}

/**
 * parse the adts header to get the frame size.
 */
int srs_aac_adts_frame_size(char* aac_raw_data, int ac_raw_size)
{
    int size = -1;
    
    if (!srs_aac_is_adts(aac_raw_data, ac_raw_size)) {
        return size;
    }
    
    // adts always 7bytes.
    if (ac_raw_size <= 7) {
        return size;
    }
    
    // last 2bits
    int16_t ch3 = aac_raw_data[3];
    // whole 8bits
    int16_t ch4 = aac_raw_data[4];
    // first 3bits
    int16_t ch5 = aac_raw_data[5];
    
    size = ((ch3 << 11) & 0x1800) | ((ch4 << 3) & 0x07f8) | ((ch5 >> 5) & 0x0007);
    
    return size;
}

/**
 * write h264 IPB-frame.
 */
int srs_write_h264_ipb_frame(Context* context, char* frame, int frame_size, uint32_t dts, uint32_t pts)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    // when sps or pps not sent, ignore the packet.
    // @see https://github.com/ossrs/srs/issues/203
    if (!context->h264_sps_pps_sent) {
        return ERROR_H264_DROP_BEFORE_SPS_PPS;
    }
    
    // 5bits, 7.3.1 NAL unit syntax,
    // ISO_IEC_14496-10-AVC-2003.pdf, page 44.
    //  5: I Frame, 1: P/B Frame
    // @remark we already group sps/pps to sequence header frame;
    //      for I/P NALU, we send them in isolate frame, each NALU in a frame;
    //      for other NALU, for example, AUD/SEI, we just ignore them, because
    //      AUD used in annexb to split frame, while SEI generally we can ignore it.
    // TODO: maybe we should group all NALUs split by AUD to a frame.
    SrsAvcNaluType nut = (SrsAvcNaluType)(frame[0] & 0x1f);
    if (nut != SrsAvcNaluTypeIDR && nut != SrsAvcNaluTypeNonIDR) {
        return ret;
    }
    
    // for IDR frame, the frame is keyframe.
    SrsVideoAvcFrameType frame_type = SrsVideoAvcFrameTypeInterFrame;
    if (nut == SrsAvcNaluTypeIDR) {
        frame_type = SrsVideoAvcFrameTypeKeyFrame;
    }
    
    std::string ibp;
    if ((err = context->avc_raw.mux_ipb_frame(frame, frame_size, ibp)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    int8_t avc_packet_type = SrsVideoAvcFrameTraitNALU;
    char* flv = NULL;
    int nb_flv = 0;
    if ((err = context->avc_raw.mux_avc2flv(ibp, frame_type, avc_packet_type, dts, pts, &flv, &nb_flv)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    // the timestamp in rtmp message header is dts.
    uint32_t timestamp = dts;
    return srs_rtmp_write_packet(context, SRS_RTMP_TYPE_VIDEO, timestamp, flv, nb_flv);
}

/**
 * write the h264 sps/pps in context over RTMP.
 */
int srs_write_h264_sps_pps(Context* context, uint32_t dts, uint32_t pts)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    // send when sps or pps changed.
    if (!context->h264_sps_changed && !context->h264_pps_changed) {
        return ret;
    }
    
    // h264 raw to h264 packet.
    std::string sh;
    if ((err = context->avc_raw.mux_sequence_header(context->h264_sps, context->h264_pps, dts, pts, sh)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    // h264 packet to flv packet.
    int8_t frame_type = SrsVideoAvcFrameTypeKeyFrame;
    int8_t avc_packet_type = SrsVideoAvcFrameTraitSequenceHeader;
    char* flv = NULL;
    int nb_flv = 0;
    if ((err = context->avc_raw.mux_avc2flv(sh, frame_type, avc_packet_type, dts, pts, &flv, &nb_flv)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    // reset sps and pps.
    context->h264_sps_changed = false;
    context->h264_pps_changed = false;
    context->h264_sps_pps_sent = true;
    
    // the timestamp in rtmp message header is dts.
    uint32_t timestamp = dts;
    return srs_rtmp_write_packet(context, SRS_RTMP_TYPE_VIDEO, timestamp, flv, nb_flv);
}

/**
 * write h264 raw frame, maybe sps/pps/IPB-frame.
 */
int srs_write_h264_raw_frame(Context* context, char* frame, int frame_size, uint32_t dts, uint32_t pts)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    // empty frame.
    if (frame_size <= 0) {
        return ret;
    }
    
    // for sps
    if (context->avc_raw.is_sps(frame, frame_size)) {
        std::string sps;
        if ((err = context->avc_raw.sps_demux(frame, frame_size, sps)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            return ret;
        }
        
        if (context->h264_sps == sps) {
            return ERROR_H264_DUPLICATED_SPS;
        }
        context->h264_sps_changed = true;
        context->h264_sps = sps;
        
        return ret;
    }
    
    // for pps
    if (context->avc_raw.is_pps(frame, frame_size)) {
        std::string pps;
        if ((err = context->avc_raw.pps_demux(frame, frame_size, pps)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            return ret;
        }
        
        if (context->h264_pps == pps) {
            return ERROR_H264_DUPLICATED_PPS;
        }
        context->h264_pps_changed = true;
        context->h264_pps = pps;
        
        return ret;
    }
    
    // ignore others.
    // 5bits, 7.3.1 NAL unit syntax,
    // ISO_IEC_14496-10-AVC-2003.pdf, page 44.
    //  7: SPS, 8: PPS, 5: I Frame, 1: P Frame, 9: AUD
    SrsAvcNaluType nut = (SrsAvcNaluType)(frame[0] & 0x1f);
    if (nut != SrsAvcNaluTypeSPS && nut != SrsAvcNaluTypePPS
        && nut != SrsAvcNaluTypeIDR && nut != SrsAvcNaluTypeNonIDR
        && nut != SrsAvcNaluTypeAccessUnitDelimiter
        ) {
        return ret;
    }
    
    // send pps+sps before ipb frames when sps/pps changed.
    if ((ret = srs_write_h264_sps_pps(context, dts, pts)) != ERROR_SUCCESS) {
        return ret;
    }
    
    // ibp frame.
    return srs_write_h264_ipb_frame(context, frame, frame_size, dts, pts);
}

/**
 * write h264 multiple frames, in annexb format.
 */
int srs_h264_write_raw_frames(srs_rtmp_t rtmp, char* frames, int frames_size, uint32_t dts, uint32_t pts)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    srs_assert(frames != NULL);
    srs_assert(frames_size > 0);
    
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    
    SrsBuffer* stream = new SrsBuffer(frames, frames_size);
    SrsAutoFree(SrsBuffer, stream);
    
    // use the last error
    // @see https://github.com/ossrs/srs/issues/203
    // @see https://github.com/ossrs/srs/issues/204
    int error_code_return = ret;
    
    // send each frame.
    while (!stream->empty()) {
        char* frame = NULL;
        int frame_size = 0;
        if ((err = context->avc_raw.annexb_demux(stream, &frame, &frame_size)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            return ret;
        }
        
        // ignore invalid frame,
        // atleast 1bytes for SPS to decode the type
        if (frame_size <= 0) {
            continue;
        }
        
        // it may be return error, but we must process all packets.
        if ((ret = srs_write_h264_raw_frame(context, frame, frame_size, dts, pts)) != ERROR_SUCCESS) {
            error_code_return = ret;
            
            // ignore known error, process all packets.
            if (srs_h264_is_dvbsp_error(ret)
                || srs_h264_is_duplicated_sps_error(ret)
                || srs_h264_is_duplicated_pps_error(ret)
                ) {
                continue;
            }
            
            return ret;
        }
    }
    
    return error_code_return;
}

srs_bool srs_h264_is_dvbsp_error(int error_code)
{
    return error_code == ERROR_H264_DROP_BEFORE_SPS_PPS;
}

srs_bool srs_h264_is_duplicated_sps_error(int error_code)
{
    return error_code == ERROR_H264_DUPLICATED_SPS;
}

srs_bool srs_h264_is_duplicated_pps_error(int error_code)
{
    return error_code == ERROR_H264_DUPLICATED_PPS;
}

srs_bool srs_h264_startswith_annexb(char* h264_raw_data, int h264_raw_size, int* pnb_start_code)
{
    SrsBuffer stream(h264_raw_data, h264_raw_size);
    return srs_avc_startswith_annexb(&stream, pnb_start_code);
}

struct Mp4Context
{
    SrsFileReader reader;
    SrsMp4Decoder dec;
};

srs_mp4_t srs_mp4_open_read(const char* file)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    Mp4Context* mp4 = new Mp4Context();
    
    if ((err = mp4->reader.open(file)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        srs_human_error("Open MP4 file failed, ret=%d", ret);
        
        srs_freep(mp4);
        return NULL;
    }
    
    return mp4;
}

void srs_mp4_close(srs_mp4_t mp4)
{
    Mp4Context* context = (Mp4Context*)mp4;
    srs_freep(context);
}

int srs_mp4_init_demuxer(srs_mp4_t mp4)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    Mp4Context* context = (Mp4Context*)mp4;
    
    if ((err = context->dec.initialize(&context->reader)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    return ret;
}

int srs_mp4_read_sample(srs_mp4_t mp4, srs_mp4_sample_t* s)
{
    s->sample = NULL;
    
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    Mp4Context* context = (Mp4Context*)mp4;
    SrsMp4Decoder* dec = &context->dec;
    
    SrsMp4HandlerType ht = SrsMp4HandlerTypeForbidden;
    if ((err = dec->read_sample(&ht, &s->frame_type, &s->frame_trait, &s->dts, &s->pts, &s->sample, &s->nb_sample)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    if (ht == SrsMp4HandlerTypeForbidden) {
        return ERROR_MP4_ILLEGAL_HANDLER;
    }
    
    if (ht == SrsMp4HandlerTypeSOUN) {
        s->codec = (uint16_t)dec->acodec;
        s->sample_rate = dec->sample_rate;
        s->channels = dec->channels;
        s->sound_bits = dec->sound_bits;
    } else {
        s->codec = (uint16_t)dec->vcodec;
    }
    s->handler_type = (uint32_t)ht;
    
    return ret;
}

void srs_mp4_free_sample(srs_mp4_sample_t* s)
{
    srs_freepa(s->sample);
}

int32_t srs_mp4_sizeof(srs_mp4_t mp4, srs_mp4_sample_t* s)
{
    if (s->handler_type == SrsMp4HandlerTypeSOUN) {
        if (s->codec == (uint16_t)SrsAudioCodecIdAAC) {
            return s->nb_sample + 2;
        }
        return s->nb_sample + 1;
    }
    
    if (s->codec == (uint16_t)SrsVideoCodecIdAVC) {
        return s->nb_sample + 5;
    }
    return s->nb_sample + 1;
}

int srs_mp4_to_flv_tag(srs_mp4_t mp4, srs_mp4_sample_t* s, char* type, uint32_t* time, char* data, int32_t size)
{
    int ret = ERROR_SUCCESS;
    
    *time = s->dts;
    
    SrsBuffer p(data, size);
    if (s->handler_type == SrsMp4HandlerTypeSOUN) {
        *type = SRS_RTMP_TYPE_AUDIO;
        
        // E.4.2.1 AUDIODATA, flv_v10_1.pdf, page 3
        p.write_1bytes(uint8_t(s->codec << 4) | uint8_t(s->sample_rate << 2) | uint8_t(s->sound_bits << 1) | s->channels);
        if (s->codec == SrsAudioCodecIdAAC) {
            p.write_1bytes(uint8_t(s->frame_trait == (uint16_t)SrsAudioAacFrameTraitSequenceHeader? 0:1));
        }
        
        p.write_bytes((char*)s->sample, s->nb_sample);
        return ret;
    }
    
    // E.4.3.1 VIDEODATA, flv_v10_1.pdf, page 5
    p.write_1bytes(uint8_t(s->frame_type<<4) | uint8_t(s->codec));
    if (s->codec == SrsVideoCodecIdAVC) {
        *type = SRS_RTMP_TYPE_VIDEO;
        
        p.write_1bytes(uint8_t(s->frame_trait == (uint16_t)SrsVideoAvcFrameTraitSequenceHeader? 0:1));
        // cts = pts - dts, where dts = flvheader->timestamp.
        uint32_t cts = s->pts - s->dts;
        p.write_3bytes(cts);
    }
    p.write_bytes((char*)s->sample, s->nb_sample);
    
    return ret;
}

srs_bool srs_mp4_is_eof(int error_code)
{
    return error_code == ERROR_SYSTEM_FILE_EOF;
}

struct FlvContext
{
    SrsFileReader reader;
    SrsFileWriter writer;
    SrsFlvTransmuxer enc;
    SrsFlvDecoder dec;
};

srs_flv_t srs_flv_open_read(const char* file)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    FlvContext* flv = new FlvContext();
    
    if ((err = flv->reader.open(file)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        srs_human_error("Open FLV file failed, ret=%d", ret);
        
        srs_freep(flv);
        return NULL;
    }
    
    if ((err = flv->dec.initialize(&flv->reader)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        srs_human_error("Initialize FLV demuxer failed, ret=%d", ret);
        
        srs_freep(flv);
        return NULL;
    }
    
    return flv;
}

srs_flv_t srs_flv_open_write(const char* file)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    FlvContext* flv = new FlvContext();
    
    if ((err = flv->writer.open(file)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        srs_human_error("Open FLV file failed, ret=%d", ret);
        
        srs_freep(flv);
        return NULL;
    }
    
    if ((err = flv->enc.initialize(&flv->writer)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        srs_human_error("Initilize FLV muxer failed, ret=%d", ret);
        
        srs_freep(flv);
        return NULL;
    }
    
    return flv;
}

void srs_flv_close(srs_flv_t flv)
{
    FlvContext* context = (FlvContext*)flv;
    srs_freep(context);
}

int srs_flv_read_header(srs_flv_t flv, char header[9])
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    FlvContext* context = (FlvContext*)flv;
    
    if (!context->reader.is_open()) {
        return ERROR_SYSTEM_IO_INVALID;
    }
    
    if ((err = context->dec.read_header(header)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    char ts[4]; // tag size
    if ((err = context->dec.read_previous_tag_size(ts)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    return ret;
}

int srs_flv_read_tag_header(srs_flv_t flv, char* ptype, int32_t* pdata_size, uint32_t* ptime)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    FlvContext* context = (FlvContext*)flv;
    
    if (!context->reader.is_open()) {
        return ERROR_SYSTEM_IO_INVALID;
    }
    
    if ((err = context->dec.read_tag_header(ptype, pdata_size, ptime)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    return ret;
}

int srs_flv_read_tag_data(srs_flv_t flv, char* data, int32_t size)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    FlvContext* context = (FlvContext*)flv;
    
    if (!context->reader.is_open()) {
        return ERROR_SYSTEM_IO_INVALID;
    }
    
    if ((err = context->dec.read_tag_data(data, size)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    char ts[4]; // tag size
    if ((err = context->dec.read_previous_tag_size(ts)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    return ret;
}

int srs_flv_write_header(srs_flv_t flv, char header[9])
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    FlvContext* context = (FlvContext*)flv;
    
    if (!context->writer.is_open()) {
        return ERROR_SYSTEM_IO_INVALID;
    }
    
    if ((err = context->enc.write_header(header)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    return ret;
}

int srs_flv_write_tag(srs_flv_t flv, char type, int32_t time, char* data, int size)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    FlvContext* context = (FlvContext*)flv;
    
    if (!context->writer.is_open()) {
        return ERROR_SYSTEM_IO_INVALID;
    }
    
    if (type == SRS_RTMP_TYPE_AUDIO) {
        if ((err = context->enc.write_audio(time, data, size)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            return ret;
        }
    } else if (type == SRS_RTMP_TYPE_VIDEO) {
        if ((err = context->enc.write_video(time, data, size)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            return ret;
        }
    } else {
        if ((err = context->enc.write_metadata(type, data, size)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            return ret;
        }
    }
    
    return ret;
}

int srs_flv_size_tag(int data_size)
{
    return SrsFlvTransmuxer::size_tag(data_size);
}

int64_t srs_flv_tellg(srs_flv_t flv)
{
    FlvContext* context = (FlvContext*)flv;
    return context->reader.tellg();
}

void srs_flv_lseek(srs_flv_t flv, int64_t offset)
{
    FlvContext* context = (FlvContext*)flv;
    int64_t r0 = context->reader.seek2(offset);
    srs_assert(r0 != -1);
}

srs_bool srs_flv_is_eof(int error_code)
{
    return error_code == ERROR_SYSTEM_FILE_EOF;
}

srs_bool srs_flv_is_sequence_header(char* data, int32_t size)
{
    return SrsFlvVideo::sh(data, (int)size);
}

srs_bool srs_flv_is_keyframe(char* data, int32_t size)
{
    return SrsFlvVideo::keyframe(data, (int)size);
}

srs_amf0_t srs_amf0_parse(char* data, int size, int* nparsed)
{
    srs_error_t err = srs_success;
    
    srs_amf0_t amf0 = NULL;
    
    SrsBuffer stream(data, size);
    
    SrsAmf0Any* any = NULL;
    if ((err = SrsAmf0Any::discovery(&stream, &any)) != srs_success) {
        srs_freep(err);
        return amf0;
    }
    
    stream.skip(-1 * stream.pos());
    if ((err = any->read(&stream)) != srs_success) {
        srs_freep(err);
        srs_freep(any);
        return amf0;
    }
    
    if (nparsed) {
        *nparsed = stream.pos();
    }
    amf0 = (srs_amf0_t)any;
    
    return amf0;
}

srs_amf0_t srs_amf0_create_string(const char* value)
{
    return SrsAmf0Any::str(value);
}

srs_amf0_t srs_amf0_create_number(srs_amf0_number value)
{
    return SrsAmf0Any::number(value);
}

srs_amf0_t srs_amf0_create_ecma_array()
{
    return SrsAmf0Any::ecma_array();
}

srs_amf0_t srs_amf0_create_strict_array()
{
    return SrsAmf0Any::strict_array();
}

srs_amf0_t srs_amf0_create_object()
{
    return SrsAmf0Any::object();
}

srs_amf0_t srs_amf0_ecma_array_to_object(srs_amf0_t ecma_arr)
{
    srs_assert(srs_amf0_is_ecma_array(ecma_arr));
    
    SrsAmf0EcmaArray* arr = (SrsAmf0EcmaArray*)ecma_arr;
    SrsAmf0Object* obj = SrsAmf0Any::object();
    
    for (int i = 0; i < arr->count(); i++) {
        std::string key = arr->key_at(i);
        SrsAmf0Any* value = arr->value_at(i);
        obj->set(key, value->copy());
    }
    
    return obj;
}

void srs_amf0_free(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    srs_freep(any);
}

int srs_amf0_size(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    return any->total_size();
}

int srs_amf0_serialize(srs_amf0_t amf0, char* data, int size)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    
    SrsBuffer stream(data, size);
    
    if ((err = any->write(&stream)) != srs_success) {
        ret = srs_error_code(err);
        srs_freep(err);
        return ret;
    }
    
    return ret;
}

srs_bool srs_amf0_is_string(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    return any->is_string();
}

srs_bool srs_amf0_is_boolean(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    return any->is_boolean();
}

srs_bool srs_amf0_is_number(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    return any->is_number();
}

srs_bool srs_amf0_is_null(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    return any->is_null();
}

srs_bool srs_amf0_is_object(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    return any->is_object();
}

srs_bool srs_amf0_is_ecma_array(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    return any->is_ecma_array();
}

srs_bool srs_amf0_is_strict_array(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    return any->is_strict_array();
}

const char* srs_amf0_to_string(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    return any->to_str_raw();
}

srs_bool srs_amf0_to_boolean(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    return any->to_boolean();
}

srs_amf0_number srs_amf0_to_number(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    return any->to_number();
}

void srs_amf0_set_number(srs_amf0_t amf0, srs_amf0_number value)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    any->set_number(value);
}

int srs_amf0_object_property_count(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    srs_assert(any->is_object());
    
    SrsAmf0Object* obj = (SrsAmf0Object*)amf0;
    return obj->count();
}

const char* srs_amf0_object_property_name_at(srs_amf0_t amf0, int index)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    srs_assert(any->is_object());
    
    SrsAmf0Object* obj = (SrsAmf0Object*)amf0;
    return obj->key_raw_at(index);
}

srs_amf0_t srs_amf0_object_property_value_at(srs_amf0_t amf0, int index)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    srs_assert(any->is_object());
    
    SrsAmf0Object* obj = (SrsAmf0Object*)amf0;
    return (srs_amf0_t)obj->value_at(index);
}

srs_amf0_t srs_amf0_object_property(srs_amf0_t amf0, const char* name)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    srs_assert(any->is_object());
    
    SrsAmf0Object* obj = (SrsAmf0Object*)amf0;
    return (srs_amf0_t)obj->get_property(name);
}

void srs_amf0_object_property_set(srs_amf0_t amf0, const char* name, srs_amf0_t value)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    srs_assert(any->is_object());
    
    SrsAmf0Object* obj = (SrsAmf0Object*)amf0;
    any = (SrsAmf0Any*)value;
    obj->set(name, any);
}

void srs_amf0_object_clear(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    srs_assert(any->is_object());
    
    SrsAmf0Object* obj = (SrsAmf0Object*)amf0;
    obj->clear();
}

int srs_amf0_ecma_array_property_count(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    srs_assert(any->is_ecma_array());
    
    SrsAmf0EcmaArray * obj = (SrsAmf0EcmaArray*)amf0;
    return obj->count();
}

const char* srs_amf0_ecma_array_property_name_at(srs_amf0_t amf0, int index)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    srs_assert(any->is_ecma_array());
    
    SrsAmf0EcmaArray* obj = (SrsAmf0EcmaArray*)amf0;
    return obj->key_raw_at(index);
}

srs_amf0_t srs_amf0_ecma_array_property_value_at(srs_amf0_t amf0, int index)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    srs_assert(any->is_ecma_array());
    
    SrsAmf0EcmaArray* obj = (SrsAmf0EcmaArray*)amf0;
    return (srs_amf0_t)obj->value_at(index);
}

srs_amf0_t srs_amf0_ecma_array_property(srs_amf0_t amf0, const char* name)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    srs_assert(any->is_ecma_array());
    
    SrsAmf0EcmaArray* obj = (SrsAmf0EcmaArray*)amf0;
    return (srs_amf0_t)obj->get_property(name);
}

void srs_amf0_ecma_array_property_set(srs_amf0_t amf0, const char* name, srs_amf0_t value)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    srs_assert(any->is_ecma_array());
    
    SrsAmf0EcmaArray* obj = (SrsAmf0EcmaArray*)amf0;
    any = (SrsAmf0Any*)value;
    obj->set(name, any);
}

int srs_amf0_strict_array_property_count(srs_amf0_t amf0)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    srs_assert(any->is_strict_array());
    
    SrsAmf0StrictArray * obj = (SrsAmf0StrictArray*)amf0;
    return obj->count();
}

srs_amf0_t srs_amf0_strict_array_property_at(srs_amf0_t amf0, int index)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    srs_assert(any->is_strict_array());
    
    SrsAmf0StrictArray* obj = (SrsAmf0StrictArray*)amf0;
    return (srs_amf0_t)obj->at(index);
}

void srs_amf0_strict_array_append(srs_amf0_t amf0, srs_amf0_t value)
{
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    srs_assert(any->is_strict_array());
    
    SrsAmf0StrictArray* obj = (SrsAmf0StrictArray*)amf0;
    any = (SrsAmf0Any*)value;
    obj->append(any);
}

int64_t srs_utils_time_ms()
{
    return srs_update_system_time_ms();
}

int64_t srs_utils_send_bytes(srs_rtmp_t rtmp)
{
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    if (!context->rtmp) {
        return 0;
    }
    return context->rtmp->get_send_bytes();
}

int64_t srs_utils_recv_bytes(srs_rtmp_t rtmp)
{
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    if (!context->rtmp) {
        return 0;
    }
    return context->rtmp->get_recv_bytes();
}

int srs_utils_parse_timestamp(
                              uint32_t time, char type, char* data, int size,
                              uint32_t* ppts
                              ) {
    int ret = ERROR_SUCCESS;
    
    if (type != SRS_RTMP_TYPE_VIDEO) {
        *ppts = time;
        return ret;
    }
    
    if (!SrsFlvVideo::h264(data, size)) {
        return ERROR_FLV_INVALID_VIDEO_TAG;
    }
    
    if (SrsFlvVideo::sh(data, size)) {
        *ppts = time;
        return ret;
    }
    
    // 1bytes, frame type and codec id.
    // 1bytes, avc packet type.
    // 3bytes, cts, composition time,
    //      pts = dts + cts, or
    //      cts = pts - dts.
    if (size < 5) {
        return ERROR_FLV_INVALID_VIDEO_TAG;
    }
    
    uint32_t cts = 0;
    char* p = data + 2;
    char* pp = (char*)&cts;
    pp[2] = *p++;
    pp[1] = *p++;
    pp[0] = *p++;
    
    *ppts = time + cts;
    
    return ret;
}

srs_bool srs_utils_flv_tag_is_ok(char type)
{
    return type == SRS_RTMP_TYPE_AUDIO || type == SRS_RTMP_TYPE_VIDEO || type == SRS_RTMP_TYPE_SCRIPT;
}

srs_bool srs_utils_flv_tag_is_audio(char type)
{
    return type == SRS_RTMP_TYPE_AUDIO;
}

srs_bool srs_utils_flv_tag_is_video(char type)
{
    return type == SRS_RTMP_TYPE_VIDEO;
}

srs_bool srs_utils_flv_tag_is_av(char type)
{
    return type == SRS_RTMP_TYPE_AUDIO || type == SRS_RTMP_TYPE_VIDEO;
}

char srs_utils_flv_video_codec_id(char* data, int size)
{
    if (size < 1) {
        return 0;
    }
    
    char codec_id = data[0];
    codec_id = codec_id & 0x0F;
    
    return codec_id;
}

char srs_utils_flv_video_avc_packet_type(char* data, int size)
{
    if (size < 2) {
        return -1;
    }
    
    if (!SrsFlvVideo::h264(data, size)) {
        return -1;
    }
    
    uint8_t avc_packet_type = data[1];
    
    if (avc_packet_type > 2) {
        return -1;
    }
    
    return avc_packet_type;
}

char srs_utils_flv_video_frame_type(char* data, int size)
{
    if (size < 1) {
        return -1;
    }
    
    if (!SrsFlvVideo::h264(data, size)) {
        return -1;
    }
    
    uint8_t frame_type = data[0];
    frame_type = (frame_type >> 4) & 0x0f;
    if (frame_type < 1 || frame_type > 5) {
        return -1;
    }
    
    return frame_type;
}

char srs_utils_flv_audio_sound_format(char* data, int size)
{
    if (size < 1) {
        return -1;
    }
    
    uint8_t sound_format = data[0];
    sound_format = (sound_format >> 4) & 0x0f;
    if (sound_format > 15 || sound_format == 12 || sound_format == 13) {
        return -1;
    }
    
    return sound_format;
}

char srs_utils_flv_audio_sound_rate(char* data, int size)
{
    if (size < 1) {
        return -1;
    }
    
    uint8_t sound_rate = data[0];
    sound_rate = (sound_rate >> 2) & 0x03;
    
    return sound_rate;
}

char srs_utils_flv_audio_sound_size(char* data, int size)
{
    if (size < 1) {
        return -1;
    }
    
    uint8_t sound_size = data[0];
    sound_size = (sound_size >> 1) & 0x01;
    
    return sound_size;
}

char srs_utils_flv_audio_sound_type(char* data, int size)
{
    if (size < 1) {
        return -1;
    }
    
    uint8_t sound_type = data[0];
    sound_type = sound_type & 0x01;
    
    return sound_type;
}

char srs_utils_flv_audio_aac_packet_type(char* data, int size)
{
    if (size < 2) {
        return -1;
    }
    
    if (srs_utils_flv_audio_sound_format(data, size) != 10) {
        return -1;
    }
    
    uint8_t aac_packet_type = data[1];
    if (aac_packet_type > 1) {
        return -1;
    }
    
    return aac_packet_type;
}

char* srs_human_amf0_print(srs_amf0_t amf0, char** pdata, int* psize)
{
    if (!amf0) {
        return NULL;
    }
    
    SrsAmf0Any* any = (SrsAmf0Any*)amf0;
    
    return any->human_print(pdata, psize);
}

const char* srs_human_flv_tag_type2string(char type)
{
    static const char* audio = "Audio";
    static const char* video = "Video";
    static const char* data = "Data";
    static const char* unknown = "Unknown";
    
    switch (type) {
        case SRS_RTMP_TYPE_AUDIO: return audio;
        case SRS_RTMP_TYPE_VIDEO: return video;
        case SRS_RTMP_TYPE_SCRIPT: return data;
        default: return unknown;
    }
    
    return unknown;
}

const char* srs_human_flv_video_codec_id2string(char codec_id)
{
    static const char* h263 = "H.263";
    static const char* screen = "Screen";
    static const char* vp6 = "VP6";
    static const char* vp6_alpha = "VP6Alpha";
    static const char* screen2 = "Screen2";
    static const char* h264 = "H.264";
    static const char* unknown = "Unknown";
    
    switch (codec_id) {
        case 2: return h263;
        case 3: return screen;
        case 4: return vp6;
        case 5: return vp6_alpha;
        case 6: return screen2;
        case 7: return h264;
        default: return unknown;
    }
    
    return unknown;
}

const char* srs_human_flv_video_avc_packet_type2string(char avc_packet_type)
{
    static const char* sps_pps = "SH";
    static const char* nalu = "Nalu";
    static const char* sps_pps_end = "SpsPpsEnd";
    static const char* unknown = "Unknown";
    
    switch (avc_packet_type) {
        case 0: return sps_pps;
        case 1: return nalu;
        case 2: return sps_pps_end;
        default: return unknown;
    }
    
    return unknown;
}

const char* srs_human_flv_video_frame_type2string(char frame_type)
{
    static const char* keyframe = "I";
    static const char* interframe = "P/B";
    static const char* disposable_interframe = "DI";
    static const char* generated_keyframe = "GI";
    static const char* video_infoframe = "VI";
    static const char* unknown = "Unknown";
    
    switch (frame_type) {
        case 1: return keyframe;
        case 2: return interframe;
        case 3: return disposable_interframe;
        case 4: return generated_keyframe;
        case 5: return video_infoframe;
        default: return unknown;
    }
    
    return unknown;
}

const char* srs_human_flv_audio_sound_format2string(char sound_format)
{
    static const char* linear_pcm = "LinearPCM";
    static const char* ad_pcm = "ADPCM";
    static const char* mp3 = "MP3";
    static const char* linear_pcm_le = "LinearPCMLe";
    static const char* nellymoser_16khz = "NellymoserKHz16";
    static const char* nellymoser_8khz = "NellymoserKHz8";
    static const char* nellymoser = "Nellymoser";
    static const char* g711_a_pcm = "G711APCM";
    static const char* g711_mu_pcm = "G711MuPCM";
    static const char* reserved = "Reserved";
    static const char* aac = "AAC";
    static const char* speex = "Speex";
    static const char* mp3_8khz = "MP3KHz8";
    static const char* device_specific = "DeviceSpecific";
    static const char* unknown = "Unknown";
    
    switch (sound_format) {
        case 0: return linear_pcm;
        case 1: return ad_pcm;
        case 2: return mp3;
        case 3: return linear_pcm_le;
        case 4: return nellymoser_16khz;
        case 5: return nellymoser_8khz;
        case 6: return nellymoser;
        case 7: return g711_a_pcm;
        case 8: return g711_mu_pcm;
        case 9: return reserved;
        case 10: return aac;
        case 11: return speex;
        case 14: return mp3_8khz;
        case 15: return device_specific;
        default: return unknown;
    }
    
    return unknown;
}

const char* srs_human_flv_audio_sound_rate2string(char sound_rate)
{
    static const char* khz_5_5 = "5.5KHz";
    static const char* khz_11 = "11KHz";
    static const char* khz_22 = "22KHz";
    static const char* khz_44 = "44KHz";
    static const char* unknown = "Unknown";
    
    switch (sound_rate) {
        case 0: return khz_5_5;
        case 1: return khz_11;
        case 2: return khz_22;
        case 3: return khz_44;
        default: return unknown;
    }
    
    return unknown;
}

const char* srs_human_flv_audio_sound_size2string(char sound_size)
{
    static const char* bit_8 = "8bit";
    static const char* bit_16 = "16bit";
    static const char* unknown = "Unknown";
    
    switch (sound_size) {
        case 0: return bit_8;
        case 1: return bit_16;
        default: return unknown;
    }
    
    return unknown;
}

const char* srs_human_flv_audio_sound_type2string(char sound_type)
{
    static const char* mono = "Mono";
    static const char* stereo = "Stereo";
    static const char* unknown = "Unknown";
    
    switch (sound_type) {
        case 0: return mono;
        case 1: return stereo;
        default: return unknown;
    }
    
    return unknown;
}

const char* srs_human_flv_audio_aac_packet_type2string(char aac_packet_type)
{
    static const char* sps_pps = "SH";
    static const char* raw = "Raw";
    static const char* unknown = "Unknown";
    
    switch (aac_packet_type) {
        case 0: return sps_pps;
        case 1: return raw;
        default: return unknown;
    }
    
    return unknown;
}

int srs_human_format_rtmp_packet(char* buffer, int nb_buffer, char type, uint32_t timestamp, char* data, int size)
{
    int ret = ERROR_SUCCESS;
    
    // Initialize to empty NULL terminated string.
    buffer[0] = 0;
    
    char sbytes[40];
    if (true) {
        int nb = srs_min(8, size);
        int p = 0;
        for (int i = 0; i < nb; i++) {
            p += snprintf(sbytes+p, 40-p, "0x%02x ", (uint8_t)data[i]);
        }
    }
    
    uint32_t pts;
    if ((ret = srs_utils_parse_timestamp(timestamp, type, data, size, &pts)) != ERROR_SUCCESS) {
        snprintf(buffer, nb_buffer, "Rtmp packet type=%s, dts=%d, size=%d, DecodeError, (%s), ret=%d",
            srs_human_flv_tag_type2string(type), timestamp, size, sbytes, ret);
        return ret;
    }
    
    if (type == SRS_RTMP_TYPE_VIDEO) {
        snprintf(buffer, nb_buffer, "Video packet type=%s, dts=%d, pts=%d, size=%d, %s(%s,%s), (%s)",
            srs_human_flv_tag_type2string(type), timestamp, pts, size,
            srs_human_flv_video_codec_id2string(srs_utils_flv_video_codec_id(data, size)),
            srs_human_flv_video_avc_packet_type2string(srs_utils_flv_video_avc_packet_type(data, size)),
            srs_human_flv_video_frame_type2string(srs_utils_flv_video_frame_type(data, size)),
            sbytes);
    } else if (type == SRS_RTMP_TYPE_AUDIO) {
        snprintf(buffer, nb_buffer, "Audio packet type=%s, dts=%d, pts=%d, size=%d, %s(%s,%s,%s,%s), (%s)",
            srs_human_flv_tag_type2string(type), timestamp, pts, size,
            srs_human_flv_audio_sound_format2string(srs_utils_flv_audio_sound_format(data, size)),
            srs_human_flv_audio_sound_rate2string(srs_utils_flv_audio_sound_rate(data, size)),
            srs_human_flv_audio_sound_size2string(srs_utils_flv_audio_sound_size(data, size)),
            srs_human_flv_audio_sound_type2string(srs_utils_flv_audio_sound_type(data, size)),
            srs_human_flv_audio_aac_packet_type2string(srs_utils_flv_audio_aac_packet_type(data, size)),
            sbytes);
    } else if (type == SRS_RTMP_TYPE_SCRIPT) {
        int nb = snprintf(buffer, nb_buffer, "Data packet type=%s, time=%d, size=%d, (%s)",
            srs_human_flv_tag_type2string(type), timestamp, size, sbytes);
        int nparsed = 0;
        while (nparsed < size) {
            int nb_parsed_this = 0;
            srs_amf0_t amf0 = srs_amf0_parse(data + nparsed, size - nparsed, &nb_parsed_this);
            if (amf0 == NULL) {
                break;
            }
            
            nparsed += nb_parsed_this;
            
            char* amf0_str = NULL;
            nb += snprintf(buffer + nb, nb_buffer - nb, "\n%s", srs_human_amf0_print(amf0, &amf0_str, NULL)) - 1;
            srs_freepa(amf0_str);
        }
        buffer[nb] = 0;
    } else {
        snprintf(buffer, nb_buffer, "Rtmp packet type=%#x, dts=%d, pts=%d, size=%d, (%s)",
            type, timestamp, pts, size, sbytes);
    }
    
    return ret;
}

int srs_human_format_rtmp_packet2(char* buffer, int nb_buffer, char type, uint32_t timestamp, char* data, int size, uint32_t pre_timestamp, int64_t pre_now, int64_t starttime, int64_t nb_packets)
{
    int ret = ERROR_SUCCESS;
    
    // Initialize to empty NULL terminated string.
    buffer[0] = 0;
    
    // packets interval in milliseconds.
    double pi = 0;
    if (pre_now > starttime && nb_packets > 0) {
        pi = (pre_now - starttime) / (double)nb_packets;
    }
    
    // global fps(video and audio mixed fps).
    double gfps = 0;
    if (pi > 0) {
        gfps = 1000 / pi;
    }
    
    int diff = 0;
    if (pre_timestamp > 0) {
        diff = (int)timestamp - (int)pre_timestamp;
    }
    
    int ndiff = 0;
    if (pre_now > 0) {
        ndiff = (int)(srs_utils_time_ms() - pre_now);
    }
    
    char sbytes[40];
    if (true) {
        int nb = srs_min(8, size);
        int p = 0;
        for (int i = 0; i < nb; i++) {
            p += snprintf(sbytes+p, 40-p, "0x%02x ", (uint8_t)data[i]);
        }
    }
    
    uint32_t pts;
    if ((ret = srs_utils_parse_timestamp(timestamp, type, data, size, &pts)) != ERROR_SUCCESS) {
        snprintf(buffer, nb_buffer, "Rtmp packet id=%" PRId64 "/%.1f/%.1f, type=%s, dts=%d, ndiff=%d, diff=%d, size=%d, DecodeError, (%s), ret=%d",
            nb_packets, pi, gfps, srs_human_flv_tag_type2string(type), timestamp, ndiff, diff, size, sbytes, ret);
        return ret;
    }
    
    if (type == SRS_RTMP_TYPE_VIDEO) {
        snprintf(buffer, nb_buffer, "Video packet id=%" PRId64 "/%.1f/%.1f, type=%s, dts=%d, pts=%d, ndiff=%d, diff=%d, size=%d, %s(%s,%s), (%s)",
            nb_packets, pi, gfps, srs_human_flv_tag_type2string(type), timestamp, pts, ndiff, diff, size,
            srs_human_flv_video_codec_id2string(srs_utils_flv_video_codec_id(data, size)),
            srs_human_flv_video_avc_packet_type2string(srs_utils_flv_video_avc_packet_type(data, size)),
            srs_human_flv_video_frame_type2string(srs_utils_flv_video_frame_type(data, size)),
            sbytes);
    } else if (type == SRS_RTMP_TYPE_AUDIO) {
        snprintf(buffer, nb_buffer, "Audio packet id=%" PRId64 "/%.1f/%.1f, type=%s, dts=%d, pts=%d, ndiff=%d, diff=%d, size=%d, %s(%s,%s,%s,%s), (%s)",
            nb_packets, pi, gfps, srs_human_flv_tag_type2string(type), timestamp, pts, ndiff, diff, size,
            srs_human_flv_audio_sound_format2string(srs_utils_flv_audio_sound_format(data, size)),
            srs_human_flv_audio_sound_rate2string(srs_utils_flv_audio_sound_rate(data, size)),
            srs_human_flv_audio_sound_size2string(srs_utils_flv_audio_sound_size(data, size)),
            srs_human_flv_audio_sound_type2string(srs_utils_flv_audio_sound_type(data, size)),
            srs_human_flv_audio_aac_packet_type2string(srs_utils_flv_audio_aac_packet_type(data, size)),
            sbytes);
    } else if (type == SRS_RTMP_TYPE_SCRIPT) {
        int nb = snprintf(buffer, nb_buffer, "Data packet id=%" PRId64 "/%.1f/%.1f, type=%s, time=%d, ndiff=%d, diff=%d, size=%d, (%s)",
            nb_packets, pi, gfps, srs_human_flv_tag_type2string(type), timestamp, ndiff, diff, size, sbytes);
        int nparsed = 0;
        while (nparsed < size) {
            int nb_parsed_this = 0;
            srs_amf0_t amf0 = srs_amf0_parse(data + nparsed, size - nparsed, &nb_parsed_this);
            if (amf0 == NULL) {
                break;
            }
            
            nparsed += nb_parsed_this;
            
            char* amf0_str = NULL;
            nb += snprintf(buffer + nb, nb_buffer - nb, "\n%s", srs_human_amf0_print(amf0, &amf0_str, NULL)) - 1;
            srs_freepa(amf0_str);
        }
        buffer[nb] = 0;
    } else {
        snprintf(buffer, nb_buffer, "Rtmp packet id=%" PRId64 "/%.1f/%.1f, type=%#x, dts=%d, pts=%d, ndiff=%d, diff=%d, size=%d, (%s)",
            nb_packets, pi, gfps, type, timestamp, pts, ndiff, diff, size, sbytes);
    }
    
    return ret;
}

const char* srs_human_format_time()
{
    struct timeval tv;
    static char buf[24];
    
    memset(buf, 0, sizeof(buf));
    
    // clock time
    if (gettimeofday(&tv, NULL) == -1) {
        return buf;
    }
    
    // to calendar time
    struct tm* tm;
    if ((tm = localtime((const time_t*)&tv.tv_sec)) == NULL) {
        return buf;
    }
    
    snprintf(buf, sizeof(buf), 
             "%d-%02d-%02d %02d:%02d:%02d.%03d", 
             1900 + tm->tm_year, 1 + tm->tm_mon, tm->tm_mday, 
             tm->tm_hour, tm->tm_min, tm->tm_sec, 
             (int)(tv.tv_usec / 1000));
    
    // for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
    buf[sizeof(buf) - 1] = 0;
    
    return buf;
}


#ifdef SRS_HIJACK_IO
srs_hijack_io_t srs_hijack_io_get(srs_rtmp_t rtmp)
{
    if (!rtmp) {
        return NULL;
    }
    
    Context* context = (Context*)rtmp;
    if (!context->skt) {
        return NULL;
    }
    
    return context->skt->hijack_io();
}
#endif

srs_rtmp_t srs_rtmp_create2(const char* url)
{
    Context* context = new Context();
    
    // use url as tcUrl.
    context->url = url;
    // auto append stream.
    context->url += "/livestream";
    
    // create socket
    srs_freep(context->skt);
    context->skt = new SimpleSocketStream();
    
    int ret = ERROR_SUCCESS;
    if ((ret = context->skt->create_socket(context)) != ERROR_SUCCESS) {
        srs_human_error("Create socket failed, ret=%d", ret);
        
        // free the context and return NULL
        srs_freep(context);
        return NULL;
    }
    
    return context;
}

int srs_rtmp_connect_app2(srs_rtmp_t rtmp, char srs_server_ip[128],char srs_server[128], char srs_primary[128], char srs_authors[128], char srs_version[32], int* srs_id, int* srs_pid)
{
    srs_server_ip[0] = 0;
    srs_server[0] = 0;
    srs_primary[0] = 0;
    srs_authors[0] = 0;
    srs_version[0] = 0;
    *srs_id = 0;
    *srs_pid = 0;
    
    int ret = ERROR_SUCCESS;
    
    if ((ret = srs_rtmp_connect_app(rtmp)) != ERROR_SUCCESS) {
        return ret;
    }
    
    srs_assert(rtmp != NULL);
    Context* context = (Context*)rtmp;
    SrsServerInfo* si = &context->si;
    
    snprintf(srs_server_ip, 128, "%s", si->ip.c_str());
    snprintf(srs_server, 128, "%s", si->sig.c_str());
    snprintf(srs_version, 32, "%d.%d.%d.%d", si->major, si->minor, si->revision, si->build);
    
    return ret;
}

int srs_human_print_rtmp_packet(char type, uint32_t timestamp, char* data, int size)
{
    return srs_human_print_rtmp_packet3(type, timestamp, data, size, 0, 0);
}

int srs_human_print_rtmp_packet2(char type, uint32_t timestamp, char* data, int size, uint32_t pre_timestamp)
{
    return srs_human_print_rtmp_packet3(type, timestamp, data, size, pre_timestamp, 0);
}

int srs_human_print_rtmp_packet3(char type, uint32_t timestamp, char* data, int size, uint32_t pre_timestamp, int64_t pre_now)
{
    return srs_human_print_rtmp_packet4(type, timestamp, data, size, pre_timestamp, pre_now, 0, 0);
}

int srs_human_print_rtmp_packet4(char type, uint32_t timestamp, char* data, int size, uint32_t pre_timestamp, int64_t pre_now,
    int64_t starttime, int64_t nb_packets
) {
    char buffer[1024];
    int ret = srs_human_format_rtmp_packet2(buffer, sizeof(buffer), type, timestamp, data, size, pre_timestamp, pre_now, starttime, nb_packets);
    srs_human_trace("%s", buffer);
    return ret;
}
    
#ifdef __cplusplus
}
#endif

// following is generated by src/libs/srs_lib_simple_socket.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_lib_simple_socket.hpp>

#include <netinet/tcp.h>

//#include <srs_kernel_error.hpp>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#define SOCKET_ETIME EWOULDBLOCK
#define SOCKET_ECONNRESET ECONNRESET

#define SOCKET_ERRNO() errno
#define SOCKET_RESET(fd) fd = -1; (void)0
#define SOCKET_CLOSE(fd) \
    if (fd > 0) {\
        ::close(fd); \
        fd = -1; \
    } \
    (void)0
#define SOCKET_VALID(x) (x > 0)
#define SOCKET_SETUP() (void)0
#define SOCKET_CLEANUP() (void)0
#else
#define SOCKET_ETIME WSAETIMEDOUT
#define SOCKET_ECONNRESET WSAECONNRESET
#define SOCKET_ERRNO() WSAGetLastError()
#define SOCKET_RESET(x) x=INVALID_SOCKET
#define SOCKET_CLOSE(x) if(x!=INVALID_SOCKET){::closesocket(x);x=INVALID_SOCKET;}
#define SOCKET_VALID(x) (x!=INVALID_SOCKET)
#define SOCKET_BUFF(x) ((char*)x)
#define SOCKET_SETUP() socket_setup()
#define SOCKET_CLEANUP() socket_cleanup()
#endif

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/uio.h>
#endif

#include <sys/types.h>
#include <errno.h>
#include <stdio.h>
#include <netdb.h>

//#include <srs_core_autofree.hpp>
//#include <srs_kernel_utility.hpp>
//#include <srs_kernel_consts.hpp>

// when io not hijacked, use simple socket, the block sync stream.
#ifndef SRS_HIJACK_IO
struct SrsBlockSyncSocket
{
    SOCKET fd;
    int    family;
    int64_t rbytes;
    int64_t sbytes;
    // The send/recv timeout in ms.
    int64_t rtm;
    int64_t stm;
    
    SrsBlockSyncSocket() {
        stm = rtm = SRS_CONSTS_NO_TMMS;
        rbytes = sbytes = 0;
        
        SOCKET_RESET(fd);
        SOCKET_SETUP();
    }
    
    virtual ~SrsBlockSyncSocket() {
        SOCKET_CLOSE(fd);
        SOCKET_CLEANUP();
    }
};
srs_hijack_io_t srs_hijack_io_create()
{
    SrsBlockSyncSocket* skt = new SrsBlockSyncSocket();
    return skt;
}
void srs_hijack_io_destroy(srs_hijack_io_t ctx)
{
    SrsBlockSyncSocket* skt = (SrsBlockSyncSocket*)ctx;
    srs_freep(skt);
}
int srs_hijack_io_create_socket(srs_hijack_io_t ctx, srs_rtmp_t owner)
{
    SrsBlockSyncSocket* skt = (SrsBlockSyncSocket*)ctx;

    skt->family = AF_INET6;
    skt->fd = ::socket(skt->family, SOCK_STREAM, 0);   // Try IPv6 first.
    if (!SOCKET_VALID(skt->fd)) {
        skt->family = AF_INET;
        skt->fd = ::socket(skt->family, SOCK_STREAM, 0);   // Try IPv4 instead, if IPv6 fails.
    }
    if (!SOCKET_VALID(skt->fd)) {
        return ERROR_SOCKET_CREATE;
    }
    
    // No TCP cache.
    int v = 1;
    setsockopt(skt->fd, IPPROTO_TCP, TCP_NODELAY, &v, sizeof(v));

    return ERROR_SUCCESS;
}
int srs_hijack_io_connect(srs_hijack_io_t ctx, const char* server_ip, int port)
{
    SrsBlockSyncSocket* skt = (SrsBlockSyncSocket*)ctx;

    char sport[8];
    snprintf(sport, sizeof(sport), "%d", port);
    
    addrinfo hints;
    memset(&hints, 0, sizeof(hints));
    hints.ai_family   = skt->family;
    hints.ai_socktype = SOCK_STREAM;
    
    addrinfo* r  = NULL;
    SrsAutoFree(addrinfo, r);
    if(getaddrinfo(server_ip, sport, (const addrinfo*)&hints, &r)) {
        return ERROR_SOCKET_CONNECT;
    }
    
    if(::connect(skt->fd, r->ai_addr, r->ai_addrlen) < 0){
        return ERROR_SOCKET_CONNECT;
    }
    
    return ERROR_SUCCESS;
}
int srs_hijack_io_read(srs_hijack_io_t ctx, void* buf, size_t size, ssize_t* nread)
{
    SrsBlockSyncSocket* skt = (SrsBlockSyncSocket*)ctx;
    
    int ret = ERROR_SUCCESS;
    
    ssize_t nb_read = ::recv(skt->fd, (char*)buf, size, 0);
    
    if (nread) {
        *nread = nb_read;
    }
    
    // On success a non-negative integer indicating the number of bytes actually read is returned
    // (a value of 0 means the network connection is closed or end of file is reached).
    if (nb_read <= 0) {
        if (nb_read < 0 && SOCKET_ERRNO() == SOCKET_ETIME) {
            return ERROR_SOCKET_TIMEOUT;
        }
        
        if (nb_read == 0) {
            errno = SOCKET_ECONNRESET;
        }
        
        return ERROR_SOCKET_READ;
    }
    
    skt->rbytes += nb_read;
    
    return ret;
}
int srs_hijack_io_set_recv_timeout(srs_hijack_io_t ctx, int64_t tm)
{
    SrsBlockSyncSocket* skt = (SrsBlockSyncSocket*)ctx;
    
    // The default for this option is zero,
    // which indicates that a receive operation shall not time out.
    int32_t sec = 0;
    int32_t usec = 0;
    
    if (tm != SRS_CONSTS_NO_TMMS) {
        sec = (int32_t)(tm / 1000);
        usec = (int32_t)((tm % 1000)*1000);
    }
    
    struct timeval tv = { sec , usec };
    if (setsockopt(skt->fd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv)) == -1) {
        return SOCKET_ERRNO();
    }
    
    skt->rtm = tm;
    
    return ERROR_SUCCESS;
}
int64_t srs_hijack_io_get_recv_timeout(srs_hijack_io_t ctx)
{
    SrsBlockSyncSocket* skt = (SrsBlockSyncSocket*)ctx;
    return skt->rtm;
}
int64_t srs_hijack_io_get_recv_bytes(srs_hijack_io_t ctx)
{
    SrsBlockSyncSocket* skt = (SrsBlockSyncSocket*)ctx;
    return skt->rbytes;
}
int srs_hijack_io_set_send_timeout(srs_hijack_io_t ctx, int64_t tm)
{
    SrsBlockSyncSocket* skt = (SrsBlockSyncSocket*)ctx;
    
    // The default for this option is zero,
    // which indicates that a receive operation shall not time out.
    int32_t sec = 0;
    int32_t usec = 0;
    
    if (tm != SRS_CONSTS_NO_TMMS) {
        sec = (int32_t)(tm / 1000);
        usec = (int32_t)((tm % 1000)*1000);
    }
    
    struct timeval tv = { sec , usec };
    if (setsockopt(skt->fd, SOL_SOCKET, SO_SNDTIMEO, &tv, sizeof(tv)) == -1) {
        return SOCKET_ERRNO();
    }
    
    skt->stm = tm;
    
    return ERROR_SUCCESS;
}
int64_t srs_hijack_io_get_send_timeout(srs_hijack_io_t ctx)
{
    SrsBlockSyncSocket* skt = (SrsBlockSyncSocket*)ctx;
    return skt->stm;
}
int64_t srs_hijack_io_get_send_bytes(srs_hijack_io_t ctx)
{
    SrsBlockSyncSocket* skt = (SrsBlockSyncSocket*)ctx;
    return skt->sbytes;
}
int srs_hijack_io_writev(srs_hijack_io_t ctx, const iovec *iov, int iov_size, ssize_t* nwrite)
{
    SrsBlockSyncSocket* skt = (SrsBlockSyncSocket*)ctx;
    
    int ret = ERROR_SUCCESS;
    
    ssize_t nb_write = ::writev(skt->fd, iov, iov_size);
    
    if (nwrite) {
        *nwrite = nb_write;
    }
    
    // On  success,  the  readv()  function  returns the number of bytes read;
    // the writev() function returns the number of bytes written.  On error, -1 is
    // returned, and errno is set appropriately.
    if (nb_write <= 0) {
        // @see https://github.com/ossrs/srs/issues/200
        if (nb_write < 0 && SOCKET_ERRNO() == SOCKET_ETIME) {
            return ERROR_SOCKET_TIMEOUT;
        }
        
        return ERROR_SOCKET_WRITE;
    }
    
    skt->sbytes += nb_write;
    
    return ret;
}
int srs_hijack_io_is_never_timeout(srs_hijack_io_t ctx, int64_t tm)
{
    return tm == SRS_CONSTS_NO_TMMS;
}
int srs_hijack_io_read_fully(srs_hijack_io_t ctx, void* buf, size_t size, ssize_t* nread)
{
    SrsBlockSyncSocket* skt = (SrsBlockSyncSocket*)ctx;
    
    int ret = ERROR_SUCCESS;
    
    size_t left = size;
    ssize_t nb_read = 0;
    
    while (left > 0) {
        char* this_buf = (char*)buf + nb_read;
        ssize_t this_nread;
        
        if ((ret = srs_hijack_io_read(ctx, this_buf, left, &this_nread)) != ERROR_SUCCESS) {
            return ret;
        }
        
        nb_read += this_nread;
        left -= (size_t)this_nread;
    }
    
    if (nread) {
        *nread = nb_read;
    }
    skt->rbytes += nb_read;
    
    return ret;
}
int srs_hijack_io_write(srs_hijack_io_t ctx, void* buf, size_t size, ssize_t* nwrite)
{
    SrsBlockSyncSocket* skt = (SrsBlockSyncSocket*)ctx;
    
    int ret = ERROR_SUCCESS;
    
    ssize_t nb_write = ::send(skt->fd, (char*)buf, size, 0);
    
    if (nwrite) {
        *nwrite = nb_write;
    }
    
    if (nb_write <= 0) {
        // @see https://github.com/ossrs/srs/issues/200
        if (nb_write < 0 && SOCKET_ERRNO() == SOCKET_ETIME) {
            return ERROR_SOCKET_TIMEOUT;
        }
        
        return ERROR_SOCKET_WRITE;
    }
    
    skt->sbytes += nb_write;
    
    return ret;
}
#endif

SimpleSocketStream::SimpleSocketStream()
{
    io = srs_hijack_io_create();
}

SimpleSocketStream::~SimpleSocketStream()
{
    if (io) {
        srs_hijack_io_destroy(io);
        io = NULL;
    }
}

srs_hijack_io_t SimpleSocketStream::hijack_io()
{
    return io;
}

int SimpleSocketStream::create_socket(srs_rtmp_t owner)
{
    srs_assert(io);
    return srs_hijack_io_create_socket(io, owner);
}

int SimpleSocketStream::connect(const char* server_ip, int port)
{
    srs_assert(io);
    return srs_hijack_io_connect(io, server_ip, port);
}

// ISrsReader
srs_error_t SimpleSocketStream::read(void* buf, size_t size, ssize_t* nread)
{
    srs_assert(io);
    int ret = srs_hijack_io_read(io, buf, size, nread);
    if (ret != ERROR_SUCCESS) {
        return srs_error_new(ret, "read");
    }
    return srs_success;
}

// ISrsProtocolReader
void SimpleSocketStream::set_recv_timeout(int64_t tm)
{
    srs_assert(io);
    srs_hijack_io_set_recv_timeout(io, tm);
}

int64_t SimpleSocketStream::get_recv_timeout()
{
    srs_assert(io);
    return srs_hijack_io_get_recv_timeout(io);
}

int64_t SimpleSocketStream::get_recv_bytes()
{
    srs_assert(io);
    return srs_hijack_io_get_recv_bytes(io);
}

// ISrsProtocolWriter
void SimpleSocketStream::set_send_timeout(int64_t tm)
{
    srs_assert(io);
    srs_hijack_io_set_send_timeout(io, tm);
}

int64_t SimpleSocketStream::get_send_timeout()
{
    srs_assert(io);
    return srs_hijack_io_get_send_timeout(io);
}

int64_t SimpleSocketStream::get_send_bytes()
{
    srs_assert(io);
    return srs_hijack_io_get_send_bytes(io);
}

srs_error_t SimpleSocketStream::writev(const iovec *iov, int iov_size, ssize_t* nwrite)
{
    srs_assert(io);
    int ret = srs_hijack_io_writev(io, iov, iov_size, nwrite);
    if (ret != ERROR_SUCCESS) {
        return srs_error_new(ret, "read");
    }
    return srs_success;
}

// ISrsProtocolReaderWriter
bool SimpleSocketStream::is_never_timeout(int64_t tm)
{
    srs_assert(io);
    return srs_hijack_io_is_never_timeout(io, tm);
}

srs_error_t SimpleSocketStream::read_fully(void* buf, size_t size, ssize_t* nread)
{
    srs_assert(io);
    int ret = srs_hijack_io_read_fully(io, buf, size, nread);
    if (ret != ERROR_SUCCESS) {
        return srs_error_new(ret, "read");
    }
    return srs_success;
}

srs_error_t SimpleSocketStream::write(void* buf, size_t size, ssize_t* nwrite)
{
    srs_assert(io);
    int ret = srs_hijack_io_write(io, buf, size, nwrite);
    if (ret != ERROR_SUCCESS) {
        return srs_error_new(ret, "read");
    }
    return srs_success;
}


// following is generated by src/libs/srs_lib_bandwidth.cpp
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Winlin
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

//#include <srs_lib_bandwidth.hpp>

// for srs-librtmp, @see https://github.com/ossrs/srs/issues/213
#ifndef _WIN32
#include <unistd.h>
#endif

#include <sstream>
using namespace std;

//#include <srs_kernel_error.hpp>
//#include <srs_rtmp_stack.hpp>
//#include <srs_rtmp_stack.hpp>
//#include <srs_core_autofree.hpp>
//#include <srs_kernel_utility.hpp>
//#include <srs_protocol_amf0.hpp>

/**
 * recv bandwidth helper.
 */
typedef bool (*_CheckPacketType)(SrsBandwidthPacket* pkt);
bool _bandwidth_is_start_play(SrsBandwidthPacket* pkt)
{
    return pkt->is_start_play();
}
bool _bandwidth_is_stop_play(SrsBandwidthPacket* pkt)
{
    return pkt->is_stop_play();
}
bool _bandwidth_is_start_publish(SrsBandwidthPacket* pkt)
{
    return pkt->is_start_publish();
}
bool _bandwidth_is_stop_publish(SrsBandwidthPacket* pkt)
{
    return pkt->is_stop_publish();
}
bool _bandwidth_is_finish(SrsBandwidthPacket* pkt)
{
    return pkt->is_finish();
}
int _srs_expect_bandwidth_packet(SrsRtmpClient* rtmp, _CheckPacketType pfn)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    while (true) {
        SrsCommonMessage* msg = NULL;
        SrsBandwidthPacket* pkt = NULL;
        if ((err = rtmp->expect_message<SrsBandwidthPacket>(&msg, &pkt)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            return ret;
        }
        SrsAutoFree(SrsCommonMessage, msg);
        SrsAutoFree(SrsBandwidthPacket, pkt);
        srs_info("get final message success.");
        
        if (pfn(pkt)) {
            return ret;
        }
    }
    
    return ret;
}
int _srs_expect_bandwidth_packet2(SrsRtmpClient* rtmp, _CheckPacketType pfn, SrsBandwidthPacket** ppkt)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    while (true) {
        SrsCommonMessage* msg = NULL;
        SrsBandwidthPacket* pkt = NULL;
        if ((err = rtmp->expect_message<SrsBandwidthPacket>(&msg, &pkt)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            return ret;
        }
        SrsAutoFree(SrsCommonMessage, msg);
        srs_info("get final message success.");
        
        if (pfn(pkt)) {
            *ppkt = pkt;
            return ret;
        }
        
        srs_freep(pkt);
    }
    
    return ret;
}

SrsBandwidthClient::SrsBandwidthClient()
{
    _rtmp = NULL;
}

SrsBandwidthClient::~SrsBandwidthClient()
{
}

int SrsBandwidthClient::initialize(SrsRtmpClient* rtmp)
{
    _rtmp = rtmp;
    
    return ERROR_SUCCESS;
}

int SrsBandwidthClient::bandwidth_check(
    int64_t* start_time, int64_t* end_time,
    int* play_kbps, int* publish_kbps,
    int* play_bytes, int* publish_bytes,
    int* play_duration, int* publish_duration
) {
    int ret = ERROR_SUCCESS;
    
    srs_update_system_time_ms();
    *start_time = srs_get_system_time_ms();
    
    // play
    if ((ret = play_start()) != ERROR_SUCCESS) {
        return ret;
    }
    if ((ret = play_checking()) != ERROR_SUCCESS) {
        return ret;
    }
    if ((ret = play_stop()) != ERROR_SUCCESS) {
        return ret;
    }
    
    // publish
    int duration_ms = 0;
    int actual_play_kbps = 0;
    if ((ret = publish_start(duration_ms, actual_play_kbps)) != ERROR_SUCCESS) {
        return ret;
    }
    if ((ret = publish_checking(duration_ms, actual_play_kbps)) != ERROR_SUCCESS) {
        return ret;
    }
    if ((ret = publish_stop()) != ERROR_SUCCESS) {
        return ret;
    }
    
    SrsBandwidthPacket* pkt = NULL;
    if ((ret = do_final(&pkt)) != ERROR_SUCCESS) {
        return ret;
    }
    SrsAutoFree(SrsBandwidthPacket, pkt);
    
    // get data
    if (true ) {
        SrsAmf0Any* prop = NULL;
        if ((prop = pkt->data->ensure_property_number("play_kbps")) != NULL) {
            *play_kbps = (int)prop->to_number();
        }
        if ((prop = pkt->data->ensure_property_number("publish_kbps")) != NULL) {
            *publish_kbps = (int)prop->to_number();
        }
        if ((prop = pkt->data->ensure_property_number("play_bytes")) != NULL) {
            *play_bytes = (int)prop->to_number();
        }
        if ((prop = pkt->data->ensure_property_number("publish_bytes")) != NULL) {
            *publish_bytes = (int)prop->to_number();
        }
        if ((prop = pkt->data->ensure_property_number("play_time")) != NULL) {
            *play_duration = (int)prop->to_number();
        }
        if ((prop = pkt->data->ensure_property_number("publish_time")) != NULL) {
            *publish_duration = (int)prop->to_number();
        }
    }
    
    srs_update_system_time_ms();
    *end_time = srs_get_system_time_ms();
    
    return ret;
}

int SrsBandwidthClient::play_start()
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    if ((ret = _srs_expect_bandwidth_packet(_rtmp, _bandwidth_is_start_play)) != ERROR_SUCCESS) {
        return ret;
    }
    srs_info("BW check recv play begin request.");
    
    if (true) {
        // send start play response to server.
        SrsBandwidthPacket* pkt = SrsBandwidthPacket::create_starting_play();
        
        if ((err = _rtmp->send_and_free_packet(pkt, 0)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            srs_error("send bandwidth check start play message failed. ret=%d", ret);
            return ret;
        }
    }
    srs_info("BW check play begin.");
    
    return ret;
}

int SrsBandwidthClient::play_checking()
{
    int ret = ERROR_SUCCESS;
    return ret;
}

int SrsBandwidthClient::play_stop()
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    if ((ret = _srs_expect_bandwidth_packet(_rtmp, _bandwidth_is_stop_play)) != ERROR_SUCCESS) {
        return ret;
    }
    srs_info("BW check recv play stop request.");
    
    if (true) {
        // send stop play response to server.
        SrsBandwidthPacket* pkt = SrsBandwidthPacket::create_stopped_play();
        
        if ((err = _rtmp->send_and_free_packet(pkt, 0)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            srs_error("send bandwidth check stop play message failed. ret=%d", ret);
            return ret;
        }
    }
    srs_info("BW check play stop.");
    
    return ret;
}

int SrsBandwidthClient::publish_start(int& duration_ms, int& play_kbps)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    if (true) {
        SrsBandwidthPacket* pkt = NULL;
        if ((ret = _srs_expect_bandwidth_packet2(_rtmp, _bandwidth_is_start_publish, &pkt)) != ERROR_SUCCESS) {
            return ret;
        }
        SrsAutoFree(SrsBandwidthPacket, pkt);
        
        SrsAmf0Any* prop = NULL;
        if ((prop = pkt->data->ensure_property_number("duration_ms")) != NULL) {
            duration_ms = (int)prop->to_number();
        }
        if ((prop = pkt->data->ensure_property_number("limit_kbps")) != NULL) {
            play_kbps = (int)prop->to_number();
        }
    }
    srs_info("BW check recv publish begin request.");
    
    if (true) {
        // send start publish response to server.
        SrsBandwidthPacket* pkt = SrsBandwidthPacket::create_starting_publish();
        
        if ((err = _rtmp->send_and_free_packet(pkt, 0)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            srs_error("send bandwidth check start publish message failed. ret=%d", ret);
            return ret;
        }
    }
    srs_info("BW check publish begin.");
    
    return ret;
}

int SrsBandwidthClient::publish_checking(int duration_ms, int play_kbps)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    if (duration_ms <= 0) {
        ret = ERROR_RTMP_BWTC_DATA;
        srs_error("server must specifies the duration, ret=%d", ret);
        return ret;
    }
    
    if (play_kbps <= 0) {
        ret = ERROR_RTMP_BWTC_DATA;
        srs_error("server must specifies the play kbp, ret=%d", ret);
        return ret;
    }
    
    int data_count = 1;
    srs_update_system_time_ms();
    int64_t starttime = srs_get_system_time_ms();
    while ((srs_get_system_time_ms() - starttime) < duration_ms) {
        // TODO: FIXME: use shared ptr message.
        SrsBandwidthPacket* pkt = SrsBandwidthPacket::create_publishing();
        
        // TODO: FIXME: magic number
        for (int i = 0; i < data_count; ++i) {
            std::stringstream seq;
            seq << i;
            std::string play_data = "SRS band check data from server's publishing......";
            pkt->data->set(seq.str(), SrsAmf0Any::str(play_data.c_str()));
        }
        data_count += 2;
        
        if ((err = _rtmp->send_and_free_packet(pkt, 0)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            srs_error("send bandwidth check publish messages failed. ret=%d", ret);
            return ret;
        }
        
        // use the play kbps to control the publish
        srs_update_system_time_ms();
        int elaps = (int)(srs_get_system_time_ms() - starttime);
        if (elaps > 0) {
            int current_kbps = (int)(_rtmp->get_send_bytes() * 8 / elaps);
            while (current_kbps > play_kbps) {
                srs_update_system_time_ms();
                elaps = (int)(srs_get_system_time_ms() - starttime);
                current_kbps = (int)(_rtmp->get_send_bytes() * 8 / elaps);
                usleep(100 * 1000); // TODO: FIXME: magic number.
            }
        }
    }
    srs_info("BW check send publish bytes over.");
    
    return ret;
}

int SrsBandwidthClient::publish_stop()
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    if (true) {
        // send start publish response to server.
        SrsBandwidthPacket* pkt = SrsBandwidthPacket::create_stop_publish();
        
        if ((err = _rtmp->send_and_free_packet(pkt, 0)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            srs_error("send bandwidth check stop publish message failed. ret=%d", ret);
            return ret;
        }
    }
    srs_info("BW client stop publish request.");
    
    if ((ret = _srs_expect_bandwidth_packet(_rtmp, _bandwidth_is_stop_publish)) != ERROR_SUCCESS) {
        return ret;
    }
    srs_info("BW check recv publish stop request.");
    
    if (true) {
        // send start publish response to server.
        SrsBandwidthPacket* pkt = SrsBandwidthPacket::create_stopped_publish();
        
        if ((err = _rtmp->send_and_free_packet(pkt, 0)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            srs_error("send bandwidth check stop publish message failed. ret=%d", ret);
            return ret;
        }
    }
    srs_info("BW check publish stop.");
    
    return ret;
}

int SrsBandwidthClient::do_final(SrsBandwidthPacket** ppkt)
{
    int ret = ERROR_SUCCESS;
    srs_error_t err = srs_success;
    
    if ((ret = _srs_expect_bandwidth_packet2(_rtmp, _bandwidth_is_finish, ppkt)) != ERROR_SUCCESS) {
        return ret;
    }
    srs_info("BW check recv finish/report request.");
    
    if (true) {
        // send final response to server.
        SrsBandwidthPacket* pkt = SrsBandwidthPacket::create_final();
        
        if ((err = _rtmp->send_and_free_packet(pkt, 0)) != srs_success) {
            ret = srs_error_code(err);
            srs_freep(err);
            srs_error("send bandwidth check final message failed. ret=%d", ret);
            return ret;
        }
    }
    srs_info("BW check final.");
    
    return ret;
}

